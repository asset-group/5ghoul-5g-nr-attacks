diff --git a/.gitignore b/.gitignore
index 7eaaa359140..0a8433381d4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -170,3 +170,23 @@ vgcore.*
 .pytest_cache/
 test/*.log
 *.code-workspace
+
+config.h
+
+wireshark.h
+
+ws_attributes.h
+
+ws_codepoints.h
+
+ws_compiler_tests.h
+
+ws_diag_control.h
+
+ws_log_defs.h
+
+ws_posix_compat.h
+
+ws_symbol_export.h
+
+ws_version.h
diff --git a/CMakeLists.txt b/CMakeLists.txt
index aa348b1e4f4..d53bedcb647 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -60,13 +60,17 @@ set(LOG_PROJECT_VERSION "${LOG_PROJECT_MAJOR_VERSION}.${LOG_PROJECT_MINOR_VERSIO
 include( CMakeOptions.txt )
 
 # We require minimum C11
-set(CMAKE_C_STANDARD 11)
-set(CMAKE_C_STANDARD_REQUIRED ON)
+if (NOT CMAKE_C_STANDARD)
+	set(CMAKE_C_STANDARD 11)
+	set(CMAKE_C_STANDARD_REQUIRED ON)
+endif()
 
 # We require minimum C++11
-set(CMAKE_CXX_STANDARD 11)
-set(CMAKE_CXX_STANDARD_REQUIRED ON)
-set(CMAKE_CXX_EXTENSIONS OFF)
+if (NOT CMAKE_CXX_STANDARD)
+	set(CMAKE_CXX_STANDARD 11)
+	set(CMAKE_CXX_STANDARD_REQUIRED ON)
+	set(CMAKE_CXX_EXTENSIONS OFF)
+endif()
 
 message(STATUS "Generating build using CMake ${CMAKE_VERSION}")
 
@@ -86,7 +90,7 @@ else()
 endif()
 
 #Where to find local cmake scripts
-set(WS_CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/modules)
+set(WS_CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake/modules)
 set(CMAKE_MODULE_PATH ${WS_CMAKE_MODULE_PATH})
 
 # CMake >= 3.9.0 supports LTO/IPO.
@@ -186,7 +190,7 @@ and CPU target ${WIRESHARK_TARGET_PROCESSOR_ARCHITECTURE}"
 		endif()
 
 		# Download third-party libraries
-		file (TO_NATIVE_PATH ${CMAKE_SOURCE_DIR}/tools/win-setup.ps1 _win_setup)
+		file (TO_NATIVE_PATH ${PROJECT_SOURCE_DIR}/tools/win-setup.ps1 _win_setup)
 		file (TO_NATIVE_PATH ${_PROJECT_LIB_DIR} _ws_lib_dir)
 		file (TO_NATIVE_PATH ${CMAKE_COMMAND} _win_cmake_command)
 
@@ -215,15 +219,15 @@ ADD_CUSTOM_CMAKE_INCLUDE()
 # files might end up in a configuration subdirectory, e.g. run/Debug or
 # run/Release. We try to set DATAFILE_DIR to actual location below.
 if(NOT ARCHIVE_OUTPUT_PATH)
-	set(ARCHIVE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/run CACHE INTERNAL
+	set(ARCHIVE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/run CACHE INTERNAL
 		   "Single output directory for building all archives.")
 endif()
 if(NOT EXECUTABLE_OUTPUT_PATH)
-	set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/run CACHE INTERNAL
+	set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/run CACHE INTERNAL
 		   "Single output directory for building all executables.")
 endif()
 if(NOT LIBRARY_OUTPUT_PATH)
-	set(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR}/run CACHE INTERNAL
+	set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/run CACHE INTERNAL
 		   "Single output directory for building all libraries.")
 endif()
 
@@ -403,9 +407,9 @@ if(CMAKE_EXTRA_GENERATOR MATCHES "Eclipse CDT4")
 endif()
 
 include_directories(
-	${CMAKE_BINARY_DIR}
-	${CMAKE_SOURCE_DIR}
-	${CMAKE_SOURCE_DIR}/include
+	${PROJECT_BINARY_DIR}
+	${PROJECT_SOURCE_DIR}
+	${PROJECT_SOURCE_DIR}/include
 )
 
 if( DUMPCAP_INSTALL_OPTION STREQUAL "suid" )
@@ -696,6 +700,9 @@ else() # ! MSVC
 	list(APPEND WIRESHARK_C_ONLY_FLAGS
 		# The following are C only, not C++
 		-Wunused-const-variable
+		# Support compilation with Clang 15
+		-Wno-error=unused-but-set-variable
+		-Wno-error=unused-but-set-parameter
 		#
 		# XXX - some versions of GCC, including the one in at
 		# least some Xcode versions that come with Mac OS X
@@ -741,6 +748,11 @@ else() # ! MSVC
 
 	list(APPEND WIRESHARK_CXX_ONLY_FLAGS
 		-Wextra-semi
+		# Support compilation with Clang 15
+		-Wno-error=unused-but-set-variable
+		-Wno-error=unused-but-set-parameter
+		-Wno-error=deprecated-volatile
+		-Wno-error=deprecated-enum-enum-conversion
 	)
 
 	#
@@ -900,8 +912,8 @@ set(CMAKE_CXX_FLAGS "${ADDED_CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS}")
 if(CMAKE_C_COMPILER_ID MATCHES "GNU" OR CMAKE_C_COMPILER_ID MATCHES "Clang")
 	# If the build dir is within the source dir, CMake will use something
 	# like ../epan/dfilter/semcheck.c. Map these relative paths in addition
-	# to CMAKE_BINARY_DIR since compile_commands.json uses absolute paths.
-	file(RELATIVE_PATH _relative_source_dir "${CMAKE_BINARY_DIR}" "${CMAKE_SOURCE_DIR}")
+	# to PROJECT_BINARY_DIR since compile_commands.json uses absolute paths.
+	file(RELATIVE_PATH _relative_source_dir "${PROJECT_BINARY_DIR}" "${PROJECT_SOURCE_DIR}")
 	string(REGEX REPLACE "/$" "" _relative_source_dir "${_relative_source_dir}")
 
 	check_c_compiler_flag(-fmacro-prefix-map=old=new C_fmacro_prefix_map_old_new_VALID)
@@ -909,8 +921,8 @@ if(CMAKE_C_COMPILER_ID MATCHES "GNU" OR CMAKE_C_COMPILER_ID MATCHES "Clang")
 	foreach(_lang C CXX)
 		if(${_lang}_fmacro_prefix_map_old_new_VALID)
 			set(_flags CMAKE_${_lang}_FLAGS)
-			set(${_flags} "${${_flags}} -fmacro-prefix-map=${CMAKE_SOURCE_DIR}/=")
-			set(${_flags} "${${_flags}} -fmacro-prefix-map=${CMAKE_BINARY_DIR}/=")
+			set(${_flags} "${${_flags}} -fmacro-prefix-map=${PROJECT_SOURCE_DIR}/=")
+			set(${_flags} "${${_flags}} -fmacro-prefix-map=${PROJECT_BINARY_DIR}/=")
 			if(_relative_source_dir MATCHES "\\.\\.$")
 				set(${_flags} "${${_flags}} -fmacro-prefix-map=${_relative_source_dir}/=")
 			endif()
@@ -1182,7 +1194,7 @@ else()
 endif()
 ws_find_package(LIBSSH ENABLE_LIBSSH HAVE_LIBSSH "0.6")
 
-ws_find_package(PCAP ENABLE_PCAP HAVE_LIBPCAP)
+# ws_find_package(PCAP ENABLE_PCAP HAVE_LIBPCAP "1")
 ws_find_package(AIRPCAP ENABLE_AIRPCAP HAVE_AIRPCAP)
 ws_find_package(Systemd BUILD_sdjournal HAVE_SYSTEMD)
 
@@ -1375,8 +1387,8 @@ endif()
 
 # Generate the distribution tarball.
 add_custom_target(dist
-	COMMAND ${CMAKE_BINARY_DIR}/packaging/source/git-export-release.sh -d "${CMAKE_BINARY_DIR}"
-	WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
+	COMMAND ${PROJECT_BINARY_DIR}/packaging/source/git-export-release.sh -d "${PROJECT_BINARY_DIR}"
+	WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
 )
 
 if(GNUTLS_FOUND)
@@ -1588,7 +1600,7 @@ elseif(NOT CMAKE_CFG_INTDIR STREQUAL ".")
 	set(_datafile_dir "${CMAKE_BINARY_DIR}/run/${CMAKE_CFG_INTDIR}")
 else()
 	# Makefile, Ninja, etc.
-	set(_datafile_dir "${CMAKE_BINARY_DIR}/run")
+	set(_datafile_dir "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/ws")
 endif()
 
 set(DATAFILE_DIR ${_datafile_dir} CACHE INTERNAL "Build time data file location.")
@@ -1639,6 +1651,8 @@ if(ENABLE_PLUGINS)
 	set(PLUGIN_SRC_DIRS
 		plugins/epan/ethercat
 		plugins/epan/gryphon
+        plugins/epan/h4bcm
+        plugins/epan/generic
 		plugins/epan/irda
 		plugins/epan/mate
 		plugins/epan/opcua
@@ -1730,22 +1744,22 @@ if(VCSVERSION_OVERRIDE)
 	# Allow distributors to override detection of the Git tag and version.
 	string(CONFIGURE "#define VCSVERSION \"@VCSVERSION_OVERRIDE@\"\n"
 		_version_h_contents ESCAPE_QUOTES)
-	file(WRITE "${CMAKE_BINARY_DIR}/vcs_version.h" "${_version_h_contents}")
+	file(WRITE "${PROJECT_SOURCE_DIR}/vcs_version.h" "${_version_h_contents}")
 	message(STATUS "VCSVERSION_OVERRIDE: ${VCSVERSION_OVERRIDE}")
 else()
 	add_custom_target(vcs_version
 		BYPRODUCTS vcs_version.h
 		COMMAND ${PYTHON_EXECUTABLE}
-			${CMAKE_SOURCE_DIR}/tools/make-version.py
-			${CMAKE_SOURCE_DIR}
+			${PROJECT_SOURCE_DIR}/tools/make-version.py
+			${PROJECT_SOURCE_DIR}
 	)
 	set_target_properties(vcs_version PROPERTIES FOLDER "Auxiliary")
 endif()
 
 set( configure_input "Built with CMake ${CMAKE_VERSION}" )
-configure_file(${CMAKE_SOURCE_DIR}/cmakeconfig.h.in ${CMAKE_BINARY_DIR}/config.h)
+configure_file(${PROJECT_SOURCE_DIR}/cmakeconfig.h.in ${PROJECT_SOURCE_DIR}/config.h)
 
-configure_file(${CMAKE_SOURCE_DIR}/ws_version.h.in ${CMAKE_BINARY_DIR}/ws_version.h)
+configure_file(${PROJECT_SOURCE_DIR}/ws_version.h.in ${PROJECT_SOURCE_DIR}/ws_version.h)
 
 set( prefix "${CMAKE_INSTALL_PREFIX}" )
 set( exec_prefix "\${prefix}" )
@@ -1756,8 +1770,8 @@ set( plugindir "\${libdir}/wireshark/${PLUGIN_VERSION_DIR}" )
 # Doxygen variables
 file(GLOB TOP_LEVEL_SOURCE_LIST *.c *.cpp *.h)
 string (REPLACE ";" " " DOXYGEN_TOP_LEVEL_SOURCES "${TOP_LEVEL_SOURCE_LIST}")
-set(DOXYGEN_INPUT_DIRECTORY ${CMAKE_SOURCE_DIR})
-set(DOXYGEN_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
+set(DOXYGEN_INPUT_DIRECTORY ${PROJECT_SOURCE_DIR})
+set(DOXYGEN_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})
 
 set(CFG_OUT_FILES
 	doxygen.cfg
@@ -1786,7 +1800,7 @@ if(BUILD_logray)
 endif()
 
 foreach( _cfg_file ${CFG_OUT_FILES} )
-	configure_file( ${CMAKE_SOURCE_DIR}/${_cfg_file}.in ${CMAKE_BINARY_DIR}/${_cfg_file} @ONLY )
+	configure_file( ${PROJECT_SOURCE_DIR}/${_cfg_file}.in ${PROJECT_BINARY_DIR}/${_cfg_file} @ONLY )
 endforeach()
 
 include(FeatureSummary)
@@ -1925,38 +1939,38 @@ elseif(APPLE)
 endif()
 
 set(TSHARK_TAP_SRC
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-credentials.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-camelsrt.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-diameter-avp.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-expert.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-exportobject.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-endpoints.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-flow.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-follow.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-funnel.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-gsm_astat.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-hosts.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-httpstat.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-icmpstat.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-icmpv6stat.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-iostat.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-iousers.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-macltestat.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-protocolinfo.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-protohierstat.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-rlcltestat.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-rpcprogs.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-rtd.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-rtp.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-rtspstat.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-sctpchunkstat.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-simple_stattable.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-sipstat.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-smbsids.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-srt.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-stats_tree.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-sv.c
-	${CMAKE_SOURCE_DIR}/ui/cli/tap-wspstat.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-credentials.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-camelsrt.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-diameter-avp.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-expert.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-exportobject.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-endpoints.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-flow.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-follow.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-funnel.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-gsm_astat.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-hosts.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-httpstat.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-icmpstat.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-icmpv6stat.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-iostat.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-iousers.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-macltestat.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-protocolinfo.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-protohierstat.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-rlcltestat.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-rpcprogs.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-rtd.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-rtp.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-rtspstat.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-sctpchunkstat.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-simple_stattable.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-sipstat.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-smbsids.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-srt.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-stats_tree.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-sv.c
+	${PROJECT_SOURCE_DIR}/ui/cli/tap-wspstat.c
 	${CUSTOM_TSHARK_TAP_SRC}
 
 )
@@ -1999,45 +2013,45 @@ endif()
 
 if (ASCIIDOCTOR_FOUND)
 	list(APPEND INSTALL_FILES
-		${CMAKE_BINARY_DIR}/doc/AUTHORS-SHORT
-		${CMAKE_BINARY_DIR}/doc/androiddump.html
-		${CMAKE_BINARY_DIR}/doc/udpdump.html
-		${CMAKE_BINARY_DIR}/doc/capinfos.html
-		${CMAKE_BINARY_DIR}/doc/captype.html
-		${CMAKE_BINARY_DIR}/doc/ciscodump.html
-		${CMAKE_BINARY_DIR}/doc/dftest.html
-		${CMAKE_BINARY_DIR}/doc/dumpcap.html
-		${CMAKE_BINARY_DIR}/doc/editcap.html
-		${CMAKE_BINARY_DIR}/doc/extcap.html
-		${CMAKE_BINARY_DIR}/doc/mergecap.html
-		${CMAKE_BINARY_DIR}/doc/randpkt.html
-		${CMAKE_BINARY_DIR}/doc/randpktdump.html
-		${CMAKE_BINARY_DIR}/doc/etwdump.html
-		${CMAKE_BINARY_DIR}/doc/rawshark.html
-		${CMAKE_BINARY_DIR}/doc/reordercap.html
-		${CMAKE_BINARY_DIR}/doc/sshdump.html
-		${CMAKE_BINARY_DIR}/doc/wifidump.html
-		${CMAKE_BINARY_DIR}/doc/text2pcap.html
-		${CMAKE_BINARY_DIR}/doc/tshark.html
-		${CMAKE_BINARY_DIR}/doc/wireshark.html
-		${CMAKE_BINARY_DIR}/doc/wireshark-filter.html
+		${PROJECT_BINARY_DIR}/doc/AUTHORS-SHORT
+		${PROJECT_BINARY_DIR}/doc/androiddump.html
+		${PROJECT_BINARY_DIR}/doc/udpdump.html
+		${PROJECT_BINARY_DIR}/doc/capinfos.html
+		${PROJECT_BINARY_DIR}/doc/captype.html
+		${PROJECT_BINARY_DIR}/doc/ciscodump.html
+		${PROJECT_BINARY_DIR}/doc/dftest.html
+		${PROJECT_BINARY_DIR}/doc/dumpcap.html
+		${PROJECT_BINARY_DIR}/doc/editcap.html
+		${PROJECT_BINARY_DIR}/doc/extcap.html
+		${PROJECT_BINARY_DIR}/doc/mergecap.html
+		${PROJECT_BINARY_DIR}/doc/randpkt.html
+		${PROJECT_BINARY_DIR}/doc/randpktdump.html
+		${PROJECT_BINARY_DIR}/doc/etwdump.html
+		${PROJECT_BINARY_DIR}/doc/rawshark.html
+		${PROJECT_BINARY_DIR}/doc/reordercap.html
+		${PROJECT_BINARY_DIR}/doc/sshdump.html
+		${PROJECT_BINARY_DIR}/doc/wifidump.html
+		${PROJECT_BINARY_DIR}/doc/text2pcap.html
+		${PROJECT_BINARY_DIR}/doc/tshark.html
+		${PROJECT_BINARY_DIR}/doc/wireshark.html
+		${PROJECT_BINARY_DIR}/doc/wireshark-filter.html
 	)
 	if(MAXMINDDB_FOUND)
-		list(APPEND INSTALL_FILES ${CMAKE_BINARY_DIR}/doc/mmdbresolve.html)
+		list(APPEND INSTALL_FILES ${PROJECT_BINARY_DIR}/doc/mmdbresolve.html)
 	endif()
 
 	if (BUILD_corbaidl2wrs)
-		list(APPEND INSTALL_FILES ${CMAKE_BINARY_DIR}/doc/idl2wrs.html)
+		list(APPEND INSTALL_FILES ${PROJECT_BINARY_DIR}/doc/idl2wrs.html)
 	endif()
 	if (BUILD_xxx2deb)
 		list(APPEND INSTALL_FILES
-			${CMAKE_BINARY_DIR}/doc/asn2deb.html
-			${CMAKE_BINARY_DIR}/doc/idl2deb.html
+			${PROJECT_BINARY_DIR}/doc/asn2deb.html
+			${PROJECT_BINARY_DIR}/doc/idl2deb.html
 		)
 	endif()
 	if (BUILD_logray)
 		list(APPEND LOG_INSTALL_FILES
-			${CMAKE_BINARY_DIR}/doc/falcodump.html
+			${PROJECT_BINARY_DIR}/doc/falcodump.html
 		)
 	endif()
 endif()
@@ -2241,7 +2255,7 @@ if(USE_REPOSITORY)
 	if(ZIP_EXECUTABLE)
 		add_custom_target(pdb_zip_package COMMENT "This packages .PDBs but will not create them.")
 		set_target_properties(pdb_zip_package PROPERTIES FOLDER "Packaging")
-		set(_pdb_zip "${CMAKE_BINARY_DIR}/Wireshark-pdb-${WIRESHARK_TARGET_PLATFORM}-${PROJECT_VERSION}.zip")
+		set(_pdb_zip "${PROJECT_BINARY_DIR}/Wireshark-pdb-${WIRESHARK_TARGET_PLATFORM}-${PROJECT_VERSION}.zip")
 		file(TO_NATIVE_PATH "${_pdb_zip}" _pdb_zip_win)
 		add_custom_command(TARGET pdb_zip_package POST_BUILD
 			COMMAND ${CMAKE_COMMAND} -E remove -f "${_pdb_zip}"
@@ -2310,9 +2324,9 @@ endif()
 # epan/wslua/CMakeLists.txt
 if(LUA_FOUND AND ENABLE_LUA)
 	set(_lua_files
-		"${CMAKE_SOURCE_DIR}/epan/wslua/init.lua"
-		"${CMAKE_SOURCE_DIR}/epan/wslua/console.lua"
-		"${CMAKE_SOURCE_DIR}/epan/wslua/dtd_gen.lua"
+		"${PROJECT_SOURCE_DIR}/epan/wslua/init.lua"
+		"${PROJECT_SOURCE_DIR}/epan/wslua/console.lua"
+		"${PROJECT_SOURCE_DIR}/epan/wslua/dtd_gen.lua"
 	)
 	foreach(_lua_file ${_lua_files})
 		get_filename_component(_lua_filename "${_lua_file}" NAME)
@@ -2329,7 +2343,7 @@ if(LUA_FOUND AND ENABLE_LUA)
 endif(LUA_FOUND AND ENABLE_LUA)
 # doc/*.html handled elsewhere.
 
-set(_protocol_data_dir ${CMAKE_SOURCE_DIR}/resources/protocols)
+set(_protocol_data_dir ${PROJECT_SOURCE_DIR}/resources/protocols)
 # Glob patterns relative to the source directory that should be copied to
 # ${DATAFILE_DIR} (including directory prefixes)
 # TODO shouldn't this use full (relative) paths instead of glob patterns?
@@ -2442,7 +2456,7 @@ add_custom_command(
 	WORKING_DIRECTORY ${_protocol_data_dir}
 )
 
-set(_profiles_src_dir ${CMAKE_SOURCE_DIR}/resources/share/wireshark)
+set(_profiles_src_dir ${PROJECT_SOURCE_DIR}/resources/share/wireshark)
 file(GLOB _profiles_src_files RELATIVE ${_profiles_src_dir} ${_profiles_src_dir}/profiles/*/*)
 set (_profiles_data_files)
 foreach(_data_file ${_profiles_src_files})
@@ -2452,7 +2466,7 @@ endforeach()
 add_custom_command(
 	OUTPUT ${_profiles_data_files}
 	COMMAND ${CMAKE_COMMAND} -E copy_directory
-		"${CMAKE_SOURCE_DIR}/resources/share/wireshark/profiles" "${DATAFILE_DIR}/profiles"
+		"${PROJECT_SOURCE_DIR}/resources/share/wireshark/profiles" "${DATAFILE_DIR}/profiles"
 )
 
 list(APPEND copy_data_files_depends
@@ -2545,9 +2559,9 @@ if(ENABLE_APPLICATION_BUNDLE)
 
 	# Add files to the Wireshark application bundle
 	# Wireshark.app/Contents
-	file(WRITE ${CMAKE_BINARY_DIR}/packaging/macosx/wireshark/PkgInfo "APPLWshk\n")
+	file(WRITE ${PROJECT_BINARY_DIR}/packaging/macosx/wireshark/PkgInfo "APPLWshk\n")
 	set(WIRESHARK_BUNDLE_CONTENTS_FILES
-		${CMAKE_BINARY_DIR}/packaging/macosx/wireshark/PkgInfo
+		${PROJECT_BINARY_DIR}/packaging/macosx/wireshark/PkgInfo
 	)
 	set_source_files_properties(${WIRESHARK_BUNDLE_CONTENTS_FILES} PROPERTIES
 		MACOSX_PACKAGE_LOCATION .
@@ -2555,8 +2569,8 @@ if(ENABLE_APPLICATION_BUNDLE)
 
 	# Wireshark.app/Contents/Resources
 	set(WIRESHARK_BUNDLE_RESOURCE_FILES
-		${CMAKE_SOURCE_DIR}/packaging/macosx/Wireshark.icns
-		${CMAKE_SOURCE_DIR}/packaging/macosx/Wiresharkdoc.icns
+		${PROJECT_SOURCE_DIR}/packaging/macosx/Wireshark.icns
+		${PROJECT_SOURCE_DIR}/packaging/macosx/Wiresharkdoc.icns
 	)
 	set_source_files_properties(${WIRESHARK_BUNDLE_RESOURCE_FILES} PROPERTIES
 		MACOSX_PACKAGE_LOCATION Resources
@@ -2585,9 +2599,9 @@ if(ENABLE_APPLICATION_BUNDLE)
 
 	# Add files to the Logray application bundle
 	# Logray.app/Contents
-	file(WRITE ${CMAKE_BINARY_DIR}/packaging/macosx/logray/PkgInfo "APPLLgry\n")
+	file(WRITE ${PROJECT_BINARY_DIR}/packaging/macosx/logray/PkgInfo "APPLLgry\n")
 	set(LOGRAY_BUNDLE_CONTENTS_FILES
-		${CMAKE_BINARY_DIR}/packaging/macosx/logray/PkgInfo
+		${PROJECT_BINARY_DIR}/packaging/macosx/logray/PkgInfo
 	)
 	set_source_files_properties(${LOGRAY_BUNDLE_CONTENTS_FILES} PROPERTIES
 		MACOSX_PACKAGE_LOCATION .
@@ -2595,8 +2609,8 @@ if(ENABLE_APPLICATION_BUNDLE)
 
 	# Logray.app/Contents/Resources
 	set(LOGRAY_BUNDLE_RESOURCE_FILES
-		${CMAKE_SOURCE_DIR}/packaging/macosx/Logray.icns
-		${CMAKE_SOURCE_DIR}/packaging/macosx/Wiresharkdoc.icns
+		${PROJECT_SOURCE_DIR}/packaging/macosx/Logray.icns
+		${PROJECT_SOURCE_DIR}/packaging/macosx/Wiresharkdoc.icns
 	)
 	set_source_files_properties(${LOGRAY_BUNDLE_RESOURCE_FILES} PROPERTIES
 		MACOSX_PACKAGE_LOCATION Resources
@@ -2678,7 +2692,7 @@ if(BUILD_wireshark AND QT_FOUND)
 		endif()
 		set_target_properties(
 			wireshark PROPERTIES
-				MACOSX_BUNDLE_INFO_PLIST ${CMAKE_BINARY_DIR}/packaging/macosx/WiresharkInfo.plist
+				MACOSX_BUNDLE_INFO_PLIST ${PROJECT_BINARY_DIR}/packaging/macosx/WiresharkInfo.plist
 		)
 		if(CMAKE_CFG_INTDIR STREQUAL ".")
 			# Add a wrapper script which opens the bundle. This adds
@@ -2687,13 +2701,13 @@ if(BUILD_wireshark AND QT_FOUND)
 			# XXX Running run/Wireshark.app/Contents/MacOS/Wireshark works
 			# fine for me (Gerald) here on Mojave. Can we just make this a
 			# symlink?
-			file(REMOVE ${CMAKE_BINARY_DIR}/run/wireshark)
-			file(WRITE ${CMAKE_BINARY_DIR}/run/wireshark "#!/bin/sh\n")
-			file(APPEND ${CMAKE_BINARY_DIR}/run/wireshark "# Generated by ${CMAKE_CURRENT_LIST_FILE}\n")
-			file(APPEND ${CMAKE_BINARY_DIR}/run/wireshark "# Wrapper script which should work around the issue described at\n")
-			file(APPEND ${CMAKE_BINARY_DIR}/run/wireshark "# https://stackoverflow.com/questions/25318524/what-exactly-should-i-pass-to-nsapp-activateignoringotherapps-to-get-my-appl\n")
-			file(APPEND ${CMAKE_BINARY_DIR}/run/wireshark "exec ${CMAKE_BINARY_DIR}/run/Wireshark.app/Contents/MacOS/Wireshark \"\$\@\"\n")
-			execute_process(COMMAND chmod a+x ${CMAKE_BINARY_DIR}/run/wireshark)
+			file(REMOVE ${PROJECT_BINARY_DIR}/run/wireshark)
+			file(WRITE ${PROJECT_BINARY_DIR}/run/wireshark "#!/bin/sh\n")
+			file(APPEND ${PROJECT_BINARY_DIR}/run/wireshark "# Generated by ${CMAKE_CURRENT_LIST_FILE}\n")
+			file(APPEND ${PROJECT_BINARY_DIR}/run/wireshark "# Wrapper script which should work around the issue described at\n")
+			file(APPEND ${PROJECT_BINARY_DIR}/run/wireshark "# https://stackoverflow.com/questions/25318524/what-exactly-should-i-pass-to-nsapp-activateignoringotherapps-to-get-my-appl\n")
+			file(APPEND ${PROJECT_BINARY_DIR}/run/wireshark "exec ${PROJECT_BINARY_DIR}/run/Wireshark.app/Contents/MacOS/Wireshark \"\$\@\"\n")
+			execute_process(COMMAND chmod a+x ${PROJECT_BINARY_DIR}/run/wireshark)
 		endif()
 	endif()
 
@@ -2781,7 +2795,7 @@ if(BUILD_logray AND QT_FOUND)
 		endif()
 		set_target_properties(
 			logray PROPERTIES
-				MACOSX_BUNDLE_INFO_PLIST ${CMAKE_BINARY_DIR}/packaging/macosx/LograyInfo.plist
+				MACOSX_BUNDLE_INFO_PLIST ${PROJECT_BINARY_DIR}/packaging/macosx/LograyInfo.plist
 		)
 		if(CMAKE_CFG_INTDIR STREQUAL ".")
 			# Add a wrapper script which opens the bundle. This adds
@@ -2790,13 +2804,13 @@ if(BUILD_logray AND QT_FOUND)
 			# XXX Running run/Logray.app/Contents/MacOS/Logray works
 			# fine for me (Gerald) here on Mojave. Can we just make this a
 			# symlink?
-			file(REMOVE ${CMAKE_BINARY_DIR}/run/logray)
-			file(WRITE ${CMAKE_BINARY_DIR}/run/logray "#!/bin/sh\n")
-			file(APPEND ${CMAKE_BINARY_DIR}/run/logray "# Generated by ${CMAKE_CURRENT_LIST_FILE}\n")
-			file(APPEND ${CMAKE_BINARY_DIR}/run/logray "# Wrapper script which should work around the issue described at\n")
-			file(APPEND ${CMAKE_BINARY_DIR}/run/logray "# https://stackoverflow.com/questions/25318524/what-exactly-should-i-pass-to-nsapp-activateignoringotherapps-to-get-my-appl\n")
-			file(APPEND ${CMAKE_BINARY_DIR}/run/logray "exec ${CMAKE_BINARY_DIR}/run/Logray.app/Contents/MacOS/Logray \"\$\@\"\n")
-			execute_process(COMMAND chmod a+x ${CMAKE_BINARY_DIR}/run/logray)
+			file(REMOVE ${PROJECT_BINARY_DIR}/run/logray)
+			file(WRITE ${PROJECT_BINARY_DIR}/run/logray "#!/bin/sh\n")
+			file(APPEND ${PROJECT_BINARY_DIR}/run/logray "# Generated by ${CMAKE_CURRENT_LIST_FILE}\n")
+			file(APPEND ${PROJECT_BINARY_DIR}/run/logray "# Wrapper script which should work around the issue described at\n")
+			file(APPEND ${PROJECT_BINARY_DIR}/run/logray "# https://stackoverflow.com/questions/25318524/what-exactly-should-i-pass-to-nsapp-activateignoringotherapps-to-get-my-appl\n")
+			file(APPEND ${PROJECT_BINARY_DIR}/run/logray "exec ${PROJECT_BINARY_DIR}/run/Logray.app/Contents/MacOS/Logray \"\$\@\"\n")
+			execute_process(COMMAND chmod a+x ${PROJECT_BINARY_DIR}/run/logray)
 		endif()
 	endif()
 
@@ -2871,7 +2885,7 @@ macro(set_extra_executable_properties _executable _folder)
 			add_custom_target(${_executable}-symlink
 				COMMAND ln -s -f
 					Wireshark.app/Contents/MacOS/${_executable}
-					${CMAKE_BINARY_DIR}/run/${_executable}
+					${PROJECT_BINARY_DIR}/run/${_executable}
 			)
 			add_dependencies(${_executable} ${_executable}-symlink)
 		endif()
@@ -3177,7 +3191,7 @@ if(BUILD_dumpcap AND PCAP_FOUND)
 		caputils
 		ui
 		version_info
-		pcap::pcap
+		pcap
 		${CAP_LIBRARIES}
 		${GTHREAD2_LIBRARIES}
 		${ZLIB_LIBRARIES}
@@ -3296,126 +3310,126 @@ if (MAXMINDDB_FOUND)
 endif()
 
 if(ENABLE_APPLICATION_BUNDLE AND BUILD_wireshark)
-	file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}/run/${CMAKE_CFG_INTDIR}/Wireshark.app/Contents/Resources/Extras")
+	file(MAKE_DIRECTORY "${PROJECT_BINARY_DIR}/run/${CMAKE_CFG_INTDIR}/Wireshark.app/Contents/Resources/Extras")
 
 	# --preserve-xattr is undocumented but ensures that we install
 	# a signed ChmodBPF script.
-	set (install_chmodbpf_component_pkg "${CMAKE_BINARY_DIR}/install.ChmodBPF.pkg")
+	set (install_chmodbpf_component_pkg "${PROJECT_BINARY_DIR}/install.ChmodBPF.pkg")
 	add_custom_command(OUTPUT "${install_chmodbpf_component_pkg}"
 		COMMAND find
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/root"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/ChmodBPF/root"
 			-type d
 			-exec chmod 755 "{}" +
 		COMMAND chmod 644
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/root/Library/LaunchDaemons/org.wireshark.ChmodBPF.plist"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/ChmodBPF/root/Library/LaunchDaemons/org.wireshark.ChmodBPF.plist"
 		COMMAND chmod 755
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/root/Library/Application Support/Wireshark/ChmodBPF/ChmodBPF"
-		COMMAND "${CMAKE_SOURCE_DIR}/packaging/macosx/osx-extras.sh"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/ChmodBPF/root/Library/Application Support/Wireshark/ChmodBPF/ChmodBPF"
+		COMMAND "${PROJECT_SOURCE_DIR}/packaging/macosx/osx-extras.sh"
 		COMMAND pkgbuild
 			--identifier org.wireshark.ChmodBPF.pkg
 			--version 1.1
 			--preserve-xattr
-			--root "${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/root"
-			--scripts "${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/install-scripts"
+			--root "${PROJECT_SOURCE_DIR}/packaging/macosx/ChmodBPF/root"
+			--scripts "${PROJECT_SOURCE_DIR}/packaging/macosx/ChmodBPF/install-scripts"
 			${install_chmodbpf_component_pkg}
 		DEPENDS
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/root/Library/Application Support/Wireshark/ChmodBPF/ChmodBPF"
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/root/Library/LaunchDaemons/org.wireshark.ChmodBPF.plist"
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/install-scripts/postinstall"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/ChmodBPF/root/Library/Application Support/Wireshark/ChmodBPF/ChmodBPF"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/ChmodBPF/root/Library/LaunchDaemons/org.wireshark.ChmodBPF.plist"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/ChmodBPF/install-scripts/postinstall"
 	)
-	set (install_chmodbpf_pkg "${CMAKE_BINARY_DIR}/run/Wireshark.app/Contents/Resources/Extras/Install ChmodBPF.pkg")
+	set (install_chmodbpf_pkg "${PROJECT_BINARY_DIR}/run/Wireshark.app/Contents/Resources/Extras/Install ChmodBPF.pkg")
 	add_custom_command(OUTPUT "${install_chmodbpf_pkg}"
 		COMMAND productbuild
 			--identifier org.wireshark.install.ChmodBPF.product
 			--version 1.1
-			--distribution "${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/install-distribution.xml"
-			--package-path "${CMAKE_BINARY_DIR}"
+			--distribution "${PROJECT_SOURCE_DIR}/packaging/macosx/ChmodBPF/install-distribution.xml"
+			--package-path "${PROJECT_BINARY_DIR}"
 			${install_chmodbpf_pkg}
 		DEPENDS
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/install-distribution.xml"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/ChmodBPF/install-distribution.xml"
 			${install_chmodbpf_component_pkg}
 	)
 
-	set (uninstall_chmodbpf_component_pkg "${CMAKE_BINARY_DIR}/uninstall.ChmodBPF.pkg")
+	set (uninstall_chmodbpf_component_pkg "${PROJECT_BINARY_DIR}/uninstall.ChmodBPF.pkg")
 	add_custom_command(OUTPUT "${uninstall_chmodbpf_component_pkg}"
 		COMMAND pkgbuild
 			--identifier org.wireshark.uninstall.ChmodBPF.pkg
 			--version 1.1
 			--nopayload
-			--scripts "${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/uninstall-scripts"
+			--scripts "${PROJECT_SOURCE_DIR}/packaging/macosx/ChmodBPF/uninstall-scripts"
 			${uninstall_chmodbpf_component_pkg}
 		DEPENDS
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/uninstall-scripts/postinstall"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/ChmodBPF/uninstall-scripts/postinstall"
 	)
-	set (uninstall_chmodbpf_pkg "${CMAKE_BINARY_DIR}/run/Wireshark.app/Contents/Resources/Extras/Uninstall ChmodBPF.pkg")
+	set (uninstall_chmodbpf_pkg "${PROJECT_BINARY_DIR}/run/Wireshark.app/Contents/Resources/Extras/Uninstall ChmodBPF.pkg")
 	add_custom_command(OUTPUT "${uninstall_chmodbpf_pkg}"
 		COMMAND productbuild
 			--identifier org.wireshark.uninstall.ChmodBPF.product
 			--version 1.1
-			--distribution "${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/uninstall-distribution.xml"
-			--package-path "${CMAKE_BINARY_DIR}"
+			--distribution "${PROJECT_SOURCE_DIR}/packaging/macosx/ChmodBPF/uninstall-distribution.xml"
+			--package-path "${PROJECT_BINARY_DIR}"
 			${uninstall_chmodbpf_pkg}
 		DEPENDS
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/ChmodBPF/uninstall-distribution.xml"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/ChmodBPF/uninstall-distribution.xml"
 			${uninstall_chmodbpf_component_pkg}
 	)
 
 	add_custom_target(chmodbpf DEPENDS ${install_chmodbpf_pkg} ${uninstall_chmodbpf_pkg})
 
-	set (install_path_helper_component_pkg "${CMAKE_BINARY_DIR}/install.path_helper.pkg")
+	set (install_path_helper_component_pkg "${PROJECT_BINARY_DIR}/install.path_helper.pkg")
 	add_custom_command(OUTPUT "${install_path_helper_component_pkg}"
 		COMMAND find
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/root"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/path_helper/root"
 			-type d
 			-exec chmod 755 "{}" +
 		COMMAND find
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/root"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/path_helper/root"
 			-type f
 			-exec chmod 644 "{}" +
 		COMMAND pkgbuild
 			--identifier org.wireshark.path_helper.pkg
 			--version 1.0
-			--root "${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/root/etc"
+			--root "${PROJECT_SOURCE_DIR}/packaging/macosx/path_helper/root/etc"
 			--install-location /private/etc
 			${install_path_helper_component_pkg}
 		DEPENDS
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/root/etc/paths.d/Wireshark"
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/root/etc/manpaths.d/Wireshark"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/path_helper/root/etc/paths.d/Wireshark"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/path_helper/root/etc/manpaths.d/Wireshark"
 	)
-	set (install_path_helper_pkg "${CMAKE_BINARY_DIR}/run/Wireshark.app/Contents/Resources/Extras/Add Wireshark to the system path.pkg")
+	set (install_path_helper_pkg "${PROJECT_BINARY_DIR}/run/Wireshark.app/Contents/Resources/Extras/Add Wireshark to the system path.pkg")
 	add_custom_command(OUTPUT "${install_path_helper_pkg}"
 		COMMAND productbuild
 			--identifier org.wireshark.install.path_helper.product
 			--version 1.0
-			--distribution "${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/install-distribution.xml"
-			--package-path "${CMAKE_BINARY_DIR}"
+			--distribution "${PROJECT_SOURCE_DIR}/packaging/macosx/path_helper/install-distribution.xml"
+			--package-path "${PROJECT_BINARY_DIR}"
 			${install_path_helper_pkg}
 		DEPENDS
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/install-distribution.xml"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/path_helper/install-distribution.xml"
 			${install_path_helper_component_pkg}
 	)
 
-	set (uninstall_path_helper_component_pkg "${CMAKE_BINARY_DIR}/uninstall.path_helper.pkg")
+	set (uninstall_path_helper_component_pkg "${PROJECT_BINARY_DIR}/uninstall.path_helper.pkg")
 	add_custom_command(OUTPUT "${uninstall_path_helper_component_pkg}"
 		COMMAND pkgbuild
 			--identifier org.wireshark.uninstall.path_helper.pkg
 			--version 1.0
 			--nopayload
-			--scripts "${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/uninstall-scripts"
+			--scripts "${PROJECT_SOURCE_DIR}/packaging/macosx/path_helper/uninstall-scripts"
 			${uninstall_path_helper_component_pkg}
 		DEPENDS
-			"${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/uninstall-scripts/postinstall"
+			"${PROJECT_SOURCE_DIR}/packaging/macosx/path_helper/uninstall-scripts/postinstall"
 	)
-	set (uninstall_path_helper_pkg "${CMAKE_BINARY_DIR}/run/Wireshark.app/Contents/Resources/Extras/Remove Wireshark from the system path.pkg")
+	set (uninstall_path_helper_pkg "${PROJECT_BINARY_DIR}/run/Wireshark.app/Contents/Resources/Extras/Remove Wireshark from the system path.pkg")
 	add_custom_command(OUTPUT "${uninstall_path_helper_pkg}"
 		COMMAND productbuild
 			--identifier org.wireshark.uninstall.path_helper.product
 			--version 1.0
-			--distribution "${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/uninstall-distribution.xml"
-			--package-path "${CMAKE_BINARY_DIR}"
+			--distribution "${PROJECT_SOURCE_DIR}/packaging/macosx/path_helper/uninstall-distribution.xml"
+			--package-path "${PROJECT_BINARY_DIR}"
 			${uninstall_path_helper_pkg}
 		DEPENDS
-			${CMAKE_SOURCE_DIR}/packaging/macosx/path_helper/uninstall-distribution.xml
+			${PROJECT_SOURCE_DIR}/packaging/macosx/path_helper/uninstall-distribution.xml
 			${uninstall_path_helper_component_pkg}
 	)
 
@@ -3425,8 +3439,8 @@ if(ENABLE_APPLICATION_BUNDLE AND BUILD_wireshark)
 	set_target_properties(wireshark_app_bundle PROPERTIES FOLDER "Copy Tasks")
 	add_custom_command(TARGET wireshark_app_bundle
 		POST_BUILD
-		COMMAND "${CMAKE_BINARY_DIR}/packaging/macosx/osx-app.sh"
-		WORKING_DIRECTORY "${CMAKE_BINARY_DIR}/run"
+		COMMAND "${PROJECT_BINARY_DIR}/packaging/macosx/osx-app.sh"
+		WORKING_DIRECTORY "${PROJECT_BINARY_DIR}/run"
 	)
 	add_dependencies(wireshark_app_bundle ${PROGLIST} chmodbpf path_helper)
 
@@ -3441,7 +3455,7 @@ if(ENABLE_APPLICATION_BUNDLE AND BUILD_wireshark)
 	COMMAND ${ASCIIDOCTOR_EXECUTABLE}
 		--backend html
 		--out-file ${_wireshark_read_me_first}
-		--attribute include-dir=${CMAKE_SOURCE_DIR}/docbook
+		--attribute include-dir=${PROJECT_SOURCE_DIR}/docbook
 		--attribute min-macos-version=${MIN_MACOS_VERSION}
 		${CMAKE_CURRENT_SOURCE_DIR}/packaging/macosx/Wireshark_read_me_first.adoc
 	DEPENDS
@@ -3455,7 +3469,7 @@ if(ENABLE_APPLICATION_BUNDLE AND BUILD_wireshark)
 	COMMAND ${ASCIIDOCTOR_EXECUTABLE}
 		--backend html
 		--out-file ${_wireshark_dsym_installation}
-		--attribute include-dir=${CMAKE_SOURCE_DIR}/docbook
+		--attribute include-dir=${PROJECT_SOURCE_DIR}/docbook
 		${CMAKE_CURRENT_SOURCE_DIR}/packaging/macosx/Wireshark_dsym_installation.adoc
 	DEPENDS
 		${CMAKE_CURRENT_SOURCE_DIR}/packaging/macosx/Wireshark_dsym_installation.adoc
@@ -3465,12 +3479,12 @@ if(ENABLE_APPLICATION_BUNDLE AND BUILD_wireshark)
 	add_dependencies(wireshark_dmg_prep wireshark_dmg_readmes)
 
 	ADD_CUSTOM_TARGET( wireshark_dmg
-		COMMAND bash -x ${CMAKE_BINARY_DIR}/packaging/macosx/osx-dmg.sh
+		COMMAND bash -x ${PROJECT_BINARY_DIR}/packaging/macosx/osx-dmg.sh
 		# Unlike wireshark_nsis_prep + wireshark_nsis, we can add a direct
 		# dependency here.
 		DEPENDS wireshark_dmg_prep
 		# We create Wireshark.app in "run". Do our work there.
-		WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/run
+		WORKING_DIRECTORY ${PROJECT_BINARY_DIR}/run
 	)
 
 endif()
@@ -3480,8 +3494,8 @@ if(ENABLE_APPLICATION_BUNDLE AND BUILD_logray)
 	set_target_properties(logray_app_bundle PROPERTIES FOLDER "Copy Tasks")
 	add_custom_command(TARGET logray_app_bundle
 		POST_BUILD
-		COMMAND "${CMAKE_BINARY_DIR}/packaging/macosx/osx-app.sh" --bundle Logray.app
-		WORKING_DIRECTORY "${CMAKE_BINARY_DIR}/run"
+		COMMAND "${PROJECT_BINARY_DIR}/packaging/macosx/osx-app.sh" --bundle Logray.app
+		WORKING_DIRECTORY "${PROJECT_BINARY_DIR}/run"
 	)
 
 	add_custom_target(logray_dmg_prep DEPENDS logray_app_bundle)
@@ -3495,7 +3509,7 @@ if(ENABLE_APPLICATION_BUNDLE AND BUILD_logray)
 	COMMAND ${ASCIIDOCTOR_EXECUTABLE}
 		--backend html
 		--out-file ${_logray_read_me_first}
-		--attribute include-dir=${CMAKE_SOURCE_DIR}/docbook
+		--attribute include-dir=${PROJECT_SOURCE_DIR}/docbook
 		--attribute min-macos-version=${MIN_MACOS_VERSION}
 		${CMAKE_CURRENT_SOURCE_DIR}/packaging/macosx/Logray_read_me_first.adoc
 	DEPENDS
@@ -3509,7 +3523,7 @@ if(ENABLE_APPLICATION_BUNDLE AND BUILD_logray)
 	COMMAND ${ASCIIDOCTOR_EXECUTABLE}
 		--backend html
 		--out-file ${_logray_dsym_installation}
-		--attribute include-dir=${CMAKE_SOURCE_DIR}/docbook
+		--attribute include-dir=${PROJECT_SOURCE_DIR}/docbook
 		${CMAKE_CURRENT_SOURCE_DIR}/packaging/macosx/Logray_dsym_installation.adoc
 	DEPENDS
 		${CMAKE_CURRENT_SOURCE_DIR}/packaging/macosx/Logray_dsym_installation.adoc
@@ -3519,12 +3533,12 @@ if(ENABLE_APPLICATION_BUNDLE AND BUILD_logray)
 	add_dependencies(logray_dmg_prep logray_dmg_readmes)
 
 	ADD_CUSTOM_TARGET( logray_dmg
-		COMMAND bash -x ${CMAKE_BINARY_DIR}/packaging/macosx/osx-dmg.sh --app-name Logray
+		COMMAND bash -x ${PROJECT_BINARY_DIR}/packaging/macosx/osx-dmg.sh --app-name Logray
 		# Unlike wireshark_nsis_prep + wireshark_nsis, we can add a direct
 		# dependency here.
 		DEPENDS logray_dmg_prep
 		# We create Wireshark.app in "run". Do our work there.
-		WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/run
+		WORKING_DIRECTORY ${PROJECT_BINARY_DIR}/run
 	)
 
 endif()
@@ -3541,10 +3555,10 @@ endif()
 
 
 string(REPLACE "-" "_" RPM_VERSION "${PROJECT_VERSION}")
-configure_file(packaging/rpm/wireshark.spec.in ${CMAKE_BINARY_DIR}/packaging/rpm/SPECS/wireshark.spec)
+configure_file(packaging/rpm/wireshark.spec.in ${PROJECT_BINARY_DIR}/packaging/rpm/SPECS/wireshark.spec)
 if(RPMBUILD_EXECUTABLE)
 	foreach(_rpm_dir BUILD RPMS SOURCES SPECS SRPMS)
-		file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}/packaging/rpm/${_rpm_dir}")
+		file(MAKE_DIRECTORY "${PROJECT_BINARY_DIR}/packaging/rpm/${_rpm_dir}")
 	endforeach()
 
 	set(_rpmbuild_with_args)
@@ -3658,22 +3672,22 @@ if(RPMBUILD_EXECUTABLE)
 
 	execute_process(
 		COMMAND ${PYTHON_EXECUTABLE}
-			${CMAKE_SOURCE_DIR}/tools/make-version.py
-			${CMAKE_SOURCE_DIR}
+			${PROJECT_SOURCE_DIR}/tools/make-version.py
+			${PROJECT_SOURCE_DIR}
 	)
 
 	add_custom_target(copy-dist
-		COMMAND cp ${CMAKE_BINARY_DIR}/wireshark*tar* ${CMAKE_BINARY_DIR}/packaging/rpm/SOURCES/
+		COMMAND cp ${PROJECT_BINARY_DIR}/wireshark*tar* ${PROJECT_BINARY_DIR}/packaging/rpm/SOURCES/
 		DEPENDS dist
 	)
 	add_custom_target(wireshark_rpm
 		COMMAND ${RPMBUILD_EXECUTABLE}
-			--define "_topdir ${CMAKE_BINARY_DIR}/packaging/rpm"
+			--define "_topdir ${PROJECT_BINARY_DIR}/packaging/rpm"
 			--define "_prefix ${CMAKE_INSTALL_PREFIX}"
 			${_rpmbuild_with_args}
 			-ba SPECS/wireshark.spec
 		DEPENDS copy-dist
-		WORKING_DIRECTORY "${CMAKE_BINARY_DIR}/packaging/rpm"
+		WORKING_DIRECTORY "${PROJECT_BINARY_DIR}/packaging/rpm"
 		COMMENT "Create a rpm from the current git commit."
 	)
 endif()
@@ -3692,7 +3706,7 @@ if(LINUXDEPLOYQT_EXECUTABLE AND APPIMAGETOOL_EXECUTABLE)
 			COMMAND false
 		)
 	endif()
-	set (_ai_appdir "${CMAKE_BINARY_DIR}/packaging/appimage/appdir")
+	set (_ai_appdir "${PROJECT_BINARY_DIR}/packaging/appimage/appdir")
 	add_custom_target(wireshark_appimage_appdir
 		COMMAND ${CMAKE_COMMAND} -E make_directory "${_ai_appdir}"
 		COMMAND env DESTDIR=${_ai_appdir}
@@ -3715,13 +3729,13 @@ if(LINUXDEPLOYQT_EXECUTABLE AND APPIMAGETOOL_EXECUTABLE)
 			${_exe_args}
 		COMMAND rm -f "${_ai_appdir}/AppRun"
 		COMMAND install
-			"${CMAKE_SOURCE_DIR}/packaging/appimage/AppRun"
+			"${PROJECT_SOURCE_DIR}/packaging/appimage/AppRun"
 			"${_ai_appdir}/AppRun"
 		DEPENDS wireshark_appimage_appdir
 	)
 	add_custom_target(wireshark_appimage
 		COMMAND env VERSION=${PROJECT_VERSION} ${APPIMAGETOOL_EXECUTABLE} appdir
-		WORKING_DIRECTORY "${CMAKE_BINARY_DIR}/packaging/appimage"
+		WORKING_DIRECTORY "${PROJECT_BINARY_DIR}/packaging/appimage"
 		DEPENDS wireshark_appimage_prep
 	)
 endif()
@@ -3787,7 +3801,7 @@ set(SHARK_PUBLIC_HEADERS
 	include/ws_posix_compat.h
 	include/ws_symbol_export.h
 	include/wireshark.h
-	${CMAKE_BINARY_DIR}/ws_version.h
+	${CMAKE_SOURCE_DIR}/libs/wireshark/ws_version.h
 )
 
 install(FILES ${SHARK_PUBLIC_HEADERS}
@@ -3822,7 +3836,7 @@ endif()
 
 install(
 	FILES
-		"${CMAKE_BINARY_DIR}/wireshark.pc"
+		"${PROJECT_BINARY_DIR}/wireshark.pc"
 	DESTINATION
 		${CMAKE_INSTALL_LIBDIR}/pkgconfig
 )
@@ -3869,7 +3883,7 @@ install(
 include(CMakePackageConfigHelpers)
 
 configure_package_config_file(WiresharkConfig.cmake.in
-	${CMAKE_BINARY_DIR}/WiresharkConfig.cmake
+	${PROJECT_BINARY_DIR}/WiresharkConfig.cmake
 	INSTALL_DESTINATION ${WIRESHARK_INSTALL_CMAKEDIR}
 	PATH_VARS
 		CMAKE_INSTALL_LIBDIR
@@ -3879,14 +3893,14 @@ configure_package_config_file(WiresharkConfig.cmake.in
 )
 
 write_basic_package_version_file(
-	${CMAKE_BINARY_DIR}/WiresharkConfigVersion.cmake
+	${PROJECT_BINARY_DIR}/WiresharkConfigVersion.cmake
 	COMPATIBILITY AnyNewerVersion
 )
 
 install(
 	FILES
-		${CMAKE_BINARY_DIR}/WiresharkConfig.cmake
-		${CMAKE_BINARY_DIR}/WiresharkConfigVersion.cmake
+		${PROJECT_BINARY_DIR}/WiresharkConfig.cmake
+		${PROJECT_BINARY_DIR}/WiresharkConfigVersion.cmake
 	DESTINATION
 		${WIRESHARK_INSTALL_CMAKEDIR}
 )
@@ -3998,7 +4012,7 @@ separate_arguments(TEST_EXTRA_ARGS)
 
 add_test(build_unittests
 	"${CMAKE_COMMAND}"
-	--build "${CMAKE_BINARY_DIR}"
+	--build "${PROJECT_BINARY_DIR}"
 	--config "${CONFIG}"
 	--target test-programs
 )
@@ -4008,7 +4022,7 @@ foreach(_group_name ${_test_group_list})
 	add_test(
 		NAME ${_group_name}
 		COMMAND ${CMAKE_COMMAND} -E env PYTHONIOENCODING=UTF-8
-			${PYTHON_EXECUTABLE} ${CMAKE_SOURCE_DIR}/test/test.py
+			${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/test/test.py
 			--verbose
 			--program-path $<TARGET_FILE_DIR:wmem_test>
 			${TEST_EXTRA_ARGS}
@@ -4020,12 +4034,12 @@ endforeach()
 set_tests_properties(suite_unittests PROPERTIES FIXTURES_REQUIRED unittests)
 
 # Make it possible to run pytest without passing the full path as argument.
-if(NOT CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
+if(NOT PROJECT_SOURCE_DIR STREQUAL PROJECT_BINARY_DIR)
 	file(READ "${CMAKE_CURRENT_SOURCE_DIR}/pytest.ini" pytest_ini)
 	string(REGEX REPLACE "\naddopts = ([^\n]+)"
 		"\naddopts = ${CMAKE_CURRENT_SOURCE_DIR}/test \\1"
 		pytest_ini "${pytest_ini}")
-	file(WRITE "${CMAKE_BINARY_DIR}/pytest.ini" "${pytest_ini}")
+	file(WRITE "${PROJECT_BINARY_DIR}/pytest.ini" "${pytest_ini}")
 endif()
 
 if (GIT_EXECUTABLE)
@@ -4033,7 +4047,7 @@ if (GIT_EXECUTABLE)
 	add_custom_target(
 		gen-authors
 		COMMAND ${PYTHON_EXECUTABLE} tools/generate_authors.py AUTHORS.src > AUTHORS
-		WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
+		WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
 	)
 else (GIT_EXECUTABLE)
 	add_custom_target( gen-authors COMMAND ${CMAKE_COMMAND} -E echo "Git not found." )
@@ -4041,7 +4055,7 @@ endif (GIT_EXECUTABLE)
 set_target_properties(gen-authors PROPERTIES FOLDER "Documentation")
 
 if (WIN32)
-	file (TO_NATIVE_PATH ${CMAKE_SOURCE_DIR}/tools/Get-HardenFlags.ps1 _win_harden_flags)
+	file (TO_NATIVE_PATH ${PROJECT_SOURCE_DIR}/tools/Get-HardenFlags.ps1 _win_harden_flags)
 	add_custom_target(hardening-check
 		COMMAND ${POWERSHELL_COMMAND} "${_win_harden_flags}" "${_dll_output_dir_win}"
 		DEPENDS ${PROGLIST}
@@ -4056,7 +4070,7 @@ else ()
 		foreach(_prog ${PROGLIST})
 			get_target_property(_prog_dir ${_prog} RUNTIME_OUTPUT_DIRECTORY)
 			if(NOT _prog_dir)
-				set(_prog_dir "${CMAKE_BINARY_DIR}/run")
+				set(_prog_dir "${PROJECT_BINARY_DIR}/run")
 			endif()
 			set(_prog_paths ${_prog_paths} "${_prog_dir}/${_prog}")
 		endforeach()
@@ -4103,7 +4117,7 @@ if(SHELLCHECK_EXECUTABLE)
 			tools/test-captures.sh
 			tools/update-tx
 			tools/valgrind-wireshark.sh
-		WORKING_DIRECTORY "${CMAKE_SOURCE_DIR}"
+		WORKING_DIRECTORY "${PROJECT_SOURCE_DIR}"
 	)
 endif()
 
@@ -4113,7 +4127,7 @@ configure_file(
 	"${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake"
 	IMMEDIATE @ONLY)
 
-add_custom_target(uninstall
+add_custom_target(uninstall_wireshark
 	COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake)
 
 # Break on programmer errors when debugging in Visual Studio
diff --git a/CMakeOptions.txt b/CMakeOptions.txt
index a3c57322d8a..c386944a2cd 100644
--- a/CMakeOptions.txt
+++ b/CMakeOptions.txt
@@ -4,7 +4,7 @@ option(BUILD_wireshark     "Build Wireshark" ON)
 option(BUILD_logray        "Build Logray" OFF)
 if(BUILD_wireshark OR BUILD_logray)
 	if(NOT DEFINED ENV{WIRESHARK_BUILD_WITH_QT5})
-		option(USE_qt6     "Use Qt6 instead of Qt5" ON)
+		option(USE_qt6     "Use Qt6 instead of Qt5" OFF)
 	else()
 		option(USE_qt6     "Use Qt6 instead of Qt5" OFF)
 	endif()
diff --git a/capture/CMakeLists.txt b/capture/CMakeLists.txt
index f25ddb31e69..8d78cf0bae0 100644
--- a/capture/CMakeLists.txt
+++ b/capture/CMakeLists.txt
@@ -49,7 +49,7 @@ add_library(caputils STATIC
 target_link_libraries(caputils
 	PUBLIC
 		wsutil
-		$<$<BOOL:${PCAP_FOUND}>:pcap::pcap>
+		pcap
 	PRIVATE
 		${NL_LIBRARIES}
 		${WIN_IPHLPAPI_LIBRARY}
@@ -87,7 +87,7 @@ add_library(capchild STATIC
 target_link_libraries(capchild
 	PRIVATE
 		wsutil
-		$<$<BOOL:${PCAP_FOUND}>:pcap::pcap>
+		pcap
 )
 
 set_target_properties(capchild PROPERTIES
@@ -113,6 +113,9 @@ CHECKAPI(
 	  ${CAPUTILS_SRC}
 )
 
+export(TARGETS caputils NAMESPACE wireshark::
+FILE ${PROJECT_BINARY_DIR}/caputils-targets.cmake)
+
 #
 # Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 #
diff --git a/capture/capture-pcap-util.h b/capture/capture-pcap-util.h
index c6cbb87f179..c9a69e4d544 100644
--- a/capture/capture-pcap-util.h
+++ b/capture/capture-pcap-util.h
@@ -43,8 +43,8 @@ GList *get_remote_interface_list(const char *hostname, const char *port,
                                  const char *passwd, int *err, char **err_str);
 #endif /* HAVE_PCAP_REMOTE */
 
-const char *linktype_val_to_name(int dlt);
-int linktype_name_to_val(const char *linktype);
+WS_DLL_PUBLIC const char *linktype_val_to_name(int dlt);
+WS_DLL_PUBLIC int linktype_name_to_val(const char *linktype);
 
 int get_pcap_datalink(pcap_t *pch, const char *devicename);
 
diff --git a/cfile.h b/cfile.h
index 976f1dfa18b..aee63c82905 100644
--- a/cfile.h
+++ b/cfile.h
@@ -61,6 +61,7 @@ struct packet_provider_data {
     frame_data  *prev_cap;
     frame_data_sequence *frames;         /* Sequence of frames, if we're keeping that information */
     GTree       *frames_modified_blocks; /* BST with modified blocks for frames (key = frame_data) */
+    unsigned int wmem_scopes_instance;   /* Instance number of the wmem scopes for this capture file */
 };
 
 typedef struct _capture_file {
diff --git a/cmake/modules/FindAsciidoctor.cmake b/cmake/modules/FindAsciidoctor.cmake
index 7a6f71616ff..8dcbcc6ca8b 100644
--- a/cmake/modules/FindAsciidoctor.cmake
+++ b/cmake/modules/FindAsciidoctor.cmake
@@ -46,12 +46,12 @@ if(ASCIIDOCTOR_EXECUTABLE)
         # --trace
         --quiet
         --attribute build_dir=${CMAKE_CURRENT_BINARY_DIR}
-        --require ${CMAKE_SOURCE_DIR}/docbook/asciidoctor-macros/ws_utils.rb
-        --require ${CMAKE_SOURCE_DIR}/docbook/asciidoctor-macros/commaize-block.rb
-        --require ${CMAKE_SOURCE_DIR}/docbook/asciidoctor-macros/cveidlink-inline-macro.rb
-        --require ${CMAKE_SOURCE_DIR}/docbook/asciidoctor-macros/manarg-block.rb
-        --require ${CMAKE_SOURCE_DIR}/docbook/asciidoctor-macros/wsbuglink-inline-macro.rb
-        --require ${CMAKE_SOURCE_DIR}/docbook/asciidoctor-macros/wssalink-inline-macro.rb
+        --require ${PROJECT_SOURCE_DIR}/docbook/asciidoctor-macros/ws_utils.rb
+        --require ${PROJECT_SOURCE_DIR}/docbook/asciidoctor-macros/commaize-block.rb
+        --require ${PROJECT_SOURCE_DIR}/docbook/asciidoctor-macros/cveidlink-inline-macro.rb
+        --require ${PROJECT_SOURCE_DIR}/docbook/asciidoctor-macros/manarg-block.rb
+        --require ${PROJECT_SOURCE_DIR}/docbook/asciidoctor-macros/wsbuglink-inline-macro.rb
+        --require ${PROJECT_SOURCE_DIR}/docbook/asciidoctor-macros/wssalink-inline-macro.rb
     )
 
     set(_asciidoctor_common_command
@@ -78,7 +78,7 @@ if(ASCIIDOCTOR_EXECUTABLE)
                 --out-file ${_output_xml}
                 ${CMAKE_CURRENT_SOURCE_DIR}/${_asciidocsource}
             DEPENDS
-                ${CMAKE_SOURCE_DIR}/docbook/attributes.adoc
+                ${PROJECT_SOURCE_DIR}/docbook/attributes.adoc
                 ${CMAKE_CURRENT_SOURCE_DIR}/${_asciidocsource}
                 ${ARGN}
         )
@@ -110,7 +110,7 @@ if(ASCIIDOCTOR_EXECUTABLE)
                 --out-file ${_output_html}
                 ${CMAKE_CURRENT_SOURCE_DIR}/${_asciidocsource}
             DEPENDS
-                ${CMAKE_SOURCE_DIR}/docbook/attributes.adoc
+                ${PROJECT_SOURCE_DIR}/docbook/attributes.adoc
                 ${CMAKE_CURRENT_SOURCE_DIR}/${_asciidocsource}
                 ${ARGN}
         )
@@ -127,12 +127,12 @@ if(ASCIIDOCTOR_EXECUTABLE)
         ADD_CUSTOM_COMMAND(
             OUTPUT
                 ${_output_txt}
-            COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_SOURCE_DIR}/tools/html2text.py
+            COMMAND ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/tools/html2text.py
                 ${_output_html}
                 > ${_output_txt}
             DEPENDS
                 ${MAN_INCLUDES}
-                ${CMAKE_SOURCE_DIR}/docbook/attributes.adoc
+                ${PROJECT_SOURCE_DIR}/docbook/attributes.adoc
                 ${CMAKE_CURRENT_SOURCE_DIR}/${_asciidocsource}
                 ${_output_html}
                 ${ARGN}
@@ -160,7 +160,7 @@ if(ASCIIDOCTOR_EXECUTABLE)
                 ${_input_adoc}
             DEPENDS
                 ${MAN_INCLUDES}
-                ${CMAKE_SOURCE_DIR}/docbook/attributes.adoc
+                ${PROJECT_SOURCE_DIR}/docbook/attributes.adoc
                 ${_input_adoc}
         )
         unset(_src_file)
@@ -187,7 +187,7 @@ if(ASCIIDOCTOR_EXECUTABLE)
                 ${_input_adoc}
             DEPENDS
                 ${MAN_INCLUDES}
-                ${CMAKE_SOURCE_DIR}/docbook/attributes.adoc
+                ${PROJECT_SOURCE_DIR}/docbook/attributes.adoc
                 ${_input_adoc}
         )
         unset(_src_file)
@@ -232,7 +232,7 @@ if(ASCIIDOCTOR_EXECUTABLE)
                     --out-file "${_output_pdf}"
                     ${CMAKE_CURRENT_SOURCE_DIR}/${_asciidocsource}
             DEPENDS
-                    ${CMAKE_SOURCE_DIR}/docbook/attributes.adoc
+                    ${PROJECT_SOURCE_DIR}/docbook/attributes.adoc
                     ${CMAKE_CURRENT_SOURCE_DIR}/${_asciidocsource}
                     ${ARGN}
             VERBATIM
@@ -283,7 +283,7 @@ if(ASCIIDOCTOR_EXECUTABLE)
                     --out-file "${_output_epub}"
                     ${CMAKE_CURRENT_SOURCE_DIR}/${_asciidocsource}
             DEPENDS
-                    ${CMAKE_SOURCE_DIR}/docbook/attributes.adoc
+                    ${PROJECT_SOURCE_DIR}/docbook/attributes.adoc
                     ${CMAKE_CURRENT_SOURCE_DIR}/${_asciidocsource}
                     ${ARGN}
             VERBATIM
diff --git a/cmake/modules/FindGLIB2.cmake b/cmake/modules/FindGLIB2.cmake
index 79e8abd29aa..d6186ce80ff 100644
--- a/cmake/modules/FindGLIB2.cmake
+++ b/cmake/modules/FindGLIB2.cmake
@@ -43,7 +43,6 @@ find_path( GLIB2_MAIN_INCLUDE_DIR
 		/opt/local/include
 		/sw/include
 		/usr/include
-		/usr/local/include
 )
 
 include(FindWSLibrary)
diff --git a/cmake/modules/UseAsn2Wrs.cmake b/cmake/modules/UseAsn2Wrs.cmake
index 9d7cdfed0c9..00c1d815366 100644
--- a/cmake/modules/UseAsn2Wrs.cmake
+++ b/cmake/modules/UseAsn2Wrs.cmake
@@ -8,7 +8,7 @@
 function(ASN2WRS)
 	if(NOT PY_ASN2WRS)
 		include(LocatePythonModule)
-		locate_python_module(asn2wrs REQUIRED PATHS "${CMAKE_SOURCE_DIR}/tools")
+		locate_python_module(asn2wrs REQUIRED PATHS "${PROJECT_SOURCE_DIR}/tools")
 	endif()
 
 	if(NOT PROTO_OPT)
@@ -18,7 +18,7 @@ function(ASN2WRS)
 	endif()
 
 	if(NOT A2W_OUTPUT_DIR)
-		set(A2W_OUTPUT_DIR "${CMAKE_SOURCE_DIR}/epan/dissectors")
+		set(A2W_OUTPUT_DIR "${PROJECT_SOURCE_DIR}/epan/dissectors")
 	endif()
 
 	set(DISSECTOR "${A2W_OUTPUT_DIR}/packet-${PROTOCOL_NAME}.c")
diff --git a/cmake/modules/UseCheckAPI.cmake b/cmake/modules/UseCheckAPI.cmake
index 1518fb4fe87..71a4e5c4e45 100644
--- a/cmake/modules/UseCheckAPI.cmake
+++ b/cmake/modules/UseCheckAPI.cmake
@@ -24,7 +24,7 @@ macro( CHECKAPI )
 	set(TARGET_NAME checkAPI_${CHECKAPI_NAME})
 	add_custom_target(${TARGET_NAME}
 		COMMAND ${PERL_EXECUTABLE}
-		  ${CMAKE_SOURCE_DIR}/tools/checkAPIs.pl
+		  ${PROJECT_SOURCE_DIR}/tools/checkAPIs.pl
 		  ${CHECKAPI_SWITCHES}
 		  ${CHECKAPI_SOURCES}
 		WORKING_DIRECTORY
diff --git a/cmake/modules/UseExecutableResources.cmake b/cmake/modules/UseExecutableResources.cmake
index 8eeb4a790ec..176d8ce5e41 100644
--- a/cmake/modules/UseExecutableResources.cmake
+++ b/cmake/modules/UseExecutableResources.cmake
@@ -14,13 +14,13 @@ function(set_executable_resources EXE_NAME PROGRAM_NAME)
 			# Use the original Wireshark / TShark .rc copyright.
 			set(COPYRIGHT_INFO "2000 Gerald Combs <gerald@wireshark.org>, Gilbert Ramirez <gram@alumni.rice.edu> and many others")
 		endif()
-		set(${EXE_NAME}_FILES ${${EXE_NAME}_FILES} ${CMAKE_BINARY_DIR}/resources/${EXE_NAME}.rc PARENT_SCOPE)
+		set(${EXE_NAME}_FILES ${${EXE_NAME}_FILES} ${PROJECT_BINARY_DIR}/resources/${EXE_NAME}.rc PARENT_SCOPE)
 		if (EXE_RC_UNIQUE_RC)
 			set (_in_file ${EXE_NAME})
 		else()
 			set (_in_file "cli_template")
 		endif()
-		set(ICON_PATH "${CMAKE_SOURCE_DIR}/resources/icons/")
-		configure_file( ${CMAKE_SOURCE_DIR}/resources/${_in_file}.rc.in ${CMAKE_BINARY_DIR}/resources/${EXE_NAME}.rc @ONLY )
+		set(ICON_PATH "${PROJECT_SOURCE_DIR}/resources/icons/")
+		configure_file( ${PROJECT_SOURCE_DIR}/resources/${_in_file}.rc.in ${PROJECT_BINARY_DIR}/resources/${EXE_NAME}.rc @ONLY )
 	endif()
 endfunction()
diff --git a/cmake/modules/UseLemon.cmake b/cmake/modules/UseLemon.cmake
index 28c4982931e..7996df45725 100644
--- a/cmake/modules/UseLemon.cmake
+++ b/cmake/modules/UseLemon.cmake
@@ -1,6 +1,6 @@
 #
 MACRO(ADD_LEMON_FILES _source _generated)
-    set(_lemonpardir ${CMAKE_SOURCE_DIR}/tools/lemon)
+    set(_lemonpardir ${PROJECT_SOURCE_DIR}/tools/lemon)
     FOREACH (_current_FILE ${ARGN})
       GET_FILENAME_COMPONENT(_in ${_current_FILE} ABSOLUTE)
       GET_FILENAME_COMPONENT(_basename ${_current_FILE} NAME_WE)
diff --git a/cmake/modules/UseMakePluginReg.cmake b/cmake/modules/UseMakePluginReg.cmake
index e6e6a9193df..8e7b78d7b58 100644
--- a/cmake/modules/UseMakePluginReg.cmake
+++ b/cmake/modules/UseMakePluginReg.cmake
@@ -1,9 +1,9 @@
 #
 function(register_plugin_files _outputfile _registertype)
 	include(LocatePythonModule)
-	locate_python_module(make-plugin-reg REQUIRED PATHS ${CMAKE_SOURCE_DIR}/tools)
+	locate_python_module(make-plugin-reg REQUIRED PATHS ${PROJECT_SOURCE_DIR}/tools)
 
-	file(RELATIVE_PATH output "${CMAKE_BINARY_DIR}" "${CMAKE_CURRENT_BINARY_DIR}/${_outputfile}")
+	file(RELATIVE_PATH output "${PROJECT_BINARY_DIR}" "${CMAKE_CURRENT_BINARY_DIR}/${_outputfile}")
 	add_custom_command(
 	    OUTPUT
 	      ${_outputfile}
diff --git a/cmake/modules/UseMakeTaps.cmake b/cmake/modules/UseMakeTaps.cmake
index aed93183ce1..e2a36d25af5 100644
--- a/cmake/modules/UseMakeTaps.cmake
+++ b/cmake/modules/UseMakeTaps.cmake
@@ -5,9 +5,9 @@ MACRO(REGISTER_TAP_FILES _outputfile)
         OUTPUT
           ${_outputfile}
         COMMAND
-          ${PYTHON_EXECUTABLE} ${CMAKE_SOURCE_DIR}/tools/make-regs.py taps ${_outputfile} ${_sources}
+          ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/tools/make-regs.py taps ${_outputfile} ${_sources}
         DEPENDS
-          ${CMAKE_SOURCE_DIR}/tools/make-regs.py
+          ${PROJECT_SOURCE_DIR}/tools/make-regs.py
           ${_sources}
         COMMENT
           "Making ${_outputfile}"
diff --git a/cmake/modules/WiresharkPlugin.cmake b/cmake/modules/WiresharkPlugin.cmake
index 76277e25684..8f633c94e8e 100644
--- a/cmake/modules/WiresharkPlugin.cmake
+++ b/cmake/modules/WiresharkPlugin.cmake
@@ -18,7 +18,7 @@ macro(SET_MODULE_INFO _plugin _ver_major _ver_minor _ver_micro _ver_extra)
 		if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/plugin.rc.in)
 			set(_plugin_rc_in ${CMAKE_CURRENT_SOURCE_DIR}/plugin.rc.in)
 		else()
-			set(_plugin_rc_in ${CMAKE_SOURCE_DIR}/plugins/plugin.rc.in)
+			set(_plugin_rc_in ${PROJECT_SOURCE_DIR}/plugins/plugin.rc.in)
 		endif()
 		configure_file(${_plugin_rc_in} plugin.rc @ONLY)
 		set(PLUGIN_RC_FILE ${CMAKE_CURRENT_BINARY_DIR}/plugin.rc)
diff --git a/doc/CMakeLists.txt b/doc/CMakeLists.txt
index 82b13f31f05..3a21903ebea 100644
--- a/doc/CMakeLists.txt
+++ b/doc/CMakeLists.txt
@@ -13,11 +13,11 @@ add_custom_command(
 	OUTPUT AUTHORS-SHORT
 	COMMAND ${PYTHON_EXECUTABLE}
 		${CMAKE_CURRENT_SOURCE_DIR}/make-authors-short.py
-		< ${CMAKE_SOURCE_DIR}/AUTHORS
+		< ${PROJECT_SOURCE_DIR}/AUTHORS
 		> ${CMAKE_CURRENT_BINARY_DIR}/AUTHORS-SHORT
 	DEPENDS
 		${CMAKE_CURRENT_SOURCE_DIR}/make-authors-short.py
-		${CMAKE_SOURCE_DIR}/AUTHORS
+		${PROJECT_SOURCE_DIR}/AUTHORS
 )
 
 set(MAN1_SOURCE_FILES)
diff --git a/doc/plugins.example/CMakeLists.txt b/doc/plugins.example/CMakeLists.txt
index 26e3ad25c9b..03d7711b2c2 100644
--- a/doc/plugins.example/CMakeLists.txt
+++ b/doc/plugins.example/CMakeLists.txt
@@ -59,16 +59,16 @@ add_custom_target(copy_plugin
 string(TOLOWER "${PROJECT_NAME}-${PROJECT_VERSION}" _pkgname)
 
 add_custom_target(package_prep
-	COMMAND ${CMAKE_COMMAND} -E make_directory  ${CMAKE_BINARY_DIR}/${_pkgname}
-	COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_SOURCE_DIR}/README $<TARGET_FILE:hello> ${CMAKE_BINARY_DIR}/${_pkgname}
+	COMMAND ${CMAKE_COMMAND} -E make_directory  ${PROJECT_BINARY_DIR}/${_pkgname}
+	COMMAND ${CMAKE_COMMAND} -E copy ${PROJECT_SOURCE_DIR}/README $<TARGET_FILE:hello> ${PROJECT_BINARY_DIR}/${_pkgname}
 )
 
 add_custom_target(package
-	COMMAND ${CMAKE_COMMAND} -E tar czf ${CMAKE_BINARY_DIR}/${_pkgname}.tar.gz --format=gnutar -- ${CMAKE_BINARY_DIR}/${_pkgname}
+	COMMAND ${CMAKE_COMMAND} -E tar czf ${PROJECT_BINARY_DIR}/${_pkgname}.tar.gz --format=gnutar -- ${PROJECT_BINARY_DIR}/${_pkgname}
 )
 add_dependencies(package package_prep)
 
 add_custom_target(package_zip
-	COMMAND ${CMAKE_COMMAND} -E tar cf ${CMAKE_BINARY_DIR}/${_pkgname}.zip --format=zip -- ${CMAKE_BINARY_DIR}/${_pkgname}
+	COMMAND ${CMAKE_COMMAND} -E tar cf ${PROJECT_BINARY_DIR}/${_pkgname}.zip --format=zip -- ${PROJECT_BINARY_DIR}/${_pkgname}
 )
 add_dependencies(package_zip package_prep)
diff --git a/docbook/CMakeLists.txt b/docbook/CMakeLists.txt
index 081d61ce29d..b2218f0c10c 100644
--- a/docbook/CMakeLists.txt
+++ b/docbook/CMakeLists.txt
@@ -258,7 +258,7 @@ set(WSUG_SOURCE
 )
 
 # Ensure ws.css is available when the user tries to open generated .html files.
-if(NOT CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
+if(NOT PROJECT_SOURCE_DIR STREQUAL PROJECT_BINARY_DIR)
 	add_custom_command(
 		OUTPUT ws.css
 		COMMAND ${CMAKE_COMMAND} -E copy_if_different
@@ -283,31 +283,31 @@ set(WSDG_SOURCE
 # new WSLUA_MODULE files must come right before any WSLUA_CONTINUE_MODULE
 # files for the same module
 set(WSLUA_MODULES
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_dumper.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_field.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_gui.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_int64.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_listener.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_pinfo.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_address.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_column.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_nstime.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_proto.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_dissector.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_pref.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_proto_expert.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_proto_field.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_tree.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_tvb.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_byte_array.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_file.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_file_handler.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_frame_info.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_capture_info.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_dir.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_wtap.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_utility.c
-	${CMAKE_SOURCE_DIR}/epan/wslua/wslua_struct.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_dumper.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_field.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_gui.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_int64.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_listener.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_pinfo.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_address.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_column.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_nstime.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_proto.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_dissector.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_pref.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_proto_expert.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_proto_field.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_tree.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_tvb.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_byte_array.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_file.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_file_handler.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_frame_info.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_capture_info.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_dir.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_wtap.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_utility.c
+	${PROJECT_SOURCE_DIR}/epan/wslua/wslua_struct.c
 )
 
 # Empty file to trigger wsluarm generation.
@@ -465,7 +465,7 @@ if (GUIDE_INSTALL_DIRS)
 	# match.
 	add_custom_target(install_guides
 		COMMAND ${CMAKE_COMMAND} -P
-			${CMAKE_SOURCE_DIR}/cmake/modules/FileInstall.cmake
+			${PROJECT_SOURCE_DIR}/cmake/modules/FileInstall.cmake
 			${GUIDE_INSTALL_DIRS}
 			${CMAKE_INSTALL_FULL_DOCDIR}
 		DEPENDS
@@ -493,7 +493,7 @@ add_custom_target(
 	news
 	COMMAND ${CMAKE_COMMAND} -E copy_if_different
 		${CMAKE_CURRENT_BINARY_DIR}/release-notes.txt
-		${CMAKE_SOURCE_DIR}/NEWS
+		${PROJECT_SOURCE_DIR}/NEWS
 	DEPENDS
 		${CMAKE_CURRENT_BINARY_DIR}/release-notes.txt
 )
diff --git a/epan/CMakeLists.txt b/epan/CMakeLists.txt
index 43a5e2445d7..65437ff4980 100644
--- a/epan/CMakeLists.txt
+++ b/epan/CMakeLists.txt
@@ -30,11 +30,11 @@ endif()
 add_custom_command(
 	OUTPUT ps.c
 	COMMAND ${PYTHON_EXECUTABLE}
-		${CMAKE_SOURCE_DIR}/tools/rdps.py
+		${PROJECT_SOURCE_DIR}/tools/rdps.py
 		${CMAKE_CURRENT_SOURCE_DIR}/print.ps
 		ps.c
 	DEPENDS
-		${CMAKE_SOURCE_DIR}/tools/rdps.py
+		${PROJECT_SOURCE_DIR}/tools/rdps.py
 		${CMAKE_CURRENT_SOURCE_DIR}/print.ps
 )
 
@@ -302,7 +302,7 @@ add_library(epan
 	$<TARGET_OBJECTS:dissector-registration>
 	$<TARGET_OBJECTS:ftypes>
 	$<$<BOOL:${LUA_FOUND}>:$<TARGET_OBJECTS:wslua>>
-	${CMAKE_BINARY_DIR}/resources/libwireshark.rc
+	${PROJECT_BINARY_DIR}/resources/libwireshark.rc
 )
 
 set_target_properties(epan PROPERTIES
@@ -354,7 +354,7 @@ target_include_directories(epan
 
 target_include_directories(epan
 	INTERFACE
-		$<BUILD_INTERFACE:${CMAKE_SOURCE_DIR}>
+		$<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>
 		$<INSTALL_INTERFACE:include/wireshark>
 )
 
@@ -380,6 +380,9 @@ target_include_directories(epan
 
 add_dependencies(epan lemon)
 
+export(TARGETS epan NAMESPACE wireshark::
+FILE ${PROJECT_BINARY_DIR}/wireshark-targets.cmake)
+
 install(TARGETS epan
 	EXPORT WiresharkTargets
 	RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
diff --git a/epan/conversation.c b/epan/conversation.c
index 88384aaadc8..ab91c6380f9 100644
--- a/epan/conversation.c
+++ b/epan/conversation.c
@@ -559,7 +559,10 @@ conversation_insert_into_hashtable(wmem_map_t *hashtable, conversation_t *conv)
         /* There's an existing chain for this key */
         DPRINT(("there's an existing conversation chain"));
 
-        chain_tail = chain_head->last;
+        if (G_LIKELY(chain_head->last))
+            chain_tail = chain_head->last;
+        else
+            chain_tail = chain_head;
 
         if (conv->setup_frame >= chain_tail->setup_frame) {
             /* This convo belongs at the end of the chain */
diff --git a/epan/dfilter/CMakeLists.txt b/epan/dfilter/CMakeLists.txt
index d77ed53f68a..055986578fc 100644
--- a/epan/dfilter/CMakeLists.txt
+++ b/epan/dfilter/CMakeLists.txt
@@ -82,8 +82,8 @@ target_include_directories(dfilter
 	PRIVATE
 		${CMAKE_CURRENT_BINARY_DIR}
 		${CMAKE_CURRENT_SOURCE_DIR}
-		${CMAKE_SOURCE_DIR}/epan
-		${CMAKE_SOURCE_DIR}/tools/lemon
+		${PROJECT_SOURCE_DIR}/epan
+		${PROJECT_SOURCE_DIR}/tools/lemon
 )
 
 set_target_properties(dfilter PROPERTIES
diff --git a/epan/dfilter/dfunctions.c b/epan/dfilter/dfunctions.c
index 689d9dbe45b..6cdbe3e6bdb 100644
--- a/epan/dfilter/dfunctions.c
+++ b/epan/dfilter/dfunctions.c
@@ -13,6 +13,7 @@
 #include "dfilter-int.h"
 #include "dfunctions.h"
 #include "sttype-field.h"
+#include "sttype-slice.h"
 #include "semcheck.h"
 
 #include <string.h>
@@ -239,6 +240,137 @@ df_func_abs(GSList *args, guint32 arg_count, GSList **retval)
     return TRUE;
 }
 
+static gboolean
+df_func_uint(GSList *args, guint32 arg_count, GSList **retval)
+{
+    GSList   *arg1;
+    fvalue_t *fv_arg, *new_fv;
+    char     *err_msg = NULL;
+    GSList   *result = NULL;
+
+    ws_assert(arg_count == 1);
+    arg1 = args->data;
+    if (arg1 == NULL)
+        return FALSE;
+
+    while (arg1) {
+        fv_arg = arg1->data;
+
+        new_fv = fvalue_new(FT_UINT64);
+        if (G_UNLIKELY(new_fv == NULL)) {
+            ws_debug("uint8: %s", err_msg);
+            g_free(err_msg);
+            err_msg = NULL;
+        }
+
+        switch (fvalue_type_ftenum(fv_arg))
+        {
+            case FT_UINT8:
+            case FT_INT8:
+                fvalue_set_uinteger64(new_fv, fv_arg->value.uinteger64 & 0x00000000000000FF);
+            case FT_UINT16:
+            case FT_INT16:
+                fvalue_set_uinteger64(new_fv, fv_arg->value.uinteger64 & 0x000000000000FFFF);
+            case FT_UINT24:
+            case FT_INT24:
+                fvalue_set_uinteger64(new_fv, fv_arg->value.uinteger64 & 0x0000000000FFFFFF);
+            case FT_UINT32:
+            case FT_INT32:
+                fvalue_set_uinteger64(new_fv, fv_arg->value.uinteger64 & 0x00000000FFFFFFFF);
+            case FT_UINT40:
+            case FT_INT40:
+                fvalue_set_uinteger64(new_fv, fv_arg->value.uinteger64 & 0x000000FFFFFFFFFF);
+            case FT_UINT48:
+            case FT_INT48:
+                fvalue_set_uinteger64(new_fv, fv_arg->value.uinteger64 & 0x0000FFFFFFFFFFFF);
+            case FT_UINT56:
+            case FT_INT56:
+                fvalue_set_uinteger64(new_fv, fv_arg->value.uinteger64 & 0x00FFFFFFFFFFFFFF);
+            case FT_UINT64:
+            case FT_INT64:
+                fvalue_set_uinteger64(new_fv, fv_arg->value.uinteger64);
+                break;
+            case FT_BYTES:
+            case FT_ETHER:
+
+                if (G_UNLIKELY(!fv_arg->value.bytes->len))
+                {
+                    ws_debug("!fv_arg->value.bytes->len=0");
+                    fvalue_free(new_fv);
+                    return FALSE;
+                }
+
+                ws_debug("----- UINT -----");
+                ws_debug("FT_BYTES len: %d", fv_arg->value.bytes->len);
+                if (ws_log_get_level() >= LOG_LEVEL_DEBUG) {
+
+                    char hex_str[512];
+                    size_t i;
+                    for (i = 0; i < fv_arg->value.bytes->len; i++)
+                    {
+                        sprintf(hex_str + i * 2, "%02X", fv_arg->value.bytes->data[i]);
+                    }
+                    hex_str[i*2 + 1] = 0;
+                    ws_debug("HEX: %s", hex_str);
+                }
+
+
+                switch (fv_arg->value.bytes->len)
+                {
+                    case 1:
+                        ws_debug("uint(FT_UINT8): %d", fv_arg->value.bytes->data[0]);
+                        fvalue_set_uinteger64(new_fv, fv_arg->value.bytes->data[0] & 0x00000000000000FF);
+                        break;
+                    case 2:
+                        ws_debug("uint(FT_UINT16): %d", *((uint16_t *)fv_arg->value.bytes->data) & 0x000000000000FFFF);
+                        fvalue_set_uinteger64(new_fv, *((uint16_t *)fv_arg->value.bytes->data) & 0x000000000000FFFF);
+                        break;
+                    case 3:
+                        ws_debug("uint(FT_UINT24): %d", *((uint16_t *)fv_arg->value.bytes->data) & 0x0000000000FFFFFF);
+                        fvalue_set_uinteger64(new_fv, *((uint32_t *)fv_arg->value.bytes->data) & 0x0000000000FFFFFF);
+                        break;
+                    case 4:
+                        ws_debug("uint(FT_UINT32): %d", *((uint16_t *)fv_arg->value.bytes->data) & 0x00000000FFFFFFFF);
+                        fvalue_set_uinteger64(new_fv, *((uint32_t *)fv_arg->value.bytes->data) & 0x00000000FFFFFFFF);
+                        break;
+                    case 5:
+                        ws_debug("uint(FT_UINT40): %lu", *((uint16_t *)fv_arg->value.bytes->data) & 0x000000FFFFFFFFFF);
+                        fvalue_set_uinteger64(new_fv, *((uint64_t *)fv_arg->value.bytes->data) & 0x000000FFFFFFFFFF);
+                        break;
+                    case 6:
+                        ws_debug("uint(FT_UINT48): %lu", *((uint16_t *)fv_arg->value.bytes->data) & 0x0000FFFFFFFFFFFF);
+                        fvalue_set_uinteger64(new_fv, *((uint64_t *)fv_arg->value.bytes->data) & 0x0000FFFFFFFFFFFF);
+                        break;
+                    case 7:
+                        ws_debug("uint(FT_UINT56): %lu", *((uint16_t *)fv_arg->value.bytes->data) & 0x00FFFFFFFFFFFFFF);
+                        fvalue_set_uinteger64(new_fv, *((uint64_t *)fv_arg->value.bytes->data) & 0x00FFFFFFFFFFFFFF);
+                        break;
+                    case 8:
+                        ws_debug("uint(FT_UINT64): %lu", *((uint16_t *)fv_arg->value.bytes->data) & fv_arg->value.uinteger64);
+                        fvalue_set_uinteger64(new_fv, fv_arg->value.uinteger64);
+                        break;
+                    default:
+                        ws_debug("TRUNCATED: uint(FT_UINT64): %lu", *((uint16_t *)fv_arg->value.bytes->data) & fv_arg->value.uinteger64);
+                        // slices with size greater than 8 bytes are truncated
+                        fvalue_set_uinteger64(new_fv, fv_arg->value.uinteger64);
+                        break;
+                }
+                break;
+            default:
+                break;
+        }
+
+        result = g_slist_prepend(result, new_fv);
+        arg1 = arg1->next;
+    }
+
+    if (g_slist_length(result) == 0)
+        return FALSE;
+
+    *retval = result;
+    return TRUE;
+}
+
 /* For upper() and lower() checks that the parameter passed to
  * it is an FT_STRING */
 static ftenum_t
@@ -440,6 +572,82 @@ ul_semcheck_absolute_value(dfwork_t *dfw, const char *func_name, ftenum_t lhs_ft
     return ftype;
 }
 
+static ftenum_t
+ul_semcheck_uint(dfwork_t *dfw, const char *func_name, ftenum_t lhs_ftype _U_,
+                            GSList *param_list, stloc_t *func_loc _U_)
+{
+    header_field_info *hfinfo;
+
+    ws_assert(g_slist_length(param_list) == 1);
+    stnode_t *st_node = param_list->data;
+
+    if (stnode_type_id(st_node) == STTYPE_FIELD) {
+        hfinfo = sttype_field_hfinfo(st_node);
+        switch (hfinfo->type) {
+            case FT_UINT8:
+            case FT_UINT16:
+            case FT_UINT24:
+            case FT_UINT32:
+            case FT_UINT40:
+            case FT_UINT48:
+            case FT_UINT56:
+            case FT_UINT64:
+            case FT_INT8:
+            case FT_INT16:
+            case FT_INT32:
+            case FT_INT40:
+            case FT_INT48:
+            case FT_INT56:
+            case FT_INT64:
+                return hfinfo->type;
+            case FT_BYTES:
+            case FT_ETHER:
+                return FT_UINT64;
+            default:
+                break;
+        }
+        FAIL(dfw, st_node, "uint conversion for field \"%s\" is not supported", hfinfo->abbrev);
+    }
+    else if (stnode_type_id(st_node) == STTYPE_SLICE) {
+        drange_t *drange = sttype_slice_drange(st_node);
+        stnode_t *slice = sttype_slice_entity(st_node);
+
+        if (stnode_type_id(slice) != STTYPE_FIELD)
+            FAIL(dfw, st_node, "Only fields can be sliced");
+
+        if (drange->total_length < 1)
+            FAIL(dfw, st_node, "Slice length must be at least 1 byte");
+
+        if (drange->total_length >= 8) {
+            return FT_UINT64;
+        }
+        else {
+            switch (drange->total_length) {
+                case 1:
+                    return FT_UINT8;
+                case 2:
+                    return FT_UINT16;
+                case 3:
+                    return FT_UINT24;
+                case 4:
+                    return FT_UINT32;
+                case 5:
+                    return FT_UINT40;
+                case 6:
+                    return FT_UINT48;
+                case 7:
+                    return FT_UINT56;
+                default:
+                    break;
+            }
+        }
+    }
+    FAIL(dfw, st_node, "Only integer fields or slices (bytes) can be used as parameter for %s()", func_name);
+}
+
+
+
+
 /* The table of all display-filter functions */
 static df_func_def_t
 df_functions[] = {
@@ -452,6 +660,8 @@ df_functions[] = {
     { "max",    df_func_max,    1, 0, ul_semcheck_compare },
     { "min",    df_func_min,    1, 0, ul_semcheck_compare },
     { "abs",    df_func_abs,    1, 1, ul_semcheck_absolute_value },
+    { "uint",   df_func_uint,   1, 1, ul_semcheck_uint },
+    // { "uint_be",  df_func_uint_be,  1, 1, ul_semcheck_uint }, // TODO
     { NULL, NULL, 0, 0, NULL }
 };
 
diff --git a/epan/dissectors/CMakeLists.txt b/epan/dissectors/CMakeLists.txt
index 49f6d77fcd8..2ba02bab1b0 100644
--- a/epan/dissectors/CMakeLists.txt
+++ b/epan/dissectors/CMakeLists.txt
@@ -16,23 +16,23 @@ add_subdirectory(pidl EXCLUDE_FROM_ALL)
 add_custom_command(
 	OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/packet-ncp2222.c
 	COMMAND ${PYTHON_EXECUTABLE}
-		${CMAKE_SOURCE_DIR}/tools/ncp2222.py
+		${PROJECT_SOURCE_DIR}/tools/ncp2222.py
 		-o ${CMAKE_CURRENT_BINARY_DIR}/packet-ncp2222.c
 	DEPENDS
 		packet-ncp2222.inc
-		${CMAKE_SOURCE_DIR}/tools/ncp2222.py
+		${PROJECT_SOURCE_DIR}/tools/ncp2222.py
 )
 
 add_custom_target(x11-dissector
 	COMMAND ${PERL_EXECUTABLE}
-		${CMAKE_SOURCE_DIR}/tools/process-x11-fields.pl ${CMAKE_CURRENT_SOURCE_DIR}
+		${PROJECT_SOURCE_DIR}/tools/process-x11-fields.pl ${CMAKE_CURRENT_SOURCE_DIR}
 		< ${CMAKE_CURRENT_SOURCE_DIR}/x11-fields
 	COMMAND ${PERL_EXECUTABLE}
-		${CMAKE_SOURCE_DIR}/tools/process-x11-xcb.pl ${CMAKE_CURRENT_SOURCE_DIR}
+		${PROJECT_SOURCE_DIR}/tools/process-x11-xcb.pl ${CMAKE_CURRENT_SOURCE_DIR}
 	DEPENDS
 		x11-fields
-		${CMAKE_SOURCE_DIR}/tools/process-x11-fields.pl
-		${CMAKE_SOURCE_DIR}/tools/process-x11-xcb.pl
+		${PROJECT_SOURCE_DIR}/tools/process-x11-fields.pl
+		${PROJECT_SOURCE_DIR}/tools/process-x11-xcb.pl
 		${CMAKE_CURRENT_SOURCE_DIR}/xcbproto
 		${CMAKE_CURRENT_SOURCE_DIR}/mesa
 )
@@ -1427,6 +1427,7 @@ set(DISSECTOR_SRC
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-maap.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-mac-lte-framed.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-mac-lte.c
+	${CMAKE_CURRENT_SOURCE_DIR}/packet-mac-nr-framed.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-mac-nr.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-maccontrol.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-macsec.c
@@ -1509,6 +1510,7 @@ set(DISSECTOR_SRC
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-nano.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-nas_5gs.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-nas_eps.c
+	${CMAKE_CURRENT_SOURCE_DIR}/packet-nas_eps-framed.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-nasdaq-itch.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-nasdaq-soup.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-nat-pmp.c
@@ -1628,6 +1630,7 @@ set(DISSECTOR_SRC
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-pcp.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-pdc.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-pdcp-lte.c
+	${CMAKE_CURRENT_SOURCE_DIR}/packet-pdcp-lte-framed.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-pdcp-nr.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-pdu-transport.c
 	${CMAKE_CURRENT_SOURCE_DIR}/packet-peap.c
@@ -2095,8 +2098,8 @@ file(GENERATE
 )
 add_custom_command(
 	OUTPUT dissectors.c
-	COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_SOURCE_DIR}/tools/make-regs.py dissectors dissectors.c @dissectors.in.txt
-	DEPENDS ${CMAKE_SOURCE_DIR}/tools/make-regs.py ${ALL_DISSECTOR_SRC}
+	COMMAND ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/tools/make-regs.py dissectors dissectors.c @dissectors.in.txt
+	DEPENDS ${PROJECT_SOURCE_DIR}/tools/make-regs.py ${ALL_DISSECTOR_SRC}
 		"${CMAKE_CURRENT_BINARY_DIR}/dissectors.in.txt"
 	COMMENT "Making dissectors.c"
 )
@@ -2161,7 +2164,7 @@ target_include_directories(dissectors
 	PRIVATE
 		${CMAKE_CURRENT_BINARY_DIR}
 		${CMAKE_CURRENT_SOURCE_DIR}
-		${CMAKE_SOURCE_DIR}/epan
+		${PROJECT_SOURCE_DIR}/epan
 )
 
 set_target_properties(dissectors PROPERTIES
diff --git a/epan/dissectors/dcerpc/CMakeLists.txt b/epan/dissectors/dcerpc/CMakeLists.txt
index e2762d3a03c..b0d33f788f9 100644
--- a/epan/dissectors/dcerpc/CMakeLists.txt
+++ b/epan/dissectors/dcerpc/CMakeLists.txt
@@ -33,7 +33,7 @@ foreach(PROTOCOL_NAME IN LISTS PIDL_DISSECTOR_NAMES)
 			"${CMAKE_CURRENT_BINARY_DIR}/packet-dcerpc-${PROTOCOL_NAME}-stamp"
 		WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/${PROTOCOL_NAME}"
 		DEPENDS
-			"${CMAKE_SOURCE_DIR}/tools/pidl/pidl"
+			"${PROJECT_SOURCE_DIR}/tools/pidl/pidl"
 			${PROTOCOL_NAME}/${PROTOCOL_NAME}.idl
 			${PROTOCOL_NAME}/${PROTOCOL_NAME}.cnf
 			${PROTOCOL_NAME}/packet-dcerpc-${PROTOCOL_NAME}-template.h
diff --git a/epan/dissectors/packet-bluetooth.c b/epan/dissectors/packet-bluetooth.c
index 448bfcac57f..f5177cf8611 100644
--- a/epan/dissectors/packet-bluetooth.c
+++ b/epan/dissectors/packet-bluetooth.c
@@ -4609,11 +4609,11 @@ dissect_bluetooth_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
     switch (pinfo->p2p_dir) {
 
     case P2P_DIR_SENT:
-        col_add_fstr(pinfo->cinfo, COL_INFO, "Sent ");
+        col_add_fstr(pinfo->cinfo, COL_INFO, "TX --> ");
         break;
 
     case P2P_DIR_RECV:
-        col_add_fstr(pinfo->cinfo, COL_INFO, "Rcvd ");
+        col_add_fstr(pinfo->cinfo, COL_INFO, "RX <-- ");
         break;
 
     default:
diff --git a/epan/dissectors/packet-bt3ds.c b/epan/dissectors/packet-bt3ds.c
index 8a22cdb70df..097abdc4614 100644
--- a/epan/dissectors/packet-bt3ds.c
+++ b/epan/dissectors/packet-bt3ds.c
@@ -60,10 +60,10 @@ dissect_bt3ds(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U
 
     switch (pinfo->p2p_dir) {
         case P2P_DIR_SENT:
-            col_set_str(pinfo->cinfo, COL_INFO, "Sent ");
+        col_set_str(pinfo->cinfo, COL_INFO, "RX <-- ");
             break;
         case P2P_DIR_RECV:
-            col_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");
+        col_set_str(pinfo->cinfo, COL_INFO, "TX --> ");
             break;
         default:
             col_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");
diff --git a/epan/dissectors/packet-btamp.c b/epan/dissectors/packet-btamp.c
index 4d7e04130f7..9f57e1f9fcb 100644
--- a/epan/dissectors/packet-btamp.c
+++ b/epan/dissectors/packet-btamp.c
@@ -382,10 +382,10 @@ dissect_btamp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U
 
     switch (pinfo->p2p_dir) {
         case P2P_DIR_SENT:
-            col_set_str(pinfo->cinfo, COL_INFO, "Sent ");
+        col_set_str(pinfo->cinfo, COL_INFO, "RX <-- ");
             break;
         case P2P_DIR_RECV:
-            col_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");
+        col_set_str(pinfo->cinfo, COL_INFO, "TX --> ");
             break;
         default:
             col_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");
diff --git a/epan/dissectors/packet-btbnep.c b/epan/dissectors/packet-btbnep.c
index bc1a2796f37..f4b27475fe5 100644
--- a/epan/dissectors/packet-btbnep.c
+++ b/epan/dissectors/packet-btbnep.c
@@ -288,10 +288,10 @@ dissect_btbnep(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _
 
     switch (pinfo->p2p_dir) {
         case P2P_DIR_SENT:
-            col_set_str(pinfo->cinfo, COL_INFO, "Sent ");
+        col_set_str(pinfo->cinfo, COL_INFO, "TX --> ");
             break;
         case P2P_DIR_RECV:
-            col_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");
+        col_set_str(pinfo->cinfo, COL_INFO, "RX <-- ");
             break;
         default:
             col_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");
diff --git a/epan/dissectors/packet-bthci_acl.c b/epan/dissectors/packet-bthci_acl.c
index bf500122c3b..ece974192d8 100644
--- a/epan/dissectors/packet-bthci_acl.c
+++ b/epan/dissectors/packet-bthci_acl.c
@@ -165,10 +165,10 @@ dissect_bthci_acl(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *dat
 
     switch (pinfo->p2p_dir) {
         case P2P_DIR_SENT:
-            col_set_str(pinfo->cinfo, COL_INFO, "Sent ");
+        col_set_str(pinfo->cinfo, COL_INFO, "TX --> ");
             break;
         case P2P_DIR_RECV:
-            col_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");
+        col_set_str(pinfo->cinfo, COL_INFO, "RX <-- ");
             break;
         default:
         col_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");
diff --git a/epan/dissectors/packet-bthid.c b/epan/dissectors/packet-bthid.c
index 99bfe5191ee..61f2a26bcf9 100644
--- a/epan/dissectors/packet-bthid.c
+++ b/epan/dissectors/packet-bthid.c
@@ -173,10 +173,10 @@ dissect_bthid(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U
 
     switch (pinfo->p2p_dir) {
         case P2P_DIR_SENT:
-            col_set_str(pinfo->cinfo, COL_INFO, "Sent ");
+        col_set_str(pinfo->cinfo, COL_INFO, "TX --> ");
             break;
         case P2P_DIR_RECV:
-            col_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");
+        col_set_str(pinfo->cinfo, COL_INFO, "RX <-- ");
             break;
         default:
             col_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");
diff --git a/epan/dissectors/packet-btl2cap.c b/epan/dissectors/packet-btl2cap.c
index 6e7ce41a142..898dad271ea 100644
--- a/epan/dissectors/packet-btl2cap.c
+++ b/epan/dissectors/packet-btl2cap.c
@@ -2412,10 +2412,10 @@ dissect_btl2cap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
     if (dir_in_col) {
         switch (pinfo->p2p_dir) {
         case P2P_DIR_SENT:
-            col_set_str(pinfo->cinfo, COL_INFO, "Sent ");
+            col_set_str(pinfo->cinfo, COL_INFO, "TX --> ");
             break;
         case P2P_DIR_RECV:
-            col_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");
+            col_set_str(pinfo->cinfo, COL_INFO, "RX <-- ");
             break;
         default:
             col_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");
diff --git a/epan/dissectors/packet-btle.c b/epan/dissectors/packet-btle.c
index a068c4e5fdc..23aad994039 100644
--- a/epan/dissectors/packet-btle.c
+++ b/epan/dissectors/packet-btle.c
@@ -1698,7 +1698,7 @@ dissect_btle(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
 
         proto_item_append_text(advertising_header_item, " (PDU Type: %s", adv_pdu_type_str_get(btle_context, pdu_type));
         item = proto_tree_add_item(advertising_header_tree, hf_advertising_header_pdu_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
-        proto_item_append_text(item, " %s", adv_pdu_type_str_get(btle_context, pdu_type));
+        // proto_item_append_text(item, " %s", adv_pdu_type_str_get(btle_context, pdu_type));
         proto_tree_add_item(advertising_header_tree, hf_advertising_header_rfu_1, tvb, offset, 1, ENC_LITTLE_ENDIAN);
 
         if (ch_sel_valid) {
@@ -3941,7 +3941,7 @@ proto_register_btle(void)
         },
         { &hf_advertising_header_pdu_type,
             { "PDU Type",                        "btle.advertising_header.pdu_type",
-            FT_UINT8, BASE_HEX, NULL, 0x0F,
+            FT_UINT8, BASE_HEX | BASE_EXT_STRING, &pdu_type_vals_ext, 0x0F,
             NULL, HFILL }
         },
         { &hf_advertising_header_rfu_1,
diff --git a/epan/dissectors/packet-btmcap.c b/epan/dissectors/packet-btmcap.c
index bfdcf5aeddd..4197f40830d 100644
--- a/epan/dissectors/packet-btmcap.c
+++ b/epan/dissectors/packet-btmcap.c
@@ -107,10 +107,10 @@ dissect_btmcap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _
 
     switch (pinfo->p2p_dir) {
         case P2P_DIR_SENT:
-            col_set_str(pinfo->cinfo, COL_INFO, "Sent ");
+        col_set_str(pinfo->cinfo, COL_INFO, "TX --> ");
             break;
         case P2P_DIR_RECV:
-            col_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");
+        col_set_str(pinfo->cinfo, COL_INFO, "RX <-- ");
             break;
         default:
             col_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");
diff --git a/epan/dissectors/packet-btrfcomm.c b/epan/dissectors/packet-btrfcomm.c
index 06f008f01e5..d01fc8747ca 100644
--- a/epan/dissectors/packet-btrfcomm.c
+++ b/epan/dissectors/packet-btrfcomm.c
@@ -598,10 +598,10 @@ dissect_btrfcomm(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data
 
     switch (pinfo->p2p_dir) {
         case P2P_DIR_SENT:
-            col_set_str(pinfo->cinfo, COL_INFO, "Sent ");
+            col_set_str(pinfo->cinfo, COL_INFO, "TX --> ");
             break;
         case P2P_DIR_RECV:
-            col_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");
+            col_set_str(pinfo->cinfo, COL_INFO, "RX <-- ");
             break;
         default:
             col_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");
@@ -1213,7 +1213,7 @@ dissect_btdun(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U
     if (is_at_cmd) {
         /* presumably an AT command */
         col_add_fstr(pinfo->cinfo, COL_INFO, "%s \"%s\"",
-                     (pinfo->p2p_dir == P2P_DIR_SENT) ? "Sent" : "Rcvd",
+                     (pinfo->p2p_dir == P2P_DIR_SENT) ? "TX -->" : "RX <--",
                      tvb_format_text(pinfo->pool, tvb, 0, length));
 
            proto_tree_add_item(st, hf_dun_at_cmd, tvb, 0, tvb_reported_length(tvb), ENC_ASCII|ENC_NA);
@@ -1226,7 +1226,7 @@ dissect_btdun(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U
             /* TODO: remove the above 'if' and this 'else-body' when "ppp_raw_hdlc" is available, requires that it is
                 made non-anonymous in ppp dissector to use */
             col_set_str(pinfo->cinfo, COL_PROTOCOL, "PPP");
-            col_add_fstr(pinfo->cinfo, COL_INFO, "%s <PPP frame>", (pinfo->p2p_dir == P2P_DIR_SENT) ? "Sent" : "Rcvd");
+            col_add_fstr(pinfo->cinfo, COL_INFO, "%s <PPP frame>", (pinfo->p2p_dir == P2P_DIR_SENT) ? "TX -->" : "RX <--");
 
             call_data_dissector(tvb, pinfo, tree);
         }
@@ -1292,7 +1292,7 @@ dissect_btspp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U
 
     if (ascii_only) {
         col_add_fstr(pinfo->cinfo, COL_INFO, "%s \"%s%s\"",
-                     (pinfo->p2p_dir == P2P_DIR_SENT) ? "Sent" : "Rcvd",
+                     (pinfo->p2p_dir == P2P_DIR_SENT) ? "TX -->" : "RX <--",
                      tvb_format_text(pinfo->pool, tvb, 0, length),
                      (tvb_captured_length(tvb) > length) ? "..." : "");
     }
@@ -1348,7 +1348,7 @@ dissect_btgnss(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _
     main_tree = proto_item_add_subtree(main_item, ett_btgnss);
 
     col_add_fstr(pinfo->cinfo, COL_INFO, "%s %s",
-            (pinfo->p2p_dir == P2P_DIR_SENT) ? "Sent" : "Rcvd",
+            (pinfo->p2p_dir == P2P_DIR_SENT) ? "TX -->" : "RX <--",
             tvb_format_text(pinfo->pool, tvb, 0, tvb_captured_length(tvb)));
 
     /* GNSS using NMEA-0183 protocol, but it is not available */
diff --git a/epan/dissectors/packet-btsap.c b/epan/dissectors/packet-btsap.c
index d0f098ac527..747956af717 100644
--- a/epan/dissectors/packet-btsap.c
+++ b/epan/dissectors/packet-btsap.c
@@ -389,10 +389,10 @@ dissect_btsap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U
 
     switch (pinfo->p2p_dir) {
         case P2P_DIR_SENT:
-            col_set_str(pinfo->cinfo, COL_INFO, "Sent ");
+            col_set_str(pinfo->cinfo, COL_INFO, "TX --> ");
             break;
         case P2P_DIR_RECV:
-            col_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");
+            col_set_str(pinfo->cinfo, COL_INFO, "RX <-- ");
             break;
         default:
             col_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");
diff --git a/epan/dissectors/packet-btsdp.c b/epan/dissectors/packet-btsdp.c
index 76085faed2c..2c39e7b6dfa 100644
--- a/epan/dissectors/packet-btsdp.c
+++ b/epan/dissectors/packet-btsdp.c
@@ -4502,10 +4502,10 @@ dissect_btsdp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
 
     switch (pinfo->p2p_dir) {
         case P2P_DIR_SENT:
-            col_set_str(pinfo->cinfo, COL_INFO, "Sent ");
+            col_set_str(pinfo->cinfo, COL_INFO, "TX --> ");
             break;
         case P2P_DIR_RECV:
-            col_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");
+            col_set_str(pinfo->cinfo, COL_INFO, "RX <-- ");
             break;
         default:
             col_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");
diff --git a/epan/dissectors/packet-e212.c b/epan/dissectors/packet-e212.c
index e3383a7abd5..c9b26d9b3db 100644
--- a/epan/dissectors/packet-e212.c
+++ b/epan/dissectors/packet-e212.c
@@ -3611,7 +3611,7 @@ proto_register_e212(void)
     },
     { &hf_E212_mcc_tai,
         { "Mobile Country Code (MCC)","e212.tai.mcc",
-        FT_UINT16, BASE_DEC|BASE_EXT_STRING, &E212_codes_ext, 0x0,
+        FT_UINT16, BASE_CUSTOM, &E212_codes_ext, 0x0,
         "Mobile Country Code MCC", HFILL }
     },
     { &hf_E212_mcc_nrcgi,
@@ -3626,7 +3626,7 @@ proto_register_e212(void)
     },
     { &hf_E212_mcc_gummei,
         { "Mobile Country Code (MCC)","e212.gummei.mcc",
-        FT_UINT16, BASE_DEC|BASE_EXT_STRING, &E212_codes_ext, 0x0,
+        FT_UINT16, BASE_CUSTOM, &E212_codes_ext, 0x0,
         "Mobile Country Code MCC", HFILL }
     },
     { &hf_E212_mcc_guami,
@@ -3666,7 +3666,7 @@ proto_register_e212(void)
     },
     { &hf_E212_mnc_tai,
         { "Mobile Network Code (MNC)","e212.tai.mnc",
-        FT_UINT16, BASE_DEC, NULL, 0x0,
+        FT_UINT16, BASE_CUSTOM, NULL, 0x0,
         "Mobile network code", HFILL }
     },
     { &hf_E212_mnc_nrcgi,
@@ -3681,7 +3681,7 @@ proto_register_e212(void)
     },
     { &hf_E212_mnc_gummei,
         { "Mobile Network Code (MNC)","e212.gummei.mnc",
-        FT_UINT16, BASE_DEC, NULL, 0x0,
+        FT_UINT16, BASE_CUSTOM, NULL, 0x0,
         "Mobile network code", HFILL }
     },
     { &hf_E212_mnc_guami,
diff --git a/epan/dissectors/packet-gsm_a_common.c b/epan/dissectors/packet-gsm_a_common.c
index b7e24fd37de..3ccd2a00cdd 100644
--- a/epan/dissectors/packet-gsm_a_common.c
+++ b/epan/dissectors/packet-gsm_a_common.c
@@ -1438,6 +1438,8 @@ guint16 elem_tlv(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint8 iei
             get_hf_elem_id(pdu_type), tvb,
             curr_offset, 1, oct);
 
+        // if (parm_len == 2)
+        //     puts("1");
         proto_tree_add_uint(subtree, hf_gsm_a_length, tvb,
             curr_offset + 1, lengt_length, parm_len);
 
@@ -1530,6 +1532,8 @@ guint16 elem_telv(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint8 ie
 
         proto_tree_add_item(subtree, hf_gsm_a_l_ext, tvb, curr_offset+1, 1, ENC_BIG_ENDIAN);
 
+        // if (lengt_length == 2)
+        //     puts("2");
         proto_tree_add_uint(subtree, hf_gsm_a_length, tvb,
             curr_offset + 1, lengt_length, parm_len);
 
@@ -1860,7 +1864,8 @@ elem_lv(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, gint pdu_type, int
 
     subtree = proto_tree_add_subtree_format(tree, tvb, curr_offset, parm_len + 1, elem_ett[idx], &item,
                                             "%s%s", elem_name, (name_add == NULL) || (name_add[0] == '\0') ? "" : name_add);
-
+        // if (parm_len == 2)
+        //     puts("4");
     proto_tree_add_uint(subtree, hf_gsm_a_length, tvb,
         curr_offset, 1, parm_len);
 
diff --git a/epan/dissectors/packet-hci_h1.c b/epan/dissectors/packet-hci_h1.c
index f0cd09eea17..5b9e5808fc6 100644
--- a/epan/dissectors/packet-hci_h1.c
+++ b/epan/dissectors/packet-hci_h1.c
@@ -35,8 +35,8 @@ static const value_string hci_h1_type_vals[] = {
 };
 static const value_string hci_h1_direction_vals[] = {
     {-1, "Unknown"},
-    {0,    "Sent"},
-    {1,    "Rcvd"},
+    {0, "TX -->"},
+    {1, "RX <--"},
     {0, NULL}
 };
 
diff --git a/epan/dissectors/packet-hci_h4.c b/epan/dissectors/packet-hci_h4.c
index 1811769dce0..5ebdafa9abd 100644
--- a/epan/dissectors/packet-hci_h4.c
+++ b/epan/dissectors/packet-hci_h4.c
@@ -39,8 +39,8 @@ static const value_string hci_h4_type_vals[] = {
     {0, NULL }
 };
 static const value_string hci_h4_direction_vals[] = {
-    {P2P_DIR_SENT,        "Sent"},
-    {P2P_DIR_RECV,        "Rcvd"},
+    {P2P_DIR_SENT, "TX --> "},
+    {P2P_DIR_RECV, "RX <-- "},
     {P2P_DIR_UNKNOWN,     "Unspecified"},
     {0, NULL}
 };
@@ -64,11 +64,11 @@ dissect_hci_h4(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)
     switch (pinfo->p2p_dir) {
 
     case P2P_DIR_SENT:
-        col_add_fstr(pinfo->cinfo, COL_INFO, "Sent ");
+        col_add_fstr(pinfo->cinfo, COL_INFO, "TX --> ");
         break;
 
     case P2P_DIR_RECV:
-        col_add_fstr(pinfo->cinfo, COL_INFO, "Rcvd ");
+        col_add_fstr(pinfo->cinfo, COL_INFO, "RX <-- ");
         break;
 
     case P2P_DIR_UNKNOWN:
diff --git a/epan/dissectors/packet-ieee1722.c b/epan/dissectors/packet-ieee1722.c
index 70d0bacb47c..e54f457d768 100644
--- a/epan/dissectors/packet-ieee1722.c
+++ b/epan/dissectors/packet-ieee1722.c
@@ -890,7 +890,12 @@ static int dissect_1722_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tr
         }
         offset += 4;
         next_tvb = tvb_new_subset_remaining(tvb, offset);
-    } else {
+    }
+    // else if (transport == IEEE_1722_TRANSPORT_ETH) {
+    //     // offset += 1;
+    //     // next_tvb = tvb_new_subset_remaining(tvb, offset);
+    // }
+    else {
         next_tvb = tvb;
     }
 
diff --git a/epan/dissectors/packet-ieee80211.c b/epan/dissectors/packet-ieee80211.c
index 0eca71118d7..44dba2f15a0 100644
--- a/epan/dissectors/packet-ieee80211.c
+++ b/epan/dissectors/packet-ieee80211.c
@@ -16378,8 +16378,10 @@ decode_qos_parameter_set(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, in
     cwmax= (1 << ecwmax) - 1;
     proto_tree_add_item(ecw_tree, hf_ieee80211_wfa_ie_wme_acp_ecw_max, tvb, offset, 1, ENC_NA);
     proto_tree_add_item(ecw_tree, hf_ieee80211_wfa_ie_wme_acp_ecw_min, tvb, offset, 1, ENC_NA);
-    proto_tree_add_uint(ecw_tree, hf_ieee80211_wfa_ie_wme_acp_cw_max, tvb, offset, 1, cwmax);
-    proto_tree_add_uint(ecw_tree, hf_ieee80211_wfa_ie_wme_acp_cw_min, tvb, offset, 1, cwmin);
+    ecw_item = proto_tree_add_uint(ecw_tree, hf_ieee80211_wfa_ie_wme_acp_cw_max, tvb, offset, 1, cwmax);
+    proto_item_set_generated(ecw_item);
+    ecw_item = proto_tree_add_uint(ecw_tree, hf_ieee80211_wfa_ie_wme_acp_cw_min, tvb, offset, 1, cwmin);
+    proto_item_set_generated(ecw_item);
     proto_item_append_text(ac_item, ", ECWmin/max %u/%u (CWmin/max %u/%u)", ecwmin, ecwmax, cwmin, cwmax);
     offset += 1;
 
diff --git a/epan/dissectors/packet-lte-rrc.c b/epan/dissectors/packet-lte-rrc.c
index 01078e22a69..de88f3ab4e1 100644
--- a/epan/dissectors/packet-lte-rrc.c
+++ b/epan/dissectors/packet-lte-rrc.c
@@ -135513,7 +135513,7 @@ void proto_register_lte_rrc(void) {
         FT_UINT32, BASE_DEC, VALS(lte_rrc_DL_CCCH_MessageType_vals), 0,
         "DL_CCCH_MessageType", HFILL }},
     { &hf_lte_rrc_c1_12,
-      { "c1", "lte-rrc.c1",
+      { "c1", "lte-rrc.c1_12",
         FT_UINT32, BASE_DEC, VALS(lte_rrc_T_c1_12_vals), 0,
         "T_c1_12", HFILL }},
     { &hf_lte_rrc_rrcConnectionReestablishment,
@@ -135553,7 +135553,7 @@ void proto_register_lte_rrc(void) {
         FT_UINT32, BASE_DEC, VALS(lte_rrc_DL_DCCH_MessageType_vals), 0,
         "DL_DCCH_MessageType", HFILL }},
     { &hf_lte_rrc_c1_13,
-      { "c1", "lte-rrc.c1",
+      { "c1", "lte-rrc.c1_13",
         FT_UINT32, BASE_DEC, VALS(lte_rrc_T_c1_13_vals), 0,
         "T_c1_13", HFILL }},
     { &hf_lte_rrc_csfbParametersResponseCDMA2000,
@@ -135621,7 +135621,7 @@ void proto_register_lte_rrc(void) {
         FT_UINT32, BASE_DEC, VALS(lte_rrc_UL_CCCH_MessageType_vals), 0,
         "UL_CCCH_MessageType", HFILL }},
     { &hf_lte_rrc_c1_14,
-      { "c1", "lte-rrc.c1",
+      { "c1", "lte-rrc.c1_14",
         FT_UINT32, BASE_DEC, VALS(lte_rrc_T_c1_14_vals), 0,
         "T_c1_14", HFILL }},
     { &hf_lte_rrc_rrcConnectionReestablishmentRequest,
@@ -135665,7 +135665,7 @@ void proto_register_lte_rrc(void) {
         FT_UINT32, BASE_DEC, VALS(lte_rrc_UL_DCCH_MessageType_vals), 0,
         "UL_DCCH_MessageType", HFILL }},
     { &hf_lte_rrc_c1_15,
-      { "c1", "lte-rrc.c1",
+      { "c1", "lte-rrc.c1_15",
         FT_UINT32, BASE_DEC, VALS(lte_rrc_T_c1_15_vals), 0,
         "T_c1_15", HFILL }},
     { &hf_lte_rrc_csfbParametersRequestCDMA2000,
diff --git a/epan/dissectors/packet-mac-lte-framed.c b/epan/dissectors/packet-mac-lte-framed.c
index 0a805513af2..5361a615399 100644
--- a/epan/dissectors/packet-mac-lte-framed.c
+++ b/epan/dissectors/packet-mac-lte-framed.c
@@ -18,21 +18,22 @@
 void proto_register_mac_lte_framed(void);
 
 /* Initialize the protocol and registered fields. */
+extern int proto_mac_lte;
 static int proto_mac_lte_framed = -1;
 
-extern int proto_mac_lte;
+/* Subdissectors */
+static dissector_handle_t mac_lte_handle;
 
 /* Main dissection function. */
 static int dissect_mac_lte_framed(tvbuff_t *tvb, packet_info *pinfo,
-                                   proto_tree *tree, void* data _U_)
+                                  proto_tree *tree, void *data _U_)
 {
-    gint                 offset = 0;
-    struct mac_lte_info  *p_mac_lte_info;
-    tvbuff_t             *mac_tvb;
-    gboolean             infoAlreadySet = FALSE;
+    gint offset = 0;
+    struct mac_lte_info *p_mac_lte_info = NULL;
+    tvbuff_t *mac_tvb;
+    gboolean infoAlreadySet = FALSE;
 
     /* Need to find enabled mac-lte dissector */
-    dissector_handle_t   mac_lte_handle = find_dissector("mac-lte");
     if (!mac_lte_handle) {
         return 0;
     }
@@ -86,6 +87,11 @@ void proto_register_mac_lte_framed(void)
     register_dissector("mac-lte-framed", dissect_mac_lte_framed, proto_mac_lte_framed);
 }
 
+void proto_reg_handoff_mac_lte_framed(void)
+{
+    mac_lte_handle = find_dissector("mac-lte");
+}
+
 /*
  * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
  *
diff --git a/epan/dissectors/packet-mac-lte.c b/epan/dissectors/packet-mac-lte.c
index 1b4befd6af3..6d091c6d99a 100644
--- a/epan/dissectors/packet-mac-lte.c
+++ b/epan/dissectors/packet-mac-lte.c
@@ -3531,7 +3531,7 @@ static void call_rlc_dissector(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tr
                                guint8 priority, gboolean rlcExtLiField, mac_lte_nb_mode nbMode)
 {
     tvbuff_t            *rb_tvb = tvb_new_subset_length(tvb, offset, data_length);
-    struct rlc_lte_info *p_rlc_lte_info;
+    struct rlc_lte_info *p_rlc_lte_info = NULL;
 
     /* Resuse or create RLC info */
     p_rlc_lte_info = (rlc_lte_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rlc_lte, 0);
diff --git a/epan/dissectors/packet-mac-nr-framed.c b/epan/dissectors/packet-mac-nr-framed.c
new file mode 100644
index 00000000000..258dec743fd
--- /dev/null
+++ b/epan/dissectors/packet-mac-nr-framed.c
@@ -0,0 +1,157 @@
+/* Routines for MAC LTE format files with context info as header.
+ *
+ * Martin Mathieson
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "config.h"
+
+#include <epan/packet.h>
+#include <epan/proto_data.h>
+#include <epan/expert.h>
+#include "packet-mac-nr.h"
+#include <stdio.h>
+
+void proto_register_mac_nr_framed(void);
+
+/* Initialize the protocol and registered fields. */
+extern int proto_mac_nr;
+static int proto_mac_nr_framed = -1;
+extern int ett_mac_nr;
+extern expert_field ei_mac_nr_unknown_udp_framing_tag;
+
+/* Subdissectors */
+static dissector_handle_t mac_nr_handle;
+
+/* Main dissection function. */
+static int dissect_mac_nr_framed(tvbuff_t *tvb, packet_info *pinfo,
+                                   proto_tree *tree, void* data _U_)
+{
+    gint        offset = 0;
+    mac_nr_info *p_mac_nr_info;
+    tvbuff_t    *mac_tvb;
+    guint8      tag;
+
+    /* Do this again on re-dissection to re-discover offset of actual PDU */
+
+       /* Needs to be at least as long as:
+       - fixed header bytes
+       - tag for data
+       - at least one byte of MAC PDU payload */
+
+    if ((size_t)tvb_reported_length_remaining(tvb, offset) < (3+2)) {
+        return 5;
+    }
+
+   /* If redissecting, use previous info struct (if available) */
+    p_mac_nr_info = (mac_nr_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_mac_nr, 0);
+    if (p_mac_nr_info == NULL) {
+        /* Allocate new info struct for this frame */
+        p_mac_nr_info = wmem_new0(wmem_file_scope(), mac_nr_info);
+
+        /* Read fixed fields */
+        p_mac_nr_info->radioType = tvb_get_guint8(tvb, offset++);
+        p_mac_nr_info->direction = tvb_get_guint8(tvb, offset++);
+        p_mac_nr_info->rntiType = tvb_get_guint8(tvb, offset++);
+
+        /* Read optional fields */
+        do {
+            /* Process next tag */
+            tag = tvb_get_guint8(tvb, offset++);
+            switch (tag) {
+                case MAC_NR_RNTI_TAG:
+                    p_mac_nr_info->rnti = tvb_get_ntohs(tvb, offset);
+                    offset += 2;
+                    break;
+                case MAC_NR_UEID_TAG:
+                    p_mac_nr_info->ueid = tvb_get_ntohs(tvb, offset);
+                    offset += 2;
+                    break;
+                case MAC_NR_HARQID:
+                    p_mac_nr_info->harqid = tvb_get_guint8(tvb, offset);
+                    offset++;
+                    break;
+                case MAC_NR_FRAME_SUBFRAME_TAG:
+                    /* deprecated */
+                    offset += 2;
+                    break;
+                case MAC_NR_PHR_TYPE2_OTHERCELL_TAG:
+                    p_mac_nr_info->phr_type2_othercell = tvb_get_guint8(tvb, offset);
+                    offset++;
+                    break;
+                case MAC_NR_FRAME_SLOT_TAG:
+                    p_mac_nr_info->sfnSlotInfoPresent = TRUE;
+                    p_mac_nr_info->sysframeNumber = tvb_get_ntohs(tvb, offset);
+                    p_mac_nr_info->slotNumber = tvb_get_ntohs(tvb, offset+2);
+                    offset += 4;
+                    break;
+                case MAC_NR_PAYLOAD_TAG:
+                    /* Have reached data, so set payload length and get out of loop */
+                    /* TODO: this is not correct if there is padding which isn't in frame */
+                    p_mac_nr_info->length = tvb_reported_length_remaining(tvb, offset);
+                    continue;
+                default:
+                    /* It must be a recognised tag */
+                    {
+                        proto_item *ti;
+                        proto_tree *subtree;
+
+                        col_set_str(pinfo->cinfo, COL_PROTOCOL, "MAC-NR");
+                        col_clear(pinfo->cinfo, COL_INFO);
+                        ti = proto_tree_add_item(tree, proto_mac_nr, tvb, offset, tvb_reported_length(tvb), ENC_NA);
+                        subtree = proto_item_add_subtree(ti, ett_mac_nr);
+                        proto_tree_add_expert(subtree, pinfo, &ei_mac_nr_unknown_udp_framing_tag,
+                                              tvb, offset-1, 1);
+                    }
+                    wmem_free(wmem_file_scope(), p_mac_nr_info);
+                    return TRUE;
+            }
+        } while (tag != MAC_NR_PAYLOAD_TAG);
+
+        p_add_proto_data(wmem_file_scope(), pinfo, proto_mac_nr, 0, p_mac_nr_info);
+    }
+    else {
+        offset = tvb_reported_length(tvb) - p_mac_nr_info->length;
+    }
+
+    /**************************************/
+    /* OK, now dissect as MAC NR          */
+
+    /* Create tvb that starts at actual MAC PDU */
+    mac_tvb = tvb_new_subset_remaining(tvb, offset);
+    // dissect_mac_nr(mac_tvb, pinfo, tree, NULL);
+    call_dissector_only(mac_nr_handle, mac_tvb, pinfo, tree, NULL);
+
+    return TRUE;
+}
+
+void proto_register_mac_nr_framed(void)
+{
+    /* Register protocol. */
+    proto_mac_nr_framed = proto_register_protocol("mac-nr-framed", "MAC-NR-FRAMED", "mac-nr-framed");
+
+    /* Allow other dissectors to find this one by name. */
+    register_dissector("mac-nr-framed", dissect_mac_nr_framed, proto_mac_nr_framed);
+}
+
+void proto_reg_handoff_mac_nr_framed(void){
+    mac_nr_handle = find_dissector("mac-nr");
+}
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 4
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=4 tabstop=8 expandtab:
+ * :indentSize=4:tabSize=8:noTabs=true:
+ */
diff --git a/epan/dissectors/packet-mac-nr.c b/epan/dissectors/packet-mac-nr.c
index 1c9b445ee08..828758a9fd7 100644
--- a/epan/dissectors/packet-mac-nr.c
+++ b/epan/dissectors/packet-mac-nr.c
@@ -313,7 +313,7 @@ static int hf_mac_nr_rar_temp_crnti = -1;
 static int hf_mac_nr_padding = -1;
 
 /* Subtrees. */
-static int ett_mac_nr = -1;
+int ett_mac_nr = -1;
 static int ett_mac_nr_context = -1;
 static int ett_mac_nr_subheader = -1;
 static int ett_mac_nr_rar_subheader = -1;
@@ -322,7 +322,7 @@ static int ett_mac_nr_me_phr_entry = -1;
 
 static expert_field ei_mac_nr_no_per_frame_data = EI_INIT;
 static expert_field ei_mac_nr_sdu_length_different_from_dissected = EI_INIT;
-static expert_field ei_mac_nr_unknown_udp_framing_tag = EI_INIT;
+expert_field ei_mac_nr_unknown_udp_framing_tag = EI_INIT;
 static expert_field ei_mac_nr_dl_sch_control_subheader_after_data_subheader = EI_INIT;
 static expert_field ei_mac_nr_ul_sch_control_subheader_before_data_subheader = EI_INIT;
 
diff --git a/epan/dissectors/packet-nas_eps-framed.c b/epan/dissectors/packet-nas_eps-framed.c
new file mode 100644
index 00000000000..60dfc22ea6a
--- /dev/null
+++ b/epan/dissectors/packet-nas_eps-framed.c
@@ -0,0 +1,77 @@
+/* Routines for NAS EPS format files with raw PDU.
+ *
+ * Matheus Eduardo Garbelini
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "config.h"
+
+#include <epan/packet.h>
+#include <epan/proto_data.h>
+
+void proto_register_mac_lte_framed(void);
+
+/* Initialize the protocol and registered fields. */
+static int proto_nas_eps_framed = -1;
+static  dissector_handle_t nas_eps_handle = NULL;
+
+extern int proto_nas_eps;
+
+/* Main dissection function. */
+static int dissect_nas_eps_framed(tvbuff_t *tvb, packet_info *pinfo,
+                                   proto_tree *tree, void* data _U_)
+{
+    gint                 offset = 0;
+    
+    if (!nas_eps_handle) {
+        return 0;
+    }
+
+    /* Do this again on re-dissection to re-discover offset of actual PDU */
+
+    /* Needs to be at least as long as:
+       - at least one byte of MAC PDU payload */
+    if ((size_t)tvb_reported_length_remaining(tvb, offset) < (1)) {
+        return 0;
+    }
+
+    /**************************************/
+    /* OK, now dissect as NAS EPS         */
+    call_dissector_only(nas_eps_handle, tvb, pinfo, tree, NULL);
+    return tvb_captured_length(tvb);
+}
+
+void proto_register_nas_eps_framed(void)
+{
+    /* Register protocol. */
+    proto_nas_eps_framed = proto_register_protocol("nas-eps-framed", "NAS-EPS-FRAMED", "nas-eps-framed");
+    /* Create tvb that starts at actual MAC PDU */
+    //  nas_eps_tvb = tvb_new_subset_remaining(tvb, offset);
+    /* Allow other dissectors to find this one by name. */
+    register_dissector("nas-eps-framed", dissect_nas_eps_framed, proto_nas_eps_framed);
+}
+
+void
+proto_reg_handoff_nas_eps_framed(void)
+{
+	 /* Need to find enabled nas-eps dissector */
+    nas_eps_handle = find_dissector("nas-eps");
+}
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 4
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=4 tabstop=8 expandtab:
+ * :indentSize=4:tabSize=8:noTabs=true:
+ */
diff --git a/epan/dissectors/packet-nas_eps.c b/epan/dissectors/packet-nas_eps.c
index af0ffdd301c..75d531974a5 100644
--- a/epan/dissectors/packet-nas_eps.c
+++ b/epan/dissectors/packet-nas_eps.c
@@ -814,8 +814,10 @@ de_emm_sec_par_to_eutra(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_,
      */
     proto_tree_add_bits_item(tree, hf_nas_eps_spare_bits, tvb, curr_offset<<3, 4, ENC_BIG_ENDIAN);
     /* Type of security context flag (TSC)  V   1/2 */
+    printf("hf_nas_eps_tsc, offset=%d\n", (curr_offset<<3)+4);
     proto_tree_add_bits_item(tree, hf_nas_eps_tsc, tvb, (curr_offset<<3)+4, 1, ENC_BIG_ENDIAN);
     /* NAS key set identifier */
+    printf("hf_nas_eps_emm_nas_key_set_id, offset=%d\n", (curr_offset<<3)+5);
     proto_tree_add_bits_item(tree, hf_nas_eps_emm_nas_key_set_id, tvb, (curr_offset<<3)+5, 3, ENC_BIG_ENDIAN);
     curr_offset++;
     return len;
@@ -1650,7 +1652,7 @@ de_emm_nas_ksi_and_seq_no(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U
 
     curr_offset = offset;
     bit_offset = curr_offset<<3;
-
+    printf("hf_nas_eps_emm_nas_key_set_id, offset=%d\n", bit_offset);
     proto_tree_add_bits_item(tree, hf_nas_eps_emm_nas_key_set_id, tvb, bit_offset, 3, ENC_BIG_ENDIAN);
     bit_offset += 3;
     proto_tree_add_bits_item(tree, hf_nas_eps_seq_no_short, tvb, bit_offset, 5, ENC_BIG_ENDIAN);
@@ -1701,9 +1703,11 @@ de_emm_nas_key_set_id_bits(tvbuff_t *tvb, proto_tree *tree, guint32 bit_offset,
     proto_item *item;
 
     /* Type of security context flag (TSC) (octet 1)    V   1/2 */
+        printf("hf_nas_eps_tsc, offset=%d\n", bit_offset);
     proto_tree_add_bits_item(tree, hf_nas_eps_tsc, tvb, bit_offset, 1, ENC_BIG_ENDIAN);
     bit_offset++;
     /* NAS key set identifier (octet 1) */
+    printf("hf_nas_eps_emm_nas_key_set_id, offset=%d\n", bit_offset);
     item = proto_tree_add_bits_item(tree, hf_nas_eps_emm_nas_key_set_id, tvb, bit_offset, 3, ENC_BIG_ENDIAN);
     if (add_string) {
         proto_item_append_text(item, "%s", add_string);
@@ -1727,9 +1731,11 @@ de_emm_nas_key_set_id(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_,
     bit_offset+=4;
 
     /* Type of security context flag (TSC) (octet 1)    V   1/2 */
+            printf("hf_nas_eps_tsc, offset=%d\n", bit_offset);
     proto_tree_add_bits_item(tree, hf_nas_eps_tsc, tvb, bit_offset, 1, ENC_BIG_ENDIAN);
     bit_offset++;
     /* NAS key set identifier (octet 1) */
+    printf("hf_nas_eps_emm_nas_key_set_id, offset=%d\n", bit_offset);
     proto_tree_add_bits_item(tree, hf_nas_eps_emm_nas_key_set_id, tvb, bit_offset, 3, ENC_BIG_ENDIAN);
     /*bit_offset+=3;*/
     curr_offset++;
diff --git a/epan/dissectors/packet-pdcp-lte-framed.c b/epan/dissectors/packet-pdcp-lte-framed.c
new file mode 100644
index 00000000000..52e8b68c26e
--- /dev/null
+++ b/epan/dissectors/packet-pdcp-lte-framed.c
@@ -0,0 +1,183 @@
+/* Routines for MAC LTE format files with context info as header.
+ *
+ * Martin Mathieson
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "config.h"
+
+#include <epan/packet.h>
+#include <epan/expert.h>
+#include <epan/proto_data.h>
+#include "packet-pdcp-lte.h"
+
+void proto_register_mac_lte_framed(void);
+
+/* Initialize the protocol and registered fields. */
+int proto_pdcp_lte_framed = -1;
+extern int proto_pdcp_lte;
+dissector_handle_t pdcp_lte_handle = NULL;
+
+/* Main dissection function. */
+static int dissect_pdcp_lte_framed(tvbuff_t *tvb, packet_info *pinfo,
+                                   proto_tree *tree, void *data _U_)
+{
+    gint offset = 0;
+    struct pdcp_lte_info *p_pdcp_lte_info;
+    tvbuff_t *pdcp_tvb;
+    guint8 tag = 0;
+    gboolean seqnumLengthTagPresent = FALSE;
+
+    /* Needs to be at least as long as:
+       - fixed header bytes
+       - tag for data
+       - at least one byte of PDCP PDU payload */
+    if (tvb_captured_length_remaining(tvb, offset) < (gint)(3 + 2))
+    {
+        return FALSE;
+    }
+
+    /* If redissecting, use previous info struct (if available) */
+    p_pdcp_lte_info = (pdcp_lte_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_pdcp_lte, 0);
+    if (p_pdcp_lte_info == NULL)
+    {
+        /* Allocate new info struct for this frame */
+        p_pdcp_lte_info = wmem_new0(wmem_file_scope(), pdcp_lte_info);
+
+        /* Read fixed fields */
+        p_pdcp_lte_info->no_header_pdu = (gboolean)tvb_get_guint8(tvb, offset++);
+        p_pdcp_lte_info->plane = (enum pdcp_plane)tvb_get_guint8(tvb, offset++);
+        if (p_pdcp_lte_info->plane == SIGNALING_PLANE)
+        {
+            p_pdcp_lte_info->seqnum_length = PDCP_SN_LENGTH_5_BITS;
+        }
+        p_pdcp_lte_info->rohc.rohc_compression = (gboolean)tvb_get_guint8(tvb, offset++);
+
+        /* Read optional fields */
+        while (tag != PDCP_LTE_PAYLOAD_TAG)
+        {
+            /* Process next tag */
+            tag = tvb_get_guint8(tvb, offset++);
+            switch (tag)
+            {
+            case PDCP_LTE_SEQNUM_LENGTH_TAG:
+                p_pdcp_lte_info->seqnum_length = tvb_get_guint8(tvb, offset);
+                offset++;
+                seqnumLengthTagPresent = TRUE;
+                break;
+            case PDCP_LTE_DIRECTION_TAG:
+                p_pdcp_lte_info->direction = tvb_get_guint8(tvb, offset);
+                offset++;
+                break;
+            case PDCP_LTE_LOG_CHAN_TYPE_TAG:
+                p_pdcp_lte_info->channelType = (LogicalChannelType)tvb_get_guint8(tvb, offset);
+                offset++;
+                break;
+            case PDCP_LTE_BCCH_TRANSPORT_TYPE_TAG:
+                p_pdcp_lte_info->BCCHTransport = (BCCHTransportType)tvb_get_guint8(tvb, offset);
+                offset++;
+                break;
+            case PDCP_LTE_ROHC_IP_VERSION_TAG:
+                /* RoHC IP version field is now 1 byte only; let's skip most significant byte
+                       to keep backward compatibility with existing UDP framing protocol */
+                p_pdcp_lte_info->rohc.rohc_ip_version = tvb_get_guint8(tvb, offset + 1);
+                offset += 2;
+                break;
+            case PDCP_LTE_ROHC_CID_INC_INFO_TAG:
+                p_pdcp_lte_info->rohc.cid_inclusion_info = tvb_get_guint8(tvb, offset);
+                offset++;
+                break;
+            case PDCP_LTE_ROHC_LARGE_CID_PRES_TAG:
+                p_pdcp_lte_info->rohc.large_cid_present = tvb_get_guint8(tvb, offset);
+                offset++;
+                break;
+            case PDCP_LTE_ROHC_MODE_TAG:
+                p_pdcp_lte_info->rohc.mode = (enum rohc_mode)tvb_get_guint8(tvb, offset);
+                offset++;
+                break;
+            case PDCP_LTE_ROHC_RND_TAG:
+                p_pdcp_lte_info->rohc.rnd = tvb_get_guint8(tvb, offset);
+                offset++;
+                break;
+            case PDCP_LTE_ROHC_UDP_CHECKSUM_PRES_TAG:
+                p_pdcp_lte_info->rohc.udp_checksum_present = tvb_get_guint8(tvb, offset);
+                offset++;
+                break;
+            case PDCP_LTE_ROHC_PROFILE_TAG:
+                p_pdcp_lte_info->rohc.profile = tvb_get_ntohs(tvb, offset);
+                offset += 2;
+                break;
+            case PDCP_LTE_CHANNEL_ID_TAG:
+                p_pdcp_lte_info->channelId = tvb_get_ntohs(tvb, offset);
+                offset += 2;
+                break;
+            case PDCP_LTE_UEID_TAG:
+                p_pdcp_lte_info->ueid = tvb_get_ntohs(tvb, offset);
+                offset += 2;
+                break;
+
+            case PDCP_LTE_PAYLOAD_TAG:
+                /* Have reached data, so get out of loop */
+                p_pdcp_lte_info->pdu_length = tvb_reported_length_remaining(tvb, offset);
+                continue;
+
+            default:
+                /* It must be a recognised tag */
+                wmem_free(wmem_file_scope(), p_pdcp_lte_info);
+                return 0;
+            }
+        }
+
+        if ((p_pdcp_lte_info->plane == USER_PLANE) && (seqnumLengthTagPresent == FALSE))
+        {
+            /* Conditional field is not present */
+            wmem_free(wmem_file_scope(), p_pdcp_lte_info);
+            return 0;
+        }
+
+        /* Store info in packet */
+        p_add_proto_data(wmem_file_scope(), pinfo, proto_pdcp_lte, 0, p_pdcp_lte_info);
+    }
+    else
+    {
+        offset = tvb_reported_length(tvb) - p_pdcp_lte_info->pdu_length;
+    }
+
+    /**************************************/
+    /* OK, now dissect as PDCP LTE        */
+
+    /* Create tvb that starts at actual PDCP PDU */
+    pdcp_tvb = tvb_new_subset_remaining(tvb, offset);
+    call_dissector_only(pdcp_lte_handle, pdcp_tvb, pinfo, tree, data);
+    return tvb_captured_length(tvb);
+}
+
+void proto_register_pdcp_lte_framed(void)
+{
+    /* Register protocol. */
+    proto_pdcp_lte_framed = proto_register_protocol("pdcp-lte-framed", "PDCP-LTE-FRAMED", "pdcp-lte-framed");
+
+    /* Allow other dissectors to find this one by name. */
+    register_dissector("pdcp-lte-framed", dissect_pdcp_lte_framed, proto_pdcp_lte_framed);
+
+    /* Need to find enabled pdcp-lte dissector */
+    pdcp_lte_handle = find_dissector("pdcp-lte");
+}
+
+/*
+ * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 4
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=4 tabstop=8 expandtab:
+ * :indentSize=4:tabSize=8:noTabs=true:
+ */
diff --git a/epan/dissectors/packet-pdcp-nr.c b/epan/dissectors/packet-pdcp-nr.c
index 0094edfc89d..3ffc0bba0fd 100644
--- a/epan/dissectors/packet-pdcp-nr.c
+++ b/epan/dissectors/packet-pdcp-nr.c
@@ -49,6 +49,7 @@ void proto_reg_handoff_pdcp_nr(void);
 
 /* Initialize the protocol and registered fields. */
 int proto_pdcp_nr = -1;
+int proto_pdcp_nr_framed = -1;
 
 extern int proto_rlc_nr;
 
@@ -1064,6 +1065,8 @@ static void checkBearerSequenceInfo(packet_info *pinfo, tvbuff_t *tvb,
     guint32                        expectedSequenceNumber = 0;
     guint32                        snLimit                = 0;
 
+    static GMutex mutex;
+    g_mutex_lock(&mutex);
     /* If find stat_report_in_frame already, use that and get out */
     if (PINFO_FD_VISITED(pinfo)) {
         p_report_in_frame =
@@ -1075,10 +1078,12 @@ static void checkBearerSequenceInfo(packet_info *pinfo, tvbuff_t *tvb,
             addBearerSequenceInfo(p_report_in_frame, p_pdcp_nr_info,
                                    sequenceNumber,
                                    pinfo, tree, tvb, security_tree, pdu_security);
+            g_mutex_unlock(&mutex);
             return;
         }
         else {
             /* Give up - we must have tried already... */
+            g_mutex_unlock(&mutex);
             return;
         }
     }
@@ -1091,7 +1096,6 @@ static void checkBearerSequenceInfo(packet_info *pinfo, tvbuff_t *tvb,
     bearer_key.bearerId = p_pdcp_nr_info->bearerId;
     bearer_key.direction = p_pdcp_nr_info->direction;
     bearer_key.notUsed = 0;
-
     /* Do the table lookup */
     p_bearer_status = (pdcp_bearer_status*)wmem_map_lookup(pdcp_sequence_analysis_bearer_hash,
                                                              get_bearer_hash_key(&bearer_key));
@@ -1204,6 +1208,7 @@ static void checkBearerSequenceInfo(packet_info *pinfo, tvbuff_t *tvb,
     /* Add state report for this frame into tree */
     addBearerSequenceInfo(p_report_in_frame, p_pdcp_nr_info, sequenceNumber,
                            pinfo, tree, tvb, security_tree, pdu_security);
+    g_mutex_unlock(&mutex);
 }
 
 
@@ -2014,6 +2019,140 @@ static gboolean dissect_pdcp_nr_heur(tvbuff_t *tvb, packet_info *pinfo,
     return TRUE;
 }
 
+/* Heuristic dissector looks for supported framing protocol (see wiki page)  */
+static gboolean dissect_pdcp_nr_framed(tvbuff_t *tvb, packet_info *pinfo,
+                                     proto_tree *tree, void *data _U_)
+{
+    gint                  offset                 = 0;
+    struct pdcp_nr_info *p_pdcp_nr_info;
+    tvbuff_t             *pdcp_tvb;
+    guint8                tag                    = 0;
+    gboolean              seqnumLengthTagPresent = FALSE;
+
+    /* Needs to be at least as long as:
+       - the signature string
+       - fixed header byte(s)
+       - tag for data
+       - at least one byte of PDCP PDU payload.
+      However, let attempted dissection show if there are any tags at all. */
+    gint min_length = (gint)(3); /* signature */
+
+    if (tvb_captured_length_remaining(tvb, offset) < min_length) {
+        return FALSE;
+    }
+
+    /* If redissecting, use previous info struct (if available) */
+    p_pdcp_nr_info = (pdcp_nr_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_pdcp_nr, 0);
+    if (p_pdcp_nr_info == NULL) {
+        /* Allocate new info struct for this frame */
+        p_pdcp_nr_info = wmem_new0(wmem_file_scope(), pdcp_nr_info);
+
+        /* Read fixed fields */
+        p_pdcp_nr_info->plane = (enum pdcp_nr_plane)tvb_get_guint8(tvb, offset++);
+        if (p_pdcp_nr_info->plane == NR_SIGNALING_PLANE) {
+            /* Signalling plane always has 12 SN bits */
+            p_pdcp_nr_info->seqnum_length = PDCP_NR_SN_LENGTH_12_BITS;
+        }
+
+
+
+        /* Read tagged fields */
+        while (tag != PDCP_NR_PAYLOAD_TAG) {
+            /* Process next tag */
+            tag = tvb_get_guint8(tvb, offset++);
+            switch (tag) {
+                case PDCP_NR_SEQNUM_LENGTH_TAG:
+                    p_pdcp_nr_info->seqnum_length = tvb_get_guint8(tvb, offset);
+                    offset++;
+                    seqnumLengthTagPresent = TRUE;
+                    break;
+                case PDCP_NR_DIRECTION_TAG:
+                    p_pdcp_nr_info->direction = tvb_get_guint8(tvb, offset);
+                    offset++;
+                    break;
+                case PDCP_NR_BEARER_TYPE_TAG:
+                    p_pdcp_nr_info->bearerType = (NRBearerType)tvb_get_guint8(tvb, offset);
+                    offset++;
+                    break;
+                case PDCP_NR_BEARER_ID_TAG:
+                    p_pdcp_nr_info->bearerId = tvb_get_guint8(tvb, offset);
+                    offset++;
+                    break;
+                case PDCP_NR_UEID_TAG:
+                    p_pdcp_nr_info->ueid = tvb_get_ntohs(tvb, offset);
+                    offset += 2;
+                    break;
+                case PDCP_NR_ROHC_COMPRESSION_TAG:
+                    p_pdcp_nr_info->rohc.rohc_compression = TRUE;
+                    break;
+                case PDCP_NR_ROHC_IP_VERSION_TAG:
+                    p_pdcp_nr_info->rohc.rohc_ip_version = tvb_get_guint8(tvb, offset);
+                    offset++;
+                    break;
+                case PDCP_NR_ROHC_CID_INC_INFO_TAG:
+                    p_pdcp_nr_info->rohc.cid_inclusion_info = TRUE;
+                    break;
+                case PDCP_NR_ROHC_LARGE_CID_PRES_TAG:
+                    p_pdcp_nr_info->rohc.large_cid_present = TRUE;
+                    break;
+                case PDCP_NR_ROHC_MODE_TAG:
+                    p_pdcp_nr_info->rohc.mode = (enum rohc_mode)tvb_get_guint8(tvb, offset);
+                    offset++;
+                    break;
+                case PDCP_NR_ROHC_RND_TAG:
+                    p_pdcp_nr_info->rohc.rnd = TRUE;
+                    break;
+                case PDCP_NR_ROHC_UDP_CHECKSUM_PRES_TAG:
+                    p_pdcp_nr_info->rohc.udp_checksum_present = TRUE;
+                    break;
+                case PDCP_NR_ROHC_PROFILE_TAG:
+                    p_pdcp_nr_info->rohc.profile = tvb_get_ntohs(tvb, offset);
+                    offset += 2;
+                    break;
+                case PDCP_NR_MACI_PRES_TAG:
+                    p_pdcp_nr_info->maci_present = TRUE;
+                    break;
+                case PDCP_NR_SDAP_HEADER_TAG:
+                    p_pdcp_nr_info->sdap_header = tvb_get_guint8(tvb, offset) & 0x03;
+                    offset++;
+                    break;
+
+                case PDCP_NR_PAYLOAD_TAG:
+                    /* Have reached data, so get out of loop */
+                    p_pdcp_nr_info->pdu_length = tvb_reported_length_remaining(tvb, offset);
+                    continue;
+
+                default:
+                    /* It must be a recognised tag */
+                    report_heur_error(tree, pinfo, &ei_pdcp_nr_unknown_udp_framing_tag, tvb, offset-1, 1);
+                    wmem_free(wmem_file_scope(), p_pdcp_nr_info);
+                    return TRUE;
+            }
+        }
+
+        if ((p_pdcp_nr_info->plane == NR_USER_PLANE) && (seqnumLengthTagPresent == FALSE)) {
+            /* Conditional field is not present */
+            report_heur_error(tree, pinfo, &ei_pdcp_nr_missing_udp_framing_tag, tvb, 0, offset);
+            wmem_free(wmem_file_scope(), p_pdcp_nr_info);
+            return TRUE;
+        }
+
+        /* Store info in packet */
+        p_add_proto_data(wmem_file_scope(), pinfo, proto_pdcp_nr, 0, p_pdcp_nr_info);
+    }
+    else {
+        offset = tvb_reported_length(tvb) - p_pdcp_nr_info->pdu_length;
+    }
+
+    /**************************************/
+    /* OK, now dissect as PDCP nr         */
+
+    /* Create tvb that starts at actual PDCP PDU */
+    pdcp_tvb = tvb_new_subset_remaining(tvb, offset);
+    dissect_pdcp_nr(pdcp_tvb, pinfo, tree, data);
+    return TRUE;
+}
+
 
 /******************************/
 /* Main dissection function.  */
@@ -2119,6 +2258,8 @@ static int dissect_pdcp_nr(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
     /***************************************/
     /* UE security algorithms              */
     if (!PINFO_FD_VISITED(pinfo)) {
+        static GMutex mutex;
+        g_mutex_lock(&mutex);
         /* Look up current state by UEID */
         current_security = (pdcp_nr_security_info_t*)wmem_map_lookup(pdcp_security_hash,
                                                                      GUINT_TO_POINTER((guint)p_pdcp_info->ueid));
@@ -2150,6 +2291,7 @@ static int dissect_pdcp_nr(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
                                 security_to_store);
             }
         }
+        g_mutex_unlock(&mutex);
     }
 
     /* Show security settings for this PDU */
@@ -3047,6 +3189,11 @@ void proto_register_pdcp_nr(void)
     /* Allow other dissectors to find this one by name. */
     register_dissector("pdcp-nr", dissect_pdcp_nr, proto_pdcp_nr);
 
+    /* Register framed protocol. */
+    proto_pdcp_nr_framed = proto_register_protocol("pdcp-nr-framed", "PDCP-NR-FRAMED", "pdcp-nr-framed");
+    /* Allow other dissectors to find this one by name. */
+    register_dissector("pdcp-nr-framed", dissect_pdcp_nr_framed, proto_pdcp_nr_framed);
+
     pdcp_nr_module = prefs_register_protocol(proto_pdcp_nr, NULL);
 
     /* Dissect uncompressed user-plane data as IP */
diff --git a/epan/dissectors/packet-per.c b/epan/dissectors/packet-per.c
index a36db40c0c8..9a7a74d2702 100644
--- a/epan/dissectors/packet-per.c
+++ b/epan/dissectors/packet-per.c
@@ -15,9 +15,10 @@ proper helper routines
  */
 
 #include "config.h"
-
+#include <stdio.h>
 #include <math.h>
-
+#include <epan/tvbuff.h>
+#include <epan/tvbuff-int.h>
 #include <epan/packet.h>
 #include <epan/exceptions.h>
 #include <epan/oids.h>
@@ -124,6 +125,34 @@ add_per_encoded_label(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree)
 
 #define SEQ_MAX_COMPONENTS 128
 
+static inline void update_per_fi_flags(field_info *fi, int start_offset, int offset){
+	int bits_offset;
+	int bytes_len;
+	// Ignore already processed fields
+	// if (FI_GET_BITS_SIZE(fi))
+	// {
+	// 	printf("FI_GET_BITS_SIZE(fi)=%d\n",FI_GET_BITS_SIZE(fi));
+	// 	bits_offset = start_offset % 8; // Align to byte boundary
+	// 	printf("2)update_per_fi_flags, bits_offset=%d\n", bits_offset);
+	// 	return;
+	// }
+
+	bits_offset = start_offset % 8; // Align to byte boundary
+	bytes_len = BLEN(start_offset, offset);
+
+	// Add missing length for protocol fields (FT_NONE) or developer mistakes
+	// It's not possible to have a difference in offset and still have a byte length = 0
+	if(!fi->length && bytes_len) fi->length=bytes_len;
+	// Add one more byte
+	if(bits_offset + (offset-start_offset) > (bytes_len << 3))
+		fi->length=bytes_len+1;
+
+	FI_RESET_FLAG(fi, FI_BITS_OFFSET(7));
+	FI_RESET_FLAG(fi, FI_BITS_SIZE(63));
+	FI_SET_FLAG(fi,FI_BITS_OFFSET(bits_offset));
+	FI_SET_FLAG(fi,FI_BITS_SIZE(offset-start_offset));
+}
+
 static void per_check_value(guint32 value, guint32 min_len, guint32 max_len, asn1_ctx_t *actx, proto_item *item, gboolean is_signed)
 {
 	if ((is_signed == FALSE) && (value > max_len)) {
@@ -558,7 +587,7 @@ guint32
 dissect_per_null(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx _U_, proto_tree *tree, int hf_index) {
 	proto_item *ti_tmp;
 
-	ti_tmp = proto_tree_add_item(tree, hf_index, tvb, offset>>3, 1, ENC_BIG_ENDIAN);
+	ti_tmp = proto_tree_add_item(tree, hf_index, tvb, offset>>3, 0, ENC_BIG_ENDIAN);
 	proto_item_append_text(ti_tmp, ": NULL");
 
 	return offset;
@@ -1150,6 +1179,10 @@ DEBUG_ENTRY("dissect_per_boolean");
 	if(bool_val){
 		*bool_val=value;
 	}
+
+	if(actx->created_item){
+		update_per_fi_flags(actx->created_item->finfo, offset, offset+1); // Advance single bit
+	}
 	return offset+1;
 }
 
@@ -1165,6 +1198,7 @@ dissect_per_integer(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree
 	tvbuff_t *val_tvb=NULL;
 	proto_item *it=NULL;
 	header_field_info *hfi;
+	guint32 start_offset;
 
 	/* 12.2.6 b */
 	offset=dissect_per_length_determinant(tvb, offset, actx, tree,hf_per_integer_length, &length, NULL);
@@ -1181,6 +1215,7 @@ dissect_per_integer(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree
 	if (actx->aligned) BYTE_ALIGN_OFFSET(offset);
 	val_tvb = tvb_new_octet_aligned(tvb, offset, length * 8);
 	val=0;
+	start_offset = offset;
 	for(i=0;i<length;i++){
 		if(i==0){
 			if(tvb_get_guint8(val_tvb, i)&0x80){
@@ -1214,6 +1249,9 @@ dissect_per_integer(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree
 	if(value){
 		*value=val;
 	}
+	if(it){
+		update_per_fi_flags(it->finfo, start_offset, offset);
+	}
 
 	return offset;
 }
@@ -1225,6 +1263,7 @@ dissect_per_integer64b(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tr
 	guint64 val;
 	proto_item *it=NULL;
 	header_field_info *hfi;
+	guint32 start_offset;
 
 	/* 12.2.6 b */
 	offset=dissect_per_length_determinant(tvb, offset, actx, tree, -1, &length, NULL);
@@ -1234,6 +1273,7 @@ dissect_per_integer64b(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tr
 		length=8;
 	}
 
+	start_offset = offset;
 	val=0;
 	for(i=0;i<length;i++){
 		if(i==0){
@@ -1268,6 +1308,9 @@ dissect_per_integer64b(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tr
 	if(value){
 		*value=(gint64)val;
 	}
+	if(it){
+		update_per_fi_flags(it->finfo, start_offset, offset);
+	}
 
 	return offset;
 }
@@ -1301,6 +1344,7 @@ dissect_per_constrained_integer(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx,
 	nstime_t timeval;
 	header_field_info *hfi;
 	int num_bits;
+	guint32 start_offset;
 
 DEBUG_ENTRY("dissect_per_constrained_integer");
 	if(has_extension){
@@ -1313,6 +1357,7 @@ DEBUG_ENTRY("dissect_per_constrained_integer");
 		}
 	}
 
+	start_offset = offset;
 	hfi = proto_registrar_get_nth(hf_index);
 
 	/* 10.5.3 Let "range" be defined as the integer value ("ub" - "lb"   1), and let the value to be encoded be "n".
@@ -1453,6 +1498,12 @@ DEBUG_ENTRY("dissect_per_constrained_integer");
 	}
 	actx->created_item = it;
 	if (value) *value = val;
+	if(it){
+		// Update 32bits min and max values;
+		it->finfo->value_min=(int32_t)min;
+		it->finfo->value_max=(int32_t)max;
+		update_per_fi_flags(it->finfo, start_offset, offset);
+	}
 	return offset;
 }
 
@@ -1466,6 +1517,7 @@ dissect_per_constrained_integer_64b(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *a
 	header_field_info *hfi;
 	int num_bits;
 	gboolean tmp;
+	guint32 start_offset;
 
 DEBUG_ENTRY("dissect_per_constrained_integer_64b");
 	if(has_extension){
@@ -1478,6 +1530,7 @@ DEBUG_ENTRY("dissect_per_constrained_integer_64b");
 		}
 	}
 
+	start_offset = offset;
 	hfi = proto_registrar_get_nth(hf_index);
 
 	/* 10.5.3 Let "range" be defined as the integer value ("ub" - "lb"   1), and let the value to be encoded be "n".
@@ -1655,6 +1708,11 @@ DEBUG_ENTRY("dissect_per_constrained_integer_64b");
 	}
 	actx->created_item = it;
 	if (value) *value = val;
+	if(it){
+		it->finfo->value_min=min;
+		it->finfo->value_max=max;
+		update_per_fi_flags(it->finfo, start_offset, offset);
+	}
 	return offset;
 }
 
@@ -1668,6 +1726,7 @@ dissect_per_enumerated(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tr
 	guint32 start_offset = offset;
 	gboolean extension_present = FALSE;
 	header_field_info *hfi;
+	guint32 value_index;
 
 	if (has_extension) {
 		/* Extension bit */
@@ -1675,6 +1734,7 @@ dissect_per_enumerated(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tr
 		if (!display_internal_per_fields) proto_item_set_hidden(actx->created_item);
 	}
 
+	value_index = offset;
 	if (!extension_present) {
 		/* 13.2  */
 		offset = dissect_per_constrained_integer(tvb, offset, actx, tree, hf_per_enum_index, 0, root_num - 1, &enum_index, FALSE);
@@ -1696,6 +1756,9 @@ dissect_per_enumerated(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tr
 	}
 	actx->created_item = it;
 	if (value) *value = val;
+	if(it){
+		update_per_fi_flags(it->finfo, value_index, offset);
+	}
 	return offset;
 }
 
@@ -1724,6 +1787,9 @@ dissect_per_real(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *tr
 
 	if (value) *value = val;
 
+	if(actx->created_item){
+		update_per_fi_flags(actx->created_item->finfo,offset,end_offset);
+	}
 	return end_offset;
 }
 
@@ -1740,6 +1806,9 @@ dissect_per_choice(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *
 	guint32 old_offset = offset;
 	proto_item *choice_item = NULL;
 	proto_tree *choice_tree = NULL;
+	guint32 start_offset;
+
+
 
 DEBUG_ENTRY("dissect_per_choice");
 
@@ -1770,6 +1839,7 @@ DEBUG_ENTRY("dissect_per_choice");
 		}
 	}
 
+	start_offset = offset;
 	if (!extension_flag) {  /* 22.6, 22.7 */
 		if (extension_root_entries == 1) {  /* 22.5 */
 			choice_index = 0;
@@ -1803,6 +1873,10 @@ DEBUG_ENTRY("dissect_per_choice");
 	if (idx != -1) {
 		choice_item = proto_tree_add_uint(tree, hf_index, tvb, old_offset>>3, 0, choice[idx].value);
 		choice_tree = proto_item_add_subtree(choice_item, ett_index);
+		if(choice_item){
+			update_per_fi_flags(choice_item->finfo, start_offset, offset);
+			proto_tree_prime_with_hfid(tree,hf_index);
+		}
 		if (!extension_flag) {
 			offset = choice[idx].func(tvb, offset, actx, choice_tree, *choice[idx].p_id);
 		} else {
@@ -2073,6 +2147,10 @@ DEBUG_ENTRY("dissect_per_sequence");
 
 	proto_item_set_len(item, (offset>>3)!=(old_offset>>3)?(offset>>3)-(old_offset>>3):1);
 	actx->created_item = item;
+	if(item){
+		update_per_fi_flags(item->finfo,old_offset,offset);
+	}
+
 	return offset;
 }
 
@@ -2102,7 +2180,7 @@ DEBUG_ENTRY("dissect_per_sequence_eag");
 			proto_item_append_text(actx->created_item, " (%s %s present)",
 				index_get_optional_name(sequence, i), optional_field_flag?"is":"is NOT");
 		}
-		if (!display_internal_per_fields) proto_item_set_hidden(actx->created_item);
+		// if (!display_internal_per_fields) proto_item_set_hidden(actx->created_item);
 		if(optional_field_flag){
 			optional_mask[i>>5]|=0x80000000>>(i&0x1f);
 		}
@@ -2215,6 +2293,9 @@ static tvbuff_t *dissect_per_bit_string_display(tvbuff_t *tvb, guint32 offset, a
 			}
 		}
 		proto_item_append_text(actx->created_item, "]");
+		if(actx->created_item){
+			update_per_fi_flags(actx->created_item->finfo, offset, offset + length);
+		}
 	}
 
 	return out_tvb;
diff --git a/epan/dissectors/packet-rlc-lte.c b/epan/dissectors/packet-rlc-lte.c
index c0aa92baf2f..300417ac6a5 100644
--- a/epan/dissectors/packet-rlc-lte.c
+++ b/epan/dissectors/packet-rlc-lte.c
@@ -796,12 +796,6 @@ static void show_PDU_in_tree(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb
     guint32 id;
     rlc_ue_parameters *params;
 
-    /* Add raw data (according to mode) */
-    proto_item *data_ti = proto_tree_add_item(tree,
-                                              (rlc_info->rlcMode == RLC_AM_MODE) ?
-                                                    hf_rlc_lte_am_data :
-                                                    hf_rlc_lte_um_data,
-                                              tvb, offset, length, ENC_NA);
 
     if (whole_pdu || (reassembly_info != NULL)) {
         if (((global_rlc_lte_call_pdcp_for_srb) && (rlc_info->channelType == CHANNEL_TYPE_SRB)) ||
@@ -902,7 +896,7 @@ static void show_PDU_in_tree(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb
             }
             ENDTRY
 
-            proto_item_set_hidden(data_ti);
+            // proto_item_set_hidden(data_ti);
         }
         else if (global_rlc_lte_call_rrc_for_mcch && (rlc_info->channelType == CHANNEL_TYPE_MCCH)) {
             /* Send whole PDU to RRC */
@@ -925,7 +919,7 @@ static void show_PDU_in_tree(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb
             }
             ENDTRY
 
-            proto_item_set_hidden(data_ti);
+            // proto_item_set_hidden(data_ti);
         }
         else if (global_rlc_lte_call_ip_for_mtch && (rlc_info->channelType == CHANNEL_TYPE_MTCH)) {
             /* Send whole PDU to IP */
@@ -948,9 +942,17 @@ static void show_PDU_in_tree(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb
             }
             ENDTRY
 
-            proto_item_set_hidden(data_ti);
+            // proto_item_set_hidden(data_ti);
         }
     }
+    else {
+        /* Add raw data (according to mode) */
+        proto_tree_add_item(tree,
+                            (rlc_info->rlcMode == RLC_AM_MODE) ?
+                                    hf_rlc_lte_am_data :
+                                    hf_rlc_lte_um_data,
+                            tvb, offset, length, ENC_NA);
+    }
 }
 
 /* Hash table functions for RLC channels */
diff --git a/epan/dissectors/packet-usb.c b/epan/dissectors/packet-usb.c
index a534cac663e..a9084fb7add 100644
--- a/epan/dissectors/packet-usb.c
+++ b/epan/dissectors/packet-usb.c
@@ -3768,7 +3768,7 @@ try_dissect_next_protocol(proto_tree *tree, tvbuff_t *next_tvb, packet_info *pin
             /* When dissecting requests, and Setup Data tree is created,
                pass it to next dissector instead of parent. */
             if (usb_conv_info->is_request && setup_tree)
-                use_setup_tree = TRUE;
+                use_setup_tree = FALSE;
 
             ctrl_recip = USB_RECIPIENT(usb_trans_info->setup.requesttype);
 
diff --git a/epan/dissectors/pidl/CMakeLists.txt b/epan/dissectors/pidl/CMakeLists.txt
index b629464927f..199964912e7 100644
--- a/epan/dissectors/pidl/CMakeLists.txt
+++ b/epan/dissectors/pidl/CMakeLists.txt
@@ -114,7 +114,7 @@ foreach(PROTOCOL_NAME IN LISTS PIDL_DISSECTOR_NAMES)
 	add_custom_command(
 		OUTPUT packet-dcerpc-${PROTOCOL_NAME}-stamp
 		COMMAND "${PERL_EXECUTABLE}"
-			"${CMAKE_SOURCE_DIR}/tools/pidl/pidl"
+			"${PROJECT_SOURCE_DIR}/tools/pidl/pidl"
 			--ws-parser
 			--outputdir ../..
 			--includedir ..
@@ -125,7 +125,7 @@ foreach(PROTOCOL_NAME IN LISTS PIDL_DISSECTOR_NAMES)
 			"${CMAKE_CURRENT_BINARY_DIR}/packet-dcerpc-${PROTOCOL_NAME}-stamp"
 		WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/${PROTOCOL_NAME}"
 		DEPENDS
-			"${CMAKE_SOURCE_DIR}/tools/pidl/pidl"
+			"${PROJECT_SOURCE_DIR}/tools/pidl/pidl"
 			${PROTOCOL_NAME}/${PROTOCOL_NAME}.idl
 			${PROTOCOL_NAME}/${PROTOCOL_NAME}.cnf
 			${PIDL_DISSECTOR_${PROTOCOL_NAME}_EXTRA_DEPS}
diff --git a/epan/ftypes/CMakeLists.txt b/epan/ftypes/CMakeLists.txt
index 0346c1ccf28..0353895f130 100644
--- a/epan/ftypes/CMakeLists.txt
+++ b/epan/ftypes/CMakeLists.txt
@@ -49,7 +49,7 @@ target_include_directories(ftypes
 	PRIVATE
 		${CMAKE_CURRENT_BINARY_DIR}
 		${CMAKE_CURRENT_SOURCE_DIR}
-		${CMAKE_SOURCE_DIR}/epan
+		${PROJECT_SOURCE_DIR}/epan
 )
 
 set_target_properties(ftypes PROPERTIES
diff --git a/epan/ftypes/ftypes.c b/epan/ftypes/ftypes.c
index 9b57c2ec124..31b7898e70f 100644
--- a/epan/ftypes/ftypes.c
+++ b/epan/ftypes/ftypes.c
@@ -851,16 +851,16 @@ fvalue_get_protocol(fvalue_t *fv)
 guint32
 fvalue_get_uinteger(fvalue_t *fv)
 {
-	ws_assert(fv->ftype->ftype == FT_IEEE_11073_SFLOAT ||
-			fv->ftype->ftype == FT_IEEE_11073_FLOAT ||
-			fv->ftype->ftype == FT_CHAR ||
-			fv->ftype->ftype == FT_UINT8 ||
-			fv->ftype->ftype == FT_UINT16 ||
-			fv->ftype->ftype == FT_UINT24 ||
-			fv->ftype->ftype == FT_UINT32 ||
-			fv->ftype->ftype == FT_IPXNET ||
-			fv->ftype->ftype == FT_FRAMENUM ||
-			fv->ftype->ftype == FT_IPv4);
+	// ws_assert(fv->ftype->ftype == FT_IEEE_11073_SFLOAT ||
+	// 		fv->ftype->ftype == FT_IEEE_11073_FLOAT ||
+	// 		fv->ftype->ftype == FT_CHAR ||
+	// 		fv->ftype->ftype == FT_UINT8 ||
+	// 		fv->ftype->ftype == FT_UINT16 ||
+	// 		fv->ftype->ftype == FT_UINT24 ||
+	// 		fv->ftype->ftype == FT_UINT32 ||
+	// 		fv->ftype->ftype == FT_IPXNET ||
+	// 		fv->ftype->ftype == FT_FRAMENUM ||
+	// 		fv->ftype->ftype == FT_IPv4);
 	ws_assert(fv->ftype->get_value.get_value_uinteger);
 	return fv->ftype->get_value.get_value_uinteger(fv);
 }
@@ -868,10 +868,10 @@ fvalue_get_uinteger(fvalue_t *fv)
 gint32
 fvalue_get_sinteger(fvalue_t *fv)
 {
-	ws_assert(fv->ftype->ftype == FT_INT8 ||
-			fv->ftype->ftype == FT_INT16 ||
-			fv->ftype->ftype == FT_INT24 ||
-			fv->ftype->ftype == FT_INT32);
+	// ws_assert(fv->ftype->ftype == FT_INT8 ||
+	// 		fv->ftype->ftype == FT_INT16 ||
+	// 		fv->ftype->ftype == FT_INT24 ||
+	// 		fv->ftype->ftype == FT_INT32);
 	ws_assert(fv->ftype->get_value.get_value_sinteger);
 	return fv->ftype->get_value.get_value_sinteger(fv);
 }
@@ -879,12 +879,12 @@ fvalue_get_sinteger(fvalue_t *fv)
 guint64
 fvalue_get_uinteger64(fvalue_t *fv)
 {
-	ws_assert(fv->ftype->ftype == FT_UINT40 ||
-			fv->ftype->ftype == FT_UINT48 ||
-			fv->ftype->ftype == FT_UINT56 ||
-			fv->ftype->ftype == FT_UINT64 ||
-			fv->ftype->ftype == FT_BOOLEAN ||
-			fv->ftype->ftype == FT_EUI64);
+	// ws_assert(fv->ftype->ftype == FT_UINT40 ||
+	// 		fv->ftype->ftype == FT_UINT48 ||
+	// 		fv->ftype->ftype == FT_UINT56 ||
+	// 		fv->ftype->ftype == FT_UINT64 ||
+	// 		fv->ftype->ftype == FT_BOOLEAN ||
+	// 		fv->ftype->ftype == FT_EUI64);
 	ws_assert(fv->ftype->get_value.get_value_uinteger64);
 	return fv->ftype->get_value.get_value_uinteger64(fv);
 }
@@ -892,10 +892,10 @@ fvalue_get_uinteger64(fvalue_t *fv)
 gint64
 fvalue_get_sinteger64(fvalue_t *fv)
 {
-	ws_assert(fv->ftype->ftype == FT_INT40 ||
-			fv->ftype->ftype == FT_INT48 ||
-			fv->ftype->ftype == FT_INT56 ||
-			fv->ftype->ftype == FT_INT64);
+	// ws_assert(fv->ftype->ftype == FT_INT40 ||
+	// 		fv->ftype->ftype == FT_INT48 ||
+	// 		fv->ftype->ftype == FT_INT56 ||
+	// 		fv->ftype->ftype == FT_INT64);
 	ws_assert(fv->ftype->get_value.get_value_sinteger64);
 	return fv->ftype->get_value.get_value_sinteger64(fv);
 }
diff --git a/epan/packet.c b/epan/packet.c
index bf8267c3acc..09649e0a960 100644
--- a/epan/packet.c
+++ b/epan/packet.c
@@ -315,12 +315,16 @@ register_shutdown_routine(void (*func)(void))
 void
 init_dissection(void)
 {
+	static guint host_name_lookup_initialized = 0;
+
 	/*
 	 * Reinitialize resolution information. Don't leak host entries from
 	 * one file to another (e.g. embarassing-host-name.example.com from
 	 * file1.pcapng into a name resolution block in file2.pcapng).
 	 */
-	host_name_lookup_reset();
+	if (!host_name_lookup_initialized)
+		host_name_lookup_reset();
+	host_name_lookup_initialized = 1; 
 
 	wmem_enter_file_scope();
 
diff --git a/epan/packet.h b/epan/packet.h
index 1213c482ffb..43bb9a420f8 100644
--- a/epan/packet.h
+++ b/epan/packet.h
@@ -716,10 +716,10 @@ WS_DLL_PUBLIC void register_cleanup_routine(void (*func)(void));
 WS_DLL_PUBLIC void register_shutdown_routine(void (*func)(void));
 
 /* Initialize all data structures used for dissection. */
-void init_dissection(void);
+WS_DLL_PUBLIC void init_dissection(void);
 
 /* Free data structures allocated for dissection. */
-void cleanup_dissection(void);
+WS_DLL_PUBLIC void cleanup_dissection(void);
 
 /* Allow protocols to register a "cleanup" routine to be
  * run after the initial sequential run through the packets.
diff --git a/epan/prefs.h b/epan/prefs.h
index f6f03aff520..0b52ddc329c 100644
--- a/epan/prefs.h
+++ b/epan/prefs.h
@@ -252,7 +252,7 @@ struct pref_custom_cbs;
 typedef struct pref_module module_t;
 
 /** Sets up memory used by proto routines. Called at program startup */
-void prefs_init(void);
+WS_DLL_PUBLIC void prefs_init(void);
 
 /** Reset preferences to default values.  Called at profile change */
 WS_DLL_PUBLIC void prefs_reset(void);
diff --git a/epan/proto.c b/epan/proto.c
index 3a751258e2b..e140f75a5c4 100644
--- a/epan/proto.c
+++ b/epan/proto.c
@@ -139,10 +139,11 @@ struct ptvcursor {
 			    "Adding %s would put more than %d items in the tree -- possible infinite loop (max number of items can be increased in advanced preferences)", \
 			    hfinfo->abbrev, prefs.gui_max_tree_items));	\
 	}								\
-	if (!(PTREE_DATA(tree)->visible)) {				\
+	if (!(PTREE_DATA(tree)->visible) && !(PTREE_DATA(tree)->fast_full_dissection)) {				\
 		if (PTREE_FINFO(tree)) {				\
 			if ((hfinfo->ref_type != HF_REF_TYPE_DIRECT)	\
-			    && (hfinfo->type != FT_PROTOCOL ||		\
+			    && (hfinfo->type != FT_PROTOCOL 	\
+				||		\
 				PTREE_DATA(tree)->fake_protocols)) {	\
 				free_block;				\
 				/* just return tree back to the caller */\
@@ -867,6 +868,12 @@ proto_tree_set_fake_protocols(proto_tree *tree, gboolean fake_protocols)
 	PTREE_DATA(tree)->fake_protocols = fake_protocols;
 }
 
+void
+proto_tree_set_fast_full_dissection(proto_tree *tree, gboolean fast_full_dissection)
+{
+	PTREE_DATA(tree)->fast_full_dissection = fast_full_dissection;
+}
+
 /* Assume dissector set only its protocol fields.
    This function is called by dissectors and allows the speeding up of filtering
    in wireshark; if this function returns FALSE it is safe to reset tree to NULL
@@ -2529,6 +2536,11 @@ tree_data_add_maybe_interesting_field(tree_data_t *tree_data, field_info *fi)
 		}
 
 		g_ptr_array_add(ptrs, fi);
+		// printf("hash_table id: %d, %s\n",hfinfo->id,hfinfo->abbrev);
+	}
+
+	if(tree_data->field_callback && fi->length){
+		tree_data->field_callback(fi);
 	}
 }
 
@@ -3047,6 +3059,10 @@ proto_tree_new_item(field_info *new_fi, proto_tree *tree,
 			break;
 	}
 	FI_SET_FLAG(new_fi, (encoding & ENC_LITTLE_ENDIAN) ? FI_LITTLE_ENDIAN : FI_BIG_ENDIAN);
+	// Fix 1
+	if (tree->finfo)
+		tree->finfo->flags |= (encoding & ENC_LITTLE_ENDIAN) ? FI_LITTLE_ENDIAN : FI_BIG_ENDIAN;
+	// Fix 1
 
 	/* Don't add new node to proto_tree until now so that any exceptions
 	 * raised by a tvbuff access method doesn't leave junk in the proto_tree. */
@@ -6314,6 +6330,9 @@ new_field_info(proto_tree *tree, header_field_info *hfinfo, tvbuff_t *tvb,
 	fi->length     = item_length;
 	fi->tree_type  = -1;
 	fi->flags      = 0;
+	fi->value_min  = 0;
+	fi->value_max  = 0;
+	fi->source_tree= tree; // Make available the tree reference in the field structure
 	if (!PTREE_DATA(tree)->visible)
 		FI_SET_FLAG(fi, FI_HIDDEN);
 	fvalue_init(&fi->value, fi->hfinfo->type);
@@ -7157,20 +7176,21 @@ proto_item_set_len(proto_item *pi, const gint length)
 {
 	field_info *fi;
 
-	/* XXX: We actually want to set the length of non visible proto_items
-         * that are protocols, if we're not faking protocols, so that
-         * ui/proto_hier_stats can work correctly. (#17877) But we don't
-         * want to set the length of the protocol accidentally when intending
-         * to set the length of a faked child. However, we can't tell whether
-         * this is called by the original item or the child when faking items.
-         */
-	TRY_TO_FAKE_THIS_REPR_VOID(pi);
+	if(!pi) return;
 
-	fi = PITEM_FINFO(pi);
-	if (fi == NULL)
-		return;
+	if(!pi->tree_data->fast_full_dissection) {
+		TRY_TO_FAKE_THIS_REPR_VOID(pi);
 
-	finfo_set_len(fi, length);
+		fi = PITEM_FINFO(pi);
+		if (fi == NULL)
+			return;
+
+		finfo_set_len(fi, length);
+	}
+	else
+	{
+		PITEM_FINFO(pi)->length = length;
+	}
 }
 
 /*
@@ -7255,6 +7275,13 @@ proto_tree_create_root(packet_info *pinfo)
 	 * changed, then we'll find out very quickly. */
 	pnode->tree_data->visible = FALSE;
 
+	/* Fast full dissection is disabled by default.
+	 * If enabled, all fields are dissected, but strings are not converted
+	*/
+	pnode->tree_data->fast_full_dissection = FALSE;
+
+	pnode->tree_data->field_callback = NULL;
+
 	/* Make sure that we fake protocols (if possible) */
 	pnode->tree_data->fake_protocols = TRUE;
 
@@ -12343,9 +12370,9 @@ proto_tree_add_bits_item(proto_tree *tree, const int hfindex, tvbuff_t *tvb,
 	 * but only after doing a bunch more work (which we can, in the common
 	 * case, shortcut here).
 	 */
+
 	CHECK_FOR_NULL_TREE(tree);
 	TRY_TO_FAKE_THIS_ITEM(tree, hfindex, hfinfo);
-
 	return proto_tree_add_bits_ret_val(tree, hfindex, tvb, bit_offset, no_of_bits, NULL, encoding);
 }
 
@@ -12432,6 +12459,11 @@ _proto_tree_add_bits_ret_val(proto_tree *tree, const int hfindex, tvbuff_t *tvb,
 
 	bf_str = decode_bits_in_field(PNODE_POOL(tree), bit_offset, no_of_bits, value, encoding);
 
+	// Fix 3
+	if (G_LIKELY(tree->finfo))
+		tree->finfo->flags = (encoding & ENC_LITTLE_ENDIAN) ? FI_LITTLE_ENDIAN : FI_BIG_ENDIAN;
+	// Fix 3
+
 	switch (hf_field->type) {
 	case FT_BOOLEAN:
 		/* Boolean field */
@@ -12724,8 +12756,11 @@ proto_tree_add_bits_ret_val(proto_tree *tree, const int hfindex, tvbuff_t *tvb,
 	if ((item = _proto_tree_add_bits_ret_val(tree, hfindex, tvb,
 						 bit_offset, no_of_bits,
 						 return_value, encoding))) {
-		FI_SET_FLAG(PNODE_FINFO(item), FI_BITS_OFFSET(bit_offset));
+
+		FI_SET_FLAG(PNODE_FINFO(item), FI_BITS_OFFSET(bit_offset % 8));
 		FI_SET_FLAG(PNODE_FINFO(item), FI_BITS_SIZE(no_of_bits));
+		// printf("FI_BITS_OFFSET=%d\n", bit_offset % 8);
+		// printf("FI_BITS_SIZE=%d\n", no_of_bits);
 	}
 	return item;
 }
diff --git a/epan/proto.h b/epan/proto.h
index 9e237976732..ce9e7eb11eb 100644
--- a/epan/proto.h
+++ b/epan/proto.h
@@ -778,6 +778,7 @@ typedef struct hf_register_info {
     header_field_info  hfinfo; /**< the field info to be registered */
 } hf_register_info;
 
+typedef struct _proto_node proto_node;
 /** string representation, if one of the proto_tree_add_..._format() functions used */
 typedef struct _item_label_t {
     char representation[ITEM_LABEL_LENGTH];
@@ -797,6 +798,9 @@ typedef struct field_info {
     fvalue_t             value;
     int                 total_layer_num;        /**< Hierarchical layer number, for all protocols in the tree. */
     int                 proto_layer_num;        /**< Protocol layer number, so 1st, 2nd, 3rd, ... for protocol X. */
+    proto_node          *source_tree;     /**< add tree which this field belong (why this was not added before?) */
+    gint64 value_min;
+    gint64 value_max;
 } field_info;
 
 
@@ -869,6 +873,8 @@ typedef struct {
     gboolean             fake_protocols;
     guint                count;
     struct _packet_info *pinfo;
+    gboolean             fast_full_dissection;
+    gint (*field_callback)(field_info *fi);
 } tree_data_t;
 
 /** Each proto_tree, proto_item is one of these. */
@@ -1187,6 +1193,13 @@ proto_tree_set_visible(proto_tree *tree, gboolean visible);
 extern void
 proto_tree_set_fake_protocols(proto_tree *tree, gboolean fake_protocols);
 
+/** Indicate whether we should perform fast full dissection (default = FALSE)
+ * If enabled, all fields are dissected, but value strings are not handled
+ @param tree the tree to be set
+ @param fast_full_dissection TRUE if we should fake protocols */
+WS_DLL_PUBLIC void
+proto_tree_set_fast_full_dissection(proto_tree *tree, gboolean fast_full_dissection);
+
 /** Mark a field/protocol ID as "interesting".
  @param tree the tree to be set (currently ignored)
  @param hfid the interesting field id
diff --git a/epan/register.c b/epan/register.c
index d8c0eda8398..c7c0844b790 100644
--- a/epan/register.c
+++ b/epan/register.c
@@ -16,6 +16,7 @@
 #include <epan/exceptions.h>
 
 #include "epan/dissectors/dissectors.h"
+#include "epan/wmem_scopes.h"
 
 static const char *cur_cb_name = NULL;
 // We could use g_atomic_pointer_set/get instead of a mutex, but that's
@@ -32,10 +33,14 @@ static void set_cb_name(const char *proto) {
 }
 
 static void *
-register_all_protocols_worker(void *arg _U_)
+register_all_protocols_worker(void *arg)
 {
     void *volatile error_message = NULL;
 
+    // Recover wmem scope from parent thread
+    wmem_scopes_t *local_wmem_scopes = (wmem_scopes_t *)arg;
+    wmem_set_all_scopes(*local_wmem_scopes);
+
     TRY {
         for (gulong i = 0; i < dissector_reg_proto_count; i++) {
             set_cb_name(dissector_reg_proto[i].cb_name);
@@ -68,8 +73,9 @@ register_all_protocols(register_cb cb, gpointer cb_data)
     gboolean called_back = FALSE;
     GThread *rapw_thread;
     const char *error_message;
+    wmem_scopes_t local_wmem_scopes = wmem_get_all_scopes();
 
-    rapw_thread = g_thread_new("register_all_protocols_worker", &register_all_protocols_worker, NULL);
+    rapw_thread = g_thread_new("register_all_protocols_worker", &register_all_protocols_worker, &local_wmem_scopes);
     while (!g_async_queue_timeout_pop(register_cb_done_q, CB_WAIT_TIME)) {
         g_mutex_lock(&cur_cb_name_mtx);
         cb_name = cur_cb_name;
@@ -88,10 +94,14 @@ register_all_protocols(register_cb cb, gpointer cb_data)
 }
 
 static void *
-register_all_protocol_handoffs_worker(void *arg _U_)
+register_all_protocol_handoffs_worker(void *arg)
 {
     void *volatile error_message = NULL;
 
+    // Recover wmem scope from parent thread
+    wmem_scopes_t *local_wmem_scopes = (wmem_scopes_t *)arg;
+    wmem_set_all_scopes(*local_wmem_scopes);
+
     TRY {
         for (gulong i = 0; i < dissector_reg_handoff_count; i++) {
             set_cb_name(dissector_reg_handoff[i].cb_name);
@@ -123,9 +133,10 @@ register_all_protocol_handoffs(register_cb cb, gpointer cb_data)
     gboolean called_back = FALSE;
     GThread *raphw_thread;
     const char *error_message;
+    wmem_scopes_t local_wmem_scopes = wmem_get_all_scopes();
 
     set_cb_name(NULL);
-    raphw_thread = g_thread_new("register_all_protocol_handoffs_worker", &register_all_protocol_handoffs_worker, NULL);
+    raphw_thread = g_thread_new("register_all_protocol_handoffs_worker", &register_all_protocol_handoffs_worker, &local_wmem_scopes);
     while (!g_async_queue_timeout_pop(register_cb_done_q, CB_WAIT_TIME)) {
         g_mutex_lock(&cur_cb_name_mtx);
         cb_name = cur_cb_name;
diff --git a/epan/stream.c b/epan/stream.c
index 5bad6037f72..0689c92d358 100644
--- a/epan/stream.c
+++ b/epan/stream.c
@@ -90,8 +90,8 @@ static gboolean stream_compare_func(gconstpointer a,
     return (key1 -> conv == key2 -> conv );
 }
 
-/* the hash table */
-static GHashTable *stream_hash;
+/* the hash table per thread */
+static WS_THREAD_LOCAL GHashTable *stream_hash;
 
 
 /* cleanup reset function, call from stream_cleanup() */
@@ -154,7 +154,7 @@ static stream_t *stream_hash_insert( const struct conversation *conv, int p2p_di
  */
 
 /* pdu counter, for generating unique pdu ids */
-static guint32 pdu_counter;
+static guint32 WS_THREAD_LOCAL pdu_counter;
 
 static void stream_cleanup_pdu_data(void)
 {
@@ -208,8 +208,8 @@ static gboolean fragment_compare_func(gconstpointer a,
             key1 -> offset == key2 -> offset );
 }
 
-/* the hash table */
-static GHashTable *fragment_hash;
+/* the hash table per thread */
+static WS_THREAD_LOCAL GHashTable *fragment_hash;
 
 
 /* cleanup function, call from stream_cleanup() */
@@ -267,7 +267,7 @@ static stream_pdu_fragment_t *fragment_hash_insert( const stream_t *stream, guin
 /*****************************************************************************/
 
 /* reassembly table */
-static reassembly_table stream_reassembly_table;
+static WS_THREAD_LOCAL reassembly_table stream_reassembly_table;
 
 /* Initialise a new stream. Call this when you first identify a distinct
  * stream. */
diff --git a/epan/tvbuff-int.h b/epan/tvbuff-int.h
index 49b65f2df9a..3ba3dd2f514 100644
--- a/epan/tvbuff-int.h
+++ b/epan/tvbuff-int.h
@@ -84,6 +84,15 @@ struct tvbuff {
 
 	/* Offset from beginning of first "real" tvbuff. */
 	gint			raw_offset;
+
+    /* Offset from the parent (top-level) tvbuff */
+	gint			offset_from_parent;
+
+    /* How many bits this tvbuff is shifted from the parent octet */
+    gint            bitshift_from_octet;
+
+    /**< parent data source top-level tvbuff */
+    struct tvbuff	*parent;  
 };
 
 WS_DLL_PUBLIC tvbuff_t *tvb_new(const struct tvb_ops *ops);
diff --git a/epan/tvbuff.c b/epan/tvbuff.c
index ab1c075fb9d..e02c20fba55 100644
--- a/epan/tvbuff.c
+++ b/epan/tvbuff.c
@@ -78,6 +78,9 @@ tvb_new(const struct tvb_ops *ops)
 	tvb->real_data		 = NULL;
 	tvb->raw_offset		 = -1;
 	tvb->ds_tvb		 = NULL;
+	tvb->offset_from_parent	 = 0;
+	tvb->bitshift_from_octet = 0;
+	tvb->parent		 = NULL;
 
 	return tvb;
 }
@@ -137,6 +140,10 @@ tvb_add_to_chain(tvbuff_t *parent, tvbuff_t *child)
 	DISSECTOR_ASSERT(parent);
 	DISSECTOR_ASSERT(child);
 
+	// Fill in the parent tvbuff in the child.
+	child->parent = parent;
+	child->offset_from_parent = parent->raw_offset;	
+
 	while (child) {
 		tmp   = child;
 		child = child->next;
@@ -374,6 +381,8 @@ tvb_new_octet_aligned(tvbuff_t *tvb, guint32 bit_offset, gint32 no_of_bits)
 	left = bit_offset % 8; /* for left-shifting */
 	right = 8 - left; /* for right-shifting */
 
+	tvb->bitshift_from_octet = right;
+
 	if (no_of_bits == -1) {
 		datalen = _tvb_captured_length_remaining(tvb, byte_offset);
 		remaining_bits = 0;
@@ -385,6 +394,9 @@ tvb_new_octet_aligned(tvbuff_t *tvb, guint32 bit_offset, gint32 no_of_bits)
 		}
 	}
 
+	// printf("byte_offset=%d, bit_offset=%d, no_of_bits=%d\n", byte_offset, bit_offset, no_of_bits);
+	// printf("left=%d, right=%d\n", left, right);
+
 	/* already aligned -> shortcut */
 	if ((left == 0) && (remaining_bits == 0)) {
 		return tvb_new_subset_length_caplen(tvb, byte_offset, datalen, datalen);
@@ -420,6 +432,8 @@ tvb_new_octet_aligned(tvbuff_t *tvb, guint32 bit_offset, gint32 no_of_bits)
 	buf[datalen-1] &= left_aligned_bitmask[remaining_bits];
 
 	sub_tvb = tvb_new_child_real_data(tvb, buf, datalen, datalen);
+	sub_tvb->offset_from_parent +=  byte_offset;
+	sub_tvb->bitshift_from_octet = right;
 	tvb_set_free_cb(sub_tvb, g_free);
 
 	return sub_tvb;
@@ -486,6 +500,8 @@ tvb_new_octet_right_aligned(tvbuff_t *tvb, guint32 bit_offset, gint32 no_of_bits
 		buf[i] &= ((1 << remaining_bits) - 1);
 
 	sub_tvb = tvb_new_child_real_data(tvb, buf, dst_len, dst_len);
+	sub_tvb->offset_from_parent +=  byte_offset;
+	sub_tvb->bitshift_from_octet = -left;
 	tvb_set_free_cb(sub_tvb, g_free);
 
 	return sub_tvb;
diff --git a/epan/wmem_scopes.c b/epan/wmem_scopes.c
index d8385d74d6e..50d1170ca6f 100644
--- a/epan/wmem_scopes.c
+++ b/epan/wmem_scopes.c
@@ -36,9 +36,9 @@
  */
 
 /* TODO: Make these thread-local */
-static wmem_allocator_t *packet_scope = NULL;
-static wmem_allocator_t *file_scope   = NULL;
-static wmem_allocator_t *epan_scope   = NULL;
+static WS_THREAD_LOCAL wmem_allocator_t *packet_scope = NULL;
+static WS_THREAD_LOCAL wmem_allocator_t *file_scope = NULL;
+static WS_THREAD_LOCAL wmem_allocator_t *epan_scope = NULL;
 
 /* Packet Scope */
 
@@ -124,8 +124,8 @@ wmem_init_scopes(void)
     wmem_init();
 
     packet_scope = wmem_allocator_new(WMEM_ALLOCATOR_BLOCK_FAST);
-    file_scope   = wmem_allocator_new(WMEM_ALLOCATOR_BLOCK);
-    epan_scope   = wmem_allocator_new(WMEM_ALLOCATOR_BLOCK);
+    file_scope   = wmem_allocator_new(WMEM_ALLOCATOR_BLOCK_FAST);
+    epan_scope   = wmem_allocator_new(WMEM_ALLOCATOR_BLOCK_FAST);
 
     /* Scopes are initialized to TRUE by default on creation */
     wmem_leave_scope(packet_scope);
@@ -149,8 +149,28 @@ wmem_cleanup_scopes(void)
     wmem_cleanup();
 
     packet_scope = NULL;
-    file_scope   = NULL;
-    epan_scope   = NULL;
+    file_scope = NULL;
+    epan_scope = NULL;
+}
+
+wmem_scopes_t
+wmem_get_all_scopes(void)
+{
+    wmem_scopes_t scopes;
+
+    scopes.packet_scope = packet_scope;
+    scopes.file_scope = file_scope;
+    scopes.epan_scope = epan_scope;
+
+    return scopes;
+}
+
+void
+wmem_set_all_scopes(wmem_scopes_t scopes)
+{
+    packet_scope = scopes.packet_scope;
+    file_scope = scopes.file_scope;
+    epan_scope = scopes.epan_scope;
 }
 
 /*
diff --git a/epan/wmem_scopes.h b/epan/wmem_scopes.h
index eb850527cae..549f5ae1b06 100644
--- a/epan/wmem_scopes.h
+++ b/epan/wmem_scopes.h
@@ -18,6 +18,13 @@
 extern "C" {
 #endif /* __cplusplus */
 
+/** A structure representing the main wmem scopes (epan, packet, file). */
+typedef struct __wmem_scopes_t {
+    wmem_allocator_t *epan_scope;
+    wmem_allocator_t *packet_scope;
+    wmem_allocator_t *file_scope;
+} wmem_scopes_t;
+
 /**
  * @brief Fetch the current epan scope.
  *
@@ -71,6 +78,14 @@ WS_DLL_PUBLIC
 void
 wmem_cleanup_scopes(void);
 
+WS_DLL_PUBLIC
+wmem_scopes_t
+wmem_get_all_scopes(void);
+
+WS_DLL_PUBLIC
+void
+wmem_set_all_scopes(wmem_scopes_t scopes);
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/epan/wslua/CMakeLists.txt b/epan/wslua/CMakeLists.txt
index f6b16ad34ba..17e9fb9084e 100644
--- a/epan/wslua/CMakeLists.txt
+++ b/epan/wslua/CMakeLists.txt
@@ -61,26 +61,26 @@ set_source_files_properties(
 
 # Used with untypical CWD
 set(WSLUA_TAPS_USED
-	${CMAKE_SOURCE_DIR}/epan/dissectors/packet-http.h
-	${CMAKE_SOURCE_DIR}/epan/dissectors/packet-ip.h
-	${CMAKE_SOURCE_DIR}/epan/dissectors/packet-udp.h
-	${CMAKE_SOURCE_DIR}/epan/dissectors/packet-h225.h
-	${CMAKE_SOURCE_DIR}/epan/dissectors/packet-ieee80211.h
+	${PROJECT_SOURCE_DIR}/epan/dissectors/packet-http.h
+	${PROJECT_SOURCE_DIR}/epan/dissectors/packet-ip.h
+	${PROJECT_SOURCE_DIR}/epan/dissectors/packet-udp.h
+	${PROJECT_SOURCE_DIR}/epan/dissectors/packet-h225.h
+	${PROJECT_SOURCE_DIR}/epan/dissectors/packet-ieee80211.h
 )
 
 add_custom_command(
 	OUTPUT
-		${CMAKE_BINARY_DIR}/epan/wslua/taps_wslua.c
+		${PROJECT_BINARY_DIR}/epan/wslua/taps_wslua.c
 		# XXX taps.txt doesn't appear to be used anywhere.
-		${CMAKE_BINARY_DIR}/epan/wslua/taps.txt
+		${PROJECT_BINARY_DIR}/epan/wslua/taps.txt
 	COMMAND
 		${PYTHON_EXECUTABLE}
-		${CMAKE_SOURCE_DIR}/epan/wslua/make-taps.py
-		${CMAKE_BINARY_DIR}/epan/wslua/taps_wslua.c
-		${CMAKE_BINARY_DIR}/epan/wslua/taps.txt
+		${PROJECT_SOURCE_DIR}/epan/wslua/make-taps.py
+		${PROJECT_BINARY_DIR}/epan/wslua/taps_wslua.c
+		${PROJECT_BINARY_DIR}/epan/wslua/taps.txt
 	DEPENDS
-		${CMAKE_SOURCE_DIR}/epan/wslua/taps.ini
-		${CMAKE_SOURCE_DIR}/epan/wslua/make-taps.py
+		${PROJECT_SOURCE_DIR}/epan/wslua/taps.ini
+		${PROJECT_SOURCE_DIR}/epan/wslua/make-taps.py
 		# Only here to add dependencies for the taps "source" files
 		${WSLUA_TAPS_USED}
 )
@@ -92,10 +92,10 @@ add_custom_command(
 		register_wslua.c
 	COMMAND
 		${PYTHON_EXECUTABLE}
-		${CMAKE_SOURCE_DIR}/epan/wslua/make-reg.py
+		${PROJECT_SOURCE_DIR}/epan/wslua/make-reg.py
 		${WSLUA_MODULES}
 	DEPENDS
-		${CMAKE_SOURCE_DIR}/epan/wslua/make-reg.py
+		${PROJECT_SOURCE_DIR}/epan/wslua/make-reg.py
 		${WSLUA_MODULES}
 		# ${CMAKE_CURRENT_BINARY_DIR}/taps_wslua.c
 )
diff --git a/epan/wslua/lrexlib/CMakeLists.txt b/epan/wslua/lrexlib/CMakeLists.txt
index 1f5f13f2787..000da752c41 100644
--- a/epan/wslua/lrexlib/CMakeLists.txt
+++ b/epan/wslua/lrexlib/CMakeLists.txt
@@ -13,7 +13,7 @@ target_link_libraries(lrexlib PRIVATE
 )
 
 target_include_directories(lrexlib SYSTEM PRIVATE
-	${CMAKE_SOURCE_DIR}/epan
+	${PROJECT_SOURCE_DIR}/epan
 	${LUA_INCLUDE_DIRS}
 	${PCRE2_INCLUDE_DIRS}
 )
diff --git a/extcap/CMakeLists.txt b/extcap/CMakeLists.txt
index 170bc7ce452..8777b97e4a3 100644
--- a/extcap/CMakeLists.txt
+++ b/extcap/CMakeLists.txt
@@ -42,32 +42,32 @@ macro(set_extcap_executable_properties _executable)
 
 	if(MSVC)
 		set_target_properties(${_executable} PROPERTIES
-			RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/run/extcap
-			RUNTIME_OUTPUT_DIRECTORY_DEBUG ${CMAKE_BINARY_DIR}/run/Debug/extcap
-			RUNTIME_OUTPUT_DIRECTORY_RELEASE ${CMAKE_BINARY_DIR}/run/Release/extcap
-			RUNTIME_OUTPUT_DIRECTORY_MINSIZEREL ${CMAKE_BINARY_DIR}/run/MinSizeRel/extcap
-			RUNTIME_OUTPUT_DIRECTORY_RELWITHDEBINFO ${CMAKE_BINARY_DIR}/run/RelWithDebInfo/extcap
+			RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/run/extcap
+			RUNTIME_OUTPUT_DIRECTORY_DEBUG ${PROJECT_BINARY_DIR}/run/Debug/extcap
+			RUNTIME_OUTPUT_DIRECTORY_RELEASE ${PROJECT_BINARY_DIR}/run/Release/extcap
+			RUNTIME_OUTPUT_DIRECTORY_MINSIZEREL ${PROJECT_BINARY_DIR}/run/MinSizeRel/extcap
+			RUNTIME_OUTPUT_DIRECTORY_RELWITHDEBINFO ${PROJECT_BINARY_DIR}/run/RelWithDebInfo/extcap
 		)
 	else()
 		set_target_properties(${_executable} PROPERTIES
-			RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/run/extcap
+			RUNTIME_OUTPUT_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/ws/extcap
 		)
 		if(ENABLE_APPLICATION_BUNDLE)
 			if(NOT CMAKE_CFG_INTDIR STREQUAL ".")
 				# Xcode
 				set_target_properties(${_executable} PROPERTIES
-					RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/run/$<CONFIG>/Wireshark.app/Contents/MacOS/extcap
+					RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/run/$<CONFIG>/Wireshark.app/Contents/MacOS/extcap
 				)
 			else()
 				set_target_properties(${_executable} PROPERTIES
-					RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/run/Wireshark.app/Contents/MacOS/extcap
+					RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/run/Wireshark.app/Contents/MacOS/extcap
 				)
 				# Create a convenience link from run/<name> to its respective
 				# target in the application bundle.
 				add_custom_target(${_executable}-symlink
 					COMMAND ln -s -f
 						Wireshark.app/Contents/MacOS/extcap/${_executable}
-						${CMAKE_BINARY_DIR}/run/${_executable}
+						${PROJECT_BINARY_DIR}/run/${_executable}
 				)
 				add_dependencies(${_executable} ${_executable}-symlink)
 			endif()
@@ -86,18 +86,18 @@ macro(set_extlog_executable_properties _executable)
 		if(NOT CMAKE_CFG_INTDIR STREQUAL ".")
 			# Xcode
 			set_target_properties(${_executable} PROPERTIES
-				RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/run/$<CONFIG>/Logray.app/Contents/MacOS/extcap
+				RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/run/$<CONFIG>/Logray.app/Contents/MacOS/extcap
 			)
 		else()
 			set_target_properties(${_executable} PROPERTIES
-				RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/run/Logray.app/Contents/MacOS/extcap
+				RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/run/Logray.app/Contents/MacOS/extcap
 			)
 			# Create a convenience link from run/<name> to its respective
 			# target in the application bundle.
 			add_custom_target(${_executable}-symlink
 				COMMAND ln -s -f
 					Logray.app/Contents/MacOS/extcap/${_executable}
-					${CMAKE_BINARY_DIR}/run/${_executable}
+					${PROJECT_BINARY_DIR}/run/${_executable}
 			)
 			add_dependencies(${_executable} ${_executable}-symlink)
 		endif()
@@ -123,7 +123,7 @@ if(BUILD_androiddump)
 				wiretap
 				wsutil
 				${WIN_WS2_32_LIBRARY}
-				$<$<BOOL:${PCAP_FOUND}>:pcap::pcap>
+				pcap
 			)
 		else()
 			message(FATAL_ERROR "You are trying to build androiddump with libpcap but do not have it")
diff --git a/packaging/nsis/CMakeLists.txt b/packaging/nsis/CMakeLists.txt
index 8d4b61513bd..10f70181315 100644
--- a/packaging/nsis/CMakeLists.txt
+++ b/packaging/nsis/CMakeLists.txt
@@ -53,10 +53,10 @@ set(LOGRAY_NSIS_FILES
 # Variables required for config.nsh
 set(PROGRAM_NAME ${CMAKE_PROJECT_NAME})
 set(LOG_PROGRAM_NAME ${LOG_PROJECT_NAME})
-file(TO_NATIVE_PATH "${CMAKE_SOURCE_DIR}" TOP_SRC_DIR)
+file(TO_NATIVE_PATH "${PROJECT_SOURCE_DIR}" TOP_SRC_DIR)
 # STAGING_DIR depends on the build configuration so we pass it
 # on the command line below.
-file(TO_NATIVE_PATH "${CMAKE_BINARY_DIR}/docbook" DOCBOOK_DIR)
+file(TO_NATIVE_PATH "${PROJECT_BINARY_DIR}/docbook" DOCBOOK_DIR)
 if(WIRESHARK_TARGET_PLATFORM STREQUAL "win32")
         set(TARGET_MACHINE x86)
 elseif(WIRESHARK_TARGET_PLATFORM STREQUAL "win64")
@@ -244,8 +244,8 @@ set(NSIS_OPTIONS
 # separately AND that building the installer itself won't overwrite
 # uninstall-wireshark.exe
 macro( ADD_NSIS_UNINSTALLER_TARGETS )
-	set (_nsis_source_dir ${CMAKE_SOURCE_DIR}/packaging/nsis )
-	set (_nsis_binary_dir ${CMAKE_BINARY_DIR}/packaging/nsis )
+	set (_nsis_source_dir ${PROJECT_SOURCE_DIR}/packaging/nsis )
+	set (_nsis_binary_dir ${PROJECT_BINARY_DIR}/packaging/nsis )
 
 	#
 	# XXX - if we're not building Wireshark, we can't build
@@ -288,7 +288,7 @@ macro( ADD_NSIS_PACKAGE_TARGETS )
 	# This should probably be fixed, so that people can produce
 	# command-line-only installer packages.
 	if(BUILD_wireshark)
-		#set (_nsis_package ${CMAKE_BINARY_DIR}/packaging/nsis/Wireshark-$(WIRESHARK_TARGET_PLATFORM)-$(VERSION).exe)
+		#set (_nsis_package ${PROJECT_BINARY_DIR}/packaging/nsis/Wireshark-$(WIRESHARK_TARGET_PLATFORM)-$(VERSION).exe)
 
 		# wireshark-qt-manifest.nsh. Created using Wireshark.exe.
 		add_custom_command(OUTPUT ${_nsis_binary_dir}/wireshark-qt-manifest.nsh
@@ -332,7 +332,7 @@ macro( ADD_NSIS_PACKAGE_TARGETS )
 	endif()
 
 	if(BUILD_logray)
-		#set (_nsis_package ${CMAKE_BINARY_DIR}/packaging/nsis/Wireshark-$(WIRESHARK_TARGET_PLATFORM)-$(VERSION).exe)
+		#set (_nsis_package ${PROJECT_BINARY_DIR}/packaging/nsis/Wireshark-$(WIRESHARK_TARGET_PLATFORM)-$(VERSION).exe)
 
 		# logray-qt-manifest.nsh. Created using Wireshark.exe.
 		add_custom_command(OUTPUT ${_nsis_binary_dir}/logray-qt-manifest.nsh
diff --git a/packaging/portableapps/CMakeLists.txt b/packaging/portableapps/CMakeLists.txt
index 5a58f652d60..01774d12d84 100644
--- a/packaging/portableapps/CMakeLists.txt
+++ b/packaging/portableapps/CMakeLists.txt
@@ -44,7 +44,7 @@ macro( ADD_PORTABLEAPPS_PACKAGE_TARGET )
 	set(_wireshark_portableapps_app_dir "${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/App/${CMAKE_PROJECT_NAME}")
 	file(TO_NATIVE_PATH "${_wireshark_portableapps_app_dir}" _wireshark_portableapps_app_dir_native)
 	file(TO_NATIVE_PATH "${DATAFILE_DIR}" _datafile_dir_native)
-	file(TO_NATIVE_PATH "${CMAKE_SOURCE_DIR}/packaging/portableapps/xcopy-deploy-exclude.txt" _xcopy_deploy_exclude)
+	file(TO_NATIVE_PATH "${PROJECT_SOURCE_DIR}/packaging/portableapps/xcopy-deploy-exclude.txt" _xcopy_deploy_exclude)
 
 	add_custom_target(wireshark_portableapps_app_dir
 		# We "Deploy using XCopy," which is described at
@@ -79,7 +79,7 @@ macro( ADD_PORTABLEAPPS_PACKAGE_TARGET )
 	# Build the PortableApps package.
 	# wireshark_nsis_prep must be built prior to this.
 	# XXX Rename this to wireshark_portableapps
-	set (_portableapps_package ${CMAKE_BINARY_DIR}/packaging/portableapps/${PORTABLEAPPS_NAME}_${PROJECT_VERSION}.paf.exe)
+	set (_portableapps_package ${PROJECT_BINARY_DIR}/packaging/portableapps/${PORTABLEAPPS_NAME}_${PROJECT_VERSION}.paf.exe)
 	add_custom_target(wireshark_portableapps
 		DEPENDS
 			wireshark_portableapps_runtime
@@ -92,7 +92,7 @@ macro( ADD_PORTABLEAPPS_PACKAGE_TARGET )
 
 	set(PORTABLEAPPS_PACKAGE_VERSION "${PROJECT_MAJOR_VERSION}.${PROJECT_MINOR_VERSION}.${PROJECT_PATCH_VERSION}.0")
 	configure_file(
-		${CMAKE_SOURCE_DIR}/packaging/portableapps/appinfo.tmpl
+		${PROJECT_SOURCE_DIR}/packaging/portableapps/appinfo.tmpl
 		${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/App/AppInfo/appinfo.ini
 		NEWLINE_STYLE WIN32
 	)
@@ -103,7 +103,7 @@ macro( ADD_PORTABLEAPPS_PACKAGE_TARGET )
 
 	set(_portableapps_launcher_ini ${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/App/AppInfo/Launcher/${PORTABLEAPPS_NAME}.ini)
 	configure_file(
-		${CMAKE_SOURCE_DIR}/packaging/portableapps/${CMAKE_PROJECT_NAME}Portable.tmpl
+		${PROJECT_SOURCE_DIR}/packaging/portableapps/${CMAKE_PROJECT_NAME}Portable.tmpl
 		${_portableapps_launcher_ini}
 		NEWLINE_STYLE WIN32
 	)
@@ -113,12 +113,12 @@ macro( ADD_PORTABLEAPPS_PACKAGE_TARGET )
 	add_custom_command(OUTPUT ${_portableapps_launcher_exe}
 		DEPENDS
 			${_portableapps_launcher_ini}
-		COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_SOURCE_DIR}/packaging/portableapps/help.html ${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/help.html
-		COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_SOURCE_DIR}/packaging/portableapps/help.html ${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/help.html
-		COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_SOURCE_DIR}/resources/icons/wireshark.ico ${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/App/AppInfo/appicon.ico
-		COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_SOURCE_DIR}/resources/icons/wsicon16.png ${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/App/AppInfo/appicon_16.png
-		COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_SOURCE_DIR}/resources/icons/wsicon32.png ${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/App/AppInfo/appicon_32.png
-		COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_SOURCE_DIR}/resources/icons/wsicon128.png ${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/App/AppInfo/appicon_128.png
+		COMMAND ${CMAKE_COMMAND} -E copy_if_different ${PROJECT_SOURCE_DIR}/packaging/portableapps/help.html ${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/help.html
+		COMMAND ${CMAKE_COMMAND} -E copy_if_different ${PROJECT_SOURCE_DIR}/packaging/portableapps/help.html ${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/help.html
+		COMMAND ${CMAKE_COMMAND} -E copy_if_different ${PROJECT_SOURCE_DIR}/resources/icons/wireshark.ico ${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/App/AppInfo/appicon.ico
+		COMMAND ${CMAKE_COMMAND} -E copy_if_different ${PROJECT_SOURCE_DIR}/resources/icons/wsicon16.png ${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/App/AppInfo/appicon_16.png
+		COMMAND ${CMAKE_COMMAND} -E copy_if_different ${PROJECT_SOURCE_DIR}/resources/icons/wsicon32.png ${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/App/AppInfo/appicon_32.png
+		COMMAND ${CMAKE_COMMAND} -E copy_if_different ${PROJECT_SOURCE_DIR}/resources/icons/wsicon128.png ${PORTABLEAPPS_LAUNCHER_STAGING_DIR}/App/AppInfo/appicon_128.png
 		COMMAND ${PORTABLEAPPS_LAUNCHER_GENERATOR_EXECUTABLE} ${_portableapps_native}
 	)
 
diff --git a/packaging/wix/CMakeLists.txt b/packaging/wix/CMakeLists.txt
index a0925e9e71b..2248f6c8dfc 100644
--- a/packaging/wix/CMakeLists.txt
+++ b/packaging/wix/CMakeLists.txt
@@ -21,9 +21,9 @@ set(WIX_GENERATED_FILES
 set(WIX_GENERATED_FILES ${WIX_GENERATED_FILES} PARENT_SCOPE)
 
 set(WIX_SOURCE_FILES
-	${CMAKE_SOURCE_DIR}/packaging/wix/Wireshark.wxs
-	${CMAKE_SOURCE_DIR}/packaging/wix/WiresharkOptionsDlg.wxs
-	${CMAKE_SOURCE_DIR}/packaging/wix/WiresharkWixUI.wxs
+	${PROJECT_SOURCE_DIR}/packaging/wix/Wireshark.wxs
+	${PROJECT_SOURCE_DIR}/packaging/wix/WiresharkOptionsDlg.wxs
+	${PROJECT_SOURCE_DIR}/packaging/wix/WiresharkWixUI.wxs
 	${WIX_GENERATED_FILES}
 )
 set(WIX_SOURCE_FILES ${WIX_SOURCE_FILES} PARENT_SCOPE)
@@ -57,10 +57,10 @@ set(WIX_OUT_FILES ${WIX_OUT_FILES} PARENT_SCOPE)
 
 # Variables required for Wireshark.wxs
 set(PROGRAM_NAME ${CMAKE_PROJECT_NAME})
-file(TO_NATIVE_PATH "${CMAKE_SOURCE_DIR}" TOP_SRC_DIR)
+file(TO_NATIVE_PATH "${PROJECT_SOURCE_DIR}" TOP_SRC_DIR)
 # STAGING_DIR depends on the build configuration so we pass it
 # on the command line below.
-file(TO_NATIVE_PATH "${CMAKE_BINARY_DIR}/docbook" DOCBOOK_DIR)
+file(TO_NATIVE_PATH "${PROJECT_BINARY_DIR}/docbook" DOCBOOK_DIR)
 if(WIRESHARK_TARGET_PLATFORM STREQUAL "win32")
 	set(TARGET_MACHINE x86)
 elseif(WIRESHARK_TARGET_PLATFORM STREQUAL "win64")
@@ -212,10 +212,10 @@ set(WIX_CANDLE_DEFINES
 	-dWiresharkVersion=${PRODUCT_VERSION}
 	-dWiresharkMajorVersion=${PROJECT_MAJOR_VERSION}
 	-dWiresharkMinorVersion=${PROJECT_MINOR_VERSION}
-	-dAssetDir=${CMAKE_SOURCE_DIR}/packaging/wix
+	-dAssetDir=${PROJECT_SOURCE_DIR}/packaging/wix
 	-dBuildOutputDir=${EXECUTABLE_OUTPUT_PATH}/${CMAKE_CFG_INTDIR}
 	-dDiameterDir=${ARCHIVE_OUTPUT_PATH}/${CMAKE_CFG_INTDIR}/diameter
-	-dIconDir=${CMAKE_SOURCE_DIR}/resources/icons
+	-dIconDir=${PROJECT_SOURCE_DIR}/resources/icons
 	-dQtTranslationDir=${ARCHIVE_OUTPUT_PATH}/${CMAKE_CFG_INTDIR}/translations
 	-dRadiusDictDir=${ARCHIVE_OUTPUT_PATH}/${CMAKE_CFG_INTDIR}/radius
 	-dSnmpMibDir=${ARCHIVE_OUTPUT_PATH}/${CMAKE_CFG_INTDIR}/snmp/mibs
@@ -226,7 +226,7 @@ set(WIX_CANDLE_DEFINES
 	${d_mmdbresolve_exe}
 	-arch ${TARGET_MACHINE}
 	-ext WixUIExtension
-	-I${CMAKE_SOURCE_DIR}/packaging/wix
+	-I${PROJECT_SOURCE_DIR}/packaging/wix
 	-out ${CMAKE_CURRENT_BINARY_DIR}/
 	PARENT_SCOPE
 )
@@ -260,8 +260,8 @@ macro( ADD_WIX_PACKAGE_TARGET )
 	# This should probably be fixed, so that people can produce
 	# command-line-only installer packages.
 	if(BUILD_wireshark)
-		set (_wix_source_dir ${CMAKE_SOURCE_DIR}/packaging/wix )
-		set (_wix_binary_dir ${CMAKE_BINARY_DIR}/packaging/wix )
+		set (_wix_source_dir ${PROJECT_SOURCE_DIR}/packaging/wix )
+		set (_wix_binary_dir ${PROJECT_BINARY_DIR}/packaging/wix )
 
 		# QtDependentComponents.wxs. Created using Wireshark.exe.
 		add_custom_command(OUTPUT ${_wix_binary_dir}/QtDependentComponents.wxs
@@ -275,7 +275,7 @@ macro( ADD_WIX_PACKAGE_TARGET )
 		# UsersGuide.wxs. Collects the contents of wsug_html_chunked.
 		# Generated with heat.exe
 		add_custom_command(OUTPUT ${_wix_binary_dir}/UsersGuide.wxs
-			COMMAND ${WIX_HEAT_EXECUTABLE} dir ${CMAKE_BINARY_DIR}/docbook/wsug_html_chunked
+			COMMAND ${WIX_HEAT_EXECUTABLE} dir ${PROJECT_BINARY_DIR}/docbook/wsug_html_chunked
 					${WIX_HEAT_FLAGS} -cg CG.Documentation -dr dirUsersGuide -var var.UsersGuideDir
 					-out ${_wix_binary_dir}/UsersGuide.wxs
 		)
diff --git a/plugins/codecs/G711/CMakeLists.txt b/plugins/codecs/G711/CMakeLists.txt
index cc9ff0f191f..ce0997d8eff 100644
--- a/plugins/codecs/G711/CMakeLists.txt
+++ b/plugins/codecs/G711/CMakeLists.txt
@@ -34,7 +34,7 @@ register_plugin_files(plugin.c
 
 add_wireshark_plugin_library(g711 codecs)
 
-target_include_directories(g711 PRIVATE ${CMAKE_SOURCE_DIR}/codecs)
+target_include_directories(g711 PRIVATE ${PROJECT_SOURCE_DIR}/codecs)
 
 target_link_libraries(g711 wsutil)
 
diff --git a/plugins/codecs/G722/CMakeLists.txt b/plugins/codecs/G722/CMakeLists.txt
index 37c08cd12e4..1f50b9c217e 100644
--- a/plugins/codecs/G722/CMakeLists.txt
+++ b/plugins/codecs/G722/CMakeLists.txt
@@ -34,7 +34,7 @@ register_plugin_files(plugin.c
 
 add_wireshark_plugin_library(g722 codecs)
 
-target_include_directories(g722 PRIVATE ${CMAKE_SOURCE_DIR}/codecs)
+target_include_directories(g722 PRIVATE ${PROJECT_SOURCE_DIR}/codecs)
 
 target_link_libraries(g722 wsutil ${SPANDSP_LIBRARIES})
 
diff --git a/plugins/codecs/G726/CMakeLists.txt b/plugins/codecs/G726/CMakeLists.txt
index 239b67f0e52..d3d612a5dad 100644
--- a/plugins/codecs/G726/CMakeLists.txt
+++ b/plugins/codecs/G726/CMakeLists.txt
@@ -34,7 +34,7 @@ register_plugin_files(plugin.c
 
 add_wireshark_plugin_library(g726 codecs)
 
-target_include_directories(g726 PRIVATE ${CMAKE_SOURCE_DIR}/codecs)
+target_include_directories(g726 PRIVATE ${PROJECT_SOURCE_DIR}/codecs)
 
 target_link_libraries(g726 wsutil ${SPANDSP_LIBRARIES})
 
diff --git a/plugins/codecs/G729/CMakeLists.txt b/plugins/codecs/G729/CMakeLists.txt
index 6c5330021fb..f4fb80e1105 100644
--- a/plugins/codecs/G729/CMakeLists.txt
+++ b/plugins/codecs/G729/CMakeLists.txt
@@ -34,7 +34,7 @@ register_plugin_files(plugin.c
 
 add_wireshark_plugin_library(g729 codecs)
 
-target_include_directories(g729 PRIVATE ${CMAKE_SOURCE_DIR}/codecs)
+target_include_directories(g729 PRIVATE ${PROJECT_SOURCE_DIR}/codecs)
 
 target_link_libraries(g729 wsutil ${BCG729_LIBRARIES})
 
diff --git a/plugins/codecs/iLBC/CMakeLists.txt b/plugins/codecs/iLBC/CMakeLists.txt
index 89292043016..709375a5f0a 100644
--- a/plugins/codecs/iLBC/CMakeLists.txt
+++ b/plugins/codecs/iLBC/CMakeLists.txt
@@ -34,7 +34,7 @@ register_plugin_files(plugin.c
 
 add_wireshark_plugin_library(ilbc codecs)
 
-target_include_directories(ilbc PRIVATE ${CMAKE_SOURCE_DIR}/codecs)
+target_include_directories(ilbc PRIVATE ${PROJECT_SOURCE_DIR}/codecs)
 
 target_link_libraries(ilbc wsutil ${ILBC_LIBRARIES})
 
diff --git a/plugins/codecs/l16_mono/CMakeLists.txt b/plugins/codecs/l16_mono/CMakeLists.txt
index f90713b70bb..98eb0fe61b1 100644
--- a/plugins/codecs/l16_mono/CMakeLists.txt
+++ b/plugins/codecs/l16_mono/CMakeLists.txt
@@ -34,7 +34,7 @@ register_plugin_files(plugin.c
 
 add_wireshark_plugin_library(l16mono codecs)
 
-target_include_directories(l16mono PRIVATE ${CMAKE_SOURCE_DIR}/codecs)
+target_include_directories(l16mono PRIVATE ${PROJECT_SOURCE_DIR}/codecs)
 
 target_link_libraries(l16mono wsutil)
 
diff --git a/plugins/codecs/opus_dec/CMakeLists.txt b/plugins/codecs/opus_dec/CMakeLists.txt
index dc3bdc21804..5dba2008fcc 100644
--- a/plugins/codecs/opus_dec/CMakeLists.txt
+++ b/plugins/codecs/opus_dec/CMakeLists.txt
@@ -34,7 +34,7 @@ register_plugin_files(plugin.c
 
 add_wireshark_plugin_library(opus_dec codecs)
 
-target_include_directories(opus_dec PRIVATE ${CMAKE_SOURCE_DIR}/codecs)
+target_include_directories(opus_dec PRIVATE ${PROJECT_SOURCE_DIR}/codecs)
 
 target_link_libraries(opus_dec wsutil ${OPUS_LIBRARIES})
 
diff --git a/plugins/codecs/sbc/CMakeLists.txt b/plugins/codecs/sbc/CMakeLists.txt
index d12de70d596..49af34b7c61 100644
--- a/plugins/codecs/sbc/CMakeLists.txt
+++ b/plugins/codecs/sbc/CMakeLists.txt
@@ -34,7 +34,7 @@ register_plugin_files(plugin.c
 
 add_wireshark_plugin_library(sbc codecs)
 
-target_include_directories(sbc PRIVATE ${CMAKE_SOURCE_DIR}/codecs)
+target_include_directories(sbc PRIVATE ${PROJECT_SOURCE_DIR}/codecs)
 
 target_link_libraries(sbc wsutil ${SBC_LIBRARIES})
 
diff --git a/plugins/epan/generic/AUTHORS b/plugins/epan/generic/AUTHORS
new file mode 100644
index 00000000000..d1bd8efb924
--- /dev/null
+++ b/plugins/epan/generic/AUTHORS
@@ -0,0 +1,2 @@
+Author:
+Olivier Aveline <wsgd@free.fr>
diff --git a/plugins/epan/generic/CMakeLists.DISSECTOR_CORE.txt b/plugins/epan/generic/CMakeLists.DISSECTOR_CORE.txt
new file mode 100644
index 00000000000..67a9df61def
--- /dev/null
+++ b/plugins/epan/generic/CMakeLists.DISSECTOR_CORE.txt
@@ -0,0 +1,50 @@
+
+# Dissector core sources.
+# All files specified here do NOT depend of wireshark.
+set(DISSECTOR_CORE_UT_SRC
+	byte_interpret.cpp byte_interpret.h
+	byte_interpret_compute_expression.cpp byte_interpret_compute_expression.h
+	T_expression.cpp T_expression.h
+	T_generic_statistics.cpp T_generic_statistics.h
+	T_interpret_data.cpp T_interpret_data.h
+	T_interpret_read_values.cpp T_interpret_read_values.h
+	T_interpret_byte_order.cpp T_interpret_byte_order.h
+	T_interpret_output.cpp T_interpret_output.h
+	T_interpret_decode.cpp T_interpret_decode.h
+	T_interpret_inside_frame.cpp T_interpret_inside_frame.h
+	T_interpret_chrono.cpp T_interpret_chrono.h
+	T_perf_time.cpp T_perf_time.h
+	T_interpret_value.cpp T_interpret_value.h
+	T_attribute_value.cpp T_attribute_value.h
+	T_frame_data.cpp T_frame_data.h
+	T_frame_data_write.cpp T_frame_data_write.h
+	T_type_definitions.cpp T_type_definitions.h
+	C_reference_counter_ptr.h C_reference_counter.h
+	C_value.cpp C_value.h
+	C_setlocale_numeric_C_guard.cpp C_setlocale_numeric_C_guard.h
+	byte_interpret_builder.cpp byte_interpret_builder.h
+	byte_interpret_build_types.cpp byte_interpret_build_types.h
+	byte_interpret_build_types_context.cpp byte_interpret_build_types_context.h
+	byte_interpret_build_types_read_token.cpp byte_interpret_build_types_read_token.h
+	byte_interpret_parse.cpp byte_interpret_parse.h
+	byte_interpret_common.cpp byte_interpret_common.h
+	byte_interpret_common_base.cpp byte_interpret_common_base.h
+	byte_interpret_common_exception.cpp byte_interpret_common_exception.h
+	byte_interpret_common_fatal.cpp byte_interpret_common_fatal.h
+	byte_interpret_common_trace.cpp byte_interpret_common_trace.h
+	byte_interpret_common_utils.h
+	byte_interpret_plugin_output.h
+	scoped_copyable_ptr.h
+	CT_debug_object_counter.cpp CT_debug_object_counter.h
+	shark_wsutil_aes.c shark_wsutil_aes.h
+	T_generic_protocol_data_base.cpp T_generic_protocol_data_base.h
+	peglib.h    # tools/make-plugin-reg.py fails to read it
+)
+
+set (DISSECTOR_CORE_OTHER_SRC
+)
+
+set (DISSECTOR_CORE_SRC
+	${DISSECTOR_CORE_UT_SRC}
+	${DISSECTOR_CORE_OTHER_SRC}
+)
diff --git a/plugins/epan/generic/CMakeLists.DISSECTOR_SUPPORT_SRC.txt b/plugins/epan/generic/CMakeLists.DISSECTOR_SUPPORT_SRC.txt
new file mode 100644
index 00000000000..481270b9269
--- /dev/null
+++ b/plugins/epan/generic/CMakeLists.DISSECTOR_SUPPORT_SRC.txt
@@ -0,0 +1,10 @@
+
+# Dissector helpers.  They're included in the source files in this
+# directory, but they're not dissectors themselves, i.e. they're not
+# used to generate "register.c").
+set (DISSECTOR_SUPPORT_SRC
+	generic.cpp generic.h
+	T_generic_protocol_data.cpp T_generic_protocol_data.h
+	C_byte_interpret_wsgd_builder.cpp C_byte_interpret_wsgd_builder.h
+	C_byte_interpret_wsgd_builder_base.cpp C_byte_interpret_wsgd_builder_base.h
+)
diff --git a/plugins/epan/generic/CMakeLists.DISSECTOR_UT_SRC.txt b/plugins/epan/generic/CMakeLists.DISSECTOR_UT_SRC.txt
new file mode 100644
index 00000000000..b35c209ca2d
--- /dev/null
+++ b/plugins/epan/generic/CMakeLists.DISSECTOR_UT_SRC.txt
@@ -0,0 +1,51 @@
+
+set (DISSECTOR_UT_TOOLS_SRC
+	unitary_tests_tools.cpp unitary_tests_tools.h
+	T_static_executor.cpp T_static_executor.h
+	T_static_executor_manager.cpp T_static_executor_manager.h
+	C_perf_chrono.cpp C_perf_chrono.h
+	unitary_tests_ut_interpret_bytes.cpp unitary_tests_ut_interpret_bytes.h
+)
+
+set (DISSECTOR_UT_SRC
+	${DISSECTOR_UT_TOOLS_SRC}
+	unitary_test_build_field.cpp
+	unitary_test_build_field_bitfield_bitstream.cpp
+	unitary_test_build_field_call_function.cpp
+	unitary_test_build_field_const_enum.cpp
+	unitary_test_build_field_invalid_syntax.cpp
+	unitary_test_build_field_loop_condition.cpp
+	unitary_test_build_field_misc.cpp
+	unitary_test_build_field_position.cpp
+	unitary_test_build_field_switch_struct.cpp
+	unitary_test_build_field_ternary.cpp
+	unitary_test_build_types_and_interpret_bytes.cpp
+	unitary_test_decode_stream_frame.cpp
+	unitary_test_decompose_left_sep_middle_sep_right.cpp
+	unitary_test_decompose_type_sep_value_sep.cpp
+	unitary_test_expression.cpp
+	unitary_test_frame_data.cpp
+	unitary_test_generic_protocol_data_base.cpp
+	unitary_test_generic_statistics.cpp
+	unitary_test_get_before_separator_after.cpp
+	unitary_test_get_number.cpp
+	unitary_test_interpret_forget.cpp
+	unitary_test_interpret_simple.cpp
+	unitary_test_interpret_simple_decoder_aes.cpp
+	unitary_test_interpret_simple_decoder_base64.cpp
+	unitary_test_interpret_simple_internal_frame.cpp
+	unitary_test_interpret_simple_position.cpp
+	unitary_test_interpret_simple_trailer.cpp
+	unitary_test_is_existing_field_or_variable.cpp
+	unitary_test_read_token.cpp
+	unitary_test_read_token_word_cplx.cpp
+	unitary_test_read_values.cpp
+	unitary_test_scoped_copyable_ptr.cpp
+	unitary_test_static_executor_manager.cpp
+	unitary_test_string_to_words.cpp
+	unitary_test_promote_printf_string_to_64bits.cpp
+	unitary_test_value_format.cpp
+	unitary_test_value_printf.cpp
+	unitary_tests_functions.cpp
+	unitary_tests_misc.cpp
+)
diff --git a/plugins/epan/generic/CMakeLists.txt b/plugins/epan/generic/CMakeLists.txt
new file mode 100644
index 00000000000..92cf62abdfc
--- /dev/null
+++ b/plugins/epan/generic/CMakeLists.txt
@@ -0,0 +1,110 @@
+# CMakeLists.txt
+#
+# Wireshark - Network traffic analyzer
+# By Gerald Combs <gerald@wireshark.org>
+# Copyright 1998 Gerald Combs
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+
+include(WiresharkPlugin)
+
+# Plugin name and version info (major minor micro extra)
+set_module_info(generic 0 5 2 0)
+
+include(cmake_wireshark_version_number.cmake)
+
+include(CMakeLists.DISSECTOR_CORE.txt)
+include(CMakeLists.DISSECTOR_SUPPORT_SRC.txt)
+
+
+add_library(libfdesc STATIC ${DISSECTOR_CORE_SRC})
+set_target_properties(libfdesc PROPERTIES FOLDER "Wsgd")
+set_property(TARGET libfdesc PROPERTY CXX_STANDARD 11)
+
+# Only files needed to generate plugin.c
+set(DISSECTOR_SRC
+	packet-generic.c
+)
+
+set(PLUGIN_FILES
+	plugin.c
+	${DISSECTOR_SRC}
+	${DISSECTOR_SUPPORT_SRC}
+)
+
+if (UNIX)
+	set_source_files_properties(
+		${PLUGIN_FILES}
+		PROPERTIES
+	# Too many errors (sign compare, ...)
+	#	COMPILE_FLAGS "${WERROR_COMMON_FLAGS}"
+		COMPILE_FLAGS ""
+	)
+else()
+	set_source_files_properties(
+		${PLUGIN_FILES}
+		PROPERTIES
+		COMPILE_FLAGS "${WERROR_COMMON_FLAGS}"
+	)
+endif()
+
+register_plugin_files(plugin.c
+	plugin
+	${DISSECTOR_SRC}
+)
+
+add_wireshark_plugin_library(generic epan)
+target_link_libraries(generic PRIVATE epan libfdesc)
+set_target_properties(generic PROPERTIES FOLDER "Wsgd")
+set_property(TARGET generic PROPERTY CXX_STANDARD 11)
+
+install_plugin(generic epan)
+
+file(GLOB DISSECTOR_HEADERS RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}" "*.h")
+CHECKAPI(
+	NAME
+	  generic
+	SWITCHES
+	  --group dissectors-prohibited
+	  --group dissectors-restricted
+	SOURCES
+	  ${DISSECTOR_SRC}
+	  ${DISSECTOR_SUPPORT_SRC}
+	  ${DISSECTOR_HEADERS}
+)
+
+
+
+# byte_interpret
+add_executable(byte_interpret byte_interpret_main.cpp)
+if (UNIX)
+	# Mandatory for peglib.h
+	#target_link_options(byte_interpret PRIVATE -pthread)  # cmake >= 3.13
+	target_link_libraries(byte_interpret PRIVATE "-pthread")
+endif()
+target_link_libraries(byte_interpret PRIVATE libfdesc)
+set_target_properties(byte_interpret PROPERTIES FOLDER "Wsgd")
+
+# unitary_tests
+# include(CMakeLists.DISSECTOR_UT_SRC.txt)
+# add_executable(unitary_tests unitary_tests.cpp ${DISSECTOR_UT_SRC})
+# if (UNIX)
+	# Mandatory for peglib.h
+	#target_link_options(byte_interpret PRIVATE -pthread)  # cmake >= 3.13
+	# target_link_libraries(unitary_tests PRIVATE "-pthread")
+# endif()
+# target_link_libraries(unitary_tests PRIVATE libfdesc)
+# set_target_properties(unitary_tests PROPERTIES FOLDER "Wsgd")
diff --git a/plugins/epan/generic/CT_debug_object_counter.cpp b/plugins/epan/generic/CT_debug_object_counter.cpp
new file mode 100644
index 00000000000..a6840c987df
--- /dev/null
+++ b/plugins/epan/generic/CT_debug_object_counter.cpp
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2012-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+// ****************************************************************************
+// Includes.
+// ****************************************************************************
+
+#include "precomp.h"
+#include "CT_debug_object_counter.h"
+
+#include <sstream>
+#include <map>
+
+using namespace std;
+
+//****************************************************************************
+// C_debug_object_counter
+//****************************************************************************
+
+#ifdef USE_C_debug_object_counter
+int  C_debug_object_counter::A_debug_counter = 0;
+
+std::map<std::string,int>  S_C_debug_object_counter_map_class_counter;
+std::map<std::string,int>  S_C_debug_object_counter_map_class_counter_old;
+std::map<std::string,int>  S_C_debug_object_counter_map_class_sizeof;
+
+C_debug_object_counter::C_debug_object_counter()
+{
+    ++A_debug_counter;
+}
+
+C_debug_object_counter::C_debug_object_counter(const C_debug_object_counter  & )
+{
+    ++A_debug_counter;
+}
+
+C_debug_object_counter::~C_debug_object_counter()
+{
+    --A_debug_counter;
+}
+
+std::string
+C_debug_object_counter::get_debug_string()
+{
+    ostringstream  oss;
+    oss << "nb_of_objects=" << A_debug_counter;
+
+    for (map<std::string,int>::const_iterator  
+        iter  = S_C_debug_object_counter_map_class_counter.begin();
+        iter != S_C_debug_object_counter_map_class_counter.end();
+      ++iter)
+    {
+        const string  & name = iter->first;
+        const int       counter_new = iter->second;
+        const int       class_sizeof = S_C_debug_object_counter_map_class_sizeof[name];
+
+        if (S_C_debug_object_counter_map_class_counter_old.empty())
+        {
+            oss << endl;
+            oss << name << "=" << counter_new;
+            oss << "    " << class_sizeof << "/" << class_sizeof*counter_new;
+            continue;
+        }
+
+        int       counter_old = 0;
+        {
+            map<std::string,int>::const_iterator
+                iter_old = S_C_debug_object_counter_map_class_counter_old.find(name);
+            if (iter_old != S_C_debug_object_counter_map_class_counter_old.end())
+            {
+                counter_old = iter_old->second;
+            }
+        }
+
+        if (counter_new != counter_old)
+        {
+            oss << endl;
+            oss << name << "=" << counter_new;
+            oss << "    ";
+            if (counter_new > counter_old)
+                oss << "+";
+            oss << (counter_new - counter_old);
+            oss << "    " << class_sizeof << "/" << class_sizeof*counter_new;
+        }
+    }
+
+    S_C_debug_object_counter_map_class_counter_old = S_C_debug_object_counter_map_class_counter;
+
+    return  oss.str();
+}
+
+void
+C_debug_object_counter::incr(const char * class_name, const int  sizeof_class)
+{
+    ++A_debug_counter;
+    S_C_debug_object_counter_map_class_counter[class_name] += 1;
+    S_C_debug_object_counter_map_class_sizeof[class_name] = sizeof_class;
+}
+
+void
+C_debug_object_counter::decr(const char * class_name)
+{
+    --A_debug_counter;
+    S_C_debug_object_counter_map_class_counter[class_name] -= 1;
+}
+
+#endif
diff --git a/plugins/epan/generic/CT_debug_object_counter.h b/plugins/epan/generic/CT_debug_object_counter.h
new file mode 100644
index 00000000000..02be2463fdf
--- /dev/null
+++ b/plugins/epan/generic/CT_debug_object_counter.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2012-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef CT_debug_object_counter_H
+#define CT_debug_object_counter_H
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include <string>
+#include <typeinfo>
+
+
+//****************************************************************************
+// C_debug_object_counter
+//****************************************************************************
+
+// Set this for debug ONLY : big performance issue.
+//#define USE_C_debug_object_counter
+
+#ifdef USE_C_debug_object_counter
+
+class C_debug_object_counter
+{
+public:
+    C_debug_object_counter();
+    C_debug_object_counter(const C_debug_object_counter  & );
+    ~C_debug_object_counter();
+
+    static int    get_nb_of_objects()                    { return A_debug_counter; }
+
+    static std::string  get_debug_string();
+
+
+    static void    incr(const char * class_name, const int  sizeof_class);
+    static void    decr(const char * class_name);
+
+private:
+    static int    A_debug_counter;
+};
+
+template<class TYPE>
+class CT_debug_object_counter
+{
+public:
+    CT_debug_object_counter()
+    {
+        C_debug_object_counter::incr(typeid(TYPE).name(), sizeof(TYPE));
+    }
+    CT_debug_object_counter(const CT_debug_object_counter &)
+    {
+        C_debug_object_counter::incr(typeid(TYPE).name(), sizeof(TYPE));
+    }
+    ~CT_debug_object_counter()
+    {
+        C_debug_object_counter::decr(typeid(TYPE).name());
+    }
+};
+#else
+
+class C_debug_object_counter
+{
+public:
+    C_debug_object_counter()                                  {  }
+    C_debug_object_counter(const C_debug_object_counter  & )  {  }
+    ~C_debug_object_counter()                                 {  }
+
+    static int    get_nb_of_objects()                    { return  0; }
+
+    static std::string  get_debug_string()               { return  ""; }
+
+};
+
+template<class TYPE>
+class CT_debug_object_counter
+{
+public:
+    CT_debug_object_counter() {  }
+    CT_debug_object_counter(const CT_debug_object_counter &) {  }
+    ~CT_debug_object_counter() {  }
+};
+#endif
+
+
+
+#endif /* CT_debug_object_counter_H */
diff --git a/plugins/epan/generic/C_byte_interpret_builder.h b/plugins/epan/generic/C_byte_interpret_builder.h
new file mode 100644
index 00000000000..3f80adcd704
--- /dev/null
+++ b/plugins/epan/generic/C_byte_interpret_builder.h
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2008-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef C_BYTE_INTERPRET_BUILDER_H
+#define C_BYTE_INTERPRET_BUILDER_H
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <string>
+using namespace std;
+
+
+#include "byte_interpret_builder.h"
+
+
+//*****************************************************************************
+// C_byte_interpret_builder
+//*****************************************************************************
+
+class C_byte_interpret_builder
+{
+public:
+
+    virtual
+    ~C_byte_interpret_builder() { }
+
+    //*****************************************************************************
+    // NB: in_out_frame_data is AFTER the value
+    //*****************************************************************************
+    virtual
+    void    value(const T_type_definitions  & /* type_definitions */,
+                  const T_frame_data        & /* in_out_frame_data */,
+                  const T_field_type_name   & /* field_type_name */,
+                  const string              & /* data_name */,
+                  const string              & /* data_simple_name */,
+                  const T_attribute_value   & /* attribute_value */,
+                  const string              & /* data_value */,
+                  const string              & /* final_type */,
+                  const int                   /* type_bit_size */,
+                  const bool                  /* is_little_endian */,
+                  const bool                  /* error */)
+    { }
+
+    //*****************************************************************************
+    // NB: in_out_frame_data is AFTER the value
+    //*****************************************************************************
+    virtual
+    void    raw_data(const T_type_definitions  & /* type_definitions */,
+                     const T_frame_data        & /* in_out_frame_data */,
+                     const T_interpret_data    & /* interpret_data */,
+                     const T_field_type_name   & /* field_type_name */,
+                     const string              & /* data_name */,
+                     const string              & /* data_simple_name */,
+                     const int                   /* type_bit_size */,
+                     const E_raw_data_type       /* raw_data_type */,
+                     const bool                  /* is_decoded_data */)
+    { }
+
+    //*****************************************************************************
+    // NB: group_end will be called
+    //*****************************************************************************
+    virtual
+    void    group_begin(const T_type_definitions  & /* type_definitions */,
+                        const T_frame_data        & /* in_out_frame_data */,
+                        const T_field_type_name   & /* field_type_name */,
+                        const string              & /* data_name */,
+                        const string              & /* data_simple_name */)
+    { }
+
+    //*****************************************************************************
+    // NB: group_begin has been called
+    //*****************************************************************************
+    virtual
+    void    group_append_text(const T_type_definitions  & /* type_definitions */,
+                              const T_frame_data        & /* in_out_frame_data */,
+//                              const T_field_type_name   & /* field_type_name */,
+                              const string              & /* data_name */,
+                              const string              & /* data_simple_name */,
+                              const string              & /* text */)
+    { }
+
+    //*****************************************************************************
+    // NB: group_begin has been called
+    //*****************************************************************************
+    virtual
+    void    group_end(const T_type_definitions  & /* type_definitions */,
+                      const T_frame_data        & /* in_out_frame_data */,
+                      const T_field_type_name   & /* field_type_name */,
+                      const string              & /* data_name */,
+                      const string              & /* data_simple_name */,
+                      const int                   /* type_bit_size */)
+    { }
+
+    //*****************************************************************************
+    // 
+    //*****************************************************************************
+    virtual
+    void    error(const T_type_definitions  & /* type_definitions */,
+                  const T_frame_data        & /* in_out_frame_data */,
+                  const T_field_type_name   & /* field_type_name */,
+                  const string              & /* data_name */,
+                  const string              & /* data_simple_name */,
+                  const string              & /* error */)
+    { }
+
+    //*****************************************************************************
+    // 
+    //*****************************************************************************
+    virtual
+    void    fatal(const T_type_definitions  & /* type_definitions */,
+                  const T_frame_data        & /* in_out_frame_data */,
+                  const T_field_type_name   & /* field_type_name */,
+                  const string              & /* data_name */,
+                  const string              & /* data_simple_name */,
+                  const string              & /* error */)
+    { }
+
+    //*****************************************************************************
+    // 
+    //*****************************************************************************
+    virtual
+    void    missing_data(const T_type_definitions  & /* type_definitions */,
+                         const T_frame_data        & /* in_out_frame_data */,
+                         const T_interpret_data    & /* interpret_data */,
+                         const T_field_type_name   & /* field_type_name */,
+                         const string              & /* data_name */,
+                         const string              & /* data_simple_name */,
+                         const string              & /* error */)
+    { }
+
+    //*****************************************************************************
+    // 
+    //*****************************************************************************
+    virtual
+    void    cmd_error(const T_type_definitions  & /* type_definitions */,
+                      const T_frame_data        & /* in_out_frame_data */,
+                      const T_field_type_name   & /* field_type_name */,
+                      const string              & /* data_name */,
+                      const string              & /* data_simple_name */)
+    { }
+
+    //*****************************************************************************
+    // 
+    //*****************************************************************************
+    virtual
+    void    cmd_fatal(const T_type_definitions  & /* type_definitions */,
+                      const T_frame_data        & /* in_out_frame_data */,
+                      const T_field_type_name   & /* field_type_name */,
+                      const string              & /* data_name */,
+                      const string              & /* data_simple_name */)
+    { }
+
+    //*****************************************************************************
+    // 
+    //*****************************************************************************
+    virtual
+    void    cmd_print(const T_type_definitions  & /* type_definitions */,
+                      const T_frame_data        & /* in_out_frame_data */,
+                      const T_field_type_name   & /* field_type_name */,
+                      const string              & /* data_name */,
+                      const string              & /* data_simple_name */)
+    { }
+
+};
+
+
+#endif /* C_BYTE_INTERPRET_BUILDER_H */
diff --git a/plugins/epan/generic/C_byte_interpret_wsgd_builder.cpp b/plugins/epan/generic/C_byte_interpret_wsgd_builder.cpp
new file mode 100644
index 00000000000..01a499e14d0
--- /dev/null
+++ b/plugins/epan/generic/C_byte_interpret_wsgd_builder.cpp
@@ -0,0 +1,1077 @@
+/*
+ * Copyright 2008-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "byte_interpret_builder.h"
+#include "byte_interpret.h"                 // is_a_raw_field ...
+
+#include "C_byte_interpret_wsgd_builder.h"
+#include "T_generic_protocol_data.h"
+
+
+/******************************************************************************
+ * dissector_try_heuristic
+ * return a gboolean !
+ *****************************************************************************/
+int     dissector_try_heuristic(T_generic_protocol_data  & protocol_data,
+                                tvbuff_t                 * next_tvb,
+                                packet_info              * pinfo,
+                                proto_tree               * tree,
+                          const int                        UNUSED(bit_length_of_subdissector_data))
+{
+    T_generic_protocol_subdissector_data  & subdissector_data = protocol_data.ws_data.subdissector_data;
+
+    /* do lookup with the heuristic subdissector table */
+    heur_dtbl_entry_t *hdtbl_entry = nullptr;
+    const int  dissector_result = dissector_try_heuristic(subdissector_data.heur_dissector_list, next_tvb, pinfo, tree, &hdtbl_entry, nullptr);
+
+    return  dissector_result;
+}
+
+/******************************************************************************
+ * dissector_try_string_return_size
+ * return  new dissector : size affectively dissected
+ * return  old dissector : tvb size
+ *****************************************************************************/
+int   dissector_try_string_return_size(dissector_table_t   sub_dissectors,
+                                 const gchar              *string,
+                                       tvbuff_t           *tvb,
+                                       packet_info        *pinfo,
+                                       proto_tree         *tree)
+{
+    int  dissector_result = 0;    // means nothing done (dissector not found)
+
+    dissector_handle_t  dissector_handle = dissector_get_string_handle(sub_dissectors, string);
+    if (dissector_handle != nullptr)
+    {
+        dissector_result = call_dissector(dissector_handle, tvb, pinfo, tree);
+    }
+
+    return  dissector_result;
+}
+
+/******************************************************************************
+ * dissector_try_uint_return_size
+ * return  new dissector : size affectively dissected
+ * return  old dissector : tvb size
+ *****************************************************************************/
+int     dissector_try_uint_return_size(dissector_table_t   sub_dissectors,
+                                 const guint32             uint_val,
+                                       tvbuff_t           *tvb,
+                                       packet_info        *pinfo,
+                                       proto_tree         *tree)
+{
+    int  dissector_result = 0;    // means nothing done (dissector not found)
+
+    dissector_handle_t  dissector_handle = dissector_get_uint_handle(sub_dissectors, uint_val);
+    if (dissector_handle != nullptr)
+    {
+        dissector_result = call_dissector(dissector_handle, tvb, pinfo, tree);
+    }
+
+    return  dissector_result;
+}
+
+/******************************************************************************
+ * dissector_try_value
+ * return  new dissector : size affectively dissected
+ * return  old dissector : tvb size
+ *****************************************************************************/
+int     dissector_try_value(T_generic_protocol_data  & protocol_data,
+                            tvbuff_t                 * next_tvb,
+                            packet_info              * pinfo,
+                            proto_tree               * tree,
+                      const int                        UNUSED(bit_length_of_subdissector_data),
+                      const C_value                  * P_value)
+{
+    int  dissector_result = 0;    // means nothing done (no value or dissector not found)
+
+    if (P_value != nullptr)
+    {
+        M_TRACE_DEBUG ("subdissector try *P_value_x=" << P_value->as_string());
+        T_generic_protocol_subdissector_data  & subdissector_data = protocol_data.ws_data.subdissector_data;
+        if (protocol_data.SUBPROTO_SUBFIELD_TYPE_WS == FT_STRING)
+        {
+            dissector_result = dissector_try_string_return_size(subdissector_data.dissector_table, P_value->get_str().c_str(), next_tvb, pinfo, tree);
+        }
+        else
+        {
+            dissector_result = dissector_try_uint_return_size(subdissector_data.dissector_table, P_value->get_int_size_t(), next_tvb, pinfo, tree);
+        }
+    }
+
+    return  dissector_result;
+}
+
+/******************************************************************************
+ * call_subdissector_or_data2
+ * return        new dissector : size affectively dissected
+ * return        old dissector : tvb size
+ * return  heuristic dissector : false/true
+ * So you must NOT rely on this return value
+ *****************************************************************************/
+
+int     call_subdissector_or_data2( T_generic_protocol_data  & protocol_data,
+                              const dissector_handle_t         dissector_to_call_handle,
+                                    tvbuff_t                 * tvb,
+                              const int                        bit_offset,
+                                    packet_info              * pinfo,
+                                    proto_tree               * tree,
+                              const int                        bit_length_of_subdissector_data,
+                              const C_value                  * P_value_1,
+                              const C_value                  * P_value_2,
+                              const C_value                  * P_value_3)
+{
+    M_TRACE_ENTER("call_subdissector_or_data", bit_length_of_subdissector_data);
+
+    T_generic_protocol_subdissector_data& subdissector_data = protocol_data.ws_data.subdissector_data;
+
+    if ((bit_offset % 8) != 0)
+    {
+        M_FATAL_COMMENT("raw/subproto/insproto only on an entire byte position");
+    }
+    if ((bit_length_of_subdissector_data % 8) != 0)
+    {
+        M_FATAL_COMMENT("raw/subproto/insproto only with an entire byte size");
+    }
+
+    const int    offset = bit_offset / 8;
+    const int    length_of_subdissector_data = bit_length_of_subdissector_data / 8;
+
+    tvbuff_t* next_tvb = tvb_new_subset_length_caplen(tvb, offset, length_of_subdissector_data, length_of_subdissector_data);
+
+    /* If the user has a "Follow UDP Stream" window loading, pass a pointer
+     * to the payload tvb through the tap system. */
+#if 0
+     // ICIOA
+    if (have_tap_listener(udp_follow_tap))
+        tap_queue_packet(udp_follow_tap, pinfo, next_tvb);
+#endif
+
+    /* determine if this packet is part of a conversation and call dissector */
+    /* for the conversation if available */
+#if 0
+    // ICIOA ne linke pas
+    if (try_conversation_dissector(&pinfo->dst, &pinfo->src, PT_UDP,        // ICIOA PT_UDP ?
+        uh_dport, uh_sport, next_tvb, pinfo, tree)) {
+        return;
+    }
+#endif
+
+    if (dissector_to_call_handle != nullptr)
+    {
+        return  call_dissector(dissector_to_call_handle, next_tvb, pinfo, tree);
+    }
+
+    if (subdissector_data.try_heuristic_first)
+    {
+        M_TRACE_DEBUG("subdissector try heuristic first");
+        const int  dissector_result = dissector_try_heuristic(protocol_data, next_tvb, pinfo, tree, bit_length_of_subdissector_data);
+        if (dissector_result != 0)
+            return  dissector_result;
+    }
+
+    {
+        const int  dissector_result = dissector_try_value(protocol_data, next_tvb, pinfo, tree, bit_length_of_subdissector_data, P_value_1);
+        if (dissector_result != 0)
+            return  dissector_result;
+    }
+    {
+        const int  dissector_result = dissector_try_value(protocol_data, next_tvb, pinfo, tree, bit_length_of_subdissector_data, P_value_2);
+        if (dissector_result != 0)
+            return  dissector_result;
+    }
+    {
+        const int  dissector_result = dissector_try_value(protocol_data, next_tvb, pinfo, tree, bit_length_of_subdissector_data, P_value_3);
+        if (dissector_result != 0)
+            return  dissector_result;
+    }
+
+    if (!subdissector_data.try_heuristic_first)
+    {
+        M_TRACE_DEBUG("subdissector try heuristic");
+        const int  dissector_result = dissector_try_heuristic(protocol_data, next_tvb, pinfo, tree, bit_length_of_subdissector_data);
+        if (dissector_result != 0)
+            return  dissector_result;
+    }
+
+    M_TRACE_DEBUG("subdissector not found ?");
+
+    return  call_dissector(T_generic_protocol_subdissector_data::data_handle, next_tvb, pinfo, tree);
+}
+
+/******************************************************************************
+ * call_subdissector_or_data
+ *****************************************************************************/
+
+void    call_subdissector_or_data(  T_generic_protocol_data  & protocol_data,
+                              const dissector_handle_t         dissector_to_call_handle,
+                                    tvbuff_t                 * tvb,
+                              const int                        bit_offset,
+                                    packet_info              * pinfo,
+                                    proto_tree               * tree,
+                              const int                        bit_length_of_subdissector_data,
+                              const C_value                  * P_value_1,
+                              const C_value                  * P_value_2,
+                              const C_value                  * P_value_3)
+{
+    // Do not rely on return value of call_subdissector_or_data2, see its comment
+
+    const int     desegment_offset_prev = pinfo->desegment_offset;
+    const guint32 desegment_len_prev    = pinfo->desegment_len;
+    const int     dissector_result = call_subdissector_or_data2(
+                                                protocol_data,
+                                                dissector_to_call_handle,
+                                                tvb,
+                                                bit_offset,
+                                                pinfo,
+                                                tree,
+                                                bit_length_of_subdissector_data,
+                                                P_value_1,
+                                                P_value_2,
+                                                P_value_3);
+    const int     desegment_offset = pinfo->desegment_offset;
+    const guint32 desegment_len    = pinfo->desegment_len;
+
+    M_TRACE_DEBUG("result=" << dissector_result <<
+                  "  offset=" << desegment_offset << " (was " << desegment_offset_prev << ")" <<
+                  "  len=" << desegment_len << " (was " << desegment_len_prev << ")"
+                 );
+
+    return;
+}
+
+//*****************************************************************************
+// C_byte_interpret_wsgd_builder
+//*****************************************************************************
+
+C_byte_interpret_wsgd_builder::C_byte_interpret_wsgd_builder(
+                                        int                   proto_idx,
+                                        tvbuff_t            * wsgd_tvb,
+                                        packet_info         * wsgd_pinfo,
+                                        proto_tree          * wsgd_tree,
+                                        proto_tree          * wsgd_msg_root_tree)
+    :C_byte_interpret_wsgd_builder_base(proto_idx, wsgd_tvb, wsgd_pinfo, wsgd_tree, wsgd_msg_root_tree)
+{
+}
+
+//*****************************************************************************
+// value
+//*****************************************************************************
+void
+C_byte_interpret_wsgd_builder::value(const T_type_definitions  & /* type_definitions */,
+                                     const T_frame_data        & in_out_frame_data,
+                                     const T_field_type_name   & field_type_name,
+                                     const string              & data_name,
+                                     const string              & data_simple_name,
+                                     const T_attribute_value   & attribute_value,
+                                     const string              & data_value,
+                                     const string              & final_type,
+                                     const int                   type_bit_size_param,
+                                     const bool                  is_little_endian,
+                                     const bool                  error)
+{
+    M_TRACE_ENTER("interpret_builder_value",
+                  "data_name=" << data_name <<
+				  "  data_simple_name=" << data_simple_name <<
+				  "  data_value=" << data_value <<
+				  "  final_type=" << final_type <<
+				  "  error=" << error
+				  );
+
+    if (A_interpret_wsgd.proto_idx < 0)
+        return;
+
+    // 2010/12/30 pb on type_bit_size_param for a variable :
+    // - could be zero
+    // - could be anything depending on the expression
+    //   ie "var type a_var = a_field;"
+    //   -> a_var will have the same type_bit_size_param as a_field
+    int   type_bit_size = type_bit_size_param;
+
+    if (field_type_name.wsgd_field_idx < 0)
+        return;
+
+    string    text = data_simple_name + ": " + data_value;    // new array management
+    {
+        const string& field_name = field_type_name.name;
+        const string& field_display_name = field_type_name.get_display_name();
+        if (field_name != field_display_name)
+        {
+            text.replace(0, field_name.size(), field_display_name);
+        }
+    }
+
+    const int       error_code = error ? PI_ERROR : 0;
+
+    M_TRACE_DEBUG("wsgd add item = " << text);
+
+    if (field_type_name.must_force_manage_as_biggest_float())
+    {
+        M_TRACE_DEBUG("PROMOTION wsgd add item double = " << text);
+        cpp_dissect_generic_add_item_double(
+            A_interpret_wsgd.proto_idx,
+            A_interpret_wsgd.wsgd_tvb,
+            A_interpret_wsgd.wsgd_pinfo,
+            A_interpret_wsgd.wsgd_tree,
+            field_type_name.wsgd_field_idx,
+            in_out_frame_data.get_bit_offset_into_initial_frame() - type_bit_size,
+            type_bit_size /* field_type_name.basic_type_bit_size */,
+            is_little_endian,    // ICIOA je suppose que wireshark applique ca seulement aux types adequats
+            text.c_str(),
+            error_code,
+            attribute_value.get_value().get_flt());
+    }
+    else if (field_type_name.must_force_manage_as_biggest_int())
+    {
+        if (type_bit_size < 0)
+        {
+            // This is a trick to know it is an enum !!!
+            // NB: wireshark forbids enum size > 4
+            // NB: wireshark forbids type_size < 0 for simple types
+
+            type_bit_size = 0;
+
+            if (final_type[0] != 'u')
+            {
+                M_TRACE_DEBUG("PROMOTION wsgd add item int32 = " << text);
+                cpp_dissect_generic_add_item_int32(
+                    A_interpret_wsgd.proto_idx,
+                    A_interpret_wsgd.wsgd_tvb,
+                    A_interpret_wsgd.wsgd_pinfo,
+                    A_interpret_wsgd.wsgd_tree,
+                    field_type_name.wsgd_field_idx,
+                    in_out_frame_data.get_bit_offset_into_initial_frame() - type_bit_size,
+                    type_bit_size /* field_type_name.basic_type_bit_size */,
+                    is_little_endian,    // ICIOA je suppose que wireshark applique ca seulement aux types adequats
+                    text.c_str(),
+                    error_code,
+                    attribute_value.get_value().get_int());
+            }
+            else
+            {
+                M_TRACE_DEBUG("PROMOTION wsgd add item uint32 = " << text);
+                cpp_dissect_generic_add_item_uint32(
+                    A_interpret_wsgd.proto_idx,
+                    A_interpret_wsgd.wsgd_tvb,
+                    A_interpret_wsgd.wsgd_pinfo,
+                    A_interpret_wsgd.wsgd_tree,
+                    field_type_name.wsgd_field_idx,
+                    in_out_frame_data.get_bit_offset_into_initial_frame() - type_bit_size,
+                    type_bit_size /* field_type_name.basic_type_bit_size */,
+                    is_little_endian,    // ICIOA je suppose que wireshark applique ca seulement aux types adequats
+                    text.c_str(),
+                    error_code,
+                    attribute_value.get_value().get_int());
+            }
+        }
+        else
+        {
+            M_TRACE_DEBUG("PROMOTION wsgd add item int64 = " << text);
+            cpp_dissect_generic_add_item_int64(
+                A_interpret_wsgd.proto_idx,
+                A_interpret_wsgd.wsgd_tvb,
+                A_interpret_wsgd.wsgd_pinfo,
+                A_interpret_wsgd.wsgd_tree,
+                field_type_name.wsgd_field_idx,
+                in_out_frame_data.get_bit_offset_into_initial_frame() - type_bit_size,
+                type_bit_size /* field_type_name.basic_type_bit_size */,
+                is_little_endian,    // ICIOA je suppose que wireshark applique ca seulement aux types adequats
+                text.c_str(),
+                error_code,
+                attribute_value.get_value().get_int());
+        }
+    }
+    else if (attribute_value.get_value().get_type() == C_value::E_type_integer)
+    {
+        // bsew : Necessary to give the value to wireshark
+        //         since byte offset and size will not permit to retrieve the value
+        if (final_type[0] != 'u')
+        {
+            if (type_bit_size <= 32)
+            {
+                M_TRACE_DEBUG("bsew PROMOTION wsgd add item int32 = " << text);
+                cpp_dissect_generic_add_item_int32(
+                    A_interpret_wsgd.proto_idx,
+                    A_interpret_wsgd.wsgd_tvb,
+                    A_interpret_wsgd.wsgd_pinfo,
+                    A_interpret_wsgd.wsgd_tree,
+                    field_type_name.wsgd_field_idx,
+                    in_out_frame_data.get_bit_offset_into_initial_frame() - type_bit_size,
+                    type_bit_size /* field_type_name.basic_type_bit_size */,
+                    is_little_endian,    // ICIOA je suppose que wireshark applique ca seulement aux types adequats
+                    text.c_str(),
+                    error_code,
+                    attribute_value.get_value().get_int());
+            }
+            else
+            {
+                M_TRACE_DEBUG("bsew PROMOTION wsgd add item int64 = " << text);
+                cpp_dissect_generic_add_item_int64(
+                    A_interpret_wsgd.proto_idx,
+                    A_interpret_wsgd.wsgd_tvb,
+                    A_interpret_wsgd.wsgd_pinfo,
+                    A_interpret_wsgd.wsgd_tree,
+                    field_type_name.wsgd_field_idx,
+                    in_out_frame_data.get_bit_offset_into_initial_frame() - type_bit_size,
+                    type_bit_size /* field_type_name.basic_type_bit_size */,
+                    is_little_endian,    // ICIOA je suppose que wireshark applique ca seulement aux types adequats
+                    text.c_str(),
+                    error_code,
+                    attribute_value.get_value().get_int());
+            }
+        }
+        else
+        {
+            if (type_bit_size <= 32)
+            {
+                M_TRACE_DEBUG("bsew PROMOTION wsgd add item uint32 = " << text);
+                cpp_dissect_generic_add_item_uint32(
+                    A_interpret_wsgd.proto_idx,
+                    A_interpret_wsgd.wsgd_tvb,
+                    A_interpret_wsgd.wsgd_pinfo,
+                    A_interpret_wsgd.wsgd_tree,
+                    field_type_name.wsgd_field_idx,
+                    in_out_frame_data.get_bit_offset_into_initial_frame() - type_bit_size,
+                    type_bit_size /* field_type_name.basic_type_bit_size */,
+                    is_little_endian,    // ICIOA je suppose que wireshark applique ca seulement aux types adequats
+                    text.c_str(),
+                    error_code,
+                    attribute_value.get_value().get_int());
+            }
+            else
+            {
+                M_TRACE_DEBUG("bsew PROMOTION wsgd add item uint64 = " << text);
+                cpp_dissect_generic_add_item_uint64(
+                    A_interpret_wsgd.proto_idx,
+                    A_interpret_wsgd.wsgd_tvb,
+                    A_interpret_wsgd.wsgd_pinfo,
+                    A_interpret_wsgd.wsgd_tree,
+                    field_type_name.wsgd_field_idx,
+                    in_out_frame_data.get_bit_offset_into_initial_frame() - type_bit_size,
+                    type_bit_size /* field_type_name.basic_type_bit_size */,
+                    is_little_endian,    // ICIOA je suppose que wireshark applique ca seulement aux types adequats
+                    text.c_str(),
+                    error_code,
+                    attribute_value.get_value().get_int());
+            }
+        }
+    }
+    else if (attribute_value.get_value().get_type() == C_value::E_type_float)
+    {
+        // bsew : Necessary to give the value to wireshark
+        //         since byte offset and size will not permit to retrieve the value
+        if (type_bit_size == 32)
+        {
+            cpp_dissect_generic_add_item_float(
+                A_interpret_wsgd.proto_idx,
+                A_interpret_wsgd.wsgd_tvb,
+                A_interpret_wsgd.wsgd_pinfo,
+                A_interpret_wsgd.wsgd_tree,
+                field_type_name.wsgd_field_idx,
+                in_out_frame_data.get_bit_offset_into_initial_frame() - type_bit_size,
+                type_bit_size /* field_type_name.basic_type_bit_size */,
+                is_little_endian,    // ICIOA je suppose que wireshark applique ca seulement aux types adequats
+                text.c_str(),
+                error_code,
+                static_cast<float>(attribute_value.get_value().get_flt()));
+        }
+        else
+        {
+            cpp_dissect_generic_add_item_double(
+                A_interpret_wsgd.proto_idx,
+                A_interpret_wsgd.wsgd_tvb,
+                A_interpret_wsgd.wsgd_pinfo,
+                A_interpret_wsgd.wsgd_tree,
+                field_type_name.wsgd_field_idx,
+                in_out_frame_data.get_bit_offset_into_initial_frame() - type_bit_size,
+                type_bit_size /* field_type_name.basic_type_bit_size */,
+                is_little_endian,    // ICIOA je suppose que wireshark applique ca seulement aux types adequats
+                text.c_str(),
+                error_code,
+                attribute_value.get_value().get_flt());
+        }
+    }
+    else if (attribute_value.get_value().get_type() == C_value::E_type_string)
+    {
+        // Ajout d'un item.
+        // La taille specifiee ici est connue ET necessaire pour les types simples
+        cpp_dissect_generic_add_item_string(
+            A_interpret_wsgd.proto_idx,
+            A_interpret_wsgd.wsgd_tvb,
+            A_interpret_wsgd.wsgd_pinfo,
+            A_interpret_wsgd.wsgd_tree,
+            field_type_name.wsgd_field_idx,
+            in_out_frame_data.get_bit_offset_into_initial_frame() - type_bit_size,
+            type_bit_size /* field_type_name.basic_type_bit_size */,
+            is_little_endian,    // ICIOA je suppose que wireshark applique ca seulement aux types adequats
+            text.c_str(),
+            error_code,
+            attribute_value.get_value().get_str().c_str());
+    }
+    else // used ???
+    {
+        // Ajout d'un item.
+        // La taille specifiee ici est connue ET necessaire pour les types simples
+        cpp_dissect_generic_add_item(
+            A_interpret_wsgd.proto_idx,
+            A_interpret_wsgd.wsgd_tvb,
+            A_interpret_wsgd.wsgd_pinfo,
+            A_interpret_wsgd.wsgd_tree,
+            field_type_name.wsgd_field_idx,
+            in_out_frame_data.get_bit_offset_into_initial_frame() - type_bit_size,
+            type_bit_size /* field_type_name.basic_type_bit_size */,
+            is_little_endian,    // ICIOA je suppose que wireshark applique ca seulement aux types adequats
+            text.c_str(),
+            error_code);
+    }
+}
+
+//*****************************************************************************
+// C_packet_info_save_restore
+// Class to protect packet_info from modifications
+// Dedicated to insproto
+// 
+// When we have ip/tcp/my_proto containing payload with ip/tcp/...
+//  we call_dissector(ip/tcp/...) which modify some packet_info data (e.g port, ip ...)
+// --> these modifications modify wireshark behavior on desegmentation (and ... ?)
+// Looks like https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=2345
+// Perhaps only src and dst fields are a problem
+//
+// I imagine that subproto have the same problem,
+//  but I imagine that subproto should not be used for this kind of scheme
+//*****************************************************************************
+
+class C_packet_info_save_restore
+{
+public:
+    C_packet_info_save_restore(packet_info& to_save_restore, bool must_save);
+    ~C_packet_info_save_restore();
+
+    void save();
+    void restore();
+
+private:
+    static
+    void partial_copy(packet_info& to, const packet_info& from);
+
+    packet_info&  A_to_save_restore;
+    bool          A_saved;
+    packet_info   A_save_packet_info;
+};
+
+C_packet_info_save_restore::C_packet_info_save_restore(packet_info& to_save_restore, bool must_save)
+    : A_to_save_restore(to_save_restore)
+    , A_saved(false)
+    , A_save_packet_info()
+{
+    if (must_save == true)
+        save();
+}
+
+C_packet_info_save_restore::~C_packet_info_save_restore()
+{
+    if (A_saved == true)
+        restore();
+}
+
+void
+C_packet_info_save_restore::partial_copy(packet_info& to, const packet_info& from)
+{
+#define M_PINFO_COPY(NAME)    to.NAME = from.NAME
+#define M_PINFO_COPY_ADDRESS(NAME)    copy_address_shallow(&to.NAME, &from.NAME)
+
+    M_PINFO_COPY(num);
+    M_PINFO_COPY(abs_ts);
+    M_PINFO_COPY(vlan_id);
+
+    M_PINFO_COPY(current_proto);
+    //M_PINFO_COPY(cinfo);
+    M_PINFO_COPY(rel_ts);
+    //M_PINFO_COPY(fd);
+    //M_PINFO_COPY(pseudo_header);
+    //M_PINFO_COPY(phdr);
+    //M_PINFO_COPY(data_src);
+    M_PINFO_COPY_ADDRESS(dl_src);
+    M_PINFO_COPY_ADDRESS(dl_dst);
+    M_PINFO_COPY_ADDRESS(net_src);
+    M_PINFO_COPY_ADDRESS(net_dst);
+    M_PINFO_COPY_ADDRESS(src);
+    M_PINFO_COPY_ADDRESS(dst);
+    M_PINFO_COPY(noreassembly_reason);
+    M_PINFO_COPY(fragmented);
+    M_PINFO_COPY(flags);
+    M_PINFO_COPY(fragmented);
+    M_PINFO_COPY(ptype);
+    M_PINFO_COPY(srcport);
+    M_PINFO_COPY(destport);
+    M_PINFO_COPY(match_uint);
+    M_PINFO_COPY(match_string);
+    M_PINFO_COPY(can_desegment);
+    M_PINFO_COPY(saved_can_desegment);
+    M_PINFO_COPY(desegment_offset);
+    M_PINFO_COPY(desegment_len);
+    M_PINFO_COPY(want_pdu_tracking);
+    M_PINFO_COPY(bytes_until_next_pdu);
+    M_PINFO_COPY(p2p_dir);
+    //M_PINFO_COPY(private_table);
+    //M_PINFO_COPY(layers);
+    M_PINFO_COPY(curr_layer_num);
+    M_PINFO_COPY(link_number);
+    M_PINFO_COPY(clnp_srcref);
+    M_PINFO_COPY(clnp_dstref);
+    M_PINFO_COPY(link_dir);
+    //M_PINFO_COPY(proto_data);
+    //M_PINFO_COPY(dependent_frames);
+    //M_PINFO_COPY(frame_end_routines);
+    //M_PINFO_COPY(epan);
+    //M_PINFO_COPY(heur_list_name);
+}
+
+void
+C_packet_info_save_restore::save()
+{
+    A_saved = true;
+
+    partial_copy(A_save_packet_info, A_to_save_restore);
+}
+
+void
+C_packet_info_save_restore::restore()
+{
+    if (A_saved != true)
+        return;
+    A_saved = false;
+
+    partial_copy(A_to_save_restore, A_save_packet_info);
+}
+
+//*****************************************************************************
+// C_columns_save_restore
+// Class to protect columns from modifications
+// Dedicated to insproto
+//*****************************************************************************
+
+class C_columns_save_restore
+{
+public:
+    C_columns_save_restore(packet_info& to_save_restore, bool must_save);
+    ~C_columns_save_restore();
+
+    void save();
+    void restore();
+
+private:
+    packet_info&  A_packet_info;
+    bool          A_saved;
+    gboolean      A_save_col_writable;
+};
+
+C_columns_save_restore::C_columns_save_restore(packet_info& to_save_restore, bool must_save)
+    : A_packet_info(to_save_restore)
+    , A_saved(false)
+    , A_save_col_writable(false)
+{
+    if (must_save == true)
+        save();
+}
+
+C_columns_save_restore::~C_columns_save_restore()
+{
+    restore();
+}
+
+void
+C_columns_save_restore::save()
+{
+    A_saved = true;
+
+    // col_set_fence forbid to clear, but still can add (a set becomes automatically a add)
+    //col_set_fence(A_packet_info.cinfo, COL_PROTOCOL);
+    //col_set_fence(A_packet_info.cinfo, COL_INFO);
+
+    A_save_col_writable = col_get_writable(A_packet_info.cinfo, -1);
+    // Seems to NOT work for destination and source
+    // Normally, I need only COL_PROTOCOL & COL_INFO
+    col_set_writable(A_packet_info.cinfo, -1/*all*/, false);
+}
+
+void
+C_columns_save_restore::restore()
+{
+    if (A_saved != true)
+        return;
+    A_saved = false;
+
+    //col_clear_fence(A_packet_info.cinfo, COL_PROTOCOL);
+    //col_clear_fence(A_packet_info.cinfo, COL_INFO);
+
+    col_set_writable(A_packet_info.cinfo, -1/*all*/, A_save_col_writable);
+}
+
+//*****************************************************************************
+// raw_data
+//*****************************************************************************
+#include "T_interpret_data.h"
+
+void
+C_byte_interpret_wsgd_builder::raw_data(const T_type_definitions  & /* type_definitions */,
+                                        const T_frame_data        & in_out_frame_data,
+                                        const T_interpret_data    & interpret_data,
+                                        const T_field_type_name   & field_type_name,
+                                        const string              & data_name,
+                                        const string              & data_simple_name,
+                                        const int                   type_bit_size,
+                                        const E_raw_data_type       raw_data_type,
+                                        const bool                  is_decoded_data)
+{
+    M_TRACE_ENTER("interpret_builder_raw_data",
+                  "data_name=" << data_name <<
+                  "  data_simple_name=" << data_simple_name
+                 );
+
+    if (A_interpret_wsgd.proto_idx < 0)
+        return;
+
+
+    tvbuff_t* p_tvbuff = A_interpret_wsgd.wsgd_tvb;
+    int       bit_offset_in_tvbuff = in_out_frame_data.get_bit_offset_into_initial_frame() - type_bit_size;
+    if (is_decoded_data)
+    {
+        // Compute tvb with the decoded data
+        const int type_byte_size = type_bit_size / 8;
+        p_tvbuff = tvb_new_real_data(
+            in_out_frame_data.get_P_bytes() - type_byte_size,  // data, 
+            type_byte_size,                                    // length,
+            type_byte_size);                                   // reported_length)
+        bit_offset_in_tvbuff = 0;
+    }
+
+
+    if (field_type_name.wsgd_field_idx < 0)
+    {
+        // subproto & insproto are NOT registered fields
+        const bool    is_subproto = (raw_data_type == E_raw_data_sub_proto);
+        const bool    is_insproto = (raw_data_type == E_raw_data_ins_proto);
+        if (is_subproto || is_insproto)
+        {
+            T_generic_protocol_data& protocol_data = get_protocol_data(A_interpret_wsgd.proto_idx);
+
+            const C_value* P_value_1 = interpret_data.get_P_value_of_read_variable(protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_1);
+            const C_value* P_value_2 = interpret_data.get_P_value_of_read_variable(protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_2);
+            const C_value* P_value_3 = interpret_data.get_P_value_of_read_variable(protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_3);
+
+            //			proto_tree   * root_tree_saved = A_interpret_wsgd.wsgd_msg_root_tree;
+            proto_tree* tree = A_interpret_wsgd.wsgd_tree;
+            if (is_subproto)
+            {
+                // Change tree to set the root one.
+                tree = A_interpret_wsgd.wsgd_msg_root_tree;
+            }
+
+
+            // Compute the handle of the dissector to call
+            dissector_handle_t  dissector_to_call_handle = nullptr;
+            if (field_type_name.str_dissector != "")
+            {
+                dissector_to_call_handle = find_dissector(field_type_name.str_dissector.c_str());
+            }
+
+            C_columns_save_restore      columns_save_restore(*A_interpret_wsgd.wsgd_pinfo, is_insproto);
+            C_packet_info_save_restore  packet_info_save_restore(*A_interpret_wsgd.wsgd_pinfo, is_insproto);
+
+
+            call_subdissector_or_data(
+                protocol_data,
+                dissector_to_call_handle,
+                p_tvbuff,
+                bit_offset_in_tvbuff,
+                A_interpret_wsgd.wsgd_pinfo,
+                tree,
+                type_bit_size,
+                P_value_1,
+                P_value_2,
+                P_value_3);
+
+            columns_save_restore.restore();
+            packet_info_save_restore.restore();
+
+            //			A_interpret_wsgd.wsgd_msg_root_tree = root_tree_saved;
+        }
+    }
+    else
+    {
+        //	const string    text = data_simple_name;    // new array management
+
+        M_TRACE_DEBUG("wsgd add item raw data");
+
+        {
+            // Ajout d'un item.
+            // La taille specifiee ici est connue ET necessaire pour les types simples
+            cpp_dissect_generic_add_item(
+                A_interpret_wsgd.proto_idx,
+                p_tvbuff,
+                A_interpret_wsgd.wsgd_pinfo,
+                A_interpret_wsgd.wsgd_tree,
+                field_type_name.wsgd_field_idx,
+                bit_offset_in_tvbuff,
+                type_bit_size /* field_type_name.basic_type_bit_size */,
+                false,    // ICIOA je suppose que wireshark applique ca seulement aux types adequats
+                nullptr,  // l'affichage du texte est fait par Wireshark
+                0);       // no error_code
+        }
+    }
+
+    if (is_decoded_data)
+    {
+        tvb_free(p_tvbuff);
+    }
+}
+
+//*****************************************************************************
+// group_begin
+//*****************************************************************************
+void
+C_byte_interpret_wsgd_builder::group_begin(const T_type_definitions  & /* type_definitions */,
+                                           const T_frame_data        & in_out_frame_data,
+                                           const T_field_type_name   & field_type_name,
+                                           const string              & data_name,
+                                           const string              & data_simple_name)
+{
+    M_TRACE_ENTER("interpret_builder_group_begin",
+                  "data_name=" << data_name << "  "
+                  "data_simple_name=" << data_simple_name);
+
+    A_wsgd_group_data.push_back(T_wsgd_group_data(A_interpret_wsgd.wsgd_tree));
+
+    if (A_interpret_wsgd.proto_idx < 0)
+        return;
+
+    if (field_type_name.wsgd_field_idx < 0)
+        return;
+
+    if ((field_type_name.basic_type_bit_size >= 0) ||
+        (field_type_name.name == "") ||
+        (field_type_name.type == "raw") ||
+        (field_type_name.type == "subproto") ||
+        (field_type_name.type == "insproto") ||
+        (field_type_name.type == "string") ||
+        (field_type_name.type == "string_nl"))
+        return;
+
+    M_TRACE_DEBUG("wsgd       add item & tree");
+
+    T_wsgd_group_data& group_data = A_wsgd_group_data.back();
+
+    string    text = data_simple_name;    // new array management
+    {
+        const string& field_name = field_type_name.name;
+        const string& field_display_name = field_type_name.get_display_name();
+        if (field_name != field_display_name)
+        {
+            text.replace(0, field_name.size(), field_display_name);
+        }
+    }
+
+    // Ajout d'un item.
+    // La taille est re-specifiee apres.
+    // La taille specifiee ici est :
+    // - inconnue pour les struct
+    // - connue ET necessaire pour les types simples
+    group_data.item = cpp_dissect_generic_add_item( A_interpret_wsgd.proto_idx,
+                                                    A_interpret_wsgd.wsgd_tvb,
+                                                    A_interpret_wsgd.wsgd_pinfo,
+                                                    A_interpret_wsgd.wsgd_tree,
+                                                    field_type_name.wsgd_field_idx,
+                                                    in_out_frame_data.get_bit_offset_into_initial_frame(),
+                                                    field_type_name.basic_type_bit_size,   // ICIOA -1 ou 0
+                                                    false,                             // little_endian
+                                                    text.c_str(),          // new array management
+                                                    0);                                // no error_code
+
+    A_interpret_wsgd.wsgd_tree = cpp_dissect_generic_add_tree(A_interpret_wsgd.proto_idx, group_data.item);
+}
+
+//*****************************************************************************
+// group_append_text
+//*****************************************************************************
+void
+C_byte_interpret_wsgd_builder::group_append_text(const T_type_definitions  & /* type_definitions */,
+                                                 const T_frame_data        & /* in_out_frame_data */,
+//                                                 const T_field_type_name   & field_type_name,
+                                                 const string              & data_name,
+                                                 const string              & data_simple_name,
+                                                 const string              & text)
+{
+    M_TRACE_ENTER("interpret_builder_group_append_text",
+                  "data_name=" << data_name <<
+                  "  data_simple_name=" << data_simple_name <<
+                  "  text=" << text);
+
+    T_wsgd_group_data    group_data = A_wsgd_group_data.back();
+
+    if (group_data.item != nullptr)
+    {
+        proto_item_append_text(group_data.item, "%s", text.c_str());
+    }
+}
+
+//*****************************************************************************
+// group_end
+//*****************************************************************************
+void
+C_byte_interpret_wsgd_builder::group_end(const T_type_definitions  & /* type_definitions */,
+                                         const T_frame_data        & /* in_out_frame_data */,
+                                         const T_field_type_name   & /* field_type_name */,
+                                         const string              & data_name,
+                                         const string              & data_simple_name,
+                                         const int                   type_bit_size)
+{
+    M_TRACE_ENTER("interpret_builder_group_end",
+                  "data_name=" << data_name <<
+                  "  data_simple_name=" << data_simple_name <<
+                  "  type_bit_size=" << type_bit_size);
+
+    T_wsgd_group_data    group_data = A_wsgd_group_data.back();
+
+    A_wsgd_group_data.pop_back();
+
+
+    if (group_data.item != nullptr)
+    {
+        if ((type_bit_size % 8) != 0)
+        {
+            M_FATAL_COMMENT("struct/... only with an entire byte size");
+        }
+        const int    type_size = type_bit_size / 8;
+        proto_item_set_len(group_data.item, type_size);
+    }
+
+    A_interpret_wsgd.wsgd_tree = group_data.tree;
+}
+
+//*****************************************************************************
+// error
+//*****************************************************************************
+void
+C_byte_interpret_wsgd_builder::error(const T_type_definitions  & /* type_definitions */,
+                                     const T_frame_data        & in_out_frame_data,
+                                     const T_field_type_name   & /* field_type_name */,
+                                     const string              & /* data_name */,
+                                     const string              & /* data_simple_name */,
+                                     const string              & error)
+{
+    if (A_interpret_wsgd.proto_idx < 0)
+        return;
+
+    string    text = "ERROR: " + error;
+    cpp_dissect_generic_add_item(
+        A_interpret_wsgd.proto_idx,
+        A_interpret_wsgd.wsgd_tvb,
+        A_interpret_wsgd.wsgd_pinfo,
+        A_interpret_wsgd.wsgd_tree,
+        K_ERROR_WSGD_FIELD_IDX,
+        in_out_frame_data.get_bit_offset_into_initial_frame(),
+        0,                                // size (-1 does not work at the end of tvb)
+        false,                            // little_endian, do not care
+        text.c_str(),
+        PI_ERROR);
+}
+
+//*****************************************************************************
+// cmd_error
+//*****************************************************************************
+void
+C_byte_interpret_wsgd_builder::cmd_error(const T_type_definitions  & /* type_definitions */,
+                                         const T_frame_data        & in_out_frame_data,
+                                         const T_field_type_name   & field_type_name,
+                                         const string              & /* data_name */,
+                                         const string              & text_to_print)
+{
+    if (A_interpret_wsgd.proto_idx < 0)
+        return;
+
+    int   error_code = 0;
+    int   field_idx = K_ANY_WSGD_FIELD_IDX;
+    if (field_type_name.type == "chat")
+    {
+        error_code = PI_CHAT;
+    }
+    else if (field_type_name.type == "note")
+    {
+        error_code = PI_NOTE;
+    }
+    else if (field_type_name.type == "warning")
+    {
+        error_code = PI_WARN;
+    }
+    else /* error, fatal and anything else */
+    {
+        error_code = PI_ERROR;
+        field_idx = K_ERROR_WSGD_FIELD_IDX;
+    }
+
+    string    text = field_type_name.type + ": " + text_to_print;
+    cpp_dissect_generic_add_item(
+        A_interpret_wsgd.proto_idx,
+        A_interpret_wsgd.wsgd_tvb,
+        A_interpret_wsgd.wsgd_pinfo,
+        A_interpret_wsgd.wsgd_tree,
+        field_idx,
+        in_out_frame_data.get_bit_offset_into_initial_frame(),
+        0,                                // size (-1 does not work at the end of tvb)
+        false,                            // little_endian, do not care
+        text.c_str(),
+        error_code);
+}
+
+//*****************************************************************************
+// cmd_print
+//*****************************************************************************
+void
+C_byte_interpret_wsgd_builder::cmd_print(const T_type_definitions  & /* type_definitions */,
+                                         const T_frame_data        & in_out_frame_data,
+                                         const T_field_type_name   & field_type_name,
+                                         const string              & /* data_name */,
+                                         const string              & text_to_print)
+{
+    if (A_interpret_wsgd.proto_idx < 0)
+        return;
+
+    string    text;
+    if (field_type_name.type != "print")
+    {
+        text += field_type_name.type + ": ";
+    }
+    text += text_to_print;
+
+    cpp_dissect_generic_add_item(
+        A_interpret_wsgd.proto_idx,
+        A_interpret_wsgd.wsgd_tvb,
+        A_interpret_wsgd.wsgd_pinfo,
+        A_interpret_wsgd.wsgd_tree,
+        K_ANY_WSGD_FIELD_IDX,
+        in_out_frame_data.get_bit_offset_into_initial_frame(),
+        0,                                // size (-1 does not work at the end of tvb)
+        false,                            // little_endian, do not care
+        text.c_str(),
+        0);                               // no error_code
+}
diff --git a/plugins/epan/generic/C_byte_interpret_wsgd_builder.h b/plugins/epan/generic/C_byte_interpret_wsgd_builder.h
new file mode 100644
index 00000000000..6806e557125
--- /dev/null
+++ b/plugins/epan/generic/C_byte_interpret_wsgd_builder.h
@@ -0,0 +1,174 @@
+/*
+ * Copyright 2008-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef C_BYTE_INTERPRET_WSGD_BUILDER_H
+#define C_BYTE_INTERPRET_WSGD_BUILDER_H
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <string>
+#include <vector>
+using namespace std;
+
+#include "C_byte_interpret_wsgd_builder_base.h"
+
+
+//*****************************************************************************
+// C_byte_interpret_wsgd_builder
+//*****************************************************************************
+
+class C_byte_interpret_wsgd_builder : public C_byte_interpret_wsgd_builder_base
+{
+public:
+
+    C_byte_interpret_wsgd_builder(int                   proto_idx,
+                                  tvbuff_t            * wsgd_tvb,
+                                  packet_info         * wsgd_pinfo,
+                                  proto_tree          * wsgd_tree,
+                                  proto_tree          * wsgd_msg_root_tree);
+
+    //*****************************************************************************
+    // NB: in_out_frame_data is AFTER the value
+    //*****************************************************************************
+
+    void    value(const T_type_definitions  & type_definitions,
+                  const T_frame_data        & in_out_frame_data,
+                  const T_field_type_name   & field_type_name,
+                  const string              & data_name,
+                  const string              & data_simple_name,
+                  const T_attribute_value   & attribute_value,
+                  const string              & data_value,
+                  const string              & final_type,
+                  const int                   type_bit_size,
+                  const bool                  is_little_endian,
+                  const bool                  error);
+
+    //*****************************************************************************
+    // NB: in_out_frame_data is AFTER the value
+    //*****************************************************************************
+
+    void    raw_data(const T_type_definitions  & type_definitions,
+                     const T_frame_data        & in_out_frame_data,
+                     const T_interpret_data    & interpret_data,
+                     const T_field_type_name   & field_type_name,
+                     const string              & data_name,
+                     const string              & data_simple_name,
+                     const int                   type_bit_size,
+                     const E_raw_data_type       raw_data_type,
+                     const bool                  is_decoded_data);
+
+    //*****************************************************************************
+    // NB: group_end will be called
+    //*****************************************************************************
+
+    void    group_begin(const T_type_definitions  & type_definitions,
+                        const T_frame_data        & in_out_frame_data,
+                        const T_field_type_name   & field_type_name,
+                        const string              & data_name,
+                        const string              & data_simple_name);
+
+    //*****************************************************************************
+    // NB: group_begin has been called
+    //*****************************************************************************
+
+    void    group_append_text(const T_type_definitions  & type_definitions,
+                              const T_frame_data        & in_out_frame_data,
+//                              const T_field_type_name   & field_type_name,
+                              const string              & data_name,
+                              const string              & data_simple_name,
+                              const string              & text);
+
+    //*****************************************************************************
+    // NB: group_begin has been called
+    //*****************************************************************************
+
+    void    group_end(const T_type_definitions  & type_definitions,
+                      const T_frame_data        & in_out_frame_data,
+                      const T_field_type_name   & field_type_name,
+                      const string              & data_name,
+                      const string              & data_simple_name,
+                      const int                   type_bit_size);
+
+    //*****************************************************************************
+    // 
+    //*****************************************************************************
+
+    void    error(const T_type_definitions  & type_definitions,
+                  const T_frame_data        & in_out_frame_data,
+                  const T_field_type_name   & field_type_name,
+                  const string              & data_name,
+                  const string              & data_simple_name,
+                  const string              & error);
+
+    //*****************************************************************************
+    // 
+    //*****************************************************************************
+#if 0
+    void    fatal(const T_type_definitions  & type_definitions,
+                  const T_frame_data        & in_out_frame_data,
+                  const T_field_type_name   & field_type_name,
+                  const string              & data_name,
+                  const string              & data_simple_name,
+                  const string              & error);
+#endif
+
+    //*****************************************************************************
+    // 
+    //*****************************************************************************
+
+    void    cmd_error(const T_type_definitions  & type_definitions,
+                      const T_frame_data        & in_out_frame_data,
+                      const T_field_type_name   & field_type_name,
+                      const string              & data_name,
+                      const string              & text_to_print);
+
+    //*****************************************************************************
+    // 
+    //*****************************************************************************
+
+    //*****************************************************************************
+    // 
+    //*****************************************************************************
+
+    void    cmd_print(const T_type_definitions  & type_definitions,
+                      const T_frame_data        & in_out_frame_data,
+                      const T_field_type_name   & field_type_name,
+                      const string              & data_name,
+                      const string              & text_to_print);
+
+
+private:
+
+    struct T_wsgd_group_data
+    {
+        proto_tree        * tree;
+        proto_item        * item;
+
+        T_wsgd_group_data (proto_tree  * proto_tree_param)
+            :tree (proto_tree_param),
+             item (nullptr)
+        { }
+    };
+
+    vector<T_wsgd_group_data>    A_wsgd_group_data;
+};
+
+
+#endif /* C_BYTE_INTERPRET_WSGD_BUILDER_H */
diff --git a/plugins/epan/generic/C_byte_interpret_wsgd_builder_base.cpp b/plugins/epan/generic/C_byte_interpret_wsgd_builder_base.cpp
new file mode 100644
index 00000000000..38750d6bd89
--- /dev/null
+++ b/plugins/epan/generic/C_byte_interpret_wsgd_builder_base.cpp
@@ -0,0 +1,633 @@
+/*
+ * Copyright 2008-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "C_byte_interpret_wsgd_builder_base.h"
+#include "T_generic_protocol_data.h"
+#include "T_interpret_data.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <epan/expert.h>
+#include <epan/tvbuff.h>
+#include <wsutil/filesystem.h>
+#include <epan/conversation.h>
+#include <epan/tap.h>
+#include <epan/prefs.h>
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+/******************************************************************************
+ * 
+ *****************************************************************************/
+
+// ICIOA bsew
+#define M_COMPUTE_BYTE_FROM_BIT_OFFSET_SIZE(bit_offset,field_bit_size)       \
+    int    offset = bit_offset / 8;                                          \
+    int    field_byte_size = 0;                                              \
+    if ((bit_offset >= 0) && (field_bit_size > 0))                           \
+    {                                                                        \
+        int    bit_offset_end = bit_offset + field_bit_size;                 \
+        int    offset_end = bit_offset_end / 8;                              \
+        int    offset_end_modulo = bit_offset_end % 8;                       \
+        if (offset_end_modulo != 0)                                          \
+        {                                                                    \
+            ++offset_end;                                                    \
+        }                                                                    \
+        field_byte_size = offset_end - offset;                               \
+    }
+
+#define wsgd_expert_add_info_format(pinfo,proto_item_1,PI_MALFORMED,error_code,format,text)                        \
+{                                                                                                                  \
+    expert_field  * p_expert_field = &P_protocol_ws_data->expert_data.ei_malformed_error;                          \
+    if (false) ;                                                                                                   \
+    else if (error_code == PI_COMMENT)  p_expert_field = &P_protocol_ws_data->expert_data.ei_malformed_comment;    \
+    else if (error_code == PI_CHAT)     p_expert_field = &P_protocol_ws_data->expert_data.ei_malformed_chat;       \
+    else if (error_code == PI_NOTE)     p_expert_field = &P_protocol_ws_data->expert_data.ei_malformed_note;       \
+    else if (error_code == PI_WARN)     p_expert_field = &P_protocol_ws_data->expert_data.ei_malformed_warn;       \
+    else if (error_code == PI_ERROR)    p_expert_field = &P_protocol_ws_data->expert_data.ei_malformed_error;      \
+    expert_add_info_format(pinfo, proto_item_1, p_expert_field, format, text);                                     \
+}
+
+/******************************************************************************
+ * cpp_dissect_generic_add_item
+ *****************************************************************************/
+
+proto_item  * cpp_dissect_generic_add_item(const int     proto_idx,
+											        tvbuff_t     * tvb,
+												    packet_info  * pinfo,
+										          proto_tree  * tree,
+										 const int     field_idx,
+										 const int     bit_offset,
+										 const int     field_bit_size,
+										 const int     little_endian,
+										 const char  * text,
+										 const int     error_code)
+{
+    T_generic_protocol_data     & protocol_data = get_protocol_data(proto_idx);
+    T_generic_protocol_ws_data  * P_protocol_ws_data = &protocol_data.ws_data;
+    proto_item                  * proto_item_1 = nullptr;
+
+    M_COMPUTE_BYTE_FROM_BIT_OFFSET_SIZE(bit_offset, field_bit_size);
+
+    M_TRACE_ENTER("cpp_dissect_generic_add_item",
+                  "proto_idx=" << proto_idx <<
+                  "  field_idx=" << field_idx <<
+                  "  field_bit_size=" << field_bit_size);
+
+    proto_item_1 = proto_tree_add_item(tree,
+                                       P_protocol_ws_data->fields_data.hf_id[field_idx],
+                                       tvb,
+                                       offset,
+                                       field_byte_size,
+                                       little_endian);
+#if 0
+    // This version could not be used :
+    // - does not accept field_bit_size = 0 or -1
+    // - works only for unsigned integers, bool and enums
+    // - works only with size <= 64 bits
+    // Fails on : raw, intX, floatX, string
+    // Works on : boolX, uintX
+    proto_item_1 = proto_tree_add_bits_item(tree,
+                                            P_protocol_ws_data->fields_data.hf_id[field_idx],
+                                            tvb,
+                                            bit_offset,
+                                            field_bit_size,
+                                            little_endian);
+#endif
+
+    if (text != nullptr)
+    {
+        proto_item_set_text(proto_item_1, "%s", text);
+    }
+    //  proto_item_set_expert_flags(proto_item_1, PI_CHECKSUM, PI_ERROR);   // result = nothing ???
+
+    if (error_code > 0)
+    {
+        wsgd_expert_add_info_format(pinfo, proto_item_1, PI_MALFORMED, error_code, "%s", text);
+
+        // Add a hidden error_in_packet field (if not already on a error_in_packet field).
+        // Permits filter on error_in_packet.
+        // ICIOA : je pourrais optimiser pour ajouter qu'un seul champ ERROR
+        //  mais bon il n'est pas sense avoir d'erreur !
+        // NB: since 12X (?), it is possible to filter on expert info
+        if ((error_code >= PI_ERROR) && (field_idx != K_ERROR_WSGD_FIELD_IDX))
+        {
+            proto_item* proto_item_error = proto_tree_add_item(
+                tree,
+                P_protocol_ws_data->fields_data.hf_id[K_ERROR_WSGD_FIELD_IDX],
+                tvb,
+                offset,
+                field_byte_size,
+                little_endian);
+            PROTO_ITEM_SET_HIDDEN(proto_item_error);
+        }
+    }
+
+    return  proto_item_1;
+}
+
+
+
+proto_item  * cpp_dissect_generic_add_item_string(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               bit_offset,
+                                        const int               field_bit_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error_code,
+                                        const char            * value)
+{
+    T_generic_protocol_data     & protocol_data = get_protocol_data(proto_idx);
+    T_generic_protocol_ws_data  * P_protocol_ws_data = &protocol_data.ws_data;
+    proto_item                  * proto_item_1 = nullptr;
+
+    M_COMPUTE_BYTE_FROM_BIT_OFFSET_SIZE(bit_offset, field_bit_size);
+
+    M_TRACE_ENTER("cpp_dissect_generic_add_item_string",
+                  "proto_idx=" << proto_idx <<
+                  "  field_idx=" << field_idx <<
+                  "  field_bit_size=" << field_bit_size <<
+                  "  value=" << value);
+
+    proto_item_1 = proto_tree_add_string_format(
+        tree,
+        P_protocol_ws_data->fields_data.hf_id[field_idx],
+        tvb,
+        offset,
+        field_byte_size,
+        value,
+        "%s", text);
+    if (error_code > 0)
+    {
+        wsgd_expert_add_info_format(pinfo, proto_item_1, PI_MALFORMED, error_code, "%s", text);
+        // Add a hidden error_in_packet field (if not already on a error_in_packet field).
+        // Permits filter on error_in_packet.
+        if ((error_code >= PI_ERROR) && (field_idx != K_ERROR_WSGD_FIELD_IDX))
+        {
+            proto_item* proto_item_error = proto_tree_add_item(
+                tree,
+                P_protocol_ws_data->fields_data.hf_id[K_ERROR_WSGD_FIELD_IDX],
+                tvb,
+                offset,
+                field_byte_size,
+                little_endian);
+            PROTO_ITEM_SET_HIDDEN(proto_item_error);
+        }
+    }
+
+    return  proto_item_1;
+}
+
+proto_item  * cpp_dissect_generic_add_item_uint32(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               bit_offset,
+                                        const int               field_bit_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error_code,
+                                        const long long         value)
+{
+    T_generic_protocol_data     & protocol_data = get_protocol_data(proto_idx);
+    T_generic_protocol_ws_data  * P_protocol_ws_data = &protocol_data.ws_data;
+    proto_item                  * proto_item_1 = nullptr;
+
+    M_COMPUTE_BYTE_FROM_BIT_OFFSET_SIZE(bit_offset, field_bit_size);
+
+    M_TRACE_ENTER("cpp_dissect_generic_add_item_uint32",
+                  "proto_idx=" << proto_idx <<
+                  "  field_idx=" << field_idx <<
+                  "  field_bit_size=" << field_bit_size <<
+                  "  value=" << value);
+
+    proto_item_1 = proto_tree_add_uint_format(
+        tree,
+        P_protocol_ws_data->fields_data.hf_id[field_idx],
+        tvb,
+        offset,
+        field_byte_size,
+        static_cast<guint32>(value),
+        "%s", text);
+    if (error_code > 0)
+    {
+        wsgd_expert_add_info_format(pinfo, proto_item_1, PI_MALFORMED, error_code, "%s", text);
+        // Add a hidden error_in_packet field (if not already on a error_in_packet field).
+        // Permits filter on error_in_packet.
+        if ((error_code >= PI_ERROR) && (field_idx != K_ERROR_WSGD_FIELD_IDX))
+        {
+            proto_item* proto_item_error = proto_tree_add_item(
+                tree,
+                P_protocol_ws_data->fields_data.hf_id[K_ERROR_WSGD_FIELD_IDX],
+                tvb,
+                offset,
+                field_byte_size,
+                little_endian);
+            PROTO_ITEM_SET_HIDDEN(proto_item_error);
+        }
+    }
+
+    return  proto_item_1;
+}
+
+proto_item  * cpp_dissect_generic_add_item_int32(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               bit_offset,
+                                        const int               field_bit_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error_code,
+                                        const long long         value)
+{
+    T_generic_protocol_data     & protocol_data = get_protocol_data(proto_idx);
+    T_generic_protocol_ws_data  * P_protocol_ws_data = &protocol_data.ws_data;
+    proto_item                  * proto_item_1 = nullptr;
+
+    M_COMPUTE_BYTE_FROM_BIT_OFFSET_SIZE(bit_offset, field_bit_size);
+
+    M_TRACE_ENTER("cpp_dissect_generic_add_item_int32",
+                  "proto_idx=" << proto_idx <<
+                  "  field_idx=" << field_idx <<
+                  "  field_bit_size=" << field_bit_size <<
+                  "  value=" << value);
+
+    proto_item_1 = proto_tree_add_int_format(
+        tree,
+        P_protocol_ws_data->fields_data.hf_id[field_idx],
+        tvb,
+        offset,
+        field_byte_size,
+        static_cast<gint>(value),
+        "%s", text);
+    if (error_code > 0)
+    {
+        wsgd_expert_add_info_format(pinfo, proto_item_1, PI_MALFORMED, error_code, "%s", text);
+        // Add a hidden error_in_packet field (if not already on a error_in_packet field).
+        // Permits filter on error_in_packet.
+        if ((error_code >= PI_ERROR) && (field_idx != K_ERROR_WSGD_FIELD_IDX))
+        {
+            proto_item* proto_item_error = proto_tree_add_item(
+                tree,
+                P_protocol_ws_data->fields_data.hf_id[K_ERROR_WSGD_FIELD_IDX],
+                tvb,
+                offset,
+                field_byte_size,
+                little_endian);
+            PROTO_ITEM_SET_HIDDEN(proto_item_error);
+        }
+    }
+
+    return  proto_item_1;
+}
+
+proto_item  * cpp_dissect_generic_add_item_uint64(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               bit_offset,
+                                        const int               field_bit_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error_code,
+                                        const long long         value)
+{
+    T_generic_protocol_data     & protocol_data = get_protocol_data(proto_idx);
+    T_generic_protocol_ws_data  * P_protocol_ws_data = &protocol_data.ws_data;
+    proto_item                  * proto_item_1 = nullptr;
+
+    M_COMPUTE_BYTE_FROM_BIT_OFFSET_SIZE(bit_offset, field_bit_size);
+
+    M_TRACE_ENTER("cpp_dissect_generic_add_item_uint64",
+                  "proto_idx=" << proto_idx <<
+                  "  field_idx=" << field_idx <<
+                  "  field_bit_size=" << field_bit_size <<
+                  "  value=" << value);
+
+    proto_item_1 = proto_tree_add_uint64_format(
+        tree,
+        P_protocol_ws_data->fields_data.hf_id[field_idx],
+        tvb,
+        offset,
+        field_byte_size,
+        value,
+        "%s", text);
+    if (error_code > 0)
+    {
+        wsgd_expert_add_info_format(pinfo, proto_item_1, PI_MALFORMED, error_code, "%s", text);
+        // Add a hidden error_in_packet field (if not already on a error_in_packet field).
+        // Permits filter on error_in_packet.
+        if ((error_code >= PI_ERROR) && (field_idx != K_ERROR_WSGD_FIELD_IDX))
+        {
+            proto_item* proto_item_error = proto_tree_add_item(
+                tree,
+                P_protocol_ws_data->fields_data.hf_id[K_ERROR_WSGD_FIELD_IDX],
+                tvb,
+                offset,
+                field_byte_size,
+                little_endian);
+            PROTO_ITEM_SET_HIDDEN(proto_item_error);
+        }
+    }
+
+    return  proto_item_1;
+}
+
+proto_item  * cpp_dissect_generic_add_item_int64(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               bit_offset,
+                                        const int               field_bit_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error_code,
+                                        const long long         value)
+{
+    T_generic_protocol_data     & protocol_data = get_protocol_data(proto_idx);
+    T_generic_protocol_ws_data  * P_protocol_ws_data = &protocol_data.ws_data;
+    proto_item                  * proto_item_1 = nullptr;
+
+    M_COMPUTE_BYTE_FROM_BIT_OFFSET_SIZE(bit_offset, field_bit_size);
+
+    M_TRACE_ENTER("cpp_dissect_generic_add_item_int64",
+                  "proto_idx=" << proto_idx <<
+                  "  field_idx=" << field_idx <<
+                  "  field_bit_size=" << field_bit_size <<
+                  "  value=" << value);
+
+    proto_item_1 = proto_tree_add_int64_format(
+        tree,
+        P_protocol_ws_data->fields_data.hf_id[field_idx],
+        tvb,
+        offset,
+        field_byte_size,
+        value,
+        "%s", text);
+    if (error_code > 0)
+    {
+        wsgd_expert_add_info_format(pinfo, proto_item_1, PI_MALFORMED, error_code, "%s", text);
+        // Add a hidden error_in_packet field (if not already on a error_in_packet field).
+        // Permits filter on error_in_packet.
+        if ((error_code >= PI_ERROR) && (field_idx != K_ERROR_WSGD_FIELD_IDX))
+        {
+            proto_item* proto_item_error = proto_tree_add_item(
+                tree,
+                P_protocol_ws_data->fields_data.hf_id[K_ERROR_WSGD_FIELD_IDX],
+                tvb,
+                offset,
+                field_byte_size,
+                little_endian);
+            PROTO_ITEM_SET_HIDDEN(proto_item_error);
+        }
+    }
+
+    return  proto_item_1;
+}
+
+proto_item  * cpp_dissect_generic_add_item_float(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               bit_offset,
+                                        const int               field_bit_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error_code,
+                                        const float             value)
+{
+    T_generic_protocol_data     & protocol_data = get_protocol_data(proto_idx);
+    T_generic_protocol_ws_data  * P_protocol_ws_data = &protocol_data.ws_data;
+    proto_item                  * proto_item_1 = nullptr;
+
+    M_COMPUTE_BYTE_FROM_BIT_OFFSET_SIZE(bit_offset, field_bit_size);
+
+    M_TRACE_ENTER("cpp_dissect_generic_add_item_float",
+                  "proto_idx=" << proto_idx <<
+                  "  field_idx=" << field_idx <<
+                  "  field_bit_size=" << field_bit_size <<
+                  "  value=" << value);
+
+    proto_item_1 = proto_tree_add_float_format(
+        tree,
+        P_protocol_ws_data->fields_data.hf_id[field_idx],
+        tvb,
+        offset,
+        field_byte_size,
+        value,
+        "%s", text);
+    if (error_code > 0)
+    {
+        wsgd_expert_add_info_format(pinfo, proto_item_1, PI_MALFORMED, error_code, "%s", text);
+        // Add a hidden error_in_packet field (if not already on a error_in_packet field).
+        // Permits filter on error_in_packet.
+        if ((error_code >= PI_ERROR) && (field_idx != K_ERROR_WSGD_FIELD_IDX))
+        {
+            proto_item* proto_item_error = proto_tree_add_item(
+                tree,
+                P_protocol_ws_data->fields_data.hf_id[K_ERROR_WSGD_FIELD_IDX],
+                tvb,
+                offset,
+                field_byte_size,
+                little_endian);
+            PROTO_ITEM_SET_HIDDEN(proto_item_error);
+        }
+    }
+
+    return  proto_item_1;
+}
+
+proto_item  * cpp_dissect_generic_add_item_double(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               bit_offset,
+                                        const int               field_bit_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error_code,
+                                        const double            value)
+{
+    T_generic_protocol_data     & protocol_data = get_protocol_data(proto_idx);
+    T_generic_protocol_ws_data  * P_protocol_ws_data = &protocol_data.ws_data;
+    proto_item                  * proto_item_1 = nullptr;
+
+    M_COMPUTE_BYTE_FROM_BIT_OFFSET_SIZE(bit_offset, field_bit_size);
+
+    M_TRACE_ENTER("cpp_dissect_generic_add_item_double",
+        "proto_idx=" << proto_idx <<
+        "  field_idx=" << field_idx <<
+        "  field_bit_size=" << field_bit_size <<
+        "  value=" << value);
+
+    proto_item_1 = proto_tree_add_double_format(
+        tree,
+        P_protocol_ws_data->fields_data.hf_id[field_idx],
+        tvb,
+        offset,
+        field_byte_size,
+        value,
+        "%s", text);
+    if (error_code > 0)
+    {
+        wsgd_expert_add_info_format(pinfo, proto_item_1, PI_MALFORMED, error_code, "%s", text);
+
+        // Add a hidden error_in_packet field (if not already on a error_in_packet field).
+        // Permits filter on error_in_packet.
+        if ((error_code >= PI_ERROR) && (field_idx != K_ERROR_WSGD_FIELD_IDX))
+        {
+            proto_item* proto_item_error = proto_tree_add_item(
+                tree,
+                P_protocol_ws_data->fields_data.hf_id[K_ERROR_WSGD_FIELD_IDX],
+                tvb,
+                offset,
+                field_byte_size,
+                little_endian);
+            PROTO_ITEM_SET_HIDDEN(proto_item_error);
+        }
+    }
+
+    return  proto_item_1;
+}
+
+//*****************************************************************************
+// C_byte_interpret_wsgd_builder_base
+//*****************************************************************************
+
+C_byte_interpret_wsgd_builder_base::C_byte_interpret_wsgd_builder_base(
+                             int                   proto_idx,
+                             tvbuff_t            * wsgd_tvb,
+                             packet_info         * wsgd_pinfo,
+                             proto_tree          * wsgd_tree,
+                             proto_tree          * wsgd_msg_root_tree)
+{
+    A_interpret_wsgd.proto_idx = proto_idx;
+    A_interpret_wsgd.wsgd_tvb = wsgd_tvb;
+    A_interpret_wsgd.wsgd_pinfo = wsgd_pinfo;
+    A_interpret_wsgd.wsgd_tree = wsgd_tree;
+    A_interpret_wsgd.wsgd_msg_root_tree = wsgd_msg_root_tree;
+    A_is_input_data_complete = false;
+}
+
+//*****************************************************************************
+// 
+//*****************************************************************************
+void
+C_byte_interpret_wsgd_builder_base::set_is_input_data_complete(bool    is_input_data_complete)
+{
+    A_is_input_data_complete = is_input_data_complete;
+}
+
+bool
+C_byte_interpret_wsgd_builder_base::is_input_data_complete() const
+{
+    return  A_is_input_data_complete;
+}
+
+//*****************************************************************************
+// missing_data
+//*****************************************************************************
+void
+C_byte_interpret_wsgd_builder_base::missing_data(const T_type_definitions  & /* type_definitions */,
+                                                 const T_frame_data        & in_out_frame_data,
+                                                 const T_interpret_data    & interpret_data,
+                                                 const T_field_type_name   & /* field_type_name */,
+                                                 const string              & /* data_name */,
+                                                 const string              & /* data_simple_name */,
+                                                 const string              & error)
+{
+    T_generic_protocol_data  & protocol_data = get_protocol_data(A_interpret_wsgd.proto_idx);
+
+    if (is_input_data_complete())
+    {
+        string    text = "MISSING_DATA: " + error;
+        cpp_dissect_generic_add_item(
+            A_interpret_wsgd.proto_idx,
+            A_interpret_wsgd.wsgd_tvb,
+            A_interpret_wsgd.wsgd_pinfo,
+            A_interpret_wsgd.wsgd_msg_root_tree,
+            K_ERROR_WSGD_FIELD_IDX,
+            in_out_frame_data.get_bit_offset_into_initial_frame(),
+            0,                                // size (-1 does not work at the end of tvb)
+            false,                            // little_endian, do not care
+            text.c_str(),
+            PI_ERROR);
+    }
+    else
+    {
+        M_TRACE_INFO("missing_data  bit_offset=" << in_out_frame_data.get_bit_offset_into_initial_frame());
+
+        const T_attribute_value* P_attr_MSG_ID_FIELD_NAME = interpret_data.get_P_attribute_value_of_read_variable(protocol_data.MSG_ID_FIELD_NAME);
+        if (P_attr_MSG_ID_FIELD_NAME == nullptr)
+        {
+            // Perhaps the header has not been entirely read ?
+            M_TRACE_WARNING("Did NOT find " << protocol_data.MSG_ID_FIELD_NAME << " (MSG_ID_FIELD_NAME) ?");
+        }
+        else if (P_attr_MSG_ID_FIELD_NAME->has_error() == true)
+        {
+            // I do not recognize the message ...
+            // I suppose it is not a 1st segment,
+            //  I could NOT do anything with it,
+            //  I must ignore it.
+            M_TRACE_FATAL("Did NOT recognize the message");
+            string    text = "Did NOT recognize the message, perhaps a message segment ?";
+            cpp_dissect_generic_add_item(
+                A_interpret_wsgd.proto_idx,
+                A_interpret_wsgd.wsgd_tvb,
+                A_interpret_wsgd.wsgd_pinfo,
+                A_interpret_wsgd.wsgd_tree,
+                K_ERROR_WSGD_FIELD_IDX,
+                in_out_frame_data.get_bit_offset_into_initial_frame(),
+                0,                                // size (-1 does not work at the end of tvb)
+                false,                            // little_endian, do not care
+                text.c_str(),
+                PI_ERROR);
+            return;
+        }
+
+        // Not an error, wait for the next segment.
+        A_interpret_wsgd.wsgd_pinfo->desegment_offset = 0;  /* Start at beginning next time */
+        A_interpret_wsgd.wsgd_pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;
+    }
+}
diff --git a/plugins/epan/generic/C_byte_interpret_wsgd_builder_base.h b/plugins/epan/generic/C_byte_interpret_wsgd_builder_base.h
new file mode 100644
index 00000000000..ade1aa555d6
--- /dev/null
+++ b/plugins/epan/generic/C_byte_interpret_wsgd_builder_base.h
@@ -0,0 +1,197 @@
+/*
+ * Copyright 2008-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef C_BYTE_INTERPRET_WSGD_BUILDER_BASE_H
+#define C_BYTE_INTERPRET_WSGD_BUILDER_BASE_H
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <string>
+using namespace std;
+
+#include "C_byte_interpret_builder.h"
+#include "generic.h"
+
+
+
+proto_item  * cpp_dissect_generic_add_item(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               offset,
+                                        const int               field_byte_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error);
+
+proto_item  * cpp_dissect_generic_add_item_string(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               offset,
+                                        const int               field_byte_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error,
+                                        const char            * value);
+
+proto_item  * cpp_dissect_generic_add_item_float(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               offset,
+                                        const int               field_byte_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error,
+                                        const float             value);
+
+proto_item  * cpp_dissect_generic_add_item_double(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               offset,
+                                        const int               field_byte_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error,
+                                        const double            value);
+
+proto_item  * cpp_dissect_generic_add_item_uint32(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               offset,
+                                        const int               field_byte_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error,
+                                        const long long         value);
+
+proto_item  * cpp_dissect_generic_add_item_int32(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               offset,
+                                        const int               field_byte_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error,
+                                        const long long         value);
+
+proto_item  * cpp_dissect_generic_add_item_uint64(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               offset,
+                                        const int               field_byte_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error,
+                                        const long long         value);
+
+proto_item  * cpp_dissect_generic_add_item_int64(
+                                        const int               proto_idx,
+                                              tvbuff_t        * tvb,
+                                              packet_info     * pinfo,
+                                              proto_tree      * tree,
+                                        const int               field_idx,
+                                        const int               offset,
+                                        const int               field_byte_size,
+                                        const int               little_endian,
+                                        const char            * text,
+                                        const int               error,
+                                        const long long         value);
+
+//*****************************************************************************
+// C_byte_interpret_wsgd_builder_base
+//*****************************************************************************
+
+class C_byte_interpret_wsgd_builder_base : public C_byte_interpret_builder
+{
+public:
+
+    C_byte_interpret_wsgd_builder_base(int                   proto_idx,
+                                       tvbuff_t            * wsgd_tvb,
+                                       packet_info         * wsgd_pinfo,
+                                       proto_tree          * wsgd_tree,
+                                       proto_tree          * wsgd_msg_root_tree);
+
+    //*****************************************************************************
+    // is_input_data_complete :
+    // - true  means all the input data is here, could NOT have more
+    // - false means it could have more input data BUT it is not sure
+    //*****************************************************************************
+    void    set_is_input_data_complete(bool    is_input_data_complete);
+    bool    is_input_data_complete() const;
+
+    //*****************************************************************************
+    // 
+    //*****************************************************************************
+
+    void    missing_data(const T_type_definitions  & type_definitions,
+                         const T_frame_data        & in_out_frame_data,
+                         const T_interpret_data    & interpret_data,
+                         const T_field_type_name   & field_type_name,
+                         const string              & data_name,
+                         const string              & data_simple_name,
+                         const string              & error);
+
+
+protected:
+
+    struct T_interpret_wsgd
+    {
+        int                   proto_idx;
+        tvbuff_t            * wsgd_tvb;
+        packet_info         * wsgd_pinfo;
+        proto_tree          * wsgd_tree;
+        proto_tree          * wsgd_msg_root_tree;
+
+        T_interpret_wsgd ()
+            :proto_idx (-1),
+             wsgd_tvb (nullptr),
+             wsgd_pinfo (nullptr),
+             wsgd_tree (nullptr),
+             wsgd_msg_root_tree (nullptr)
+        {
+        }
+    };
+
+    T_interpret_wsgd             A_interpret_wsgd;
+    bool                         A_is_input_data_complete;
+};
+
+
+#endif /* C_BYTE_INTERPRET_WSGD_BUILDER_BASE_H */
diff --git a/plugins/epan/generic/C_perf_chrono.cpp b/plugins/epan/generic/C_perf_chrono.cpp
new file mode 100644
index 00000000000..63506927441
--- /dev/null
+++ b/plugins/epan/generic/C_perf_chrono.cpp
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "C_perf_chrono.h"
+
+
+//*****************************************************************************
+//*****************************************************************************
+#if 0
+#include <time.h> 
+#include <sys/times.h> 
+void   text_unix_time()
+{
+    cout << "CLOCKS_PER_SEC = " << CLOCKS_PER_SEC << endl;  // gives 1000000
+//	cout << "CLK_TCK        = " << CLK_TCK        << endl;
+    cout << "clock() = " << clock() << endl;
+    cout << "times() = " << times(nullptr) << endl;
+    sleep(1);
+    cout << "clock() = " << clock() << endl;
+    cout << "times() = " << times(nullptr) << endl;
+}
+#endif
+
+//*****************************************************************************
+// C_perf_chrono
+//*****************************************************************************
+
+long    C_perf_chrono::A_total_ms = 0;
+long    C_perf_chrono::A_total_ms_decode = 0;
+long    C_perf_chrono::A_total_ms_no_decode = 0;
+long    C_perf_chrono::A_total_sizeof_bytes = 0;
+long    C_perf_chrono::A_total_sizeof_bytes_decode = 0;
+long    C_perf_chrono::A_total_sizeof_bytes_no_decode = 0;
+
+C_perf_chrono::C_perf_chrono(      T_interpret_data    & interpret_data,
+                             const char                * in_input_string,
+                             const size_t                in_sizeof_bytes)
+    :A_interpret_data(interpret_data),
+     A_input_string(in_input_string),
+     A_sizeof_bytes(in_sizeof_bytes)
+{
+}
+
+C_perf_chrono::~C_perf_chrono()
+{
+    T_perf_time  perf_time_val;
+
+    const long          ms_diff_ctor = perf_time_diff_ms(perf_time_val, A_perf_time_ctor);
+    T_interpret_data    interpret_data = A_interpret_data;
+    const string      & decode_function = interpret_data.get_decode_function();
+    const string        decode = decode_function.empty() ? "      " : "decode" ;
+
+    if (get_debug() == false)
+    {
+        A_total_ms           += ms_diff_ctor;
+        A_total_sizeof_bytes += A_sizeof_bytes;
+
+        if (decode_function.empty())
+        {
+            A_total_ms_no_decode           += ms_diff_ctor;
+            A_total_sizeof_bytes_no_decode += A_sizeof_bytes;
+        }
+        else
+        {
+            A_total_ms_decode           += ms_diff_ctor;
+            A_total_sizeof_bytes_decode += A_sizeof_bytes;
+        }
+    }
+
+    output(ms_diff_ctor, A_sizeof_bytes, decode, get_debug(), A_input_string);
+}
+
+void
+C_perf_chrono::output(
+        const long              ms_diff_ctor,
+        const int               nb_bytes,
+        const string          & decode,
+        const E_debug_status    debug,
+        const string          & what)
+{
+    cout.width(5);
+    cout << ms_diff_ctor << " ms  ";
+
+    cout.width(5);
+    cout << nb_bytes << " bytes  ";
+
+    cout << decode;
+    cout << " ";
+
+    if (debug == E_debug_status_OFF)
+    {
+        cout << "     ";
+    }
+    else
+    {
+        cout << "debug";
+    }
+
+    cout << "  for " << what;
+    cout << endl;
+}
+
+void
+C_perf_chrono::end()
+{
+    output(A_total_ms_no_decode, A_total_sizeof_bytes_no_decode, "      ", E_debug_status_OFF, "sum of all times (do not compare with decode time)");
+    output(A_total_ms_decode   , A_total_sizeof_bytes_decode   , "decode", E_debug_status_OFF, "sum of all times");
+    output(A_total_ms          , A_total_sizeof_bytes          , "all   ", E_debug_status_OFF, "sum of all times");
+}
diff --git a/plugins/epan/generic/C_perf_chrono.h b/plugins/epan/generic/C_perf_chrono.h
new file mode 100644
index 00000000000..e5a13a02953
--- /dev/null
+++ b/plugins/epan/generic/C_perf_chrono.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef C_PERF_CHRONO_H
+#define C_PERF_CHRONO_H
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "byte_interpret_common.h"
+#include "T_interpret_data.h"
+#include "T_perf_time.h"
+
+
+//*****************************************************************************
+// C_perf_chrono
+//*****************************************************************************
+
+class C_perf_chrono
+{
+public:
+    C_perf_chrono(      T_interpret_data    & interpret_data,
+                  const char                * in_input_string,
+                  const size_t                in_sizeof_bytes);
+    ~C_perf_chrono();
+
+    static void    end();
+
+private:
+
+    static void    output(
+        const long              ms_diff_ctor,
+        const int               nb_bytes,
+        const string          & decode_function,
+        const E_debug_status    debug,
+        const string          & what);
+
+    T_interpret_data    & A_interpret_data;
+    const char  * A_input_string;
+    const size_t  A_sizeof_bytes;
+    T_perf_time   A_perf_time_ctor;
+
+    static long   A_total_ms;
+    static long   A_total_ms_decode;
+    static long   A_total_ms_no_decode;
+    static long   A_total_sizeof_bytes;
+    static long   A_total_sizeof_bytes_decode;
+    static long   A_total_sizeof_bytes_no_decode;
+};
+
+#endif
diff --git a/plugins/epan/generic/C_reference_counter.h b/plugins/epan/generic/C_reference_counter.h
new file mode 100644
index 00000000000..075b2acdf96
--- /dev/null
+++ b/plugins/epan/generic/C_reference_counter.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2009-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#pragma once
+
+//*****************************************************************************
+// Includes
+//*****************************************************************************
+
+#include "byte_interpret_common.h"
+
+
+//*****************************************************************************
+// C_reference_counter ********************************************************
+//*****************************************************************************
+// Basic class for objects used with smart pointers.
+//*****************************************************************************
+
+class C_reference_counter
+{
+protected:
+
+    //---------------------------------------------------------------------------
+    // Constructor.
+    //---------------------------------------------------------------------------
+    C_reference_counter() : _ref_counter(0) {}
+
+    //---------------------------------------------------------------------------
+    // Copy constructor.
+    // Special behavior, DO NOT COPY _ref_counter.
+    //---------------------------------------------------------------------------
+    C_reference_counter(const C_reference_counter&) : _ref_counter(0) {}
+
+    //---------------------------------------------------------------------------
+    // Assignment operator.
+    // Special behavior, DO NOT MODIFY _ref_counter.
+    //---------------------------------------------------------------------------
+    C_reference_counter&  operator= (const C_reference_counter&)
+    {
+        return *this;
+    }
+
+    //---------------------------------------------------------------------------
+    // Destructor (verification of reference counter).
+    //---------------------------------------------------------------------------
+    virtual ~C_reference_counter()
+    {
+        M_ASSERT(_ref_counter == 0);
+    }
+
+
+private:
+
+    //---------------------------------------------------------------------------
+    // Reference counter (number of smart pointers which point on this object).
+    // mutable means that a const method can modify the counter.
+    // It's normal for this reference counter to be mutable, if not, smart
+    //  pointer on a const object is not possible.
+    //---------------------------------------------------------------------------
+    mutable
+    int            _ref_counter;
+
+    //---------------------------------------------------------------------------
+    // Increments the reference counter.
+    //---------------------------------------------------------------------------
+    void           incr_ref() const
+    {
+        ++_ref_counter;
+    }
+
+    //---------------------------------------------------------------------------
+    // Decrements the reference counter (destroys itself if necessary).
+    //---------------------------------------------------------------------------
+    void           decr_ref() const
+    {
+        if (--_ref_counter <= 0)
+            delete this;
+    }
+
+    //---------------------------------------------------------------------------
+    // Friends.
+    //---------------------------------------------------------------------------
+    friend void  C_reference_counter_ptr_add_ref(const C_reference_counter *);
+    friend void  C_reference_counter_ptr_release(const C_reference_counter *);
+};
+
+
+//-----------------------------------------------------------------------------
+// Functions dedicated to C_reference_counter_ptr.
+// Only the C_reference_counter_ptr class must use them.
+//-----------------------------------------------------------------------------
+inline
+void  C_reference_counter_ptr_add_ref (const C_reference_counter *  ptr)
+{
+    ptr->incr_ref ();
+}
+
+inline
+void  C_reference_counter_ptr_release (const C_reference_counter *  ptr)
+{
+    ptr->decr_ref ();
+}
diff --git a/plugins/epan/generic/C_reference_counter_ptr.h b/plugins/epan/generic/C_reference_counter_ptr.h
new file mode 100644
index 00000000000..b1aca7f9a23
--- /dev/null
+++ b/plugins/epan/generic/C_reference_counter_ptr.h
@@ -0,0 +1,231 @@
+/*
+ * Copyright 2009-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#pragma once
+
+//*****************************************************************************
+// Includes
+//*****************************************************************************
+
+#include <iostream>
+#include <utility>
+using namespace std;
+
+#include "byte_interpret_common.h"
+
+
+//*****************************************************************************
+// C_reference_counter_ptr ****************************************************
+//*****************************************************************************
+//! Template class for shared pointers.
+//*****************************************************************************
+//! Relies on unqualified calls to
+//!
+//! void  C_reference_counter_ptr_add_ref (T * p);
+//! void  C_reference_counter_ptr_release (T * p);
+//!
+//! You must defines this 2 functions (with the good behavior) for your kind
+//!  of object.
+//! NB: These 2 functions already exist for classes inherited from
+//!  C_reference_counter.
+//*****************************************************************************
+
+template <class TYPE> class C_reference_counter_ptr
+{
+public:
+
+    //---------------------------------------------------------------------------
+    //! Constructor.
+    //---------------------------------------------------------------------------
+    C_reference_counter_ptr(TYPE *p_object)
+        : _p_object(p_object)
+    {
+        add_ref();
+    }
+
+    //---------------------------------------------------------------------------
+    //! Default constructor.
+    //---------------------------------------------------------------------------
+    C_reference_counter_ptr() : _p_object(nullptr) {}
+
+    //---------------------------------------------------------------------------
+    //! Copy constructor.
+    //---------------------------------------------------------------------------
+    C_reference_counter_ptr(const C_reference_counter_ptr&  rhs)
+        : _p_object(rhs.get())
+    {
+        add_ref();
+    }
+
+    //---------------------------------------------------------------------------
+    //! Copy constructor template.
+    //! For initialization of a shared pointer from a compatible shared pointer (
+    //! e.g. initialization of C_reference_counter_ptr<const T> from
+    //! C_reference_counter_ptr<T>).
+    //---------------------------------------------------------------------------
+    template <class OTHER>
+    C_reference_counter_ptr(const C_reference_counter_ptr<OTHER>  & rhs)
+        : _p_object(rhs.get())
+    {
+        add_ref();
+    }
+
+    //---------------------------------------------------------------------------
+    //! Assignment operator. 
+    //---------------------------------------------------------------------------
+    C_reference_counter_ptr&   operator= (const C_reference_counter_ptr&  rhs)
+    {
+        //! set deals with auto assigment.
+        set(rhs.get());
+        return  *this;
+    }
+
+    //---------------------------------------------------------------------------
+    //! Destructor.
+    //---------------------------------------------------------------------------
+    ~C_reference_counter_ptr() { sup_ref(); }
+
+    //---------------------------------------------------------------------------
+    //! operator ->.
+    //! operator *.
+    //---------------------------------------------------------------------------
+    TYPE*  operator -> () const { return  _p_object; }
+    TYPE&  operator *  () const { return *_p_object; }
+
+    //---------------------------------------------------------------------------
+    //! Automatic cast.
+    //! BECAREFUL about unexpected implicit conversion.
+    //---------------------------------------------------------------------------
+    operator TYPE* () const { return  _p_object; }
+
+    //---------------------------------------------------------------------------
+    //! Returns true if pointer is NULL.
+    //! Not necessary if operator TYPE* is defined.
+    //---------------------------------------------------------------------------
+    bool  operator! () const
+    {
+        return  _p_object == nullptr;
+    }
+
+    //---------------------------------------------------------------------------
+    //! Gets the pointer on the data.
+    //---------------------------------------------------------------------------
+    TYPE       *get() const { return  _p_object; }
+
+    //---------------------------------------------------------------------------
+    //! Swap (permits to avoid add_ref and sup_ref operations).
+    //---------------------------------------------------------------------------
+    void    swap(C_reference_counter_ptr  & rhs)
+    {
+        TYPE  * tmp = _p_object;
+        _p_object = rhs._p_object;
+        rhs._p_object = tmp;
+    }
+
+
+private:
+
+    //---------------------------------------------------------------------------
+    //! Sets the pointer on the data.
+    //---------------------------------------------------------------------------
+    void        set(TYPE  * p_object)
+    {
+        if (p_object != _p_object)
+        {
+            // sup_ref ();
+            // _p_object = p_object;
+            // add_ref ();
+            // Previous code is simpler but less performant.
+
+            if (_p_object != nullptr)
+            {
+                C_reference_counter_ptr_release(_p_object);
+                _p_object = p_object;
+                add_ref();
+            }
+            else
+            {
+                // _p_object == nullptr, so :
+                // - C_reference_counter_ptr_release is forbidden
+                // - p_object != nullptr
+                _p_object = p_object;
+                C_reference_counter_ptr_add_ref(_p_object);
+            }
+        }
+    }
+
+    //---------------------------------------------------------------------------
+    //! Add a reference on the object.
+    //---------------------------------------------------------------------------
+    inline
+    void    add_ref()
+    {
+        if (_p_object != nullptr)
+            C_reference_counter_ptr_add_ref(_p_object);
+    }
+
+    //---------------------------------------------------------------------------
+    //! Remove a reference on the object.
+    //---------------------------------------------------------------------------
+    inline
+    void    sup_ref()
+    {
+        if (_p_object != nullptr)
+        {
+            C_reference_counter_ptr_release(_p_object);
+            _p_object = nullptr;
+        }
+    }
+
+
+    //---------------------------------------------------------------------------
+    //! Pointed object.
+    //---------------------------------------------------------------------------
+    TYPE      *_p_object;
+};
+
+// ============================================================================
+// ASSOCIATED FUNCTIONS
+// ============================================================================
+
+template<class T>
+void  swap (C_reference_counter_ptr<T>  & lhs,
+            C_reference_counter_ptr<T>  & rhs)
+{
+    lhs.swap(rhs);
+}
+
+//! operator<<
+
+#if defined(__GNUC__) &&  (__GNUC__ < 3)
+
+template<class Y> std::ostream & operator<< (std::ostream & os, C_reference_counter_ptr<Y> const & p)
+{
+    os << p.get();
+    return os;
+}
+
+#else
+
+template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, C_reference_counter_ptr<Y> const & p)
+{
+    os << p.get();
+    return os;
+}
+
+#endif
diff --git a/plugins/epan/generic/C_setlocale_numeric_C_guard.cpp b/plugins/epan/generic/C_setlocale_numeric_C_guard.cpp
new file mode 100644
index 00000000000..5aa04243faf
--- /dev/null
+++ b/plugins/epan/generic/C_setlocale_numeric_C_guard.cpp
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+
+#include <cstdio>
+#include <clocale>
+#include <string.h>
+#include <cstdlib>
+
+using namespace std;
+
+#include "C_setlocale_numeric_C_guard.h"
+
+#ifdef WIN32
+#define strdup  _strdup
+#endif
+
+//*****************************************************************************
+// C_setlocale_numeric_C_guard
+//*****************************************************************************
+
+C_setlocale_numeric_C_guard::C_setlocale_numeric_C_guard()
+    : _locale_saved(setlocale(LC_NUMERIC, "C"))
+{
+    if (_locale_saved)
+    {
+        _locale_saved = strdup(_locale_saved);
+    }
+}
+
+// restore the saved locale
+C_setlocale_numeric_C_guard::~C_setlocale_numeric_C_guard()
+{
+    setlocale(LC_NUMERIC, _locale_saved);
+    free(_locale_saved);
+}
diff --git a/plugins/epan/generic/C_setlocale_numeric_C_guard.h b/plugins/epan/generic/C_setlocale_numeric_C_guard.h
new file mode 100644
index 00000000000..fbfea8ee45e
--- /dev/null
+++ b/plugins/epan/generic/C_setlocale_numeric_C_guard.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef C_SETLOCALE_NUMERIC_C_GUARD
+#define C_SETLOCALE_NUMERIC_C_GUARD
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+
+//*****************************************************************************
+// C_setlocale_numeric_C_guard
+//*****************************************************************************
+
+class C_setlocale_numeric_C_guard
+{
+public:
+    // save the current locale for LC_NUMERIC (used for numeric input/output, e.g. strtoll)
+    // change the locale for LC_NUMERIC (so 0.236 is a valid number)
+    C_setlocale_numeric_C_guard();
+
+    // restore the saved locale
+    ~C_setlocale_numeric_C_guard();
+
+private:
+    char* _locale_saved;
+};
+
+#endif
diff --git a/plugins/epan/generic/C_value.cpp b/plugins/epan/generic/C_value.cpp
new file mode 100644
index 00000000000..cae51293898
--- /dev/null
+++ b/plugins/epan/generic/C_value.cpp
@@ -0,0 +1,1517 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "C_value.h"
+#include "byte_interpret_common.h"
+#include "byte_interpret_parse.h"
+
+#include <cstdio>
+#include <cmath>
+#include <algorithm>
+using namespace std;
+
+
+//*****************************************************************************
+// 
+//*****************************************************************************
+
+ostream &  operator<< (ostream  & os, const C_value::E_type  type)
+{
+    if (type == C_value::E_type_integer)
+    {
+        os << "integer";
+    }
+    else if (type == C_value::E_type_float)
+    {
+        os << "float";
+    }
+    else if (type == C_value::E_type_string)
+    {
+        os << "string";
+    }
+    else if (type == C_value::E_type_msg)
+    {
+        os << "msg";
+    }
+    else if (type == C_value::E_type_struct)
+    {
+        os << "struct";
+    }
+    else
+    {
+        os << "unknow_type=" << static_cast<int>(type);
+    }
+
+    return  os;
+}
+
+//*****************************************************************************
+// 
+//*****************************************************************************
+
+ostream &  operator<< (ostream  & os, const C_value        & rhs)
+{
+    os << "type=" << rhs.A_type << "  ";
+    os << "int=" << rhs.A_integer << "  ";
+    os << "flt=" << rhs.A_flt << "  ";
+    os << "str=" << rhs.A_str << "  ";
+    os << "bit_position_offset=" << rhs.A_bit_position_offset << "  ";
+    os << "bit_position_size=" << rhs.A_bit_position_size << "  ";
+//    os << "external_type__cvtbd=" << rhs.A_external_type__cvtbd << "  ";
+    os << "external_type_bit_size__cvtbd=" << rhs.A_external_type_bit_size__cvtbd << "  ";
+
+    return  os;
+}
+
+//*****************************************************************************
+// 
+//*****************************************************************************
+
+C_value::C_value ()
+    :A_type (E_type_string),
+     A_external_type_bit_size__cvtbd(0),
+     A_integer (0),
+     A_flt (0.0),
+     A_str (""),                 // means NOT intialized for quantum, offset, constraints
+     A_bit_position_offset(-1),
+     A_bit_position_size(-1)
+{
+}
+
+C_value::C_value (const E_type               type)
+    :A_type (type),
+     A_external_type_bit_size__cvtbd(0),
+     A_integer (0),
+     A_flt (0.0),
+     A_str (""),                 // means NOT intialized for quantum, offset, constraints
+     A_bit_position_offset(-1),
+     A_bit_position_size(-1)
+{
+    if (A_type == E_type_msg)
+    {
+        A_str = "nil";
+    }
+}
+
+C_value::C_value (const E_type               type,
+                        T_msg                msg)
+    :A_type (type),
+     A_external_type_bit_size__cvtbd(0),
+     A_integer ((long long)msg),
+     A_flt ((double)(long long)msg),
+     A_str (get_string(msg)),
+     A_bit_position_offset(-1),
+     A_bit_position_size(-1)
+{
+    if (A_type != E_type_msg)
+    {
+        M_FATAL_COMMENT("Value type must be msg and not " << type);
+    }
+    if (A_integer == 0)
+    {
+        A_str = "nil";
+    }
+}
+
+
+#define CTOR_INT_LL(TYPE)                                                     \
+C_value::C_value (TYPE    integer)                                            \
+    :A_type (E_type_integer),                                                 \
+     A_external_type_bit_size__cvtbd(0),                                      \
+     A_integer (integer),                                                     \
+     A_flt ((double)integer),                                                 \
+     A_str (get_string ((long long)integer)),                                 \
+     A_bit_position_offset(-1),                                               \
+     A_bit_position_size(-1)                                                  \
+{                                                                             \
+}
+
+// long long cast is mandatory for char ctor
+#define CTOR_INT_CHAR(TYPE)    CTOR_INT_LL(TYPE)
+
+// long long cast gives better performance (see get_string implementation)
+#define CTOR_INT(TYPE)         CTOR_INT_LL(TYPE)
+
+CTOR_INT(bool)
+CTOR_INT_CHAR(         char)
+CTOR_INT_CHAR(  signed char)
+CTOR_INT_CHAR(unsigned char)
+CTOR_INT(  signed short)
+CTOR_INT(unsigned short)
+CTOR_INT(  signed int)
+CTOR_INT(unsigned int)
+CTOR_INT(  signed long)
+CTOR_INT_LL(unsigned long)
+CTOR_INT_LL(  signed long long)
+CTOR_INT_LL(unsigned long long)
+
+
+C_value::C_value (float        flt)
+    :A_type (E_type_float),
+     A_external_type_bit_size__cvtbd(0),
+     A_integer ((long long)flt),
+     A_flt (flt),
+     A_str (get_string (flt)),        // pb precision
+     A_bit_position_offset(-1),
+     A_bit_position_size(-1)
+{
+}
+
+C_value::C_value (double       flt)
+    :A_type (E_type_float),
+     A_external_type_bit_size__cvtbd(0),
+     A_integer ((long long)flt),
+     A_flt (flt),
+     A_str (get_string (flt)),        // pb precision
+     A_bit_position_offset(-1),
+     A_bit_position_size(-1)
+{
+}
+
+C_value::C_value (const string    & str)
+    :A_type (E_type_string),
+     A_external_type_bit_size__cvtbd(0),
+     A_integer (0),
+     A_flt (0.0),
+     A_str (str),
+     A_bit_position_offset(-1),
+     A_bit_position_size(-1)
+{
+    // No automatic transformation to integer or float.
+    // This must be done explicitely by user.
+}
+
+// NB: this constructor is necessary,
+//  because the string version is NOT called with :
+// C_value("anything")
+// It seems that an integer constructor is called instead !!!
+C_value::C_value (const char      * str)
+    :A_type (E_type_string),
+     A_external_type_bit_size__cvtbd(0),
+     A_integer (0),
+     A_flt (0.0),
+     A_str (str),
+     A_bit_position_offset(-1),
+     A_bit_position_size(-1)
+{
+}
+
+//*****************************************************************************
+// Assignment operator
+//*****************************************************************************
+C_value &
+C_value::operator=(const C_value  & rhs)
+{
+    A_type                 = rhs.A_type;
+    A_integer              = rhs.A_integer;
+    A_flt                  = rhs.A_flt;
+    A_str                  = rhs.A_str;
+
+    A_bit_position_offset  = rhs.A_bit_position_offset;
+    A_bit_position_size    = rhs.A_bit_position_size;
+
+    // Special behavior
+    // ICIOA a revoir
+    // si la valeur de this est definie :
+    // - ne pas la modifier
+    // - verifier que la valeur assignee est compatible
+    // si la valeur de this n'est pas definie :
+    // - ne pas la modifier ? 
+    // voir M_COMPUTE_NEW_EXTERNAL_TYPE_RESULT_RHS
+    if (A_external_type_bit_size__cvtbd == 0)
+    {
+        A_external_type_bit_size__cvtbd = rhs.A_external_type_bit_size__cvtbd;
+    }
+
+    return  *this;
+}
+
+//*****************************************************************************
+// external_type
+//*****************************************************************************
+
+void
+C_value::set_external_type(const std::string  & final_type)
+{
+//    A_external_type__cvtbd = final_type;
+    A_external_type_bit_size__cvtbd = 0;
+
+    long    bit_size = 0;
+    if ((strncmp(final_type.c_str(), "uint", 4) == 0) &&
+        (get_number(final_type.c_str()+4, &bit_size) == true))
+    {
+        A_external_type_bit_size__cvtbd = bit_size;
+    }
+    else if ((strncmp(final_type.c_str(), "int", 3) == 0) &&
+             (get_number(final_type.c_str()+3, &bit_size) == true))
+    {
+        A_external_type_bit_size__cvtbd = - bit_size;
+    }
+    else if ((strncmp(final_type.c_str(), "float", 3) == 0) &&
+             (get_number(final_type.c_str()+5, &bit_size) == true))
+    {
+        A_external_type_bit_size__cvtbd = - bit_size;
+    }
+    // else string ???
+}
+    
+bool
+C_value::get_external_type_signed ()  const
+{
+    return  A_external_type_bit_size__cvtbd < 0;
+}
+
+int
+C_value::get_external_type_bit_size ()  const
+{
+    if (A_external_type_bit_size__cvtbd < 0)
+        return  - A_external_type_bit_size__cvtbd;
+    else
+        return  A_external_type_bit_size__cvtbd;
+}
+
+int
+C_value::get_external_type_byte_size ()  const
+{
+    if (A_external_type_bit_size__cvtbd < 0)
+        return  - A_external_type_bit_size__cvtbd / 8;
+    else
+        return  A_external_type_bit_size__cvtbd / 8;
+}
+
+void
+C_value::set_external_type_bit_size(int    external_type_bit_size)
+{
+    A_external_type_bit_size__cvtbd = external_type_bit_size;
+}
+
+//*****************************************************************************
+// set_bit_position_offset_size
+//*****************************************************************************
+void
+C_value::set_bit_position_offset_size(int  offset, int  size)
+{
+    A_bit_position_offset = offset;
+    A_bit_position_size = size;
+}
+
+//*****************************************************************************
+// Get methods : Fatal if internal type does not match.
+//*****************************************************************************
+
+long long
+C_value::get_int ()  const
+{
+    M_FATAL_IF_NE (A_type, E_type_integer);
+    return  A_integer;
+}
+
+std::size_t
+C_value::get_int_size_t()  const
+{
+    M_FATAL_IF_NE(A_type, E_type_integer);
+    M_FATAL_IF_LT(A_integer, 0);
+    M_FATAL_IF_GT(A_integer, SIZE_MAX);
+    return  static_cast<std::size_t>(A_integer);
+}
+
+int
+C_value::get_int_int()  const
+{
+    M_FATAL_IF_NE(A_type, E_type_integer);
+    M_FATAL_IF_LT(A_integer, INT_MIN);
+    M_FATAL_IF_GT(A_integer, INT_MAX);
+    return  static_cast<int>(A_integer);
+}
+
+double
+C_value::get_flt ()  const
+{
+    M_FATAL_IF_NE (A_type, E_type_float);
+    return  A_flt;
+}
+
+const string  &
+C_value::get_str ()  const
+{
+    M_FATAL_IF_NE (A_type, E_type_string);
+    return  A_str;
+}
+
+C_value::T_msg
+C_value::get_msg ()  const
+{
+    M_FATAL_IF_NE (A_type, E_type_msg);
+    return  reinterpret_cast<T_msg>(A_integer);
+}
+
+bool
+C_value::get_bool ()  const
+{
+    if (A_type == E_type_integer)
+        return  A_integer != 0;
+//    else if (A_type == E_type_float)    // ICIOA 2009/03/08 if necessary -> as_bool
+//        return  A_flt != 0;
+
+    M_FATAL_COMMENT ("get_bool bad type " << A_type);
+    return  false;
+}
+
+//*****************************************************************************
+// No fatal.
+//*****************************************************************************
+
+const string  &
+C_value::as_string () const
+{
+    return  A_str;
+}
+
+//*****************************************************************************
+// Fatal if fail to promote value to a numeric value.
+//*****************************************************************************
+void
+C_value::convert_to_numeric()
+{
+    M_TRACE_ENTER("convert_to_numeric", "");
+
+    promote();
+
+    M_FATAL_IF_NE (is_numeric (), true);
+}
+
+//*****************************************************************************
+// Fatal if fail to promote value to a int value.
+//*****************************************************************************
+void
+C_value::convert_to_int(int  base)
+{
+    M_TRACE_ENTER("convert_to_int", "");
+
+    if (A_type == E_type_float)
+    {
+        A_type = E_type_integer;
+        A_str = get_string ((long long)A_integer);
+    }
+    else if (A_type == E_type_string)
+    {
+        // Try to promote to integer
+        long long    value;
+        double       value_dbl;
+        if (get_number(A_str.c_str(), base, value))
+        {
+            A_type = E_type_integer;
+            A_integer = value;
+            A_flt = (double)value;
+        }
+        else if (get_number(A_str.c_str(), value_dbl))
+        {
+            A_type = E_type_integer;           // can loose data, e.g 1e120
+            A_integer = (long long)value_dbl;
+            A_flt = value_dbl;
+        }
+    }
+
+    M_FATAL_IF_NE (get_type (), E_type_integer);
+}
+
+//*****************************************************************************
+// Fatal if fail to promote value to a float value.
+//*****************************************************************************
+void
+C_value::convert_to_float()
+{
+    M_TRACE_ENTER("convert_to_float", "");
+
+    if (A_type == E_type_integer)
+    {
+        A_type = E_type_float;
+        A_str = get_string ((long long)A_flt);
+    }
+    else if (A_type == E_type_string)
+    {
+        // Try to promote to float
+        double    value;
+        if (get_number(A_str.c_str(), value))
+        {
+            A_type = E_type_float;
+            A_integer = (long long)value;
+            A_flt = value;
+        }
+    }
+
+    M_FATAL_IF_NE (get_type (), E_type_float);
+}
+
+//*****************************************************************************
+// get_format_percent_letter
+//*****************************************************************************
+
+char    get_format_percent_letter(const char  * str)
+{
+    char    format_percent_letter = '\0';    // nothing found
+
+    while ((str = strchr(str, '%')) != nullptr)
+    {
+        ++str;
+
+        if (*str == '%')
+        {
+            ++str;
+            continue;
+        }
+
+        while ((*str != '\0') &&
+               ((isalpha(*str) == 0) || (*str == 'h') || (*str == 'l') || (*str == 'L')))
+        {
+            ++str;
+        }
+
+        format_percent_letter = tolower(*str);
+        break;
+    }
+
+    return  format_percent_letter;
+}
+
+//*****************************************************************************
+// Try to apply format to the value.
+// Only str modified.
+//*****************************************************************************
+void
+C_value::format(const string  & display)
+{
+    M_TRACE_ENTER("format", "display=" << display << "  type=" << A_type << "  str=" << A_str);
+
+    char    tmp_str[999+1];
+
+    if (display == "hex")
+    {
+        if (A_type == E_type_integer)
+        {
+            sprintf(tmp_str, "0x%llx", A_integer);
+            A_str = tmp_str;
+        }
+    }
+    else if (display == "oct")
+    {
+        if (A_type == E_type_integer)
+        {
+            sprintf(tmp_str, "0%llo", A_integer);
+            A_str = tmp_str;
+        }
+    }
+    else if (display == "bin")
+    {
+        if (A_type == E_type_integer)
+        {
+            strcpy(tmp_str, "");
+            bool    output_zero = false;
+            for (int  idx = 63; idx >= 0; --idx)
+            {
+                if (A_integer & (1LL << idx))
+                {
+                    if (output_zero == false)
+                    {
+                        strcat(tmp_str, "b");
+                        output_zero = true;
+                    }
+                    strcat(tmp_str, "1");
+                }
+                else if (output_zero)
+                {
+                    strcat(tmp_str, "0");
+                }
+            }
+            if (output_zero == false)
+            {
+                strcpy(tmp_str, "b0");
+            }
+            A_str = tmp_str;
+        }
+    }
+    else
+    {
+        char   format_percent_letter = get_format_percent_letter(display.c_str());
+
+        if (format_percent_letter == 's')
+        {
+            sprintf(tmp_str, display.c_str(), A_str.c_str());
+            A_str = tmp_str;
+        }
+        else if ((format_percent_letter != '\0') && (is_numeric()))
+        {
+            if ((format_percent_letter == 'e') ||
+                (format_percent_letter == 'f') ||
+                (format_percent_letter == 'g'))
+            {
+                sprintf(tmp_str, display.c_str(), A_flt);
+                A_str = tmp_str;
+            }
+            else
+            {
+                sprintf(tmp_str, display.c_str(), A_integer);
+                A_str = tmp_str;
+            }
+        }
+        else
+        {
+            // Error, unexpected display string
+            M_TRACE_ERROR("format bad display " << display);
+        }
+    }
+}
+
+//*****************************************************************************
+// Re-initialise string without format.
+// Nothing done for a string value.
+//*****************************************************************************
+void
+C_value::format_reset()
+{
+    M_TRACE_ENTER("format_reset", "");
+
+    if (A_type == E_type_float)
+    {
+        A_str = get_string(A_flt);
+    }
+    else if (A_type == E_type_integer)
+    {
+        A_str = get_string(A_integer);
+    }
+    else if (A_type == E_type_msg)
+    {
+        if (A_integer != 0)
+        {
+            A_str = get_string(A_integer);
+        }
+    }
+}
+
+//*****************************************************************************
+// Only str modified.
+// Type and other values NOT modified.
+//*****************************************************************************
+void
+C_value::set_str(const string  & str)
+{
+    A_str = str;
+}
+
+//*****************************************************************************
+// Try to promote to numeric type.
+// Returns the new type.
+//*****************************************************************************
+
+C_value::E_type
+C_value::promote()
+{
+    if (A_type == E_type_string)
+    {
+        // Try to promote to integer
+        {
+            long long    value;
+            if (get_number(A_str.c_str(), value))
+            {
+                A_type = E_type_integer;
+                A_integer = value;
+                A_flt = (double)value;
+                return  A_type;
+            }
+        }
+
+        // Try to promote to float
+        {
+            double    value;
+            if (get_number(A_str.c_str(), value))
+            {
+                A_type = E_type_float;
+                A_integer = (long long)value;
+                A_flt = value;
+                return  A_type;
+            }
+        }
+    }
+
+    return  A_type;
+}
+
+//*****************************************************************************
+// ICIOA codage global a revoir
+// 
+// ICIOA determination de A_external_type__cvtbd a revoir (a verifier au minimum)
+//*****************************************************************************
+
+class C_value_set_position_offset
+{
+    C_value  & A_value_to_set;
+    int        A_pos;
+    int        A_offset;
+//	string     A_external_type__cvtbd;
+    int        A_external_type_bit_size__cvtbd;
+
+public:
+    C_value_set_position_offset(C_value  & val, int pos, int offset,
+//                          const string   & external_type__cvtbd)//,
+                                int        external_type_bit_size__cvtbd)
+        :A_value_to_set(val),
+         A_pos(pos),
+         A_offset(offset),
+//         A_external_type__cvtbd(external_type__cvtbd)//,
+         A_external_type_bit_size__cvtbd(external_type_bit_size__cvtbd)
+    {
+    }
+
+    ~C_value_set_position_offset()
+    {
+        A_value_to_set.set_bit_position_offset_size(A_pos, A_offset);
+//        A_value_to_set.set_external_type(A_external_type__cvtbd);
+        A_value_to_set.set_external_type_bit_size(A_external_type_bit_size__cvtbd);
+    }
+};
+
+
+#define M_COMPUTE_NEW_POSITION_OFFSET_RESULT_RHS(RESULT,RHS)                \
+    if (RHS A_bit_position_size > 0)                                        \
+    {                                                                       \
+        if (RESULT A_bit_position_size <= 0)                                \
+        {                                                                   \
+            RESULT A_bit_position_offset = RHS A_bit_position_offset;       \
+            RESULT A_bit_position_size   = RHS A_bit_position_size;         \
+        }                                                                   \
+        else                                                                \
+        {                                                                   \
+            int  bit_position_offset_end = max((RESULT A_bit_position_offset + RESULT A_bit_position_size), (RHS A_bit_position_offset + RHS A_bit_position_size));  \
+            RESULT A_bit_position_offset = min(RESULT A_bit_position_offset, RHS A_bit_position_offset);   \
+            RESULT A_bit_position_size   = bit_position_offset_end - RESULT A_bit_position_offset;         \
+        }                                                                   \
+    }
+
+#define M_COMPUTE_NEW_EXTERNAL_TYPE_RESULT_RHS(RESULT,RHS)                  \
+    if (RESULT A_external_type_bit_size__cvtbd == 0)                        \
+    {                                                                       \
+        RESULT A_external_type_bit_size__cvtbd = RHS A_external_type_bit_size__cvtbd;     \
+    }
+
+#define M_COMPUTE_NEW_POSITION_OFFSET()                                     \
+    M_COMPUTE_NEW_POSITION_OFFSET_RESULT_RHS(this-> ,rhs.);                 \
+    M_COMPUTE_NEW_EXTERNAL_TYPE_RESULT_RHS(this-> ,rhs.);                   \
+    C_value_set_position_offset  vspo(*this, this->A_bit_position_offset, this->A_bit_position_size, this->A_external_type_bit_size__cvtbd)
+
+
+//*****************************************************************************
+// printf function for C_value
+//*****************************************************************************
+C_value
+C_value::sprintf_values(const std::string      & printf_format,
+                        const vector<C_value>  & values_to_print)
+{
+    M_TRACE_ENTER("sprintf_values", "printf_format=" << printf_format);
+
+    char    tmp_str[999+1];
+
+    // No parameters.
+    if (values_to_print.empty())
+    {
+        strncpy(tmp_str, printf_format.c_str(), sizeof(tmp_str));
+        return  tmp_str;
+    }
+
+    // 1 parameter.
+    // This will NOT work if I want to do a %s on a numeric value.
+    // Must I change format to manage %s as I do here ?
+#if 0
+    if (values_to_print.size() == 1)
+    {
+        C_value  val = values_to_print[0];
+        val.format(printf_format);
+        return  val.as_string();
+    }
+#endif
+
+    // Highlight data.
+    int   A_bit_position_offset = -1;
+    int   A_bit_position_size = -1;
+
+    // Many parameters.
+    strcpy(tmp_str, "");
+    unsigned int       value_idx = 0;
+    string::size_type  idx_begin = 0;
+    string::size_type  idx_format = 0;
+    while (idx_begin < printf_format.size())
+    {
+        idx_format = printf_format.find ('%', idx_begin);
+
+        if (idx_format == string::npos)
+        {
+            strcat(tmp_str, &printf_format[idx_begin]);
+            break;
+        }
+
+        strncat(tmp_str, &printf_format[idx_begin], idx_format-idx_begin);
+        ++idx_format;
+
+        // if %%
+        if (printf_format[idx_format] == '%')
+        {
+            // This is a simple % character
+            strcat(tmp_str, "%");
+
+            idx_begin = idx_format + 1;
+            continue;
+        }
+
+        idx_begin = idx_format - 1;
+
+        M_FATAL_IF_GE (value_idx, values_to_print.size());
+
+        // 
+        idx_format = printf_format.find ('%', idx_begin+1);
+
+        if (idx_format == string::npos)
+        {
+            idx_format = printf_format.size();
+        }
+
+        char   tmp_str_format[999+1];
+        strncpy(tmp_str_format, &printf_format[idx_begin], idx_format-idx_begin);
+        tmp_str_format[idx_format-idx_begin] = '\0';
+
+        M_TRACE_DEBUG("str=" << tmp_str << "  " <<
+                      "str_format=" << tmp_str_format << "  " <<
+                      "idx_begin=" << idx_begin << "  " <<
+                      "idx_format=" << idx_format << "  " <<
+                      "value_idx=" << value_idx);
+
+        // 
+        const C_value  & value = values_to_print[value_idx];
+
+        M_COMPUTE_NEW_POSITION_OFFSET_RESULT_RHS(,value.);
+
+        if (value.get_type() == C_value::E_type_string)
+        {
+            sprintf(tmp_str+strlen(tmp_str), tmp_str_format, value.as_string().c_str());
+        }
+        else
+        {
+            // Search if %...s is specified.
+            const char  * p_format = tmp_str_format;
+            while ((*p_format != '\0') &&
+                   ((isalpha(*p_format) == 0) || (*p_format == 'l') || (*p_format == 'L')))
+            {
+                ++p_format;
+            }
+
+            if (*p_format == 's')
+            {
+                sprintf(tmp_str+strlen(tmp_str), tmp_str_format, value.as_string().c_str());
+            }
+            else if (value.get_type() == C_value::E_type_float)
+            {
+                sprintf(tmp_str+strlen(tmp_str), tmp_str_format, value.get_flt());
+            }
+            else if (value.get_type() == C_value::E_type_integer)
+            {
+                sprintf(tmp_str+strlen(tmp_str), tmp_str_format, value.get_int());
+            }
+            else if (value.get_type() == C_value::E_type_msg)
+            {
+                sprintf(tmp_str+strlen(tmp_str), tmp_str_format, value.get_msg());
+            }
+        }
+
+        // Next.
+        idx_begin = idx_format;
+        ++value_idx;
+    }
+
+    C_value  return_value(tmp_str);
+    return_value.set_bit_position_offset_size(A_bit_position_offset,
+                                              A_bit_position_size);
+
+    return  return_value;
+}
+
+//*****************************************************************************
+// Logical operators.
+// Allowed : NOT string and NOT string
+//*****************************************************************************
+bool
+C_value::operator&& (const C_value  & rhs) const
+{
+    M_FATAL_IF_EQ (    A_type, E_type_string);
+    M_FATAL_IF_EQ (rhs.A_type, E_type_string);
+
+    return  A_flt && rhs.A_flt;
+}
+
+bool
+C_value::operator|| (const C_value  & rhs) const
+{
+    M_FATAL_IF_EQ (    A_type, E_type_string);
+    M_FATAL_IF_EQ (rhs.A_type, E_type_string);
+
+    return  A_flt || rhs.A_flt;
+}
+
+//*****************************************************************************
+// Comparison operators.
+// Allowed :     string and     string
+// Allowed :     msg    and     msg                only for== and !=
+// Allowed : NOT string and NOT string
+//*****************************************************************************
+bool
+C_value::operator== (const C_value  & rhs) const
+{
+    if ((    A_type == E_type_string) ||
+        (rhs.A_type == E_type_string))
+    {
+        M_FATAL_IF_NE (A_type, rhs.A_type);
+        return  A_str == rhs.A_str;
+    }
+
+    if ((    A_type == E_type_msg) ||
+        (rhs.A_type == E_type_msg))
+    {
+        M_FATAL_IF_NE (A_type, rhs.A_type);
+        return  A_integer == rhs.A_integer;
+    }
+
+    if ((    A_type == E_type_struct) ||
+        (rhs.A_type == E_type_struct))
+    {
+        M_FATAL_COMMENT("operator == could NOT be used for struct");
+    }
+
+    if (A_type == E_type_integer)
+    {
+        if (rhs.A_type == E_type_integer)
+            return  A_integer == rhs.A_integer;
+        else
+            return  A_integer == rhs.A_flt;
+    }
+    else
+    {
+        if (rhs.A_type == E_type_integer)
+            return  A_flt == rhs.A_integer;
+        else
+            return  A_flt == rhs.A_flt;
+    }
+}
+
+bool
+C_value::operator!= (const C_value  & rhs) const
+{
+    if ((    A_type == E_type_string) ||
+        (rhs.A_type == E_type_string))
+    {
+        M_FATAL_IF_NE (A_type, rhs.A_type);
+        return  A_str != rhs.A_str;
+    }
+
+    if ((    A_type == E_type_msg) ||
+        (rhs.A_type == E_type_msg))
+    {
+        M_FATAL_IF_NE (A_type, rhs.A_type);
+        return  A_integer != rhs.A_integer;
+    }
+
+    if ((    A_type == E_type_struct) ||
+        (rhs.A_type == E_type_struct))
+    {
+        M_FATAL_COMMENT("operator != could NOT be used for struct");
+    }
+
+    if (A_type == E_type_integer)
+    {
+        if (rhs.A_type == E_type_integer)
+            return  A_integer != rhs.A_integer;
+        else
+            return  A_integer != rhs.A_flt;
+    }
+    else
+    {
+        if (rhs.A_type == E_type_integer)
+            return  A_flt != rhs.A_integer;
+        else
+            return  A_flt != rhs.A_flt;
+    }
+}
+
+bool
+C_value::operator<= (const C_value  & rhs) const
+{
+    if ((    A_type == E_type_string) ||
+        (rhs.A_type == E_type_string))
+    {
+        M_FATAL_IF_NE (A_type, rhs.A_type);
+        return  A_str <= rhs.A_str;
+    }
+
+    if ((    A_type == E_type_msg) ||
+        (rhs.A_type == E_type_msg))
+    {
+        M_FATAL_COMMENT("operator <= could NOT be used for msg");
+    }
+    if ((    A_type == E_type_struct) ||
+        (rhs.A_type == E_type_struct))
+    {
+        M_FATAL_COMMENT("operator <= could NOT be used for struct");
+    }
+
+    if (A_type == E_type_integer)
+    {
+        if (rhs.A_type == E_type_integer)
+            return  A_integer <= rhs.A_integer;
+        else
+            return  A_integer <= rhs.A_flt;
+    }
+    else
+    {
+        if (rhs.A_type == E_type_integer)
+            return  A_flt <= rhs.A_integer;
+        else
+            return  A_flt <= rhs.A_flt;
+    }
+}
+
+bool
+C_value::operator>= (const C_value  & rhs) const
+{
+    if ((    A_type == E_type_string) ||
+        (rhs.A_type == E_type_string))
+    {
+        M_FATAL_IF_NE (A_type, rhs.A_type);
+        return  A_str >= rhs.A_str;
+    }
+
+    if ((    A_type == E_type_msg) ||
+        (rhs.A_type == E_type_msg))
+    {
+        M_FATAL_COMMENT("operator >= could NOT be used for msg");
+    }
+    if ((    A_type == E_type_struct) ||
+        (rhs.A_type == E_type_struct))
+    {
+        M_FATAL_COMMENT("operator >= could NOT be used for struct");
+    }
+
+    if (A_type == E_type_integer)
+    {
+        if (rhs.A_type == E_type_integer)
+            return  A_integer >= rhs.A_integer;
+        else
+            return  A_integer >= rhs.A_flt;
+    }
+    else
+    {
+        if (rhs.A_type == E_type_integer)
+            return  A_flt >= rhs.A_integer;
+        else
+            return  A_flt >= rhs.A_flt;
+    }
+}
+
+bool
+C_value::operator< (const C_value  & rhs) const
+{
+    if ((    A_type == E_type_string) ||
+        (rhs.A_type == E_type_string))
+    {
+        M_FATAL_IF_NE (A_type, rhs.A_type);
+        return  A_str < rhs.A_str;
+    }
+
+    if ((    A_type == E_type_msg) ||
+        (rhs.A_type == E_type_msg))
+    {
+        M_FATAL_COMMENT("operator < could NOT be used for msg");
+    }
+    if ((    A_type == E_type_struct) ||
+        (rhs.A_type == E_type_struct))
+    {
+        M_FATAL_COMMENT("operator < could NOT be used for struct");
+    }
+
+    if (A_type == E_type_integer)
+    {
+        if (rhs.A_type == E_type_integer)
+            return  A_integer < rhs.A_integer;
+        else
+            return  A_integer < rhs.A_flt;
+    }
+    else
+    {
+        if (rhs.A_type == E_type_integer)
+            return  A_flt < rhs.A_integer;
+        else
+            return  A_flt < rhs.A_flt;
+    }
+}
+
+bool
+C_value::operator> (const C_value  & rhs) const
+{
+    if ((    A_type == E_type_string) ||
+        (rhs.A_type == E_type_string))
+    {
+        M_FATAL_IF_NE (A_type, rhs.A_type);
+        return  A_str > rhs.A_str;
+    }
+
+    if ((    A_type == E_type_msg) ||
+        (rhs.A_type == E_type_msg))
+    {
+        M_FATAL_COMMENT("operator > could NOT be used for msg");
+    }
+    if ((    A_type == E_type_struct) ||
+        (rhs.A_type == E_type_struct))
+    {
+        M_FATAL_COMMENT("operator > could NOT be used for struct");
+    }
+
+    if (A_type == E_type_integer)
+    {
+        if (rhs.A_type == E_type_integer)
+            return  A_integer > rhs.A_integer;
+        else
+            return  A_integer > rhs.A_flt;
+    }
+    else
+    {
+        if (rhs.A_type == E_type_integer)
+            return  A_flt > rhs.A_integer;
+        else
+            return  A_flt > rhs.A_flt;
+    }
+}
+
+
+//*****************************************************************************
+// Provides OPERATOR from OPERATOR=
+//*****************************************************************************
+
+#define M_OPERATOR_CONST_FROM_OPERATOR_EQUAL(OPERATOR)         \
+C_value                                                        \
+C_value::operator OPERATOR (const C_value  & rhs) const        \
+{                                                              \
+    C_value    left(*this);                                \
+    left OPERATOR ## = rhs;                                \
+    return  left;                                          \
+}
+
+//*****************************************************************************
+// Bit operators.
+// Allowed : integers
+//*****************************************************************************
+C_value &
+C_value::operator&= (const C_value  & rhs)
+{
+    M_FATAL_IF_NE (    A_type, E_type_integer);
+    M_FATAL_IF_NE (rhs.A_type, E_type_integer);
+
+    M_COMPUTE_NEW_POSITION_OFFSET();
+
+    *this = C_value (A_integer & rhs.A_integer);
+    return  *this;
+}
+
+C_value &
+C_value::operator|= (const C_value  & rhs)
+{
+    M_FATAL_IF_NE (    A_type, E_type_integer);
+    M_FATAL_IF_NE (rhs.A_type, E_type_integer);
+
+    M_COMPUTE_NEW_POSITION_OFFSET();
+
+    *this = C_value (A_integer | rhs.A_integer);
+    return  *this;
+}
+
+C_value &
+C_value::operator^= (const C_value  & rhs)
+{
+    M_FATAL_IF_NE (    A_type, E_type_integer);
+    M_FATAL_IF_NE (rhs.A_type, E_type_integer);
+
+    M_COMPUTE_NEW_POSITION_OFFSET();
+
+    *this = C_value (A_integer ^ rhs.A_integer);
+    return  *this;
+}
+
+C_value &
+C_value::operator<<= (const C_value  & rhs)
+{
+    M_FATAL_IF_NE (    A_type, E_type_integer);
+    M_FATAL_IF_NE (rhs.A_type, E_type_integer);
+
+    M_COMPUTE_NEW_POSITION_OFFSET();
+
+    *this = C_value (A_integer << rhs.A_integer);
+    return  *this;
+}
+
+C_value &
+C_value::operator>>= (const C_value  & rhs)
+{
+    M_FATAL_IF_NE (    A_type, E_type_integer);
+    M_FATAL_IF_NE (rhs.A_type, E_type_integer);
+
+    M_COMPUTE_NEW_POSITION_OFFSET();
+
+    *this = C_value (A_integer >> rhs.A_integer);
+    return  *this;
+}
+
+M_OPERATOR_CONST_FROM_OPERATOR_EQUAL(&)
+M_OPERATOR_CONST_FROM_OPERATOR_EQUAL(|)
+M_OPERATOR_CONST_FROM_OPERATOR_EQUAL(^)
+M_OPERATOR_CONST_FROM_OPERATOR_EQUAL(<<)
+M_OPERATOR_CONST_FROM_OPERATOR_EQUAL(>>)
+
+//*****************************************************************************
+// Arithmetic operators.
+// Allowed : NOT string, NOT msg and NOT string, NOT msg
+// + : string  and string  ok
+// % : integer and integer only
+//*****************************************************************************
+C_value &
+C_value::operator+= (const C_value  & rhs)
+{
+    M_COMPUTE_NEW_POSITION_OFFSET();
+
+    if ((    A_type == E_type_string) ||
+        (rhs.A_type == E_type_string))
+    {
+        M_FATAL_IF_NE (A_type, rhs.A_type);
+        *this = C_value (A_str + rhs.A_str);
+        return  *this;
+    }
+
+    if ((    A_type == E_type_msg) ||
+        (rhs.A_type == E_type_msg))
+    {
+        M_FATAL_COMMENT("operator += could NOT be used for msg");
+    }
+    if ((    A_type == E_type_struct) ||
+        (rhs.A_type == E_type_struct))
+    {
+        M_FATAL_COMMENT("operator += could NOT be used for struct");
+    }
+
+    if (A_type == E_type_integer)
+    {
+        if (rhs.A_type == E_type_integer)
+            *this = C_value (A_integer + rhs.A_integer);
+        else
+            *this = C_value (A_integer + rhs.A_flt);
+    }
+    else
+    {
+        if (rhs.A_type == E_type_integer)
+            *this = C_value (A_flt + rhs.A_integer);
+        else
+            *this = C_value (A_flt + rhs.A_flt);
+    }
+
+    return  *this;
+}
+
+C_value &
+C_value::operator-= (const C_value  & rhs)
+{
+    if ((    A_type == E_type_string) ||
+        (rhs.A_type == E_type_string))
+    {
+        M_FATAL_COMMENT("operator -= could NOT be used for string");
+    }
+    if ((    A_type == E_type_msg) ||
+        (rhs.A_type == E_type_msg))
+    {
+        M_FATAL_COMMENT("operator -= could NOT be used for msg");
+    }
+    if ((    A_type == E_type_struct) ||
+        (rhs.A_type == E_type_struct))
+    {
+        M_FATAL_COMMENT("operator -= could NOT be used for struct");
+    }
+
+    M_COMPUTE_NEW_POSITION_OFFSET();
+
+    if (A_type == E_type_integer)
+    {
+        if (rhs.A_type == E_type_integer)
+            *this = C_value (A_integer - rhs.A_integer);
+        else
+            *this = C_value (A_integer - rhs.A_flt);
+    }
+    else
+    {
+        if (rhs.A_type == E_type_integer)
+            *this = C_value (A_flt - rhs.A_integer);
+        else
+            *this = C_value (A_flt - rhs.A_flt);
+    }
+
+    return  *this;
+}
+
+C_value &
+C_value::operator*= (const C_value  & rhs)
+{
+    if ((    A_type == E_type_string) ||
+        (rhs.A_type == E_type_string))
+    {
+        M_FATAL_COMMENT("operator *= could NOT be used for string");
+    }
+    if ((    A_type == E_type_msg) ||
+        (rhs.A_type == E_type_msg))
+    {
+        M_FATAL_COMMENT("operator *= could NOT be used for msg");
+    }
+    if ((    A_type == E_type_struct) ||
+        (rhs.A_type == E_type_struct))
+    {
+        M_FATAL_COMMENT("operator *= could NOT be used for struct");
+    }
+
+    M_COMPUTE_NEW_POSITION_OFFSET();
+
+    if (A_type == E_type_integer)
+    {
+        if (rhs.A_type == E_type_integer)
+            *this = C_value (A_integer * rhs.A_integer);
+        else
+            *this = C_value (A_integer * rhs.A_flt);
+    }
+    else
+    {
+        if (rhs.A_type == E_type_integer)
+            *this = C_value (A_flt * rhs.A_integer);
+        else
+            *this = C_value (A_flt * rhs.A_flt);
+    }
+
+    return  *this;
+}
+#if 0
+C_value &
+C_value::operator/= (const C_value  & rhs)
+{
+    if ((    A_type == E_type_string) ||
+        (rhs.A_type == E_type_string))
+    {
+        M_FATAL_COMMENT("operator /= could NOT be used for string");
+    }
+    if ((    A_type == E_type_msg) ||
+        (rhs.A_type == E_type_msg))
+    {
+        M_FATAL_COMMENT("operator /= could NOT be used for msg");
+    }
+    if ((    A_type == E_type_struct) ||
+        (rhs.A_type == E_type_struct))
+    {
+        M_FATAL_COMMENT("operator /= could NOT be used for struct");
+    }
+
+    M_COMPUTE_NEW_POSITION_OFFSET();
+#if 0
+    // All divide must give float ?
+    *this = C_value (A_flt / rhs.A_flt);
+#else
+    if (A_type == E_type_integer)
+    {
+        if (rhs.A_type == E_type_integer)
+            *this = C_value (A_integer / rhs.A_integer);
+        else
+            *this = C_value (A_integer / rhs.A_flt);
+    }
+    else
+    {
+        if (rhs.A_type == E_type_integer)
+            *this = C_value (A_flt / rhs.A_integer);
+        else
+            *this = C_value (A_flt / rhs.A_flt);
+    }
+#endif
+    return  *this;
+}
+#endif
+
+C_value &
+C_value::operator%= (const C_value  & rhs)
+{
+    M_FATAL_IF_NE (    A_type, E_type_integer);
+    M_FATAL_IF_NE (rhs.A_type, E_type_integer);
+
+    M_COMPUTE_NEW_POSITION_OFFSET();
+
+    *this = C_value (A_integer % rhs.A_integer);
+
+    return  *this;
+}
+
+M_OPERATOR_CONST_FROM_OPERATOR_EQUAL(+)
+M_OPERATOR_CONST_FROM_OPERATOR_EQUAL(-)
+M_OPERATOR_CONST_FROM_OPERATOR_EQUAL(*)
+//M_OPERATOR_CONST_FROM_OPERATOR_EQUAL(/)
+M_OPERATOR_CONST_FROM_OPERATOR_EQUAL(%)
+
+C_value &
+C_value::this_divide_float (const C_value  & rhs)
+{
+    if ((    A_type == E_type_string) ||
+        (rhs.A_type == E_type_string))
+    {
+        M_FATAL_COMMENT("operator /= could NOT be used for string");
+    }
+    if ((    A_type == E_type_msg) ||
+        (rhs.A_type == E_type_msg))
+    {
+        M_FATAL_COMMENT("operator /= could NOT be used for msg");
+    }
+    if ((    A_type == E_type_struct) ||
+        (rhs.A_type == E_type_struct))
+    {
+        M_FATAL_COMMENT("operator /= could NOT be used for struct");
+    }
+
+    M_COMPUTE_NEW_POSITION_OFFSET();
+
+    // All divide must give float ?
+    *this = C_value (A_flt / rhs.A_flt);
+
+    return  *this;
+}
+
+C_value &
+C_value::this_divide_c (const C_value  & rhs)
+{
+    if ((    A_type == E_type_string) ||
+        (rhs.A_type == E_type_string))
+    {
+        M_FATAL_COMMENT("operator /= could NOT be used for string");
+    }
+    if ((    A_type == E_type_msg) ||
+        (rhs.A_type == E_type_msg))
+    {
+        M_FATAL_COMMENT("operator /= could NOT be used for msg");
+    }
+    if ((    A_type == E_type_struct) ||
+        (rhs.A_type == E_type_struct))
+    {
+        M_FATAL_COMMENT("operator /= could NOT be used for struct");
+    }
+
+    M_COMPUTE_NEW_POSITION_OFFSET();
+
+    if (A_type == E_type_integer)
+    {
+        if (rhs.A_type == E_type_integer)
+            *this = C_value (A_integer / rhs.A_integer);
+        else
+            *this = C_value (A_integer / rhs.A_flt);
+    }
+    else
+    {
+        if (rhs.A_type == E_type_integer)
+            *this = C_value (A_flt / rhs.A_integer);
+        else
+            *this = C_value (A_flt / rhs.A_flt);
+    }
+
+    return  *this;
+}
+
+C_value
+C_value::divide_float (const C_value  & lhs, const C_value  & rhs)
+{
+    C_value  value = lhs;
+    value.this_divide_float(rhs);
+
+    return  value;
+}
+C_value
+C_value::divide_c (const C_value  & lhs, const C_value  & rhs)
+{
+    C_value  value = lhs;
+    value.this_divide_c(rhs);
+
+    return  value;
+}
+
+//*****************************************************************************
+// Pow.
+// Allowed : NOT string and NOT string
+//*****************************************************************************
+C_value
+C_value::pow_internal(const C_value  & lhs, const C_value  & rhs)
+{
+    if ((lhs.A_type == E_type_string) ||
+        (rhs.A_type == E_type_string))
+    {
+        M_FATAL_COMMENT("operator ** could NOT be used for string");
+    }
+    if ((lhs.A_type == E_type_msg) ||
+        (rhs.A_type == E_type_msg))
+    {
+        M_FATAL_COMMENT("operator ** could NOT be used for msg");
+    }
+    if ((lhs.A_type == E_type_struct) ||
+        (rhs.A_type == E_type_struct))
+    {
+        M_FATAL_COMMENT("operator ** could NOT be used for struct");
+    }
+
+    double  pow_val = 0.0;
+
+    if (lhs.A_type == E_type_integer)
+    {
+        if (rhs.A_type == E_type_integer)
+        {
+            pow_val = ::pow (static_cast<double>(lhs.A_integer), static_cast<int>(rhs.A_integer));
+            return  static_cast<long long>(pow_val);
+        }
+        else
+            pow_val = ::pow (static_cast<double>(lhs.A_integer), rhs.A_flt);
+    }
+    else
+    {
+        if (rhs.A_type == E_type_integer)
+            pow_val = ::pow (lhs.A_flt, static_cast<int>(rhs.A_integer));
+        else
+            pow_val = ::pow (lhs.A_flt, rhs.A_flt);
+    }
+
+    return  pow_val;
+}
+C_value
+C_value::pow(const C_value  & lhs, const C_value  & rhs)
+{
+    C_value  val = pow_internal(lhs, rhs);
+
+    M_COMPUTE_NEW_POSITION_OFFSET_RESULT_RHS(val., rhs.);
+
+    return  val;
+}
diff --git a/plugins/epan/generic/C_value.h b/plugins/epan/generic/C_value.h
new file mode 100644
index 00000000000..225f64062e6
--- /dev/null
+++ b/plugins/epan/generic/C_value.h
@@ -0,0 +1,218 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef C_VALUE_H
+#define C_VALUE_H
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <string>
+#include <vector>
+
+#include "CT_debug_object_counter.h"
+
+// ****************************************************************************
+// C_value
+// - contains a value of a given type : integer, float, string or msg
+// - conversions between types (when possible)
+// - arithmetic operations (when possible)
+// - logical comparisons (when possible)
+// ****************************************************************************
+
+struct C_value : public CT_debug_object_counter<C_value>
+{
+    enum E_type
+    {
+        E_type_integer,
+        E_type_float,
+        E_type_string,
+        E_type_msg,        // not a simple type
+        E_type_struct      // not a simple type, not used ?
+    };
+
+    typedef const void *    T_msg;
+
+    C_value ();
+    C_value (const E_type               type);
+
+    C_value (const E_type               type,
+                   T_msg                msg);
+
+    // bool will be managed as an integer.
+    C_value (const bool                 boolean);
+
+    C_value (const          char        integer);
+    C_value (const   signed char        integer);
+    C_value (const unsigned char        integer);
+    C_value (const   signed short       integer);
+    C_value (const unsigned short       integer);
+    C_value (const   signed int         integer);
+    C_value (const unsigned int         integer);
+    C_value (const   signed long        integer);
+    C_value (const unsigned long        integer);
+    C_value (const   signed long long   integer);
+    C_value (const unsigned long long   integer);
+
+    C_value (const float                flt);
+    C_value (const double               flt);
+
+    C_value (const std::string        & str);
+    C_value (const char               * str);
+
+    // Assignment operator
+    C_value &  operator=(const C_value  & rhs);
+
+    // Type of the value
+    E_type               get_type () const { return  A_type; }
+    bool                 is_numeric () const { return  A_type <= E_type_float; }
+
+    // At this time :
+    // Only set the external basic type (uint3, float32, string(7) ...)
+    // The type itself is not modified
+    void                 set_external_type(const std::string  & external_type);
+//    const std::string  & get_external_type ()  const;
+    bool                 get_external_type_signed ()  const;
+    int                  get_external_type_bit_size ()  const;
+    int                  get_external_type_byte_size ()  const;
+    void                 set_external_type_bit_size(int    external_type_bit_size);
+
+    // Fatal if internal type does not match.
+    long long            get_int ()  const;
+    std::size_t          get_int_size_t()  const;  // fatal if value exceeds size_t limits
+    int                  get_int_int()  const;     // fatal if value exceeds int limits
+    bool                 get_bool () const;     // internal type must be integer
+    double               get_flt ()  const;
+    const std::string  & get_str ()  const;
+    T_msg                get_msg ()  const;
+
+    // Returns the internal string.
+    const std::string  & as_string () const;
+
+    // Transform the type of value to a string.
+    void                 convert_to_string ()       { A_type = E_type_string; }
+
+    // Transform the type of value to a numeric type.
+    // Fatal if not possible.
+    void                 convert_to_numeric ();
+    void                 convert_to_int (int  base = 0);
+    void                 convert_to_float ();
+
+    // Try to apply format to the value.
+    // Only str modified.
+    void                 format(const std::string  & display);
+
+    // Re-initialise string without format.
+    // Nothing done for a string value.
+    void                 format_reset();
+
+    static
+    C_value              sprintf_values(const std::string           & printf_format,
+                                        const std::vector<C_value>  & values_to_print);
+
+    // Only str modified.
+    // Type and other values NOT modified.
+    void                 set_str(const std::string  & str);
+
+    // Try to promote to numeric type.
+    // Returns the new type.
+    E_type               promote();
+
+    // Position offset and size (unit = bit).
+    void    set_bit_position_offset_size(int  offset, int  size);
+    int     get_bit_position_offset() const   { return  A_bit_position_offset; }
+    int     get_bit_position_size() const     { return  A_bit_position_size; }
+
+    // Logical operators.
+    bool       operator&& (const C_value  & rhs) const;
+    bool       operator|| (const C_value  & rhs) const;
+
+    // Comparison operators.
+    bool       operator== (const C_value  & rhs) const;
+    bool       operator!= (const C_value  & rhs) const;
+    bool       operator<= (const C_value  & rhs) const;
+    bool       operator>= (const C_value  & rhs) const;
+    bool       operator<  (const C_value  & rhs) const;
+    bool       operator>  (const C_value  & rhs) const;
+
+    // Bit operators.
+    C_value    operator&  (const C_value  & rhs) const;
+    C_value    operator|  (const C_value  & rhs) const;
+    C_value    operator^  (const C_value  & rhs) const;
+    C_value    operator<< (const C_value  & rhs) const;
+    C_value    operator>> (const C_value  & rhs) const;
+
+    // Arithmetic operators.
+    C_value    operator+  (const C_value  & rhs) const;
+    C_value    operator-  (const C_value  & rhs) const;
+    C_value    operator*  (const C_value  & rhs) const;
+//    C_value    operator/  (const C_value  & rhs) const;
+    C_value    operator%  (const C_value  & rhs) const;
+
+    static
+    C_value    divide_float(const C_value  & lhs, const C_value  & rhs);
+    static
+    C_value    divide_c(const C_value  & lhs, const C_value  & rhs);
+    static
+    C_value    pow(const C_value  & lhs, const C_value  & rhs);
+
+    // OPERATOR= versions.
+    C_value &  operator&= (const C_value  & rhs);
+    C_value &  operator|= (const C_value  & rhs);
+    C_value &  operator^= (const C_value  & rhs);
+    C_value &  operator<<= (const C_value  & rhs);
+    C_value &  operator>>= (const C_value  & rhs);
+    C_value &  operator+= (const C_value  & rhs);
+    C_value &  operator-= (const C_value  & rhs);
+    C_value &  operator*= (const C_value  & rhs);
+//    C_value &  operator/= (const C_value  & rhs);
+    C_value &  operator%= (const C_value  & rhs);
+
+    C_value &  this_divide_float(const C_value  & rhs);
+    C_value &  this_divide_c(const C_value  & rhs);
+
+
+private:
+    static
+    C_value    pow_internal(const C_value  & lhs, const C_value  & rhs);
+
+    // Sizeof std::string = 28 bytes  for VCEE2008 & 32bits
+    // Sizeof             = 4 + 4 + 8 + 8 + 28 + 4 + 4 = 60 bytes != 64
+
+    // Sizeof std::string = 40 bytes  for VCEE2008 & 64bits
+    // Sizeof             = 4 + 4 + 8 + 8 + 40 + 4 + 4 = 72 bytes
+
+    E_type         A_type;
+    int            A_external_type_bit_size__cvtbd;
+//    std::string    A_external_type__cvtbd;
+    long long      A_integer;
+    double         A_flt;
+    std::string    A_str;
+
+    int            A_bit_position_offset;
+    int            A_bit_position_size;
+
+    friend std::ostream &  operator<< (std::ostream  & os, const C_value        & rhs);
+};
+
+std::ostream &  operator<< (std::ostream  & os, const C_value::E_type  type);
+std::ostream &  operator<< (std::ostream  & os, const C_value        & rhs);
+
+
+#endif /* C_VALUE_H */
diff --git a/plugins/epan/generic/F_common_print.h b/plugins/epan/generic/F_common_print.h
new file mode 100644
index 00000000000..dce34b4ceaa
--- /dev/null
+++ b/plugins/epan/generic/F_common_print.h
@@ -0,0 +1,211 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//!@n      Provides functions to print (for debug purpose) data.
+//!@n      Add a prefix at the beginning of the output.
+//!@n  
+//!@n      - print template function which use ostream & operator<<.
+//!@n      - M_PRINT_ATTRIBUT to print an object attribute.
+//!@n  
+//!@n  Important              : 
+//!@n      If a class TYPE provides a print method, you must define a print
+//!@n       function (for this TYPE) which calls the corresponding print
+//!@n       method.
+
+#ifndef F_COMMON_PRINT_H
+#define F_COMMON_PRINT_H
+
+//*****************************************************************************
+// Includes
+//*****************************************************************************
+
+#include <iostream>
+#include <string>
+#include <map>
+#include <vector>
+#include <list>
+
+using namespace std;
+
+
+//*****************************************************************************
+//    Name      : print
+//!@n Role      : output the in_line_prefix and the specified object on the
+//!@n              specified stream.
+//!@n             Works for any type which works with ostream & operator<<.
+//!@n Important : 
+//!@n  To have a well printed format (i.e. in_line_prefix appears at the
+//!@n   beginning of EACH line), this function must be redefined for any class
+//!@n   which implement a print method.
+//!@n
+//!@n  ATTENTION, an operator<< on a given TYPE must NOT call the print 
+//!@n   function with TYPE parameter if this function has not been redefined.
+// Example, the following function implementation :
+// ostream &  operator<< (ostream & os, const TYPE & rhs)
+// {
+//     return  print (os, rhs, "");
+// }
+//  is FORBIDDEN if ostream & print (ostream &, const TYPE &, const string &)
+//  is NOT defined.
+//*****************************************************************************
+template <class TYPE>
+inline
+ostream &
+print     (      ostream              & in_out_os,
+           const TYPE                 & in_right,
+           const string               & in_line_prefix)
+{
+    in_out_os << in_line_prefix;
+    in_out_os << in_right;
+    in_out_os << endl;
+    return  in_out_os;
+}
+
+
+//*****************************************************************************
+//    Name      : print_container
+//!@n Role      : Print a container with STL compliant interface.
+//!@n Important : 
+//*****************************************************************************
+template <class TYPE>
+inline
+ostream &
+print_container (      ostream       & os,
+                 const TYPE          & rhs,
+                 const string        & in_line_prefix)
+{
+    typename TYPE::const_iterator  iter;
+    for (  iter  = rhs.begin ();
+           iter != rhs.end ();
+         ++iter)
+    {
+        print (os, *iter, in_line_prefix);
+    }
+
+    return  os;
+}
+
+
+//*****************************************************************************
+//    Name      : print
+//!@n Role      : Specialized version for bool.
+//!@n Important :
+//*****************************************************************************
+template <>
+inline
+ostream &
+print (      ostream       & os,
+       const bool          & rhs,
+       const string        & in_line_prefix)
+{
+    const char *  bool_str = rhs == false ? "false" : "true";
+    return  print (os, bool_str, in_line_prefix);
+}
+
+
+//*****************************************************************************
+//    Name      : print
+//!@n Role      : Specialized version for vector.
+//!@n Important : 
+//*****************************************************************************
+template <class TYPE>
+inline
+ostream &
+print (      ostream       & os,
+       const vector<TYPE>  & rhs,
+       const string        & in_line_prefix)
+{
+    return  print_container (os, rhs, in_line_prefix);
+}
+
+
+//*****************************************************************************
+//    Name      : print
+//!@n Role      : Specialized version for list.
+//!@n Important : 
+//*****************************************************************************
+template <class TYPE>
+inline
+ostream &
+print (      ostream     & os,
+       const list<TYPE>  & rhs,
+       const string      & in_line_prefix)
+{
+    return  print_container (os, rhs, in_line_prefix);
+}
+
+
+//*****************************************************************************
+//    Name      : print
+//!@n Role      : Specialized version for pair<const KEY, VAL> (map element).
+//!@n Important : 
+//*****************************************************************************
+template <class KEY, class VAL>
+inline
+ostream &
+print (      ostream               & os,
+       const pair<const KEY, VAL>  & rhs,
+       const string                & in_line_prefix)
+{
+    ostringstream    oss;
+    oss << in_line_prefix << rhs.first << " : ";
+    return  print (os, rhs.second , oss.str ());
+}
+
+
+
+//*****************************************************************************
+//    Name      : print
+//!@n Role      : Specialized version for map.
+//!@n Important : 
+//*****************************************************************************
+template <class TYPE_ELT,
+          class TYPE_DATA>
+inline
+ostream &
+print (      ostream                  & os,
+       const map<TYPE_ELT,TYPE_DATA>  & rhs,
+       const string                   & in_line_prefix)
+{
+    return  print_container (os, rhs, in_line_prefix);
+}
+
+
+//*****************************************************************************
+//    Name      : M_PRINT_ATTRIBUT
+//!@n Role      : Call the print function with a line prefix = 
+//!@n              in_line_prefix + <attribut name> " => "
+//!@n Important : Used ONLY into a print method.
+//*****************************************************************************
+
+#define M_PRINT_ATTRIBUT(in_out_os,ATTRIBUT,in_line_prefix)                   \
+    ::print (in_out_os, ATTRIBUT, in_line_prefix + #ATTRIBUT " => ")
+
+
+//*****************************************************************************
+//    Name      : M_PRINT_INSIDE_ATTRIBUT
+//!@n Role      : Idem previous for a private type (with print method inside
+//!@n              the class itself.
+//!@n Important : Used ONLY into a print method.
+//*****************************************************************************
+
+#define M_PRINT_INSIDE_ATTRIBUT(in_out_os,ATTRIBUT,in_line_prefix)           \
+    print (in_out_os, ATTRIBUT, in_line_prefix + #ATTRIBUT " => ")
+
+
+#endif /* F_COMMON_PRINT_H */
diff --git a/plugins/epan/generic/T_attribute_value.cpp b/plugins/epan/generic/T_attribute_value.cpp
new file mode 100644
index 00000000000..22aa6b8e71e
--- /dev/null
+++ b/plugins/epan/generic/T_attribute_value.cpp
@@ -0,0 +1,206 @@
+/*
+ * Copyright 2008-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "T_attribute_value.h"
+using namespace std;
+
+
+//*****************************************************************************
+// T_attribute_value
+//*****************************************************************************
+
+T_attribute_value::T_attribute_value()
+    :transformed(""),
+     P_error(nullptr)
+{
+    original = transformed.as_string();
+}
+
+void
+T_attribute_value::reset()
+{
+    transformed = C_value("");
+    P_error = nullptr;
+    original = transformed.as_string();
+}
+
+T_attribute_value::T_attribute_value(const C_value  & value)
+    :transformed(value),
+     P_error(nullptr)
+{
+    original = transformed.as_string();
+}
+
+void
+T_attribute_value::reset(const C_value  & value)
+{
+    transformed = value;
+    P_error = nullptr;
+    original = transformed.as_string();
+}
+
+T_attribute_value::T_attribute_value(const T_attribute_value  & rhs)
+    :CT_debug_object_counter<T_attribute_value>(rhs),
+     transformed(rhs.transformed),
+     P_error(nullptr),
+     original(rhs.original)
+{
+    if (rhs.P_error != nullptr)
+    {
+        P_error = new string(*rhs.P_error);
+    }
+}
+
+T_attribute_value&
+T_attribute_value::operator=(const T_attribute_value  & rhs)
+{
+    transformed = rhs.transformed;
+    original = rhs.original;
+
+    if (rhs.P_error != P_error)
+    {
+        if (P_error != nullptr)
+        {
+            delete P_error;
+            P_error = nullptr;
+        }
+        if (rhs.P_error != nullptr)
+        {
+            P_error = new string(*rhs.P_error);
+        }
+    }
+
+    return  *this;
+}
+
+T_attribute_value::~T_attribute_value()
+{
+    if (P_error != nullptr)
+    {
+        delete P_error;
+        P_error = nullptr;
+    }
+}
+
+//*****************************************************************************
+// set_error
+//*****************************************************************************
+void
+T_attribute_value::set_error(const std::string  & in_error)
+{
+    if (P_error != nullptr)
+    {
+        delete P_error;
+        P_error = nullptr;
+    }
+
+    if (in_error.empty() == false)
+    {
+        P_error = new string(in_error);
+    }
+}
+
+//*****************************************************************************
+// set_value_transformed
+//*****************************************************************************
+void
+T_attribute_value::set_value_transformed(const C_value&  value)
+{
+    transformed = value;
+}
+
+//*****************************************************************************
+// set_value_original
+//*****************************************************************************
+void
+T_attribute_value::set_value_original(const C_value&  value)
+{
+    transformed = value;
+
+    original = transformed.as_string();
+}
+
+//*****************************************************************************
+// set_value_original_format_reset
+//*****************************************************************************
+void
+T_attribute_value::set_value_original_format_reset(const C_value&  value)
+{
+    transformed = value;
+
+    {
+        C_value  original_value = transformed;
+
+        // normalize the string original
+        original_value.format_reset();
+
+        original = original_value.as_string();
+    }
+}
+
+//*****************************************************************************
+// change_value_str_only
+//*****************************************************************************
+void
+T_attribute_value::change_value_str_only(const string &  new_str)
+{
+    transformed.set_str(new_str);
+}
+
+//*****************************************************************************
+// set_bit_position_offset_size
+//*****************************************************************************
+void
+T_attribute_value::set_bit_position_offset_size(int  offset, int  size)
+{
+    transformed.set_bit_position_offset_size(offset, size);
+}
+
+//*****************************************************************************
+// swap
+//*****************************************************************************
+
+void    swap(T_attribute_value  & lhs,
+             T_attribute_value  & rhs)
+{
+    swap(lhs.transformed, rhs.transformed);
+    swap(lhs.P_error,     rhs.P_error);
+    swap(lhs.original,    rhs.original);
+}
+
+//*****************************************************************************
+// attribute_value_to_string
+//*****************************************************************************
+
+string    attribute_value_to_string (const T_attribute_value  & attribute_value)
+{
+    string    value_str = attribute_value.transformed.as_string();
+
+    if (attribute_value.original != attribute_value.transformed.as_string())
+        value_str += " (" + attribute_value.original + ")";
+
+    if (attribute_value.P_error != nullptr)
+        value_str += "\t" + *attribute_value.P_error;
+
+    return  value_str;
+}
diff --git a/plugins/epan/generic/T_attribute_value.h b/plugins/epan/generic/T_attribute_value.h
new file mode 100644
index 00000000000..dcdd7dee44c
--- /dev/null
+++ b/plugins/epan/generic/T_attribute_value.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2008-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_attribute_value_h
+#define T_attribute_value_h
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "C_value.h"
+#include <string>
+
+#include "byte_interpret_common.h"
+
+//*****************************************************************************
+// T_attribute_value
+//*****************************************************************************
+
+struct T_attribute_value : public CT_debug_object_counter<T_attribute_value>
+{
+public:
+    const C_value&  get_value() const                { return  transformed; }
+
+    // set value as a transformed value (so original is not modified)
+    void            set_value_transformed(const C_value&  value);
+
+    // set value as an original value
+    void            set_value_original(const C_value&  value);
+
+    // set value as an original value and reset string format
+    void            set_value_original_format_reset(const C_value&  value);
+
+    // Only change the string of the value
+    void            change_value_str_only(const string &  new_str);
+
+    // error text (unknow enum value, constraints ...)
+    void    set_error(const std::string  & in_error);
+    bool    has_error() const                        { return  (P_error != nullptr); }
+    const std::string *  get_P_error() const         { return  P_error; }
+
+    void    set_bit_position_offset_size(int  offset, int  size);
+
+    T_attribute_value();
+    T_attribute_value(const C_value  & value);
+
+    T_attribute_value(const T_attribute_value  & rhs);
+    T_attribute_value&  operator=(const T_attribute_value  & rhs);
+    ~T_attribute_value();
+
+    void    reset();
+    void    reset(const C_value  & value);
+
+private:
+    // VCEE2008 & 32bits
+    // Sizeof = 64 + 4 + 28 =  96 bytes
+
+    // VCEE2008 & 64bits
+    // Sizeof = 72 + 8 + 40 = 120 bytes
+
+    // enum : symbolic name
+    // int  : after quantum,offset
+    // int  : after hex, oct ip
+    C_value    transformed;
+
+    // error text (unknow enum value, constraints ...)
+    // Pointer permits to use less memory (when there is no error)
+    std::string   * P_error;
+
+    // the original value read
+    std::string     original;
+
+    friend void    swap(T_attribute_value  & lhs,
+                        T_attribute_value  & rhs);
+
+    friend std::string    attribute_value_to_string (const T_attribute_value  & attribute_value);
+};
+
+void    swap(T_attribute_value  & lhs,
+             T_attribute_value  & rhs);
+
+
+std::string    attribute_value_to_string (const T_attribute_value  & attribute_value);
+
+
+#endif /* T_attribute_value_h */
diff --git a/plugins/epan/generic/T_expression.cpp b/plugins/epan/generic/T_expression.cpp
new file mode 100644
index 00000000000..e58380161c2
--- /dev/null
+++ b/plugins/epan/generic/T_expression.cpp
@@ -0,0 +1,1600 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "T_expression.h"
+#include "byte_interpret_parse.h"
+#include "T_type_definitions.h"
+
+// FRHED needs this after previous include to find "std::find" !
+#include <algorithm>
+using namespace std;
+
+
+
+string    words_to_string(const vector<string>::const_iterator      & iter_begin,
+                          const vector<string>::const_iterator      & iter_end);
+string    words_to_string(const vector<string>      & words);
+
+E_return_code    get_complex_value (const T_type_definitions  & type_definitions,
+                                    const T_interpret_data    & interpret_data,
+                                    const string              & value_str,
+                                          C_value             & value);
+
+#if 1
+// ICIOA put this into another file
+//*****************************************************************************
+// date
+//*****************************************************************************
+
+#if 0
+void     date_get_year_from_days(int    ref_year,
+                                 int    number_of_days,
+                                 int  & year,
+                                 int  & number_of_days_in_year)
+{
+    year = -1;
+
+    if (ref_year < 1583)
+    {
+        return;  // ICIOA, exception
+    }
+    if (number_of_days < 0)
+    {
+        return;  // ICIOA, exception
+    }
+
+    year = ref_year;
+    number_of_days_in_year = number_of_days;
+    while (1)
+    {
+        const int  days_in_year = (year % 4) ? 365 : 366;  // ICIOA approximation
+        if (number_of_days_in_year < days_in_year)
+        {
+            break;
+        }
+
+        number_of_days_in_year -= days_in_year;
+        ++year;
+    }
+}
+
+void     date_get_year_from_seconds(int          ref_year,
+                                    long long    number_of_seconds,
+                                    int        & year,
+                                    long long  & number_of_seconds_in_year)
+{
+    year = -1;
+
+    if (ref_year < 1583)
+    {
+        return;  // ICIOA, exception
+    }
+    if (number_of_seconds < 0)
+    {
+        return;  // ICIOA, exception
+    }
+
+    long long    sec = number_of_seconds % (3600 * 24);
+    int          number_of_days = (number_of_seconds - sec) / (3600 * 24);
+    int          number_of_days_in_year = 0;
+
+    date_get_year_from_days(ref_year, number_of_days, 
+                            year, number_of_days_in_year);
+
+    number_of_seconds_in_year = sec + (number_of_days_in_year * (3600 * 24));
+}
+#endif
+//void     date.get_month_from_year_days    (in uint16{min=1583} year, in uint16 number_of_days_in_year   , out uint8 month, out uint8 day)");
+//void     date.get_month_from_year_seconds (in uint16{min=1583} year, in uint32 number_of_seconds_in_year, out uint8 month, out uint8 day, out uint32 number_of_seconds_in_day)");
+
+//*****************************************************************************
+// date_is_bissextile
+//*****************************************************************************
+
+bool  date_is_bissextile(int year)
+{
+    if (year < 1583)
+    {
+        return  "Year must be >= 1583";  // ICIOA, exception
+    }
+
+    // year must be :
+    // - multiple of 4       AND
+    // - not multiple of 100  OR multiple of 400
+    return  (((year % 4) == 0) && (((year % 100) != 0) || ((year % 400) == 0)));
+}
+
+//*****************************************************************************
+// date_get_string_from_days
+//*****************************************************************************
+
+string  date_get_string_from_days(int ref_year, int  number_of_days)
+{
+    if (ref_year < 1583)
+    {
+        return  "Reference year must be >= 1583";  // ICIOA, exception
+    }
+    if (number_of_days < 0)
+    {
+        return  "Number of days must be >= 0";  // ICIOA, exception
+    }
+
+    int  value_work = number_of_days;
+
+    // Compute year (and remaining days)
+    int   year = ref_year;
+    while (1)
+    {
+        const int  days_in_year = date_is_bissextile(year) ? 366 : 365;
+        if (value_work < days_in_year)
+        {
+            break;
+        }
+
+        value_work -= days_in_year;
+        ++year;
+    }
+
+    // Compute month (and remaining days)
+    int   month = 1;
+    while (1)
+    {
+        if (value_work < 31)  { break; }
+        value_work -= 31;
+        ++month;
+
+        if (date_is_bissextile(year) == true)
+        {
+            if (value_work < 29)  { break; }
+            value_work -= 29;
+            ++month;
+        }
+        else
+        {
+          if (value_work < 28)  { break; }
+          value_work -= 28;
+            ++month;
+        }
+        if (value_work < 31)  { break; }
+        value_work -= 31;
+        ++month;
+
+        if (value_work < 30)  { break; }
+        value_work -= 30;
+        ++month;
+
+        if (value_work < 31)  { break; }
+        value_work -= 31;
+        ++month;
+
+        if (value_work < 30)  { break; }
+        value_work -= 30;
+        ++month;
+
+        if (value_work < 31)  { break; }
+        value_work -= 31;
+        ++month;
+
+        if (value_work < 31)  { break; }
+        value_work -= 31;
+        ++month;
+
+        if (value_work < 30)  { break; }
+        value_work -= 30;
+        ++month;
+
+        if (value_work < 31)  { break; }
+        value_work -= 31;
+        ++month;
+
+        if (value_work < 30)  { break; }
+        value_work -= 30;
+        ++month;
+
+        if (value_work < 31)  { break; }
+        value_work -= 31;
+        ++month;
+    }
+
+    int  day = value_work + 1;
+
+    char  str[99+1];
+    sprintf(str, "%d/%02d/%02d", year, month, day);
+
+    return  str;
+}
+
+//*****************************************************************************
+// date_get_string_from_seconds
+//*****************************************************************************
+
+string  date_get_string_from_seconds(int ref_year, long long  number_of_seconds)
+{
+    if (number_of_seconds < 0)
+    {
+        return  "Number of seconds must be >= 0";  // ICIOA, exception
+    }
+
+    const int        seconds = number_of_seconds % 60;
+    const long long  number_of_minutes = (number_of_seconds - seconds) / 60;
+
+    const int        minutes = number_of_minutes % 60;
+    const long long  number_of_hours = (number_of_minutes - minutes) / 60;
+
+    const int        hours = number_of_hours % 24;
+    const long long  days = (number_of_hours - hours) / 24;
+
+    string  str = date_get_string_from_days(ref_year, static_cast<int>(days));
+
+    {
+        char  str_tmp[99+1];
+        sprintf(str_tmp, " %02d:%02d:%02d", hours, minutes, seconds);
+        str += str_tmp;
+    }
+
+    return  str;
+}
+#endif
+
+//*****************************************************************************
+// Constructor
+//*****************************************************************************
+
+T_expression::T_expression()
+    :A_value_alreay_computed(false),
+     A_type(E_type_none),
+     A_operation(E_operation_none)
+{
+}
+
+//*****************************************************************************
+// get_variable_name
+//*****************************************************************************
+const std::string  &
+T_expression::get_variable_name() const
+{
+    M_FATAL_IF_FALSE(is_a_variable());
+
+    return  A_variable_or_function_name;    // ICIOA array -> reduced !!!
+}
+
+//*****************************************************************************
+// build_expression_words
+//*****************************************************************************
+void
+T_expression::build_expression_words(
+                         const T_type_definitions        & type_definitions,
+                         const std::vector<std::string>  & words)
+{
+    if (A_original_string_expression.empty())
+    {
+        for (string::size_type  idx = 0; idx < words.size (); ++idx)
+        {
+            A_original_string_expression += words[idx];
+            A_original_string_expression += " ";
+        }
+    }
+
+    vector<string>::const_iterator  iter;
+    vector<string>::const_iterator  iter_begin = words.begin ();
+    vector<string>::const_iterator  iter_end   = words.end ();
+    if (((iter =  find (iter_begin, iter_end,  "?")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end, "&&")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end, "||")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end,  "&")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end,  "|")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end,  "^")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end, "<<")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end, ">>")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end, "==")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end, "!=")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end, "<=")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end, ">=")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end,  "<")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end,  ">")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end,  "+")) != iter_end) ||
+        ((iter = rfind (iter_begin, iter_end,  "-")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end,  "*")) != iter_end) ||
+        ((iter = rfind (iter_begin, iter_end, "//")) != iter_end) ||
+        ((iter = rfind (iter_begin, iter_end,  "/")) != iter_end) ||
+        ((iter = rfind (iter_begin, iter_end,  "%")) != iter_end) ||
+        ((iter =  find (iter_begin, iter_end, "**")) != iter_end))
+    {
+        A_type = E_type_operation;
+
+
+        const string  & operation = *iter;
+
+        // faire un vector avec le debut
+        vector<string>    words_left (iter_begin, iter);
+        if ((operation == "-") && (iter == iter_begin))
+        {
+            // Operator - unary.
+
+            // faire un vector avec la fin
+            ++iter;
+            if (iter == iter_end)
+            {
+                M_FATAL_COMMENT ("Found operator " << operation << " at the end of expression (" << words_to_string(words) << ")");
+            }
+            vector<string>    words_right (iter, iter_end);
+            // Add a zero before to make it binary.
+            words_right[0] = "(0-" + words_right[0] + ")";
+            build_expression_words(type_definitions, words_right);
+            return;
+        }
+#if 1
+        else if (operation == "-")
+        {
+            // Operator - not at the beginning, but could be unary
+            vector<string>::const_iterator  iter_prev = iter;
+            --iter_prev;
+            const string  & str_prev = *iter_prev;
+            if ((str_prev ==  "?") ||
+                (str_prev == "&&") ||
+                (str_prev == "||") ||
+                (str_prev ==  "&") ||
+                (str_prev ==  "|") ||
+                (str_prev ==  "^") ||
+                (str_prev == "<<") ||
+                (str_prev == ">>") ||
+                (str_prev == "==") ||
+                (str_prev == "!=") ||
+                (str_prev == "<=") ||
+                (str_prev == ">=") ||
+                (str_prev ==  "<") ||
+                (str_prev ==  ">") ||
+                (str_prev ==  "+") ||
+                (str_prev ==  "-") ||
+                (str_prev == "**") ||
+                (str_prev ==  "*") ||
+                (str_prev == "//") ||
+                (str_prev ==  "/") ||
+                (str_prev ==  "%"))
+            {
+                ++iter;
+                if (iter == iter_end)
+                {
+                    M_FATAL_COMMENT ("Found operator " << operation << " at the end of expression (" << words_to_string(iter_begin, iter_end) << ")");
+                }
+
+                vector<string>    new_words (iter_begin, iter_end);
+                // Add a zero before to make it binary.
+                new_words[iter-iter_begin] = "(0-" + (*iter) + ")";
+                --iter;
+                new_words.erase(new_words.begin()+(iter-iter_begin));
+
+                build_expression_words(type_definitions, new_words);
+                return;
+            }
+        }
+#endif
+        else if (iter == iter_begin)
+        {
+            M_FATAL_COMMENT ("Found operator " << operation << " at the beginning of expression (" << words_to_string(words) << ")");
+        }
+
+        // faire un vector avec la fin
+        ++iter;
+        if (iter == iter_end)
+        {
+            M_FATAL_COMMENT ("Found operator " << operation << " at the end of expression (" << words_to_string(words) << ")");
+        }
+        vector<string>    words_right (iter, iter_end);
+
+        --iter;
+
+        A_expressions.push_back(T_expression());
+        A_expressions.back().build_expression_words(type_definitions, words_left);
+
+
+        // condition operator.
+        if (operation == "?")
+        {
+            A_operation = E_operation_condition;
+
+            vector<string>::iterator  iter_sep =
+                                      find (words_right.begin (),
+                                            words_right.end (),
+                                            ":");
+            if (iter_sep == words_right.begin ())
+            {
+                M_FATAL_COMMENT ("Found separator : directly after ? expression (" << words_to_string(words_right) << ")");
+            }
+            if (iter_sep == words_right.end ())
+            {
+                M_FATAL_COMMENT ("Found separator : at the end of ? expression (" << words_to_string(words_right) << ")");
+            }
+            
+            vector<string>    condition_words_left (words_right.begin(), iter_sep);
+            A_expressions.push_back(T_expression());
+            A_expressions.back().build_expression_words(type_definitions, condition_words_left);
+
+            vector<string>    condition_words_right(++iter_sep, words_right.end());
+            A_expressions.push_back(T_expression());
+            A_expressions.back().build_expression_words(type_definitions, condition_words_right);
+
+            return;
+        }
+
+        // Other operators.
+        A_expressions.push_back(T_expression());
+        A_expressions.back().build_expression_words(type_definitions, words_right);
+
+        if (operation == "&&")
+            A_operation = E_operation_logical_and;
+        else if (operation == "||")
+            A_operation = E_operation_logical_or;
+        else if (operation == "&")
+            A_operation = E_operation_bit_and;
+        else if (operation == "|")
+            A_operation = E_operation_bit_or;
+        else if (operation == "^")
+            A_operation = E_operation_bit_xor;
+        else if (operation == "<<")
+            A_operation = E_operation_bit_shift_left;
+        else if (operation == ">>")
+            A_operation = E_operation_bit_shift_right;
+        else if (operation == "==")
+            A_operation = E_operation_equal;
+        else if (operation == "!=")
+            A_operation = E_operation_not_equal;
+        else if (operation == "<=")
+            A_operation = E_operation_less_or_equal;
+        else if (operation == ">=")
+            A_operation = E_operation_greater_or_equal;
+        else if (operation == "<")
+            A_operation = E_operation_less;
+        else if (operation == ">")
+            A_operation = E_operation_greater;
+        else if (operation == "*")
+            A_operation = E_operation_multiply;
+        else if (operation == "//")
+            A_operation = E_operation_divide_float;
+        else if (operation == "/")
+            A_operation = E_operation_divide_c;
+        else if (operation == "%")
+            A_operation = E_operation_modulo;
+        else if (operation == "+")
+            A_operation = E_operation_addition;
+        else if (operation == "-")
+            A_operation = E_operation_subtraction;
+        else if (operation == "**")
+            A_operation = E_operation_pow;
+        else
+        {
+            M_FATAL_COMMENT ("Bad operator " << operation << " : bug in software. expression (" << words_to_string(words) << ")");
+        }
+        return;
+    }
+
+    if (words.size () == 1)
+    {
+        build_expression_str (type_definitions, words[0]);
+        return;
+    }
+
+    if (words.size () == 2)
+    {
+        A_type = E_type_function_call;
+        A_variable_or_function_name = words[0];
+
+        const string  & function_name = words[0];
+        const string  & function_parameters = words[1];
+
+        if (function_name == "string.length")
+        {
+            M_FATAL_IF_FALSE(true);
+        }
+
+#if 0
+        {
+            // Built-in functions with 1 parameter.
+            A_expressions.push_back(T_expression());
+            A_expressions.back().build_expression_str(type_definitions, function_parameters);
+            return;
+        }
+        else
+#endif
+        const T_function_definition  * P_fct = nullptr;
+        if ((function_name != "print"))
+        {
+            P_fct = type_definitions.get_P_function(function_name);
+            if (P_fct == nullptr)
+            {
+                M_FATAL_COMMENT("Function " << function_name << " does not exist.");
+            }
+        }
+
+        vector<string>    fct_parameters;
+        {
+            if ((function_parameters == "") ||
+                (function_parameters[0] != '(') ||
+                (function_parameters[function_parameters.size()-1] != ')'))
+            {
+                M_FATAL_COMMENT("Bad function parameters (" << function_parameters << ")");
+            }
+
+            // Remove ( and ).
+            string            function_parameters_copy = function_parameters;
+            function_parameters_copy.erase(0, 1);
+            function_parameters_copy.erase(function_parameters_copy.size()-1);
+
+            // Split on ,.
+            string_to_words(function_parameters_copy, fct_parameters, K_parser_cfg_parameters);
+        }
+
+        for (unsigned int idx=0; idx<fct_parameters.size(); ++idx)
+        {
+            A_expressions.push_back(T_expression());
+            A_expressions.back().build_expression_str(type_definitions, fct_parameters[idx]);
+        }
+
+        if (function_name == "print")
+        {
+            // verifier qu'il y a au moins 1 parametre
+            // voir si param 0 calculable
+            //   + promote
+        }
+        else if (P_fct != nullptr)
+        {
+            // Check the number of parameters
+            if (static_cast<int>(fct_parameters.size()) < P_fct->get_nb_of_mandatory_parameters())
+            {
+                M_FATAL_COMMENT("Too few parameters for function " << function_name);
+            }
+            if (fct_parameters.size() > P_fct->get_function_parameters().size())
+            {
+                M_FATAL_COMMENT("Too many parameters for function " << function_name);
+            }
+        }
+
+        return;
+    }
+
+    for (string::size_type  idx = 0; idx < words.size (); ++idx)
+    {
+        M_TRACE_ERROR ("words[" << idx << "] = " << words[idx]);
+    }
+    M_FATAL_COMMENT ("Bad expression (" << words_to_string(words) << ")");
+}
+
+//*****************************************************************************
+// build_expression_str
+//*****************************************************************************
+void
+T_expression::build_expression_str(
+                         const T_type_definitions  & type_definitions,
+                         const std::string         & in_str)
+{
+    M_TRACE_ENTER("build_expression_str", in_str);
+
+    if (A_original_string_expression.empty())
+    {
+        A_original_string_expression = in_str;
+    }
+
+    vector<string>    words;
+    string_to_words (in_str, words, K_parser_cfg_C);
+
+    if (words.empty ())
+    {
+        M_FATAL_COMMENT("Empty expression.");
+    }
+
+    if ((words.size () == 1) && (words[0] == in_str))
+    {
+        string  & new_str = words[0];
+        remove_word_limits (new_str, '(', ')');
+        if (new_str != in_str)
+        {
+            build_expression_str (type_definitions, new_str);
+            return;
+        }
+
+        // Manage expressions inside arrays
+        if (new_str.find(']') != string::npos)
+        {
+            build_expression_array(type_definitions,new_str);
+            return;
+        }
+
+        T_interpret_data  interpret_data;
+        E_return_code     rc = get_complex_value (type_definitions, interpret_data, new_str, A_value);
+        if (rc == E_rc_ok)
+        {
+            A_type = E_type_value;
+        }
+        else if (is_a_valid_long_variable_name(new_str))
+        {
+            A_type = E_type_variable;
+            A_variable_or_function_name = new_str;
+        }
+        else
+        {
+            M_FATAL_COMMENT("Does not understand expression '" << new_str << "'");
+        }
+        return;
+    }
+
+    build_expression_words (type_definitions, words);
+}
+
+//*****************************************************************************
+// build_expression
+//*****************************************************************************
+void
+T_expression::build_expression(
+                         const C_value             & value)
+{
+    if (A_original_string_expression.empty())
+    {
+        A_original_string_expression = value.as_string();
+    }
+
+    A_value = value;
+    A_type = E_type_value;
+
+
+    const T_type_definitions    type_definitions;
+    pre_compute_expression(type_definitions);
+}
+
+//*****************************************************************************
+// build_expression
+//*****************************************************************************
+void
+T_expression::build_expression(
+                         const T_type_definitions  & type_definitions,
+                         const std::string         & str)
+{
+    build_expression_str(type_definitions,str);
+    pre_compute_expression(type_definitions);
+}
+
+//*****************************************************************************
+// build_expression_array
+//*****************************************************************************
+void
+T_expression::build_expression_array(
+                         const T_type_definitions  & type_definitions,
+                         const std::string         & in_str)
+{
+    M_TRACE_ENTER("build_expression_array", in_str);
+
+    // Compute the value of each array index.
+    string    left_part;
+    string    str_array_index;
+    string    right_part = in_str;
+    string    reduced_variable_name;
+    while (decompose_left_sep_middle_sep_right (right_part,
+                                                      '[',
+                                                      ']',
+                                                      left_part,
+                                                      str_array_index,
+                                                      right_part) == E_rc_ok)
+    {
+        reduced_variable_name += left_part;
+        reduced_variable_name += "[]";
+
+        M_FATAL_IF_EQ(str_array_index, "");
+
+        A_expressions.push_back(T_expression());
+        A_expressions.back().build_expression_str(type_definitions, str_array_index);
+
+        if (right_part == "")    // nothing remains
+        {
+            break;
+        }
+        if (right_part.find('[') == string::npos)    // no array remains
+        {
+            reduced_variable_name += right_part;
+            break;
+        }
+    }
+
+    A_type = E_type_variable;
+    A_variable_or_function_name = reduced_variable_name;
+
+    M_TRACE_DEBUG("A_variable_or_function_name=" << A_variable_or_function_name);
+}
+
+//*****************************************************************************
+// pre_compute_expression
+//*****************************************************************************
+void
+T_expression::pre_compute_expression(
+                         const T_type_definitions      & type_definitions)
+{
+    M_TRACE_ENTER("pre_compute_expression", *this);
+
+    if (A_value_alreay_computed == true)
+    {
+        return;
+    }
+
+    T_interpret_data    interpret_data;
+    T_frame_data        in_out_frame_data;
+    const string        data_name;
+    const string      & data_simple_name = data_name;
+    ostringstream       os_out;
+    ostringstream     & os_err = os_out;
+    bool                pre_compute_result_do_not_care = true;
+
+    compute_expression(
+                type_definitions,
+                interpret_data,
+                in_out_frame_data,
+                data_name,
+                data_simple_name,
+                os_out,
+                os_err,
+                true /* pre_compute */,
+                pre_compute_result_do_not_care);
+
+    M_TRACE_LEAVE(*this);
+}
+
+std::ostream &  operator<< (std::ostream    & os,
+                      const T_expression    & rhs)
+{
+    os << "input=" << rhs.A_original_string_expression << "  ";
+
+    if (rhs.A_value_alreay_computed == true)
+    {
+        os << "value=" << rhs.A_value.as_string() << "  ";
+    }
+
+    os << "type=" << rhs.A_type << "  ";
+
+    if (rhs.A_variable_or_function_name != "")
+    {
+        os << "variable_or_function_name=" << rhs.A_variable_or_function_name << "  ";
+    }
+
+    if (rhs.A_operation != T_expression::E_operation_none)
+    {
+        os << "operation=" << rhs.A_operation << "  ";
+    }
+
+    return  os;
+}
+
+std::ostream &  operator<< (std::ostream            & os,
+                      const T_expression::E_type    & rhs)
+{
+    switch (rhs)
+    {
+    case T_expression::E_type_none          : os << "none";          break;
+    case T_expression::E_type_value         : os << "value";         break;
+    case T_expression::E_type_variable      : os << "variable";      break;
+    case T_expression::E_type_function_call : os << "function_call"; break;
+    case T_expression::E_type_operation     : os << "operation";     break;
+    default                                 : os << (int)rhs;        break;
+    }
+    return  os;
+}
+
+std::ostream &  operator<< (std::ostream               & os,
+                      const T_expression::E_operation  & rhs)
+{
+    switch (rhs)
+    {
+    case T_expression::E_operation_none             : os << "none";             break;
+    case T_expression::E_operation_condition        : os << "condition";        break;
+    case T_expression::E_operation_logical_and      : os << "logical_and";      break;
+    case T_expression::E_operation_logical_or       : os << "logical_or";       break;
+    case T_expression::E_operation_bit_and          : os << "bit_and";          break;
+    case T_expression::E_operation_bit_or           : os << "bit_or";           break;
+    case T_expression::E_operation_bit_xor          : os << "bit_xor";          break;
+    case T_expression::E_operation_bit_shift_left   : os << "bit_shift_left";   break;
+    case T_expression::E_operation_bit_shift_right  : os << "bit_shift_right";  break;
+    case T_expression::E_operation_equal            : os << "equal";            break;
+    case T_expression::E_operation_not_equal        : os << "not_equal";        break;
+    case T_expression::E_operation_less_or_equal    : os << "less_or_equal";    break;
+    case T_expression::E_operation_greater_or_equal : os << "greater_or_equal"; break;
+    case T_expression::E_operation_less             : os << "less";             break;
+    case T_expression::E_operation_greater          : os << "greater";          break;
+    case T_expression::E_operation_addition         : os << "addition";         break;
+    case T_expression::E_operation_subtraction      : os << "subtraction";      break;
+    case T_expression::E_operation_pow              : os << "pow";              break;
+    case T_expression::E_operation_multiply         : os << "multiply";         break;
+    case T_expression::E_operation_divide_float     : os << "divide_float";     break;
+    case T_expression::E_operation_divide_c         : os << "divide_c";         break;
+    case T_expression::E_operation_modulo           : os << "modulo";           break;
+    default                                         : os << (int)rhs;           break;
+    }
+
+    return  os;
+}
+
+//*****************************************************************************
+// compute_expression
+//*****************************************************************************
+const C_value &
+T_expression::compute_expression(
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const std::string             & data_name,
+                         const std::string             & data_simple_name,
+                               std::ostream            & os_out,
+                               std::ostream            & os_err) const
+{
+    bool    pre_compute_result_do_not_care = true;
+
+    const C_value &  result = compute_expression(
+                    type_definitions,
+                    interpret_data,
+                    in_out_frame_data,
+                    data_name,
+                    data_simple_name,
+                    os_out,
+                    os_err,
+                    false /* pre_compute */,
+                    pre_compute_result_do_not_care);
+
+    return  result;
+}
+
+//*****************************************************************************
+// compute_expression_no_io
+//*****************************************************************************
+const C_value &
+T_expression::compute_expression_no_io(
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data) const
+{
+    T_frame_data        in_out_frame_data;
+    const string        data_name;
+    const string      & data_simple_name = data_name;
+    ostringstream       os_out;
+    ostringstream     & os_err = os_out;
+
+    return  compute_expression(
+                type_definitions,
+                interpret_data,
+                in_out_frame_data,
+                data_name,
+                data_simple_name,
+                os_out,
+                os_err);
+}
+
+//*****************************************************************************
+// compute_expression_static
+//*****************************************************************************
+const C_value &
+T_expression::compute_expression_static(
+                         const T_type_definitions      & type_definitions) const
+{
+    T_interpret_data    interpret_data;
+    T_frame_data        in_out_frame_data;
+    const string        data_name;
+    const string      & data_simple_name = data_name;
+    ostringstream       os_out;
+    ostringstream     & os_err = os_out;
+
+    return  compute_expression(
+                type_definitions,
+                interpret_data,
+                in_out_frame_data,
+                data_name,
+                data_simple_name,
+                os_out,
+                os_err);
+}
+
+//*****************************************************************************
+// compute_expression
+//-----------------------------------------------------------------------------
+// For performance optimisation,
+//  we try to compute (partially or completely) expression during initialisation
+// This is possible if the expression does not require existing variable. 
+// - pre_compute = true means trying to compute during initialisation
+//   pre_compute = false :
+//   - if error -> exception
+//   - do not care about pre_compute_result
+//   pre_compute = true :
+//   - if non existent needed variable -> no exception, pre_compute_result set to false
+//   - if other error -> exception
+//   - must care about pre_compute_result
+// - pre_compute_result = result of pre computation
+//*****************************************************************************
+const C_value &
+T_expression::compute_expression(
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const std::string             & data_name,
+                         const std::string             & data_simple_name,
+                               std::ostream            & os_out,
+                               std::ostream            & os_err,
+                               bool                      pre_compute,
+                               bool                    & pre_compute_result) const
+{
+    if (A_value_alreay_computed == false)
+    {
+        if (A_type == E_type_value)
+        {
+            // nothing to do
+            pre_compute_result = true;
+        }
+        else if ((A_type == E_type_variable) && (A_expressions.empty()))
+        {
+            pre_compute_result = interpret_data.get_value_of_read_variable (
+                                    A_variable_or_function_name,
+                                    A_value);
+            
+            if ((pre_compute_result != true) && (pre_compute == false))
+            {
+                M_FATAL_COMMENT("unknow variable/field = " << A_variable_or_function_name);
+            }
+        }
+        else if (A_type == E_type_variable)
+        {
+            compute_expression_variable_array(
+                type_definitions,
+                interpret_data,
+                in_out_frame_data,
+                data_name,
+                data_simple_name,
+                os_out,
+                os_err,
+                pre_compute,
+                pre_compute_result);
+        }
+        else if (A_type == E_type_operation)
+        {
+            compute_expression_operation(
+                type_definitions,
+                interpret_data,
+                in_out_frame_data,
+                data_name,
+                data_simple_name,
+                os_out,
+                os_err,
+                pre_compute,
+                pre_compute_result);
+        }
+        else if (A_type == E_type_function_call)
+        {
+            compute_expression_function(
+                type_definitions,
+                interpret_data,
+                in_out_frame_data,
+                data_name,
+                data_simple_name,
+                os_out,
+                os_err,
+                pre_compute,
+                pre_compute_result);
+        }
+        else
+        {
+            M_FATAL_COMMENT("expression.type unknow = " << A_type);
+        }
+
+        if (pre_compute && pre_compute_result)
+        {
+            A_value_alreay_computed = true;
+        }
+    }
+
+    return  A_value;
+}
+
+//*****************************************************************************
+// compute_expression_variable_array
+//*****************************************************************************
+void
+T_expression::compute_expression_variable_array(
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const std::string             & data_name,
+                         const std::string             & data_simple_name,
+                               std::ostream            & os_out,
+                               std::ostream            & os_err,
+                               bool                      pre_compute,
+                               bool                    & pre_compute_result) const
+{
+    if (pre_compute) { pre_compute_result = false; return; }   /* ICIOA temporaire */
+
+    string  variable_name = A_variable_or_function_name;
+
+    for (vector<T_expression>::reverse_iterator
+            iter  = A_expressions.rbegin();
+            iter != A_expressions.rend();
+            ++iter)
+    {
+        T_expression  expression = *iter;
+
+        // Compute index expression
+        C_value  idx_value = expression.compute_expression(
+                                type_definitions,
+                                interpret_data,
+                                in_out_frame_data,
+                                data_name,
+                                data_simple_name,
+                                os_out,
+                                os_err);
+        M_FATAL_IF_NE(idx_value.get_type(), C_value::E_type_integer);
+
+        // Compute where to insert
+        string::size_type  insert_idx = variable_name.rfind("[]");
+        M_FATAL_IF_EQ(insert_idx, string::npos);
+
+        ++insert_idx;
+
+        // Insert index string
+        variable_name.insert(insert_idx, idx_value.as_string());
+    }
+
+
+    if (interpret_data.get_value_of_read_variable (
+            variable_name,
+            A_value) != true)
+    {
+        M_FATAL_COMMENT("unknow variable/field = " << variable_name);
+    }
+}
+
+//*****************************************************************************
+// get_pointer_...
+// Returns the address
+//*****************************************************************************
+
+long long  get_pointer_pos_len_bits(T_frame_data  & in_out_frame_data,
+                                    std::size_t     pos_bits,
+                                    std::size_t     length_bits)
+{
+    // Save current position
+    const long  pos_current_bits = in_out_frame_data.get_bit_offset();
+
+    // Set position to the last position asked.
+    // Trigger a fatal error if not enough data.
+    // Sufficient to ensure desegmentation ICIOA ??? or need to trigger specific exception ?
+    in_out_frame_data.set_bit_offset(pos_bits + length_bits);
+
+    // Set position to the first position asked.
+    // Check we are at beginning of a byte
+    // Get the pointer.
+    in_out_frame_data.set_bit_offset(pos_bits);
+    M_FATAL_IF_FALSE(in_out_frame_data.is_physically_at_beginning_of_byte());
+    const T_byte *  ptr = in_out_frame_data.get_P_bytes();
+
+    // Restore current position
+    in_out_frame_data.set_bit_offset(pos_current_bits);
+
+    return  (long long)ptr;
+}
+
+long long  get_pointer_pos_len_bytes(T_frame_data  & in_out_frame_data,
+                                     std::size_t     pos_bytes,
+                                     std::size_t     length_bytes)
+{
+    return  get_pointer_pos_len_bits(in_out_frame_data, pos_bytes * 8, length_bytes * 8);
+}
+
+long long  get_pointer_len_bits(T_frame_data  & in_out_frame_data,
+                                std::size_t     length_bits)
+{
+    return  get_pointer_pos_len_bits(in_out_frame_data, in_out_frame_data.get_bit_offset(), length_bits);
+}
+
+long long  get_pointer_len_bytes(T_frame_data  & in_out_frame_data,
+                                 std::size_t     length_bytes)
+{
+    return  get_pointer_pos_len_bits(in_out_frame_data, in_out_frame_data.get_bit_offset(), length_bytes * 8);
+}
+
+//*****************************************************************************
+// 
+//*****************************************************************************
+
+#ifndef UINT32_MAX
+#define UINT32_MAX  4294967295
+#endif
+
+string::size_type  string_count_fdesc_to_cpp(const C_value  & fdesc_count)
+{
+    const long long        count = fdesc_count.get_int();
+    string::size_type  cpp_count = ((count < 0) || (count >= UINT32_MAX)) ? string::npos : static_cast<string::size_type>(count);
+
+    return  cpp_count;
+}
+
+C_value  string_count_cpp_to_fdesc(const string::size_type  cpp_count)
+{
+    // string::npos value on 64 bits could not save into C_value(int64).
+    // So use -1 instead.
+    // - good : can     use  string.find(...) < 0
+    // - bad  : can NOT use  uint = string.find(...)  -> behavior modifications
+    // So use UINT32_MAX instead.
+    // - good : can     use  uint32 = string.find(...) 
+    // - bad  : can NOT use  string.find(...) < 0
+//    const long long        count = (cpp_count == string::npos) ? -1LL : cpp_count;
+    const long long        count = (cpp_count == string::npos) ? UINT32_MAX : cpp_count;
+    C_value          fdesc_count(count);
+
+    return  fdesc_count;
+}
+
+//*****************************************************************************
+// compute_expression_function
+//*****************************************************************************
+C_value    T_expression_compute_function (
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const T_function_definition   & fct_def,
+                               vector<T_expression>    & fct_parameters,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err,
+                               bool                      pre_compute,
+                               bool                    & pre_compute_result);
+
+void
+T_expression::compute_expression_function(
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const std::string             & data_name,
+                         const std::string             & data_simple_name,
+                               std::ostream            & os_out,
+                               std::ostream            & os_err,
+                               bool                      pre_compute,
+                               bool                    & pre_compute_result) const
+{
+    pre_compute_result = true;
+
+    const C_value  * P_parameter_values[50];    // ICIOA magic number
+
+    for (unsigned int   idx = 0; idx < A_expressions.size(); ++idx)
+    {
+        bool    pre_compute_result_local = true;
+
+        P_parameter_values[idx] = & A_expressions[idx].compute_expression(
+                    type_definitions, interpret_data, in_out_frame_data,
+                    data_name, data_simple_name, os_out, os_err,
+                    pre_compute, pre_compute_result_local);
+        pre_compute_result &= pre_compute_result_local;
+    }
+
+    if ((pre_compute == true) && (pre_compute_result == false))
+    {
+        return;    // parameters pre computation failed (should be normal)
+    }
+
+
+    if (A_variable_or_function_name == "print")
+    {
+        string    printf_format = (* P_parameter_values[0]).get_str();;
+        promote_printf_string_to_64bits(printf_format);
+
+        // Compute values to print.
+        vector<C_value>    values_to_print;
+        for (unsigned int   idx = 1; idx < A_expressions.size(); ++idx)
+        {
+            values_to_print.push_back(* P_parameter_values[idx]);
+        }
+
+        // printf.
+        A_value = C_value::sprintf_values(printf_format, values_to_print);
+    }
+    else if (A_variable_or_function_name == "is_existing_field_or_variable")
+    {
+        if (pre_compute == true)
+        {
+            // Can not be pre-computed
+            pre_compute_result = false;
+            return;
+        }
+        const bool  is_existing = interpret_data.is_read_variable(P_parameter_values[0]->get_str());
+        A_value = is_existing;
+    }
+    else if (A_variable_or_function_name == "to_string")
+    {
+        A_value = * P_parameter_values[0];
+        A_value.convert_to_string();
+    }
+    else if (A_variable_or_function_name == "to_numeric")
+    {
+        A_value = * P_parameter_values[0];
+        A_value.convert_to_numeric();
+    }
+    else if (A_variable_or_function_name == "to_float")
+    {
+        A_value = * P_parameter_values[0];
+        A_value.convert_to_float();
+    }
+    else if (A_variable_or_function_name == "to_integer")
+    {
+        A_value = * P_parameter_values[0];
+
+        C_value  value_base = 0;
+        if (A_expressions.size() > 1)
+        {
+            value_base = * P_parameter_values[1];
+        }
+
+        A_value.convert_to_int(value_base.get_int_int());
+    }
+    else if (A_variable_or_function_name == "getenv")
+    {
+        const char  * env_value = getenv(P_parameter_values[0]->as_string().c_str());
+        A_value = (env_value == nullptr) ? "" : env_value;
+    }
+    else if (A_variable_or_function_name == "string.length")
+    {
+        A_value = * P_parameter_values[0];
+        A_value = A_value.get_str().length();
+    }
+    else if (A_variable_or_function_name == "string.substr")
+    {
+        A_value = * P_parameter_values[0];
+        C_value  value_idx = * P_parameter_values[1];
+
+        string::size_type  cpp_count = string::npos;
+        if (A_expressions.size() > 2)
+        {
+            cpp_count = string_count_fdesc_to_cpp(* P_parameter_values[2]);
+        }
+
+        A_value = A_value.get_str().substr(value_idx.get_int_size_t(), cpp_count);
+    }
+    else if (A_variable_or_function_name == "string.erase")
+    {
+        A_value = * P_parameter_values[0];
+
+        C_value  value_idx = * P_parameter_values[1];
+
+        string::size_type  cpp_count = string::npos;
+        if (A_expressions.size() > 2)
+        {
+            cpp_count = string_count_fdesc_to_cpp(* P_parameter_values[2]);
+        }
+
+        string  str_copy = A_value.get_str();
+        str_copy.erase(value_idx.get_int_size_t(), cpp_count);
+        A_value = str_copy;
+    }
+    else if (A_variable_or_function_name == "string.insert")
+    {
+        A_value = * P_parameter_values[0];
+
+        C_value  value_idx = * P_parameter_values[1];
+        C_value  value_str = * P_parameter_values[2];
+
+        string  str_copy = A_value.get_str();
+        str_copy.insert(value_idx.get_int_size_t(), value_str.get_str());
+        A_value = str_copy;
+    }
+    else if (A_variable_or_function_name == "string.replace")
+    {
+        A_value = * P_parameter_values[0];
+
+        C_value            value_idx = * P_parameter_values[1];
+        string::size_type  cpp_count = string_count_fdesc_to_cpp(* P_parameter_values[2]);
+        C_value            value_str = * P_parameter_values[3];
+
+        string  str_copy = A_value.get_str();
+        str_copy.replace(value_idx.get_int_size_t(), cpp_count,value_str.get_str());
+        A_value = str_copy;
+    }
+    else if (A_variable_or_function_name == "string.replace_all")
+    {
+        A_value = * P_parameter_values[0];
+
+        C_value  value_str_old = * P_parameter_values[1];
+        C_value  value_str_new = * P_parameter_values[2];
+
+        A_value = get_replace_all(A_value.get_str(), value_str_old.get_str(), value_str_new.get_str());
+    }
+    else if (A_variable_or_function_name == "string.find")
+    {
+        A_value = * P_parameter_values[0];
+
+        C_value  value_str = * P_parameter_values[1];
+
+        C_value  value_idx = 0;
+        if (A_expressions.size() > 2)
+        {
+            value_idx = * P_parameter_values[2];
+        }
+
+        A_value = string_count_cpp_to_fdesc(A_value.get_str().find(value_str.get_str(), value_idx.get_int_size_t()));
+    }
+    else if (A_variable_or_function_name == "date.get_string_from_days")
+    {
+        A_value = * P_parameter_values[0];
+
+        C_value  number_of_days = * P_parameter_values[1];
+
+        const string  str_date = date_get_string_from_days(A_value.get_int_int(), number_of_days.get_int_int());
+        A_value = str_date;
+    }
+    else if (A_variable_or_function_name == "date.get_string_from_seconds")
+    {
+        A_value = * P_parameter_values[0];
+
+        C_value  number_of_seconds = * P_parameter_values[1];
+
+        const string  str_date = date_get_string_from_seconds(A_value.get_int_int(), number_of_seconds.get_int());
+        A_value = str_date;
+    }
+    else if (A_variable_or_function_name == "get_pointer_len_bytes")
+    {
+        const C_value  & length_bytes = * P_parameter_values[0];
+
+        A_value = get_pointer_len_bytes(in_out_frame_data, length_bytes.get_int_size_t());
+    }
+    else if (A_variable_or_function_name == "get_pointer_len_bits")
+    {
+        const C_value  & length_bits = * P_parameter_values[0];
+
+        A_value = get_pointer_len_bits(in_out_frame_data, length_bits.get_int_size_t());
+    }
+    else if (A_variable_or_function_name == "get_pointer_pos_len_bytes")
+    {
+        const C_value  & pos_bytes    = * P_parameter_values[0];
+        const C_value  & length_bytes = * P_parameter_values[1];
+
+        A_value = get_pointer_pos_len_bytes(in_out_frame_data, pos_bytes.get_int_size_t(), length_bytes.get_int_size_t());
+    }
+    else if (A_variable_or_function_name == "get_pointer_pos_len_bits")
+    {
+        const C_value  & pos_bits    = * P_parameter_values[0];
+        const C_value  & length_bits = * P_parameter_values[1];
+
+        A_value = get_pointer_pos_len_bits(in_out_frame_data, pos_bits.get_int_size_t(), length_bits.get_int_size_t());
+    }
+#if 0
+    else if (A_variable_or_function_name == "string.")
+    {
+        A_value = * P_parameter_values[0];
+
+//        A_value = A_value.get_str().find(str, idx);
+//        A_value = A_value.get_str().find_first_not_of(str,idx);
+//        A_value = A_value.get_str().find_first_of(str,idx);
+//        A_value = A_value.get_str().find_last_not_of(str,idx);
+//        A_value = A_value.get_str().find_last_of(str,idx);
+//        A_value = A_value.get_str().rfind(str,idx);
+    }
+#endif
+    else
+    {
+        const T_function_definition  * P_fct = type_definitions.get_P_function(A_variable_or_function_name);
+        if (P_fct == nullptr)
+        {
+            M_FATAL_COMMENT("Function " << A_variable_or_function_name << " does not exist.");
+        }
+
+        A_value = T_expression_compute_function (type_definitions,
+                                  interpret_data,
+                                  in_out_frame_data,
+                                 *P_fct,
+                                  A_expressions,  // function_parameters
+                                  data_name,
+                                  data_simple_name,
+                                  os_out,
+                                  os_err,
+                                  pre_compute, pre_compute_result);
+    }
+}
+
+//*****************************************************************************
+// compute_expression_operation
+//*****************************************************************************
+void
+T_expression::compute_expression_operation(
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const std::string             & data_name,
+                         const std::string             & data_simple_name,
+                               std::ostream            & os_out,
+                               std::ostream            & os_err,
+                               bool                      pre_compute,
+                               bool                    & pre_compute_result) const
+{
+    pre_compute_result = true;
+
+#if 0
+    // faire un vector avec le debut
+    if ((operation == "-") && (iter == iter_begin))
+    {
+        // Operator - unary.
+        vector<string>    words;
+        words.push_back("0");
+        words.insert(words.end(), iter_begin, iter_end);
+
+        return  compute_expression (type_definitions, interpret_data, in_out_frame_data, words.begin(), words.end(), data_name, data_simple_name, os_out, os_err);
+    }
+#endif
+
+    bool             pre_compute_result_left = true;
+    const C_value  & value_left =
+        A_expressions[0].compute_expression(
+            type_definitions, interpret_data, in_out_frame_data,
+            data_name, data_simple_name, os_out, os_err,
+            pre_compute, pre_compute_result_left);
+
+    pre_compute_result = pre_compute_result && pre_compute_result_left;
+
+
+    // pre_compute : try to compute all expressions
+    // compute     : minimal computation
+    //               for condition/logical operators
+
+    if (A_operation == E_operation_condition)   // operator ? :
+    {
+        bool  condition = true;
+        if ((pre_compute == false) || (pre_compute_result_left == true))
+        {
+            condition = value_left.get_bool ();
+        }
+
+        if ((condition == true) || pre_compute)
+        {
+            bool             pre_compute_result_local;
+            A_value = A_expressions[1].compute_expression(
+                type_definitions, interpret_data, in_out_frame_data,
+                data_name, data_simple_name, os_out, os_err,
+                pre_compute, pre_compute_result_local);
+
+            pre_compute_result = pre_compute_result && pre_compute_result_local;
+        }
+        if ((condition == false) || pre_compute)
+        {
+            bool             pre_compute_result_local;
+            const C_value  & value_ref = A_expressions[2].compute_expression(
+                type_definitions, interpret_data, in_out_frame_data,
+                data_name, data_simple_name, os_out, os_err,
+                pre_compute, pre_compute_result_local);
+
+            if (condition == false)
+            {
+                A_value = value_ref;
+            }
+
+            pre_compute_result = pre_compute_result && pre_compute_result_local;
+        }
+    }
+    else if (A_operation == E_operation_logical_and)
+    {
+        bool  condition = true;
+        if ((pre_compute == false) || (pre_compute_result_left == true))
+        {
+            condition = value_left.get_bool ();
+            A_value = value_left;
+        }
+
+        if ((condition == true) || pre_compute)
+        {
+            bool             pre_compute_result_local;
+            const C_value  & value_right =
+                      A_expressions[1].compute_expression(
+                        type_definitions, interpret_data, in_out_frame_data,
+                        data_name, data_simple_name, os_out, os_err,
+                        pre_compute, pre_compute_result_local);
+
+            pre_compute_result = pre_compute_result && pre_compute_result_local;
+
+            if ((pre_compute == false) || (pre_compute_result == true))
+            {
+                A_value = value_left && value_right;
+            }
+        }
+    }
+    else if (A_operation == E_operation_logical_or)
+    {
+        bool  condition = false;
+        if ((pre_compute == false) || (pre_compute_result_left == true))
+        {
+            condition = value_left.get_bool ();
+            A_value = value_left;
+        }
+
+        if ((condition == false) || pre_compute)
+        {
+            bool             pre_compute_result_local;
+            const C_value  & value_right =
+                      A_expressions[1].compute_expression(
+                        type_definitions, interpret_data, in_out_frame_data,
+                        data_name, data_simple_name, os_out, os_err,
+                        pre_compute, pre_compute_result_local);
+
+            pre_compute_result = pre_compute_result && pre_compute_result_local;
+
+            if ((pre_compute == false) || (pre_compute_result == true))
+            {
+                A_value = value_left || value_right;
+            }
+        }
+    }
+    else
+    {
+        bool             pre_compute_result_local;
+        const C_value  & value_right =
+            A_expressions[1].compute_expression(
+                type_definitions, interpret_data, in_out_frame_data,
+                data_name, data_simple_name, os_out, os_err,
+                pre_compute, pre_compute_result_local);
+
+        pre_compute_result = pre_compute_result && pre_compute_result_local;
+
+        if ((pre_compute == false) || (pre_compute_result == true))
+        {
+            // Others operators.
+            if (A_operation == E_operation_bit_and)
+                A_value = value_left & value_right;
+            else if (A_operation == E_operation_bit_or)
+                A_value = value_left | value_right;
+            else if (A_operation == E_operation_bit_xor)
+                A_value = value_left ^ value_right;
+            else if (A_operation == E_operation_bit_shift_left)
+                A_value = value_left << value_right;
+            else if (A_operation == E_operation_bit_shift_right)
+                A_value = value_left >> value_right;
+            else if (A_operation == E_operation_equal)
+                A_value = value_left == value_right;
+            else if (A_operation == E_operation_not_equal)
+                A_value = value_left != value_right;
+            else if (A_operation == E_operation_less_or_equal)
+                A_value = value_left <= value_right;
+            else if (A_operation == E_operation_greater_or_equal)
+                A_value = value_left >= value_right;
+            else if (A_operation == E_operation_less)
+                A_value = value_left <  value_right;
+            else if (A_operation == E_operation_greater)
+                A_value = value_left >  value_right;
+            else if (A_operation == E_operation_addition)
+                A_value = value_left +  value_right;
+            else if (A_operation == E_operation_subtraction)
+                A_value = value_left -  value_right;
+            else if (A_operation == E_operation_pow)
+                A_value = C_value::pow(value_left, value_right);
+            else if (A_operation == E_operation_multiply)
+                A_value = value_left *  value_right;
+            else if (A_operation == E_operation_divide_float)
+                A_value = C_value::divide_float(value_left, value_right);
+            else if (A_operation == E_operation_divide_c)
+                A_value = C_value::divide_c(value_left, value_right);
+            else if (A_operation == E_operation_modulo)
+                A_value = value_left %  value_right;
+            else
+            {
+                M_FATAL_COMMENT ("Bad operator " << A_operation << " : bug in software.");
+            }
+        }
+    }
+
+//    if (pre_compute && pre_compute_result)
+//    {
+//        A_value_alreay_computed = true;
+//    }
+}
diff --git a/plugins/epan/generic/T_expression.h b/plugins/epan/generic/T_expression.h
new file mode 100644
index 00000000000..104656d231b
--- /dev/null
+++ b/plugins/epan/generic/T_expression.h
@@ -0,0 +1,251 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_expression_h
+#define T_expression_h
+
+//****************************************************************************
+// Includes.
+//****************************************************************************
+
+#include <string>
+#include <vector>
+
+#include "C_value.h"
+#include "T_interpret_data.h"
+#include "T_frame_data.h"
+
+struct T_type_definitions;
+
+
+//****************************************************************************
+// 
+//****************************************************************************
+#if 0
+expression could be :
+  value          integer float string 
+  constant       enum
+  variable
+  - expression
+  expression operator expression
+  expression ?        expression : expression
+  to_string  expression
+  to_numeric expression
+  print     ( expression, ... )
+  function  ( expression, ... )
+#endif
+
+//****************************************************************************
+// T_expression
+//****************************************************************************
+
+struct T_expression : public CT_debug_object_counter<T_expression>
+{
+    enum E_type
+    {
+        E_type_none,
+        E_type_value,
+        E_type_variable,
+        E_type_function_call,
+        E_type_operation
+    };
+
+    enum E_operation
+    {
+        E_operation_none,
+        E_operation_condition,
+        E_operation_logical_and,
+        E_operation_logical_or,
+        E_operation_bit_and,
+        E_operation_bit_or,
+        E_operation_bit_xor,
+        E_operation_bit_shift_left,
+        E_operation_bit_shift_right,
+        E_operation_equal,
+        E_operation_not_equal,
+        E_operation_less_or_equal,
+        E_operation_greater_or_equal,
+        E_operation_less,
+        E_operation_greater,
+        E_operation_addition,
+        E_operation_subtraction,
+        E_operation_pow,
+        E_operation_multiply,
+        E_operation_divide_float,
+        E_operation_divide_c,
+        E_operation_modulo
+    };
+
+    T_expression();
+
+    bool             is_defined() const           { return  A_type != E_type_none; }
+
+    bool             is_a_value() const           { return  A_type == E_type_value; }
+    bool             is_a_variable() const        { return  A_type == E_type_variable; }
+    const std::string  & get_variable_name() const;
+
+    const std::string  & get_original_string_expression() const   { return  A_original_string_expression; }
+
+
+    void             build_expression(
+                         const T_type_definitions  & type_definitions,
+                         const std::string         & str);
+    void             build_expression(
+                         const C_value             & value);
+
+
+    void      pre_compute_expression(
+                         const T_type_definitions      & type_definitions);
+
+
+    const C_value &  compute_expression(
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const std::string             & data_name,
+                         const std::string             & data_simple_name,
+                               std::ostream            & os_out,
+                               std::ostream            & os_err) const;
+
+    const C_value &  compute_expression_no_io(
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data) const;
+
+    const C_value &  compute_expression_static(
+                         const T_type_definitions      & type_definitions) const;
+    
+private:
+
+    void             build_expression_str(
+                         const T_type_definitions  & type_definitions,
+                         const std::string         & str);
+
+    void             build_expression_words(
+                         const T_type_definitions        & type_definitions,
+                         const std::vector<std::string>  & words);
+
+    void             build_expression_array(
+                         const T_type_definitions  & type_definitions,
+                         const std::string         & str);
+
+public:
+    const C_value &  compute_expression(
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const std::string             & data_name,
+                         const std::string             & data_simple_name,
+                               std::ostream            & os_out,
+                               std::ostream            & os_err,
+                               bool                      pre_compute,
+                               bool                    & pre_compute_result) const;
+private:
+
+    void      compute_expression_variable_array(
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const std::string             & data_name,
+                         const std::string             & data_simple_name,
+                               std::ostream            & os_out,
+                               std::ostream            & os_err,
+                               bool                      pre_compute,
+                               bool                    & pre_compute_result) const;
+
+    void      compute_expression_function(
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const std::string             & data_name,
+                         const std::string             & data_simple_name,
+                               std::ostream            & os_out,
+                               std::ostream            & os_err,
+                               bool                      pre_compute,
+                               bool                    & pre_compute_result) const;
+
+    void      compute_expression_operation(
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const std::string             & data_name,
+                         const std::string             & data_simple_name,
+                               std::ostream            & os_out,
+                               std::ostream            & os_err,
+                               bool                      pre_compute,
+                               bool                    & pre_compute_result) const;
+
+    // The original string from which the expression have been build.
+    //
+    std::string                         A_original_string_expression;
+
+    // True if the value has already been calculated (during initialisation).
+    mutable bool                        A_value_alreay_computed;
+
+    // Type of expression.
+    E_type                              A_type;
+
+    // The value.
+    // compute_expression always return this value.
+    mutable C_value                     A_value;
+
+    // Name of the variable or name of the function.
+    std::string                         A_variable_or_function_name;
+
+    // Operation to do (with A_expressions)
+    E_operation                         A_operation;
+
+    // Expression for function call or operation or variable with array
+    mutable std::vector<T_expression>   A_expressions;
+
+    // Expressions for array index
+#if 0
+
+    struct T_array
+    {
+        T_expression  expression;
+        // reduced_variable_name :
+        // if the orginal variable name was   "left[idx_1].field[idx_2][idx_3]"
+        //  then the reduced_variable_name is "left[].field[][]"
+        // This idx_... gives the position where to insert
+        //  the result of the expression.
+        int           idx_inside_reduced_variable_name;
+    };
+//    std::vector<T_array>        A_arrays;
+#endif
+
+    friend std::ostream &  operator<< (std::ostream    & os,
+                             const T_expression    & rhs);
+    friend std::ostream &  operator<< (std::ostream            & os,
+                             const T_expression::E_type    & rhs);
+    friend std::ostream &  operator<< (std::ostream               & os,
+                             const T_expression::E_operation  & rhs);
+
+public:
+    const std::vector<T_expression>& get_expressions_for_UT() const { return A_expressions; }
+};
+
+std::ostream &  operator<< (std::ostream    & os,
+                      const T_expression    & rhs);
+std::ostream &  operator<< (std::ostream            & os,
+                      const T_expression::E_type    & rhs);
+std::ostream &  operator<< (std::ostream               & os,
+                      const T_expression::E_operation  & rhs);
+
+
+
+#endif /* T_expression_h */
diff --git a/plugins/epan/generic/T_frame_data.cpp b/plugins/epan/generic/T_frame_data.cpp
new file mode 100644
index 00000000000..dcb3d7bc0ca
--- /dev/null
+++ b/plugins/epan/generic/T_frame_data.cpp
@@ -0,0 +1,344 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "T_frame_data.h"
+
+using namespace std;
+
+//*****************************************************************************
+// T_frame_data
+//*****************************************************************************
+
+T_frame_data::T_frame_data()
+    :A_P_bytes (nullptr),
+     A_remaining_bits (0),
+     A_initial_P_bytes (nullptr),
+     A_bit_offset_in_1st_byte (0),
+     A_initial_sizeof_bits (0),
+     A_initial_frame_starting_bit_offset (0)
+{
+}
+
+//*****************************************************************************
+// T_frame_data
+//*****************************************************************************
+
+T_frame_data::T_frame_data(const void       * P_bytes_void,
+                           const short        bit_offset_in_1st_byte_param,
+                           const long         sizeof_bits)
+    :A_P_bytes ((const T_byte *)P_bytes_void),
+     A_remaining_bits (sizeof_bits),
+     A_initial_P_bytes (A_P_bytes),
+     A_bit_offset_in_1st_byte (bit_offset_in_1st_byte_param),
+     A_initial_sizeof_bits (sizeof_bits),
+     A_initial_frame_starting_bit_offset (0)
+{
+}
+
+//*****************************************************************************
+// get_remaining_entire_bytes
+//*****************************************************************************
+long
+T_frame_data::get_remaining_entire_bytes() const
+{
+    return  (A_remaining_bits - (A_remaining_bits % 8)) / 8;
+}
+
+//*****************************************************************************
+// set_offset
+//*****************************************************************************
+void
+T_frame_data::set_offset(long    byte_offset, short   bit_offset_in_byte)
+{
+    set_bit_offset((byte_offset * 8) + bit_offset_in_byte);
+}
+
+//*****************************************************************************
+// set_bit_offset
+//*****************************************************************************
+void
+T_frame_data::set_bit_offset(long    bit_offset)
+{
+    M_FATAL_IF_LT(bit_offset, 0);
+    M_FATAL_IF_GT(bit_offset, A_initial_sizeof_bits);
+
+    A_remaining_bits = A_initial_sizeof_bits - bit_offset;
+    long    physical_bit_offset = get_physical_bit_offset();
+    A_P_bytes = A_initial_P_bytes + ((physical_bit_offset - (physical_bit_offset % 8)) / 8);
+}
+
+//*****************************************************************************
+// can_move_forward
+//*****************************************************************************
+bool
+T_frame_data::can_move_forward(long    byte_offset, short   bit_offset_in_byte) const
+{
+    return  can_move_bit_forward((byte_offset * 8) + bit_offset_in_byte);
+}
+
+//*****************************************************************************
+// move_forward
+//*****************************************************************************
+void
+T_frame_data::move_forward(long    byte_offset, short   bit_offset_in_byte)
+{
+    move_bit_forward((byte_offset * 8) + bit_offset_in_byte);
+}
+
+//*****************************************************************************
+// can_move_bit_forward
+//*****************************************************************************
+bool
+T_frame_data::can_move_bit_forward(long    bit_offset) const
+{
+    M_FATAL_IF_LT(bit_offset, 0);
+
+    if (A_remaining_bits < bit_offset)
+        return  false;
+
+    return  true;
+}
+
+//*****************************************************************************
+// move_bit_forward
+//*****************************************************************************
+void
+T_frame_data::move_bit_forward(long    bit_offset)
+{
+    M_FATAL_IF_FALSE(can_move_bit_forward(bit_offset));
+
+    set_bit_offset(A_initial_sizeof_bits - (A_remaining_bits - bit_offset));
+}
+
+//*****************************************************************************
+// can_move
+//*****************************************************************************
+bool
+T_frame_data::can_move(long    byte_offset, short   bit_offset_in_byte) const
+{
+    return  can_move_bit((byte_offset * 8) + bit_offset_in_byte);
+}
+
+//*****************************************************************************
+// move
+//*****************************************************************************
+void
+T_frame_data::move(long    byte_offset, short   bit_offset_in_byte)
+{
+    move_bit((byte_offset * 8) + bit_offset_in_byte);
+}
+
+//*****************************************************************************
+// can_move_bit
+//*****************************************************************************
+bool
+T_frame_data::can_move_bit(long    bit_offset) const
+{
+    if (A_remaining_bits < bit_offset)
+        return  false;
+
+    if (A_remaining_bits-bit_offset > A_initial_sizeof_bits)
+        return  false;
+
+    return  true;
+}
+
+//*****************************************************************************
+// move_bit
+//*****************************************************************************
+void
+T_frame_data::move_bit(long    bit_offset)
+{
+    M_FATAL_IF_FALSE(can_move_bit(bit_offset));
+
+    set_bit_offset(A_initial_sizeof_bits - (A_remaining_bits - bit_offset));
+}
+
+//*****************************************************************************
+// read_1_byte
+//*****************************************************************************
+T_byte    
+T_frame_data::read_1_byte()
+{
+    M_FATAL_IF_LT(A_remaining_bits, 8);
+
+    T_byte    byte = *A_P_bytes;
+
+    if (is_physically_at_beginning_of_byte() != true)
+    {
+        unsigned char    byte_array[2];
+        memcpy(byte_array, A_P_bytes, 2);
+
+        const int   decalage_1 = get_physical_bit_offset() % 8;
+        byte_array[0] <<= decalage_1;
+        byte_array[1] >>= (8 - decalage_1);
+
+        byte = byte_array[0] | byte_array[1];
+    }
+
+    ++A_P_bytes;
+    A_remaining_bits -= 8;
+
+    return  byte;
+}
+
+//*****************************************************************************
+// read_n_bytes
+//*****************************************************************************
+void
+T_frame_data::read_n_bytes(short  n_bytes, void  * P_n_bytes_read_void)
+{
+    M_FATAL_IF_LT(n_bytes, 1);
+    M_FATAL_IF_NULL(P_n_bytes_read_void);
+
+    const short    n_bits = n_bytes * 8;
+
+    M_FATAL_IF_LT(A_remaining_bits, n_bits);
+
+    if (is_physically_at_beginning_of_byte() == true)
+    {
+        memcpy (P_n_bytes_read_void, A_P_bytes, n_bytes);
+        A_P_bytes += n_bytes;
+        A_remaining_bits -= n_bits;
+    }
+    else
+    {
+        const int   decalage_1 = get_physical_bit_offset() % 8;
+        const int   decalage_2 = 8 - decalage_1;
+
+        unsigned char  * P_n_bytes_read = (unsigned char*)P_n_bytes_read_void;
+
+        for (int  idx = 0; idx < n_bytes; ++idx)
+        {
+            unsigned char  byte_1 = *A_P_bytes << decalage_1;
+            ++A_P_bytes;
+            A_remaining_bits -= 8;
+
+            unsigned char  byte_2 = *A_P_bytes >> decalage_2;
+
+            *P_n_bytes_read = byte_1 | byte_2;
+            ++P_n_bytes_read;
+        }
+    }
+}
+
+//*****************************************************************************
+// read_less_1_byte
+//*****************************************************************************
+T_byte
+T_frame_data::read_less_1_byte(short  n_bits)
+{
+    M_FATAL_IF_LT(n_bits, 1);
+    M_FATAL_IF_GT(n_bits, 7);
+
+    M_FATAL_IF_LT(A_remaining_bits, n_bits);
+
+    T_byte    byte = *A_P_bytes;
+
+    const short    remaining_bits_in_byte = 8 - (get_physical_bit_offset() % 8);
+
+    if (remaining_bits_in_byte == 8)
+    {
+        byte >>= 8 - n_bits;
+        A_remaining_bits -= n_bits;
+        return  byte;
+    }
+
+    if (remaining_bits_in_byte >= n_bits)
+    {
+        byte = bit_erase_left(byte, 8 - remaining_bits_in_byte);
+
+        byte >>= remaining_bits_in_byte - n_bits;
+        A_remaining_bits -= n_bits;
+        if (remaining_bits_in_byte == n_bits)
+        {
+            ++A_P_bytes;
+        }
+        return  byte;
+    }
+
+    /* bits to read are on 2 bytes */
+    {
+        unsigned char    byte_array[2];
+        memcpy(byte_array, A_P_bytes, 2);
+
+        byte_array[0] <<= 8 - remaining_bits_in_byte;
+        byte_array[0] >>= 8 - remaining_bits_in_byte - (n_bits - remaining_bits_in_byte);
+
+        byte_array[1] >>= 8 - (n_bits - remaining_bits_in_byte);
+
+        byte = byte_array[0] | byte_array[1];
+
+        ++A_P_bytes;
+        A_remaining_bits -= n_bits;
+
+        return  byte;
+    }
+}
+
+//*****************************************************************************
+// read_n_bits
+//*****************************************************************************
+void
+T_frame_data::read_n_bits(short  n_bits, void  * P_n_bytes_read_void, short  n_bytes_read)
+{
+    M_FATAL_IF_LT(n_bits, 1);
+    M_FATAL_IF_NULL(P_n_bytes_read_void);
+    M_FATAL_IF_LT(n_bytes_read, 1);
+
+    // I suppose that n_bytes_read is enough AND not more.
+
+    if ((n_bits % 8) == 0)
+    {
+        read_n_bytes(n_bits / 8, P_n_bytes_read_void);
+        return;
+    }
+
+    unsigned char  * P_n_bytes_read = (unsigned char*)P_n_bytes_read_void;
+
+    *P_n_bytes_read = read_less_1_byte(n_bits % 8);
+    ++P_n_bytes_read;
+
+    if (n_bits > 8)
+    {
+        read_n_bytes(n_bits / 8, P_n_bytes_read);
+    }
+}
+
+//*****************************************************************************
+// set_initial_frame_starting_bit_offset
+//*****************************************************************************
+void
+T_frame_data::set_initial_frame_starting_bit_offset(long    bit_offset)
+{
+    A_initial_frame_starting_bit_offset = bit_offset;
+}
+
+//*****************************************************************************
+// set_bit_offset_into_initial_frame
+//*****************************************************************************
+void         
+T_frame_data::set_bit_offset_into_initial_frame(long    bit_offset)
+{
+    set_bit_offset(bit_offset - A_initial_frame_starting_bit_offset);
+}
diff --git a/plugins/epan/generic/T_frame_data.h b/plugins/epan/generic/T_frame_data.h
new file mode 100644
index 00000000000..06dd4abc5b8
--- /dev/null
+++ b/plugins/epan/generic/T_frame_data.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_frame_data_h
+#define T_frame_data_h
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "byte_interpret_common.h"
+
+
+//*****************************************************************************
+// T_frame_data
+// Reference some raw data (data not copied, allocated, deleted).
+// Manage a position inside this data.
+// Permits to read/write inside data.
+//*****************************************************************************
+
+struct T_frame_data : public CT_debug_object_counter<T_frame_data>
+{
+    T_frame_data();
+
+    // Ctor which define the data used.
+    T_frame_data(const void       * initial_P_bytes,
+                 const short        bit_offset_in_1st_byte,
+                 const long         initial_sizeof_bits);
+
+    // All methods except ...physical... take care of bit_offset_in_1st_byte.
+    // E.g: get_bit_offset gives the bit offset STARTING AT bit_offset_in_1st_byte.
+
+    // The offset of the current position from the beginning
+    long            get_bit_offset() const            { return  A_initial_sizeof_bits - A_remaining_bits; }
+    long            get_physical_bit_offset() const   { return  A_bit_offset_in_1st_byte + get_bit_offset(); }
+
+    // The current position
+    const T_byte  * get_P_bytes() const               { return  A_P_bytes; }
+    const T_byte  * get_initial_P_bytes() const       { return  A_initial_P_bytes; }
+
+    bool            is_physically_at_beginning_of_byte() const   { return  ((get_physical_bit_offset() % 8) == 0); }
+
+    // The remaining size from the current position
+    long            get_remaining_bits() const   { return  A_remaining_bits; }
+    long            get_remaining_entire_bytes() const;
+
+
+    // The initial size
+    long      get_initial_sizeof_bits() const    { return  A_initial_sizeof_bits; }
+
+
+    // Move inside data.
+    bool    can_move_1_byte_forward() const             { return  (A_remaining_bits >= 8); }
+    void        move_1_byte_forward()                   { move_bit(8); }
+
+    bool    can_move_forward(long    byte_offset, short   bit_offset_in_byte) const;
+    void        move_forward(long    byte_offset, short   bit_offset_in_byte);
+
+    bool    can_move_bit_forward(long    bit_offset) const;
+    void        move_bit_forward(long    bit_offset);
+
+    bool    can_move(long    byte_offset, short   bit_offset_in_byte) const;
+    void        move(long    byte_offset, short   bit_offset_in_byte);
+
+    bool    can_move_bit(long    bit_offset) const;
+    void        move_bit(long    bit_offset);
+
+    void    set_offset(long    byte_offset, short   bit_offset_in_byte);
+    void    set_bit_offset(long    bit_offset);
+
+    // Read some data.
+    T_byte          read_1_byte();
+    void            read_n_bytes(short  n_bytes, void  * P_n_bytes_read);
+    T_byte          read_less_1_byte(short  n_bits);
+    void            read_n_bits(short  n_bits, void  * P_n_bytes_read, short  n_bytes_read);
+
+
+    // Parent frame
+    void         set_initial_frame_starting_bit_offset(long    bit_offset);
+    long         get_bit_offset_into_initial_frame() const   { return  get_bit_offset() + A_initial_frame_starting_bit_offset; }
+    void         set_bit_offset_into_initial_frame(long    bit_offset);
+
+
+    // Interface dedicated to T_decode_stream_frame
+    void        n_bits_data_appended(long    n_bits) { A_initial_sizeof_bits += n_bits; A_remaining_bits += n_bits; }
+
+private:
+protected:
+    // NB: copy ctor and assignment operators are ok
+    // Because no memory is managed here, it only points to ...
+
+    const T_byte  * A_P_bytes;
+    long            A_remaining_bits;
+
+    const T_byte  * A_initial_P_bytes;
+    short           A_bit_offset_in_1st_byte;
+    long            A_initial_sizeof_bits;
+
+    // Bit offset into the parent frame where this frame starts
+    long            A_initial_frame_starting_bit_offset;
+};
+
+//*****************************************************************************
+// 
+//*****************************************************************************
+inline
+T_byte  bit_erase_left(T_byte  byte, short  n_bits)
+{
+    byte <<= n_bits;
+    byte >>= n_bits;
+    return  byte;
+}
+
+inline
+T_byte  bit_erase_right(T_byte  byte, short  n_bits)
+{
+    byte >>= n_bits;
+    byte <<= n_bits;
+    return  byte;
+}
+
+inline
+T_byte  bit_erase_left_right(T_byte  byte, short  n_bits_left, short  n_bits_right)
+{
+    byte = bit_erase_left (byte, n_bits_left);
+    byte = bit_erase_right(byte, n_bits_right);
+    return  byte;
+}
+
+inline
+T_byte  bit_set_left(T_byte  byte, short  n_bits)
+{
+    byte |= bit_erase_right(0xff, 8 - n_bits);
+    return  byte;
+}
+
+inline
+T_byte  bit_set_right(T_byte  byte, short  n_bits)
+{
+    byte |= bit_erase_left(0xff, 8 - n_bits);
+    return  byte;
+}
+
+inline
+T_byte  bit_set_left_right(T_byte  byte, short  n_bits_left, short  n_bits_right)
+{
+    byte = bit_set_left (byte, n_bits_left);
+    byte = bit_set_right(byte, n_bits_right);
+    return  byte;
+}
+
+
+
+
+#endif /* T_frame_data_h */
diff --git a/plugins/epan/generic/T_frame_data_write.cpp b/plugins/epan/generic/T_frame_data_write.cpp
new file mode 100644
index 00000000000..343286b109d
--- /dev/null
+++ b/plugins/epan/generic/T_frame_data_write.cpp
@@ -0,0 +1,221 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "T_frame_data_write.h"
+
+using namespace std;
+
+//*****************************************************************************
+// T_frame_data_write
+//*****************************************************************************
+
+T_frame_data_write::T_frame_data_write()
+    :T_frame_data ()
+{
+}
+
+//*****************************************************************************
+// T_frame_data_write
+//*****************************************************************************
+
+T_frame_data_write::T_frame_data_write(void       * P_bytes_void,
+                           const short        bit_offset_in_1st_byte,
+                           const long         sizeof_bits)
+    :T_frame_data (P_bytes_void, bit_offset_in_1st_byte, sizeof_bits)
+{
+}
+
+//*****************************************************************************
+// write_1_byte
+//*****************************************************************************
+void
+T_frame_data_write::write_1_byte(T_byte  byte)
+{
+    M_FATAL_IF_LT(A_remaining_bits, 8);
+
+    if (is_physically_at_beginning_of_byte() != true)
+    {
+        unsigned char    byte_array[2];
+        memset(byte_array, 0xff, sizeof(byte_array));
+
+        const int   decalage_1 = get_physical_bit_offset() % 8;
+
+        T_byte  byte0 = byte >> decalage_1;
+        byte_array[0] &= byte0;
+
+        T_byte  byte1 = byte << (8 - decalage_1);
+        byte_array[1] &= byte1;
+
+        memcpy(const_cast<T_byte*>(A_P_bytes), byte_array, sizeof(byte_array));
+    }
+    else
+    {
+        *const_cast<T_byte*>(A_P_bytes) = byte;
+    }
+
+    ++A_P_bytes;
+    A_remaining_bits -= 8;
+}
+
+//*****************************************************************************
+// write_n_bytes
+//*****************************************************************************
+void
+T_frame_data_write::write_n_bytes(short  n_bytes, const void  * P_n_bytes_write_void)
+{
+    M_FATAL_IF_LT(n_bytes, 1);
+    M_FATAL_IF_NULL(P_n_bytes_write_void);
+
+    const short    n_bits = n_bytes * 8;
+
+    M_FATAL_IF_LT(A_remaining_bits, n_bits);
+
+    if (is_physically_at_beginning_of_byte() == true)
+    {
+        memcpy (const_cast<T_byte*>(A_P_bytes), P_n_bytes_write_void, n_bytes);
+        A_P_bytes += n_bytes;
+        A_remaining_bits -= n_bits;
+    }
+    else
+    {
+        unsigned char  * P_n_bytes_write = (unsigned char*)P_n_bytes_write_void;
+        for (int  idx = 0; idx < n_bytes; ++idx)
+        {
+            write_1_byte(P_n_bytes_write[idx]);
+        }
+    }
+}
+
+//*****************************************************************************
+// write_less_1_byte
+//*****************************************************************************
+// Take the lower significant bits
+//*****************************************************************************
+void
+T_frame_data_write::write_less_1_byte(T_byte  byte, short  n_bits)
+{
+    if (n_bits == 8)
+    {
+        write_1_byte(byte);
+        return;
+    }
+
+    M_FATAL_IF_LT(n_bits, 1);
+    M_FATAL_IF_GT(n_bits, 7);
+
+    M_FATAL_IF_LT(A_remaining_bits, n_bits);
+
+    const short    remaining_bits_in_byte = 8 - (get_physical_bit_offset() % 8);
+
+    if (remaining_bits_in_byte == 8)
+    {
+        // We are at the beginning of the destination byte.
+
+        // move to left & right bits = 0
+        byte <<= 8 - n_bits;
+
+        T_byte    byte_in_place = bit_erase_left(*A_P_bytes, n_bits);
+
+        byte_in_place |= byte;
+
+        *const_cast<T_byte*>(A_P_bytes) = byte_in_place;
+        A_remaining_bits -= n_bits;
+        return;
+    }
+
+    if (remaining_bits_in_byte >= n_bits)
+    {
+        // We are not at the beginning of the destination byte.
+        // But still fit in this 1 destination byte. 
+
+        // move to left & right bits = 0
+        byte <<= 8 - n_bits;
+        // move to right place & left bits = 0
+        byte >>= 8 - remaining_bits_in_byte;
+
+        T_byte    byte_in_place_left  = bit_erase_right(*A_P_bytes, remaining_bits_in_byte);
+        T_byte    byte_in_place_right = bit_erase_left (*A_P_bytes, 8 - (remaining_bits_in_byte - n_bits));
+
+        *const_cast<T_byte*>(A_P_bytes) = byte_in_place_left | byte | byte_in_place_right;
+
+        A_remaining_bits -= n_bits;
+        if (remaining_bits_in_byte == n_bits)
+        {
+            ++A_P_bytes;
+        }
+        return;
+    }
+
+    /* bits to write are on 2 destination bytes */
+    {
+        byte = bit_erase_left(byte, 8 - n_bits);
+
+        T_byte         byte_to_set_1 = byte >> (n_bits - remaining_bits_in_byte);
+        T_byte         byte_in_place_1 = bit_erase_right(*A_P_bytes, remaining_bits_in_byte);
+        byte_to_set_1 |= byte_in_place_1;
+
+        T_byte         byte_to_set_2 = byte << (8 - (n_bits - remaining_bits_in_byte));
+        T_byte         byte_in_place_2 = bit_erase_left(*A_P_bytes, n_bits - remaining_bits_in_byte);
+        byte_to_set_2 |= byte_in_place_2;
+
+        unsigned char    byte_array[2];
+        byte_array[0] = byte_to_set_1 | byte_in_place_1;
+        byte_array[1] = byte_to_set_2 | byte_in_place_2;
+
+        memcpy(const_cast<T_byte*>(A_P_bytes), byte_array, 2);
+
+        ++A_P_bytes;
+        A_remaining_bits -= n_bits;
+
+        return;
+    }
+}
+
+//*****************************************************************************
+// write_n_bits
+//*****************************************************************************
+void
+T_frame_data_write::write_n_bits(short  n_bits, const void  * P_n_bytes_write_void, short  n_bytes_write)
+{
+    M_FATAL_IF_LT(n_bits, 1);
+    M_FATAL_IF_NULL(P_n_bytes_write_void);
+    M_FATAL_IF_LT(n_bytes_write, 1);
+
+    // I suppose that n_bytes_write is enough AND not more.
+
+    if ((n_bits % 8) == 0)
+    {
+        write_n_bytes(n_bits / 8, P_n_bytes_write_void);
+        return;
+    }
+
+    unsigned char  * P_n_bytes_write = (unsigned char*)P_n_bytes_write_void;
+
+    write_less_1_byte(*P_n_bytes_write, n_bits % 8);
+    ++P_n_bytes_write;
+
+    if (n_bits > 8)
+    {
+        write_n_bytes(n_bits / 8, P_n_bytes_write);
+    }
+}
diff --git a/plugins/epan/generic/T_frame_data_write.h b/plugins/epan/generic/T_frame_data_write.h
new file mode 100644
index 00000000000..302854f7842
--- /dev/null
+++ b/plugins/epan/generic/T_frame_data_write.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_frame_data_write_h
+#define T_frame_data_write_h
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "T_frame_data.h"
+
+
+//*****************************************************************************
+// T_frame_data
+// Reference some raw data (data not copied, allocated, deleted).
+// Manage a position inside this data.
+// Permits to read/write inside data.
+//*****************************************************************************
+
+struct T_frame_data_write : public T_frame_data
+{
+    T_frame_data_write();
+
+    // Ctor which define the data used.
+    T_frame_data_write(void       * initial_P_bytes,
+                 const short        bit_offset_in_1st_byte,
+                 const long         initial_sizeof_bits);
+
+    // Write some data.
+    void            write_1_byte(T_byte  byte);
+    void            write_n_bytes(short  n_bytes, const void  * P_n_bytes_write);
+    void            write_less_1_byte(T_byte  byte, short  n_bits);
+    void            write_n_bits(short  n_bits, const void  * P_n_bytes_write, short  n_bytes_write);
+};
+
+
+#endif /* T_frame_data_write_h */
diff --git a/plugins/epan/generic/T_generic_protocol_data.cpp b/plugins/epan/generic/T_generic_protocol_data.cpp
new file mode 100644
index 00000000000..77d5ec5a09a
--- /dev/null
+++ b/plugins/epan/generic/T_generic_protocol_data.cpp
@@ -0,0 +1,559 @@
+/*
+ * Copyright 2008-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes
+//*****************************************************************************
+
+#include "T_generic_protocol_data.h"
+#include "byte_interpret_common.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+#include "byte_interpret_build_types_context.h"
+
+#include <fstream>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <wsutil/filesystem.h>
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+//*****************************************************************************
+// 
+//*****************************************************************************
+
+// Only 1 data handle for all dissectors.
+// Initialized only once.
+dissector_handle_t  T_generic_protocol_subdissector_data::data_handle = nullptr;    // recursive call ok
+
+
+/******************************************************************************
+ * T_generic_protocol_ws_data
+ *****************************************************************************/
+
+#if 0
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <stdio.h>
+#include <glib.h>
+#include <epan/packet.h>
+
+
+//*****************************************************************************
+// dump_hf_data
+//*****************************************************************************
+
+void    dump_hf_data(const hf_register_info  * hf)
+{
+    M_FATAL_IF_FALSE(hf != nullptr);
+
+    M_FATAL_IF_FALSE(hf->p_id != nullptr);
+    trace_value_ptr ("c   hf->p_id",  hf->p_id);
+    trace_value_int ("c  *hf->p_id", *hf->p_id);
+
+    trace_value_str ("c   hf->hfinfo.name", hf->hfinfo.name);
+    trace_value_str ("c   hf->hfinfo.abbrev", hf->hfinfo.abbrev);
+    trace_value_int ("c   hf->hfinfo.type", hf->hfinfo.type);
+    if (hf->hfinfo.type == 0)
+    {
+        M_FATAL_IF_FALSE(hf->hfinfo.display == 0);
+    }
+    else
+        trace_value_int ("c   hf->hfinfo.display", hf->hfinfo.display);
+    trace_value_ptr ("c   hf->hfinfo.strings", hf->hfinfo.strings);
+    //trace_value_int ("c   hf->hfinfo.bitmask", hf->hfinfo.bitmask);
+    //trace_value_str ("c   hf->hfinfo.blurb", hf->hfinfo.blurb);
+    M_FATAL_IF_FALSE(hf->hfinfo.bitmask == 0);
+    M_FATAL_IF_FALSE(hf->hfinfo.blurb == hf->hfinfo.name);
+
+    //trace_value_int ("c   hf->hfinfo.id", hf->hfinfo.id);
+    //trace_value_int ("c   hf->hfinfo.parent", hf->hfinfo.parent);
+    //trace_value_int ("c   hf->hfinfo.ref_count", hf->hfinfo.ref_count);
+    //trace_value_int ("c   hf->hfinfo.bitshift", hf->hfinfo.bitshift);
+    //trace_value_ptr ("c   hf->hfinfo.same_name_next", hf->hfinfo.same_name_next);
+    //trace_value_ptr ("c   hf->hfinfo.same_name_prev", hf->hfinfo.same_name_prev);
+    M_FATAL_IF_FALSE(hf->hfinfo.id == 0);
+    M_FATAL_IF_FALSE(hf->hfinfo.parent == 0);
+    M_FATAL_IF_FALSE(hf->hfinfo.ref_count == 0);
+    M_FATAL_IF_FALSE(hf->hfinfo.bitshift == 0);
+    M_FATAL_IF_FALSE(hf->hfinfo.same_name_next == nullptr);
+    M_FATAL_IF_FALSE(hf->hfinfo.same_name_prev == nullptr);
+}
+
+//*****************************************************************************
+// dump_hf_datas
+//*****************************************************************************
+
+void    dump_hf_datas(const int                 nb_of_hfs,
+                      const hf_register_info  * hf,
+                      const char              * title)
+{
+    int   idx_data;
+    trace_str (title);
+    for (idx_data = 0; idx_data < nb_of_hfs; ++idx_data)
+    {
+        trace_value_int ("c   idx_data", idx_data);
+        dump_hf_data(&hf[idx_data]);
+    }
+}
+
+//*****************************************************************************
+// dump_fields_data
+//*****************************************************************************
+
+void    dump_fields_data(const T_generic_protocol_ws_data  * P_protocol_ws_data,
+                         const char                         * title,
+                         const int                            before_register)
+{
+    int   idx_data;
+    trace_str (title);
+    for (idx_data = 0; idx_data <= P_protocol_ws_data->fields_data.max_field_idx; ++idx_data)
+    {
+        trace_value_int ("c   idx_data", idx_data);
+
+        if ((idx_data > 0) && (before_register == FALSE))
+        {
+            M_FATAL_IF_FALSE(P_protocol_ws_data->fields_data.ett_id[idx_data] == P_protocol_ws_data->fields_data.ett_id[idx_data-1]+1);
+        }
+        else
+            trace_value_int ("c   ett_id[idx_data]", P_protocol_ws_data->fields_data.ett_id[idx_data]);
+
+        //trace_value_ptr ("c  &ett_id[idx_data]", &P_protocol_ws_data->fields_data.ett_id[idx_data]);
+        //trace_value_ptr ("c   ett[idx_data]", P_protocol_ws_data->fields_data.ett[idx_data]);
+        M_FATAL_IF_FALSE(P_protocol_ws_data->fields_data.ett[idx_data] == &P_protocol_ws_data->fields_data.ett_id[idx_data]);
+
+        trace_value_int ("c   hf_id[idx_data]", P_protocol_ws_data->fields_data.hf_id[idx_data]);
+        //trace_value_ptr ("c  &hf_id[idx_data]", &P_protocol_ws_data->fields_data.hf_id[idx_data]);
+        //trace_value_ptr ("c   hf[idx_data].p_id", P_protocol_ws_data->fields_data.hf[idx_data].p_id);
+        M_FATAL_IF_FALSE(P_protocol_ws_data->fields_data.hf[idx_data].p_id == &P_protocol_ws_data->fields_data.hf_id[idx_data]);
+
+        trace_value_str ("c   hf[idx_data].hfinfo.name", P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.name);
+        trace_value_str ("c   hf[idx_data].hfinfo.abbrev", P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.abbrev);
+        trace_value_int ("c   hf[idx_data].hfinfo.type", P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.type);
+        if (P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.type == 0)
+        {
+            M_FATAL_IF_FALSE(P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.display == 0);
+        }
+        else
+            trace_value_int ("c   hf[idx_data].hfinfo.display", P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.display);
+        trace_value_ptr ("c   hf[idx_data].hfinfo.strings", P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.strings);
+        //trace_value_int ("c   hf[idx_data].hfinfo.bitmask", P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.bitmask);
+        //trace_value_str ("c   hf[idx_data].hfinfo.blurb", P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.blurb);
+        M_FATAL_IF_FALSE(P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.bitmask == 0);
+        M_FATAL_IF_FALSE(P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.blurb == P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.name);
+
+        trace_value_int ("c   hf[idx_data].hfinfo.id", P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.id);
+        trace_value_int ("c   hf[idx_data].hfinfo.parent", P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.parent);
+        trace_value_int ("c   hf[idx_data].hfinfo.ref_count", P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.ref_count);
+        trace_value_int ("c   hf[idx_data].hfinfo.bitshift", P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.bitshift);
+        trace_value_ptr ("c   hf[idx_data].hfinfo.same_name_next", P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.same_name_next);
+        trace_value_ptr ("c   hf[idx_data].hfinfo.same_name_prev", P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.same_name_prev);
+        //M_FATAL_IF_FALSE(P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.id == 0);
+        //M_FATAL_IF_FALSE(P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.parent == 0);
+        //M_FATAL_IF_FALSE(P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.ref_count == 0);
+        //M_FATAL_IF_FALSE(P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.bitshift == 0);
+        //M_FATAL_IF_FALSE(P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.same_name_next == nullptr);
+        //M_FATAL_IF_FALSE(P_protocol_ws_data->fields_data.hf[idx_data].hfinfo.same_name_prev == nullptr);
+    }
+}
+#endif
+
+/******************************************************************************
+ * dissect_generic_<proto_idx>
+ *****************************************************************************/
+
+int   S_proto_idx_dissect_in_progress = -1;
+
+#define M_DEFINE_DISSECT_FCT(PROTO_IDX)                                                   \
+static gint                                                                               \
+dissect_generic_ ## PROTO_IDX (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *)       \
+{                                                                                         \
+    M_TRACE_ENTER("dissect_generic_proto", PROTO_IDX);                                    \
+                                                                                          \
+    const int   previous_proto_idx_dissect_in_progress = S_proto_idx_dissect_in_progress; \
+    S_proto_idx_dissect_in_progress = PROTO_IDX;                                          \
+                                                                                          \
+    const int   result = dissect_generic_proto(PROTO_IDX, tvb, pinfo, tree);              \
+                                                                                          \
+    S_proto_idx_dissect_in_progress = previous_proto_idx_dissect_in_progress;             \
+                                                                                          \
+    return  result;                                                                       \
+}
+
+#define M_DEFINE_HEURISTIC_FCT(PROTO_IDX)                                                 \
+static gboolean                                                                           \
+heuristic_generic_ ## PROTO_IDX (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *)     \
+{                                                                                         \
+    M_TRACE_ENTER("heuristic_generic_proto", PROTO_IDX);                                  \
+                                                                                          \
+    const int   previous_proto_idx_dissect_in_progress = S_proto_idx_dissect_in_progress; \
+    S_proto_idx_dissect_in_progress = PROTO_IDX;                                          \
+                                                                                          \
+    const int   result = heuristic_generic_proto(PROTO_IDX, tvb, pinfo, tree);            \
+                                                                                          \
+    S_proto_idx_dissect_in_progress = previous_proto_idx_dissect_in_progress;             \
+                                                                                          \
+    return  result;                                                                       \
+}
+
+
+#define M_DEFINE_PROTO_FCT(PROTO_IDX)                                                     \
+        M_DEFINE_DISSECT_FCT(PROTO_IDX)                                                   \
+        M_DEFINE_HEURISTIC_FCT(PROTO_IDX)
+
+
+M_DEFINE_PROTO_FCT(0)
+M_DEFINE_PROTO_FCT(1)
+M_DEFINE_PROTO_FCT(2)
+M_DEFINE_PROTO_FCT(3)
+M_DEFINE_PROTO_FCT(4)
+M_DEFINE_PROTO_FCT(5)
+M_DEFINE_PROTO_FCT(6)
+M_DEFINE_PROTO_FCT(7)
+M_DEFINE_PROTO_FCT(8)
+M_DEFINE_PROTO_FCT(9)
+M_DEFINE_PROTO_FCT(10)
+M_DEFINE_PROTO_FCT(11)
+M_DEFINE_PROTO_FCT(12)
+M_DEFINE_PROTO_FCT(13)
+M_DEFINE_PROTO_FCT(14)
+M_DEFINE_PROTO_FCT(15)
+M_DEFINE_PROTO_FCT(16)
+M_DEFINE_PROTO_FCT(17)
+M_DEFINE_PROTO_FCT(18)
+M_DEFINE_PROTO_FCT(19)
+
+#undef M_DEFINE_PROTO_FCT
+
+//*****************************************************************************
+// The protocol's data
+//*****************************************************************************
+
+/*static*/ vector<T_generic_protocol_data>    S_protocol_data;
+
+T_generic_protocol_data  & get_protocol_data(const int   proto_idx)
+{
+    M_FATAL_IF_GE(proto_idx, static_cast<long>(S_protocol_data.size()));
+
+    return  S_protocol_data[proto_idx];
+}
+
+T_generic_protocol_data  & new_protocol_data(const int   proto_idx)
+{
+    M_FATAL_IF_GE(proto_idx, static_cast<long>(S_protocol_data.size()));
+
+    S_protocol_data[proto_idx].proto_idx = proto_idx;
+
+#define M_DEFINE_PROTO_FCT(PROTO_IDX)                                                         \
+    else if (proto_idx == PROTO_IDX)                                                          \
+    {                                                                                         \
+        S_protocol_data[proto_idx].ws_data.P_dissect_fct   =   dissect_generic_ ## PROTO_IDX; \
+        S_protocol_data[proto_idx].ws_data.P_heuristic_fct = heuristic_generic_ ## PROTO_IDX; \
+    }
+
+    if (FALSE)  ;
+    M_DEFINE_PROTO_FCT(0)
+    M_DEFINE_PROTO_FCT(1)
+    M_DEFINE_PROTO_FCT(2)
+    M_DEFINE_PROTO_FCT(3)
+    M_DEFINE_PROTO_FCT(4)
+    M_DEFINE_PROTO_FCT(5)
+    M_DEFINE_PROTO_FCT(6)
+    M_DEFINE_PROTO_FCT(7)
+    M_DEFINE_PROTO_FCT(8)
+    M_DEFINE_PROTO_FCT(9)
+    M_DEFINE_PROTO_FCT(10)
+    M_DEFINE_PROTO_FCT(11)
+    M_DEFINE_PROTO_FCT(12)
+    M_DEFINE_PROTO_FCT(13)
+    M_DEFINE_PROTO_FCT(14)
+    M_DEFINE_PROTO_FCT(15)
+    M_DEFINE_PROTO_FCT(16)
+    M_DEFINE_PROTO_FCT(17)
+    M_DEFINE_PROTO_FCT(18)
+    M_DEFINE_PROTO_FCT(19)
+
+#undef M_DEFINE_PROTO_FCT
+
+    M_FATAL_IF_EQ(S_protocol_data[proto_idx].ws_data.P_dissect_fct, nullptr);
+
+
+    return  S_protocol_data[proto_idx];
+}
+
+// This could NOT work because
+//  it could happen that the protocol is already registered and in this case :
+// - I could NOT unregister it        and so
+// - I must keep data because whireshark use them (proto names)
+// So if I remove data, all following protocols are said already existent !!!
+#if 0
+void    remove_protocol_data_if_exist(const int   proto_idx)
+{
+    M_FATAL_IF_GE(proto_idx, static_cast<long>(S_protocol_data.size()));
+
+    // WARNING_ADDRESSES
+    // NB: this function is supposed to be called only during register initialisation.
+    // At this moment, the protocols after this one are supposed NOT initialized.
+    // pop_back do NOT change the address of the vector.
+    S_protocol_data[proto_idx] = T_generic_protocol_data();
+    S_protocol_data.pop_back();
+
+    return;
+}
+#endif
+
+T_generic_protocol_data  & get_protocol_data_from_proto_abbrev(const char  * proto_abbrev)
+{
+    for (vector<T_generic_protocol_data>::iterator  iter  = S_protocol_data.begin();
+                                                    iter != S_protocol_data.end();
+                                                  ++iter)
+    {
+        if (proto_abbrev == iter->PROTOABBREV)
+        {
+            return  *iter;
+        }
+    }
+
+    M_FATAL_COMMENT("Proto abbrev " << proto_abbrev << " NOT found.");
+
+    return  *(T_generic_protocol_data*)nullptr;        // avoid compiler warning
+}
+
+void    set_max_nb_of_protocol_data(const size_t   max_nb)
+{
+    M_TRACE_ENTER("set_max_nb_of_protocol_data", max_nb);
+
+    // WARNING_ADDRESSES
+    // It is mandatory to add all items now.
+    for (size_t proto_idx = 0; proto_idx < max_nb; ++proto_idx)
+    {
+        T_generic_protocol_data    protocol_data;
+
+        // Do NOT set proto_idx attribute.
+        // It permits to know if protocol_data has been initialized.
+
+        S_protocol_data.push_back(protocol_data);
+    }
+}
+
+//*****************************************************************************
+// add_initial_types
+//*****************************************************************************
+#if 0
+void    add_initial_types (T_generic_protocol_data  & protocol_data)
+{
+    // Define bool8 (and others) as enums.
+    // Necessary for wireshark display filters accept "false" and "true".
+    //  if (protocol_data.type_definitions.is_a_type_name("bool8") == false)
+    {
+        istringstream           iss("enum8     bool8   { false 0  true 1 }");
+
+        const string    result = build_types(iss, protocol_data.type_definitions);
+        M_FATAL_IF_NE(result, "");
+    }
+
+    //  if (protocol_data.type_definitions.is_a_type_name("bool16") == false)
+    {
+        istringstream           iss("enum16    bool16  as  bool8 ;");
+
+        const string    result = build_types(iss, protocol_data.type_definitions);
+        M_FATAL_IF_NE(result, "");
+    }
+    //  if (protocol_data.type_definitions.is_a_type_name("bool32") == false)
+    {
+        istringstream           iss("enum32    bool32  as  bool8 ;");
+
+        const string    result = build_types(iss, protocol_data.type_definitions);
+        M_FATAL_IF_NE(result, "");
+    }
+    //  if (protocol_data.type_definitions.is_a_type_name("bool1") == false)
+    {
+        istringstream           iss("enum1    bool1  as  bool8 ;");
+
+        const string    result = build_types(iss, protocol_data.type_definitions);
+        M_FATAL_IF_NE(result, "");
+    }
+}
+#endif
+//*****************************************************************************
+// read_file_wsgd
+//*****************************************************************************
+
+void    read_file_wsgd (const string                   & wsgd_file_name,
+                              T_generic_protocol_data  & protocol_data)
+{
+    M_TRACE_ENTER("read_file_wsgd", wsgd_file_name);
+    ifstream              ifs(wsgd_file_name.c_str());
+    if (!ifs)
+    {
+        M_FATAL_COMMENT("Impossible to open file " << wsgd_file_name);
+    }
+
+    const std::string file_content{ std::istreambuf_iterator<char>(ifs),
+                                    std::istreambuf_iterator<char>() };
+    istringstream  iss(file_content);
+
+    // Read the 1st part of the file (until PROTO_TYPE_DEFINITIONS)
+    read_file_wsgd_until_types(iss, protocol_data, protocol_data.ws_data.tap_data.stats);
+
+    // Read the type definitions of the protocol.
+    C_debug_set_temporary  debug_register_proto_main(protocol_data.DEBUG);
+    C_debug_set_temporary  debug_type_definitions;
+    bool                   must_ouput_types = false;
+
+    //  add_initial_types (protocol_data);
+    string    wsgd_file_name_short = wsgd_file_name;
+    {
+        const string::size_type  idx_last_dir = wsgd_file_name_short.find_last_of("/\\");
+        if (idx_last_dir != string::npos)
+        {
+            wsgd_file_name_short.erase(0, idx_last_dir + 1);
+        }
+    }
+    build_types_context_include_file_open(wsgd_file_name_short);
+
+    {
+        protocol_data.type_definitions.map_const_value["shark::progfile_dir"] = get_progfile_dir();
+        protocol_data.type_definitions.map_const_value["shark::plugin_dir"] = get_plugins_dir_with_version();
+        protocol_data.type_definitions.map_const_value["shark::datafile_dir"] = get_datafile_dir();
+        protocol_data.type_definitions.map_const_value["shark::systemfile_dir"] = get_systemfile_dir();
+        protocol_data.type_definitions.map_const_value["shark::profiles_dir"] = get_profiles_dir();
+        protocol_data.type_definitions.map_const_value["shark::persdatafile_dir"] = get_persdatafile_dir();
+    }
+
+    while (is_istream_empty(iss) != true)
+    {
+        const string    result = build_types(iss,
+                                             protocol_data.type_definitions);
+
+        if (result == "DEBUG")
+        {
+            debug_type_definitions.set(E_debug_status_ON);
+            continue;
+        }
+        else if (result == "DEBUG_NO_TIME")
+        {
+            debug_type_definitions.set(E_debug_status_ON_NO_TIME);
+            continue;
+        }
+
+        M_FATAL_IF_NE(result, "");
+    }
+
+    build_types_context_include_file_close(wsgd_file_name_short);
+
+    // Verify that all mandatory data have been initialized.
+    protocol_data.check_config_parameters_initialized();
+
+    // Check HEURISTIC_FUNCTION
+    {
+        if (protocol_data.HEURISTIC_FUNCTION != "")
+        {
+            if (protocol_data.type_definitions.is_a_function(protocol_data.HEURISTIC_FUNCTION) == false)
+            {
+                M_FATAL_COMMENT("HEURISTIC_FUNCTION (" << protocol_data.HEURISTIC_FUNCTION << ") is NOT a defined function name");
+            }
+        }
+    }
+
+
+    // Check MSG_HEADER_TYPE.
+    if (protocol_data.type_definitions.is_a_defined_type_name(protocol_data.MSG_HEADER_TYPE) == false)
+    {
+        M_FATAL_COMMENT("MSG_HEADER_TYPE (" << protocol_data.MSG_HEADER_TYPE << ") is NOT a defined type name");
+    }
+
+    // Check GLOBAL_DATA_TYPE.
+    if (protocol_data.GLOBAL_DATA_TYPE != "")
+    {
+        if (protocol_data.type_definitions.is_a_struct(protocol_data.GLOBAL_DATA_TYPE) == false)
+        {
+            M_FATAL_COMMENT("GLOBAL_DATA_TYPE (" << protocol_data.GLOBAL_DATA_TYPE << ") is NOT a defined struct type name");
+        }
+    }
+
+    string    switch_orig_type;
+    string    switch_discriminant_str;
+
+    // Check MSG_MAIN_TYPE.
+    if ((protocol_data.MSG_MAIN_TYPE != "") &&
+        (protocol_data.type_definitions.is_a_defined_type_name(protocol_data.MSG_MAIN_TYPE) == false) &&
+        (is_a_switch_value(protocol_data.type_definitions, protocol_data.MSG_MAIN_TYPE, switch_orig_type, switch_discriminant_str) == false))
+    {
+        M_FATAL_COMMENT("MSG_MAIN_TYPE (" << protocol_data.MSG_MAIN_TYPE << ") is NOT a defined type name");
+    }
+
+    // Check MSG_FROM_MAIN_TYPE.
+    if ((protocol_data.MSG_FROM_MAIN_TYPE != "") &&
+        (protocol_data.type_definitions.is_a_defined_type_name(protocol_data.MSG_FROM_MAIN_TYPE) == false) &&
+        (is_a_switch_value(protocol_data.type_definitions, protocol_data.MSG_FROM_MAIN_TYPE, switch_orig_type, switch_discriminant_str) == false))
+    {
+        M_FATAL_COMMENT("MSG_FROM_MAIN_TYPE (" << protocol_data.MSG_FROM_MAIN_TYPE << ") is NOT a defined type name");
+    }
+
+    // Check MSG_TO_MAIN_TYPE.
+    if ((protocol_data.MSG_TO_MAIN_TYPE != "") &&
+        (protocol_data.type_definitions.is_a_defined_type_name(protocol_data.MSG_TO_MAIN_TYPE) == false) &&
+        (is_a_switch_value(protocol_data.type_definitions, protocol_data.MSG_TO_MAIN_TYPE, switch_orig_type, switch_discriminant_str) == false))
+    {
+        M_FATAL_COMMENT("MSG_TO_MAIN_TYPE (" << protocol_data.MSG_TO_MAIN_TYPE << ") is NOT a defined type name");
+    }
+
+    if (must_ouput_types && get_debug())
+    {
+        get_state_ostream() << protocol_data.type_definitions;
+    }
+}
+
+//*****************************************************************************
+// get_P_interpret_read_values_of_msg
+//*****************************************************************************
+#if 0
+const T_interpret_read_values  * get_P_interpret_read_values_of_msg(int   msg_id)
+{
+    // Retrieve the current protocol.
+    M_FATAL_IF_LT(S_proto_idx_dissect_in_progress, 0);
+    M_FATAL_IF_GE(S_proto_idx_dissect_in_progress, S_protocol_data.size());
+
+    T_generic_protocol_data  & protocol_data = S_protocol_data[S_proto_idx_dissect_in_progress];
+
+    // Retrieve the specified message.
+    T_generic_protocol_global_data  & global_data = protocol_data.ws_data.global_data;
+    M_FATAL_IF_LT(msg_id, 0);
+    M_FATAL_IF_GE(msg_id, global_data.saved_interpreted_datas.size());
+
+    if (msg_id == global_data.saved_interpreted_datas.size())
+    {
+        // ICIOA c'est le message courant
+    }
+
+    return  global_data.saved_interpreted_datas[msg_id].RCP_interpret_data;
+}
+#endif
diff --git a/plugins/epan/generic/T_generic_protocol_data.h b/plugins/epan/generic/T_generic_protocol_data.h
new file mode 100644
index 00000000000..040e5f6dd36
--- /dev/null
+++ b/plugins/epan/generic/T_generic_protocol_data.h
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2008-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __T_GENERIC_PROTOCOL_DATA_H__
+#define __T_GENERIC_PROTOCOL_DATA_H__
+
+//*****************************************************************************
+// Includes
+//*****************************************************************************
+
+#include "config.h"
+
+#include <glib.h>
+#include <epan/packet.h>
+#include <epan/expert.h>
+
+#include <string>
+#include <vector>
+#include <utility>
+using namespace std;
+
+#include "byte_interpret_build_types.h"
+#include "T_interpret_data.h"
+#include "T_generic_protocol_data_base.h"
+#include "T_generic_statistics.h"
+
+
+/******************************************************************************
+ * T_generic_protocol_ws_data
+ *****************************************************************************/
+
+struct T_generic_protocol_fields_data : public CT_debug_object_counter<T_generic_protocol_fields_data>
+{
+  vector<gint>                hf_id;
+  vector<gint>                ett_id;
+  vector<hf_register_info>    hf;         // WARNING_ADDRESSES
+  vector<gint *>              ett;        // WARNING_ADDRESSES
+};
+
+struct T_generic_protocol_enum_value : public CT_debug_object_counter<T_generic_protocol_enum_value>
+{
+  vector<value_string>    value_strings;
+};
+
+struct T_generic_protocol_enum_values_data : public CT_debug_object_counter<T_generic_protocol_enum_values_data>
+{
+  vector<T_generic_protocol_enum_value>    enum_values;
+};
+
+struct T_generic_protocol_expert_data : public CT_debug_object_counter<T_generic_protocol_expert_data>
+{
+  expert_field              ei_malformed_comment;
+  expert_field              ei_malformed_chat;
+  expert_field              ei_malformed_note;
+  expert_field              ei_malformed_warn;
+  expert_field              ei_malformed_error;
+  vector<ei_register_info>  ei;
+
+  T_generic_protocol_expert_data()
+  {
+    expert_field  ei_initializer = EI_INIT;
+    ei_malformed_comment = ei_initializer;
+    ei_malformed_chat = ei_initializer;
+    ei_malformed_note = ei_initializer;
+    ei_malformed_warn = ei_initializer;
+    ei_malformed_error = ei_initializer;
+  }
+};
+
+struct T_generic_protocol_subdissector_data : public CT_debug_object_counter<T_generic_protocol_subdissector_data>
+{
+  dissector_table_t      dissector_table;
+  heur_dissector_list_t  heur_dissector_list;
+  gboolean               try_heuristic_first;
+
+  static
+  dissector_handle_t     data_handle;
+
+  T_generic_protocol_subdissector_data()
+      :dissector_table (nullptr),
+       heur_dissector_list (nullptr),
+       try_heuristic_first (FALSE)
+  { }
+};
+
+struct T_generic_protocol_tap_data : public CT_debug_object_counter<T_generic_protocol_tap_data>
+{
+  int                    proto_tap;
+  T_stats                stats;
+  bool                   tap_is_needed;    // for statistics
+  T_RCP_interpret_data   RCP_last_msg_interpret_data;
+
+  T_generic_protocol_tap_data()
+      :proto_tap (-1),
+       tap_is_needed(false)
+  { }
+};
+
+struct T_generic_protocol_saved_interpreted_data : public CT_debug_object_counter<T_generic_protocol_saved_interpreted_data>
+{
+  long                    packet_number;
+  long                    msg_number_inside_packet;
+  T_RCP_interpret_data    RCP_interpret_data;
+
+  T_generic_protocol_saved_interpreted_data()
+      :packet_number(0),
+       msg_number_inside_packet(0)
+  { }
+};
+
+struct T_generic_protocol_global_data : public CT_debug_object_counter<T_generic_protocol_global_data>
+{
+  // Contains the initial values of global data
+  T_RCP_interpret_data    RCP_initialized_data;
+
+  // Contains all interpret_data of msg
+  vector<T_generic_protocol_saved_interpreted_data>  saved_interpreted_datas;
+
+  T_generic_protocol_global_data()
+      : RCP_initialized_data(new T_interpret_data())
+  {
+  }
+};
+
+struct T_generic_protocol_ws_data : public CT_debug_object_counter<T_generic_protocol_ws_data>
+{
+  /* Wireshark ID of the protocol */
+  int       proto_generic;
+
+  gint      ( * P_dissect_fct )(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *);
+  gboolean  ( * P_heuristic_fct )(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *);
+
+  dissector_handle_t                    dissector_handle;
+
+  T_generic_protocol_fields_data        fields_data;
+  T_generic_protocol_enum_values_data   enum_values_data;
+  T_generic_protocol_expert_data        expert_data;
+
+  T_generic_protocol_subdissector_data  subdissector_data;
+
+  T_generic_protocol_tap_data           tap_data;
+
+  T_generic_protocol_global_data        global_data;
+
+  T_generic_protocol_ws_data()
+      :proto_generic (-1),
+       P_dissect_fct (nullptr),
+       dissector_handle (nullptr)
+  { }
+};
+
+//*****************************************************************************
+// T_generic_protocol_data
+//*****************************************************************************
+
+struct T_generic_protocol_data : public T_generic_protocol_data_base
+{
+    T_generic_protocol_ws_data    ws_data;
+};
+
+/******************************************************************************
+ * called by dissect_generic_<proto_idx>
+ * called by heuristic_generic_<proto_idx>
+ *****************************************************************************/
+gint
+dissect_generic_proto(const int    proto_idx, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+
+gboolean
+heuristic_generic_proto(const int    proto_idx, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree);
+
+//*****************************************************************************
+// The protocol's data
+//*****************************************************************************
+
+T_generic_protocol_data  & get_protocol_data(const int   proto_idx);
+T_generic_protocol_data  & new_protocol_data(const int   proto_idx);
+
+T_generic_protocol_data  & get_protocol_data_from_proto_abbrev(const char  * proto_abbrev);
+
+void    set_max_nb_of_protocol_data(const size_t   max_nb);
+
+//*****************************************************************************
+// read_file_wsgd
+//*****************************************************************************
+
+void    read_file_wsgd (const string                   & wsgd_file_name,
+                              T_generic_protocol_data  & protocol_data);
+
+
+#endif /* __T_GENERIC_PROTOCOL_DATA_H__ */
diff --git a/plugins/epan/generic/T_generic_protocol_data_base.cpp b/plugins/epan/generic/T_generic_protocol_data_base.cpp
new file mode 100644
index 00000000000..9e377c69c51
--- /dev/null
+++ b/plugins/epan/generic/T_generic_protocol_data_base.cpp
@@ -0,0 +1,383 @@
+/*
+ * Copyright 2008-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes
+//*****************************************************************************
+
+#include "byte_interpret_common.h"
+void fatal_PROTO_TYPE_DEFINITIONS_not_found()
+{
+    M_FATAL_COMMENT("PROTO_TYPE_DEFINITIONS not found");  // must stay line 30 (for test purpose)
+}
+
+#include "T_generic_protocol_data_base.h"
+#include "byte_interpret_common_utils.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+
+#include <istream>
+
+
+//*****************************************************************************
+// check_not_already_initialized
+//*****************************************************************************
+void    check_not_already_initialized(const string  & val)
+{
+    M_FATAL_IF_NE(val, "");
+}
+void    check_not_already_initialized(const int    val)
+{
+    M_FATAL_IF_NE(val, -1);
+}
+
+//*****************************************************************************
+// check_initialized
+//*****************************************************************************
+void    check_initialized(const string  & val)
+{
+    M_FATAL_IF_EQ(val, "");
+}
+void    check_initialized(const int    val)
+{
+    M_FATAL_IF_EQ(val, -1);
+}
+void    check_initialized(const vector<int>  & val)
+{
+    M_FATAL_IF_EQ(val.size(), 0);
+}
+
+//*****************************************************************************
+// T_generic_protocol_data
+//*****************************************************************************
+void
+T_generic_protocol_data_base::check_config_parameters_initialized() const
+{
+    ::check_initialized(PROTONAME);
+    ::check_initialized(PROTOSHORTNAME);
+    ::check_initialized(PROTOABBREV);
+
+    if (PARENTS.empty() &&
+        PARENTS_HEURISTIC.empty())
+    {
+        M_FATAL_COMMENT("Must set PARENT_SUBFIELD & PARENT_SUBFIELD_VALUES");
+    }
+    for (vector<T_generic_protocol_data_base::T_parent>::const_iterator
+        parent_iter = PARENTS.begin();
+        parent_iter != PARENTS.end();
+        ++parent_iter)
+    {
+        const T_generic_protocol_data_base::T_parent  & parent = *parent_iter;
+        ::check_initialized(parent.PARENT_SUBFIELD);
+        if (parent.PARENT_SUBFIELD_VALUES_int.empty() &&
+            parent.PARENT_SUBFIELD_VALUES_str.empty() &&
+            parent.PARENT_SUBFIELD_RANGES_int.empty())
+        {
+            M_FATAL_COMMENT("Must set PARENT_SUBFIELD_VALUES or PARENT_SUBFIELD_RANGE");
+        }
+    }
+
+    ::check_initialized(MSG_HEADER_TYPE);
+    ::check_initialized(MSG_ID_FIELD_NAME);
+    //  ::check_initialized(MSG_TITLE);  optional
+    //  ::check_initialized(MSG_SUMMARY_SUBSIDIARY_FIELD_NAMES);  optional
+    if (MSG_MAIN_TYPE == "")
+    {
+        if ((MSG_FROM_MAIN_TYPE == "") || (MSG_TO_MAIN_TYPE == ""))
+        {
+            M_FATAL_COMMENT("Must set MSG_MAIN_TYPE or MSG_FROM_MAIN_TYPE and MSG_TO_MAIN_TYPE");
+        }
+    }
+}
+
+//*****************************************************************************
+// read_file_wsgd_until_types
+//*****************************************************************************
+
+void    read_file_wsgd_until_types(
+                              istringstream                 & iss,
+                              T_generic_protocol_data_base  & protocol_data,
+                              T_stats                       & stats)
+{
+    M_TRACE_ENTER("read_file_wsgd_until_types", "");
+
+    // string ou int
+#define M_READ_NAME_VALUE(NAME,VARIABLE)                     \
+    else if (keyword == #NAME)  {                            \
+        check_not_already_initialized(VARIABLE);             \
+        iss >> VARIABLE;                                     \
+        M_TRACE_DEBUG (#NAME << " = " << VARIABLE);          \
+    }
+
+#define M_READ_VALUE(NAME)                                   \
+    M_READ_NAME_VALUE(NAME,protocol_data.NAME)
+
+// bool
+#define M_READ_NAME_BOOL(NAME,VARIABLE)                      \
+    else if (keyword == #NAME)  {                            \
+        string    word;                                      \
+        iss >> word;                                         \
+        if ((word == "false") || (word == "no")) {           \
+            VARIABLE = false;                                \
+        }                                                    \
+        else if ((word == "true") || (word == "yes")) {      \
+            VARIABLE = true;                                 \
+        }                                                    \
+        else {                                               \
+            M_FATAL_COMMENT("Bad value for " #NAME);         \
+        }                                                    \
+        M_TRACE_DEBUG (#NAME << " = " << VARIABLE);          \
+    }
+
+// bool
+#define M_READ_BOOL(NAME)                                    \
+    M_READ_NAME_BOOL(NAME,protocol_data.NAME)
+
+// vector<int>
+#define M_READ_VALUES(NAME)                                  \
+    else if (keyword == #NAME)  {                            \
+        string    line;                                      \
+        getline (iss, line);                                 \
+        istringstream  is_line(line.c_str());                \
+        while (is_istream_empty(is_line) != true)            \
+        {                                                    \
+            int    val;                                      \
+            is_line >> val;                                  \
+            protocol_data.NAME.push_back(val);               \
+        }                                                    \
+    }
+
+// vector<string>
+#define M_READ_STRINGS(NAME,VARIABLE)                        \
+    else if (keyword == #NAME)  {                            \
+        iss >> ws;                                           \
+        string    line;                                      \
+        getline (iss, line);                                 \
+        istringstream  is_line(line.c_str());                \
+        while (is_istream_empty(is_line) != true)            \
+        {                                                    \
+            string    val;                                   \
+            is_line >> val;                                  \
+            protocol_data.VARIABLE.push_back(val);           \
+        }                                                    \
+    }
+
+// string
+#define M_READ_LINE(NAME)                                                \
+    else if (keyword == #NAME)  {                                        \
+        check_not_already_initialized(protocol_data.NAME);               \
+        iss >> ws;                                                       \
+        getline (iss, protocol_data.NAME);                               \
+        const string::size_type  NAME_size = protocol_data.NAME.size();  \
+        if ((NAME_size > 0) &&                                           \
+            (protocol_data.NAME[NAME_size-1] == '\r'))                   \
+        {                                                                \
+            protocol_data.NAME.erase(NAME_size-1);                       \
+        }                                                                \
+        M_TRACE_DEBUG (#NAME << " = " << protocol_data.NAME);            \
+    }
+
+    // Read the 1st part of the file (until PROTO_TYPE_DEFINITIONS).
+    bool  PROTO_TYPE_DEFINITIONS_found = false;
+    while (is_istream_empty(iss) != true)
+    {
+        string    keyword;
+        iss >> keyword;
+
+        if (keyword == "DEBUG")
+        {
+            protocol_data.DEBUG = E_debug_status_ON;
+//            set_debug(protocol_data.DEBUG);
+            continue;
+        }
+        else if (keyword == "DEBUG_NO_TIME")
+        {
+            protocol_data.DEBUG = E_debug_status_ON_NO_TIME;
+            continue;
+        }
+        else if (keyword == "PROTO_TYPE_DEFINITIONS")
+        {
+            PROTO_TYPE_DEFINITIONS_found = true;
+            break;
+        }
+        M_READ_LINE(PROTONAME)
+        M_READ_VALUE(PROTOSHORTNAME)
+        M_READ_VALUE(PROTOABBREV)
+
+        else if (keyword == "PARENT_SUBFIELD")
+        {
+            protocol_data.PARENTS.push_back(T_generic_protocol_data_base::T_parent());
+            iss >> protocol_data.PARENTS.back().PARENT_SUBFIELD;
+            M_TRACE_DEBUG("PARENT_SUBFIELD = " << protocol_data.PARENTS.back().PARENT_SUBFIELD);
+        }
+        M_READ_STRINGS(PARENT_SUBFIELD_VALUES, PARENTS.back().PARENT_SUBFIELD_VALUES_str)
+        else if (keyword == "PARENT_SUBFIELD_RANGE")
+        {
+            pair<int, int>    low_high;
+            iss >> low_high.first;
+            iss >> low_high.second;
+            protocol_data.PARENTS.back().PARENT_SUBFIELD_RANGES_int.push_back(low_high);
+        }
+        else if (keyword == "PARENT_HEURISTIC")
+        {
+            string   parent_name;
+            iss >> parent_name;
+            protocol_data.PARENTS_HEURISTIC.push_back(parent_name);
+        }
+        M_READ_VALUE(HEURISTIC_FUNCTION)
+        else if (keyword == "ADD_FOR_DECODE_AS_TABLE")
+        {
+            string   table_name;
+            iss >> table_name;
+            protocol_data.ADD_FOR_DECODE_AS_TABLES.push_back(table_name);
+        }
+
+        else if (keyword == "SUBFIELD")
+        {
+            check_not_already_initialized(protocol_data.SUBPROTO_SUBFIELD);
+            iss >> ws;
+            string    line;
+            getline(iss, line);
+            {
+                istringstream  is_line(line.c_str());
+                is_line >> protocol_data.SUBPROTO_SUBFIELD;
+                is_line >> protocol_data.SUBPROTO_SUBFIELD_TYPE;
+                if (protocol_data.SUBPROTO_SUBFIELD == "")
+                {
+                    M_FATAL_COMMENT("Missing name on SUBFIELD line = " << line);
+                }
+                if (protocol_data.SUBPROTO_SUBFIELD_TYPE == "")
+                {
+                    M_FATAL_COMMENT("Missing type on SUBFIELD line = " << line);
+                }
+                if (protocol_data.SUBPROTO_SUBFIELD_TYPE == "uint8")
+                    protocol_data.SUBPROTO_SUBFIELD_TYPE_WS = FT_UINT8;
+                else if (protocol_data.SUBPROTO_SUBFIELD_TYPE == "uint16")
+                    protocol_data.SUBPROTO_SUBFIELD_TYPE_WS = FT_UINT16;
+                else if (protocol_data.SUBPROTO_SUBFIELD_TYPE == "uint24")
+                    protocol_data.SUBPROTO_SUBFIELD_TYPE_WS = FT_UINT24;
+                else if (protocol_data.SUBPROTO_SUBFIELD_TYPE == "uint32")
+                    protocol_data.SUBPROTO_SUBFIELD_TYPE_WS = FT_UINT32;
+                else if (protocol_data.SUBPROTO_SUBFIELD_TYPE == "string")
+                    protocol_data.SUBPROTO_SUBFIELD_TYPE_WS = FT_STRING;
+                else
+                {
+                    M_FATAL_COMMENT("Bad type on SUBFIELD line = " << line);
+                }
+                if (is_istream_empty(is_line) != true)
+                {
+                    string    key_word_from;
+                    is_line >> key_word_from;
+                    if (key_word_from != "from")
+                    {
+                        M_FATAL_COMMENT("Expecting key word from on SUBFIELD line = " << line);
+                    }
+
+                    is_line >> protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_1;
+                    is_line >> protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_2;
+                    is_line >> protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_3;
+                    if (protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_1 == "")
+                    {
+                        M_FATAL_COMMENT("Expecting at least one field after from on SUBFIELD line = " << line);
+                    }
+                    if (is_istream_empty(is_line) != true)
+                    {
+                        M_FATAL_COMMENT("Too much data on SUBFIELD line = " << line);
+                    }
+                }
+                if (protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_1 == "")
+                    protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_1 = protocol_data.SUBPROTO_SUBFIELD;
+            }
+        }
+
+        M_READ_VALUE(MSG_HEADER_TYPE)
+        M_READ_VALUE(MSG_ID_FIELD_NAME)
+        M_READ_VALUE(MSG_TITLE)
+        M_READ_STRINGS(MSG_SUMMARY_SUBSIDIARY_FIELD_NAMES, MSG_SUMMARY_SUBSIDIARY_FIELD_NAMES)
+        M_READ_VALUE(MSG_MAIN_TYPE)
+        M_READ_VALUE(MSG_FROM_MAIN_TYPE)
+        M_READ_VALUE(MSG_TO_MAIN_TYPE)
+        M_READ_LINE(MSG_TOTAL_LENGTH)
+        M_READ_VALUE(MSG_HEADER_LENGTH)
+        M_READ_VALUE(MSG_TRAILER_LENGTH)
+        M_READ_VALUE(GLOBAL_DATA_TYPE)
+        M_READ_BOOL(PACKET_CONTAINS_ONLY_1_MSG)
+        M_READ_BOOL(PACKET_CONTAINS_ONLY_COMPLETE_MSG)
+        M_READ_BOOL(MANAGE_WIRESHARK_PINFO)
+        else if (keyword == "STATISTICS")
+        {
+            read_file_wsgd_statistics(iss, stats);
+        }
+        else
+        {
+            M_FATAL_COMMENT("unexpected keyword=" << keyword);
+        }
+    }
+
+    rtrim(protocol_data.PROTONAME);
+
+    if (protocol_data.MSG_TRAILER_LENGTH > 0)
+    {
+        protocol_data.type_definitions.trailer_sizeof_bits = protocol_data.MSG_TRAILER_LENGTH * 8;
+    }
+
+    if (PROTO_TYPE_DEFINITIONS_found == false)
+    {
+        fatal_PROTO_TYPE_DEFINITIONS_not_found();
+    }
+
+    // Check/update PARENTS
+    for (auto & parent : protocol_data.PARENTS)
+    {
+        // Transform strings to integer values (if they are integers).
+        for (auto& value_str : parent.PARENT_SUBFIELD_VALUES_str)
+        {
+            long    subfield_val_int = 0;
+            if (get_number(value_str.c_str(), &subfield_val_int))
+            {
+                parent.PARENT_SUBFIELD_VALUES_int.push_back(subfield_val_int);
+            }
+            else
+            {
+                remove_string_limits(value_str);
+            }
+        }
+
+        if (parent.PARENT_SUBFIELD_VALUES_int.size() == parent.PARENT_SUBFIELD_VALUES_str.size())
+        {
+            // They are all integers.
+            parent.PARENT_SUBFIELD_VALUES_str.clear();
+        }
+        else if (parent.PARENT_SUBFIELD_VALUES_int.empty())
+        {
+            // None are integers : nothing to do.
+        }
+        else
+        {
+            // Mixed integers and strings : NOT accepted.
+            M_FATAL_COMMENT("PARENT_SUBFIELD_VALUES must be integers or strings, NOT both. NB: if you want a string like 12, use \"12\".");
+
+        }
+    }
+
+    remove_string_limits(protocol_data.HEURISTIC_FUNCTION);
+}
diff --git a/plugins/epan/generic/T_generic_protocol_data_base.h b/plugins/epan/generic/T_generic_protocol_data_base.h
new file mode 100644
index 00000000000..cf22d3b3237
--- /dev/null
+++ b/plugins/epan/generic/T_generic_protocol_data_base.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2008-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#pragma once
+
+//*****************************************************************************
+// Includes
+//*****************************************************************************
+
+#include "config.h"
+#include <epan/packet.h>
+
+#include <string>
+#include <vector>
+#include <sstream>
+using namespace std;
+
+#include "CT_debug_object_counter.h"
+#include "byte_interpret_common.h"
+#include "T_generic_statistics.h"
+#include "T_type_definitions.h"
+
+
+//*****************************************************************************
+// T_generic_protocol_data_base
+//*****************************************************************************
+
+struct T_generic_protocol_data_base : public CT_debug_object_counter<T_generic_protocol_data_base>
+{
+    int       proto_idx;  // identify the proto
+
+    bool      is_proto_usable() const        { return  proto_idx >= 0; }
+    void      proto_is_NOT_usable()          { proto_idx = -1; }
+
+    string    wsgd_file_name;
+
+    E_debug_status  DEBUG;
+
+    string    PROTONAME;
+    string    PROTOSHORTNAME;
+    string    PROTOABBREV;
+
+    struct T_parent
+    {
+        string                   PARENT_SUBFIELD;
+        vector<int>              PARENT_SUBFIELD_VALUES_int;
+        vector<string>           PARENT_SUBFIELD_VALUES_str;
+        vector<pair<int,int> >   PARENT_SUBFIELD_RANGES_int;
+    };
+    vector<T_parent>  PARENTS;
+
+    vector<string>    PARENTS_HEURISTIC;
+    string            HEURISTIC_FUNCTION;
+
+    vector<string>    ADD_FOR_DECODE_AS_TABLES;
+
+    string            SUBPROTO_SUBFIELD;
+    string            SUBPROTO_SUBFIELD_PARAM;
+    string            SUBPROTO_SUBFIELD_PARAM_UI;
+    string            SUBPROTO_SUBFIELD_TYPE;
+    ftenum_t          SUBPROTO_SUBFIELD_TYPE_WS;
+    string            SUBPROTO_SUBFIELD_FROM_REAL_1;
+    string            SUBPROTO_SUBFIELD_FROM_REAL_2;
+    string            SUBPROTO_SUBFIELD_FROM_REAL_3;
+
+    bool              PACKET_CONTAINS_ONLY_1_MSG;
+    bool              PACKET_CONTAINS_ONLY_COMPLETE_MSG;
+    bool              MANAGE_WIRESHARK_PINFO;
+
+    string            MSG_HEADER_TYPE;
+    string            MSG_ID_FIELD_NAME;
+    string            MSG_TITLE;
+    vector<string>    MSG_SUMMARY_SUBSIDIARY_FIELD_NAMES;
+    string            MSG_MAIN_TYPE;
+    string            MSG_FROM_MAIN_TYPE;
+    string            MSG_TO_MAIN_TYPE;
+    string            MSG_TOTAL_LENGTH;
+    int               MSG_HEADER_LENGTH;
+    int               MSG_TRAILER_LENGTH;
+
+    string            GLOBAL_DATA_TYPE;
+
+    T_type_definitions    type_definitions;
+
+    void    check_config_parameters_initialized() const;
+
+    T_generic_protocol_data_base()
+        : proto_idx(-1)
+        , DEBUG(E_debug_status_OFF)
+        , SUBPROTO_SUBFIELD_TYPE_WS(FT_NONE)
+        , PACKET_CONTAINS_ONLY_1_MSG(false)
+        , PACKET_CONTAINS_ONLY_COMPLETE_MSG(false)
+        , MANAGE_WIRESHARK_PINFO(false)
+        , MSG_HEADER_LENGTH(-1)
+        , MSG_TRAILER_LENGTH(-1)
+    { }
+};
+
+//*****************************************************************************
+// read_file_wsgd_until_types
+// Stop after read "PROTO_TYPE_DEFINITIONS"
+//*****************************************************************************
+
+void    read_file_wsgd_until_types(
+                              istringstream                 & iss,
+                              T_generic_protocol_data_base  & protocol_data,
+                              T_stats                       & stats);
diff --git a/plugins/epan/generic/T_generic_statistics.cpp b/plugins/epan/generic/T_generic_statistics.cpp
new file mode 100644
index 00000000000..73308790531
--- /dev/null
+++ b/plugins/epan/generic/T_generic_statistics.cpp
@@ -0,0 +1,319 @@
+/* 
+ * Copyright 2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes
+//*****************************************************************************
+
+#include "T_generic_statistics.h"
+#include "byte_interpret_parse.h"
+
+
+//*****************************************************************************
+// T_stats::get_sub_group_by_full_name
+//*****************************************************************************
+T_stats_sub_group&
+T_stats::get_sub_group_by_full_name(const std::string& full_name)
+{
+    for (auto& group : groups)
+    {
+        for (auto& sub_group : group.sub_groups)
+        {
+            if (full_name == sub_group.full_name)
+            {
+                return  sub_group;
+            }
+        }
+    }
+
+    M_FATAL_COMMENT("sub_group.full_name == " << full_name << " not found");
+}
+
+//*****************************************************************************
+// peglib parser
+//*****************************************************************************
+#include "peglib.h"
+
+// t_parser_error
+struct t_parser_error
+{
+    size_t  line;       // line where parser stop in error, start at 1
+    size_t  col;        // column where parser stop in error, start at 1
+    string  msg;        // parser error message
+
+    t_parser_error()
+        : line(0)
+        , col(0)
+    {}
+
+    bool  is_at_beginning() const { return line == 1 && col == 1; }
+};
+
+std::ostream& operator<<(std::ostream& os, const t_parser_error& rhs)
+{
+    os << "line=" << rhs.line << " ";
+    os << "col=" << rhs.col << " ";
+    os << rhs.msg;
+    return os;
+}
+
+//*****************************************************************************
+// get_remaining
+// Get the remaining input, ie from line/col specified in parser_error
+//*****************************************************************************
+std::string  get_remaining(const std::string& input, const t_parser_error& parser_error)
+{
+    M_TRACE_ENTER_NO_LEAVE("get_remaining", "parser_error=" << parser_error);
+
+    string::size_type  offset = 0;
+    {
+        size_t             line_counter = 1;
+        while (line_counter < parser_error.line)
+        {
+            auto pos = input.find_first_of("\r\n", offset);
+            if (pos == string::npos)
+            {
+                // impossible
+                M_TRACE_ERROR("No enough lines found ???");
+                return "";
+            }
+
+            if ((input[pos] == '\r') && (input[pos + 1] == '\n'))
+            {
+                ++pos;
+            }
+
+            offset = pos + 1;
+            ++line_counter;
+        }
+    }
+    offset += (parser_error.col - 1);
+    const std::string  remaining_input = input.substr(offset);
+
+    return remaining_input;
+}
+
+//*****************************************************************************
+// get_first_line
+//*****************************************************************************
+std::string  get_first_line(const std::string& input)
+{
+    std::string result;
+    istringstream  iss(input);
+    std::getline(iss, result);
+    return result;
+}
+
+//*****************************************************************************
+// read_file_wsgd_statistics
+//*****************************************************************************
+
+void  read_file_wsgd_statistics(std::istringstream& iss,
+                                T_stats&            stats)
+{
+    M_TRACE_ENTER("read_file_wsgd_statistics", "");
+
+    peg::parser parser;
+
+    t_parser_error  parser_error;
+    parser.log = [&parser_error](size_t line, size_t col, const string& msg) {
+        parser_error.line = line;
+        parser_error.col = col;
+        parser_error.msg = msg;
+    };
+
+    const bool load_result = parser.load_grammar(R"(
+    Root                      <- STATISTICS RemainingContent
+    STATISTICS                <- WS+ ( StatisticsSubMenu / StatisticsTopic ) WS* EndOfLine
+
+    StatisticsSubMenu         <- <String> WS* SubMenuList
+    StatisticsTopic           <- <String> WS* TopicList
+
+    SubMenuList               <- '[' _* SubMenu _* (',' _* SubMenu _*)* ','? _* ']'
+    SubMenu                   <- <String> WS* TopicList
+    TopicList                 <- '[' _* Topic _* (',' _* Topic _*)* ','? _* ']'
+    Topic                     <- <String> WS+ < IdentificatorSimple >
+
+    RemainingContent          <- < .* >
+    IdentificatorSimple       <- < [a-zA-Z_] [a-zA-Z0-9_]* >
+    String                    <- '"' < (!EndOfLine [^"])* > '"'
+
+    ~_                        <- WS / EndOfLine
+    ~WS                       <- SpaceChar / LineComment
+    ~LineComment              <- '#' (!EndOfLine .)*
+    ~SpaceChar                <- ' ' / '\t'
+    ~EndOfLine                <- '\r\n' / '\n' / '\r'
+    )");
+    if (!load_result)
+    {
+        M_FATAL_COMMENT("peglib load fail");
+    }
+
+    parser["String"] = [](const peg::SemanticValues& sv) {
+        return sv.token();
+    };
+    parser["IdentificatorSimple"] = [](const peg::SemanticValues& sv) {
+        return sv.token();
+    };
+
+    struct T_parse_final_result
+    {
+        T_stats&     stats;
+        std::string  remaining_content;
+
+        T_parse_final_result(T_stats& stats_param)
+            : stats(stats_param)
+        {}
+    };
+
+    parser["Topic"] = [](const peg::SemanticValues& sv) {
+        // <String> WS+ < IdentificatorSimple >
+        T_stats_topic  topic;
+        topic.topic_name = peg::any_cast<std::string>(sv[0]);
+        topic.variable_name = peg::any_cast<std::string>(sv[1]);
+        return topic;
+    };
+    parser["TopicList"] = [](const peg::SemanticValues& sv) {
+        // [' _* Topic _* (',' _* Topic _*)* ','? _* ']'
+        T_stats_sub_group  sub_group;
+        for (auto& any : sv)
+        {
+            T_stats_topic  topic = peg::any_cast<T_stats_topic>(any);
+            sub_group.topics.push_back(topic);
+        }
+        return sub_group;
+    };
+
+    parser["SubMenu"] = [](const peg::SemanticValues& sv) {
+        // <String> WS* TopicList
+        T_stats_sub_group  sub_group = peg::any_cast<T_stats_sub_group>(sv[1]);
+        sub_group.sub_group_name = peg::any_cast<std::string>(sv[0]);
+        return sub_group;
+    };
+    parser["SubMenuList"] = [](const peg::SemanticValues& sv) {
+        // '[' _* SubMenu _* (',' _* SubMenu _*)* ','? _* ']'
+        T_stats_group  group;
+        for (auto& any : sv)
+        {
+            T_stats_sub_group  sub_group = peg::any_cast<T_stats_sub_group>(any);
+            group.sub_groups.push_back(sub_group);
+        }
+        return group;
+    };
+
+    parser["StatisticsSubMenu"] = [](const peg::SemanticValues& sv) {
+        // <String> WS* SubMenuList
+        T_stats_group  group = peg::any_cast<T_stats_group>(sv[1]);
+        group.group_name = peg::any_cast<std::string>(sv[0]);
+
+        for (auto& sub_group : group.sub_groups)
+        {
+            if (sub_group.sub_group_name == "")
+            {
+                M_FATAL_COMMENT("STATISTICS " << group.group_name << " : sub menu name must not be empty");
+            }
+
+            sub_group.full_name = group.group_name + "/" + sub_group.sub_group_name;
+
+            // Check unicity of sub_group.sub_group_name
+            const auto counter = std::count_if(begin(group.sub_groups), end(group.sub_groups),
+            [sub_group](const T_stats_sub_group& current_sub_group)
+            {
+                return (current_sub_group.sub_group_name == sub_group.sub_group_name);
+            });
+            if (counter > 1)
+            {
+                M_FATAL_COMMENT("STATISTICS " << group.group_name << " : sub menu name " << sub_group.sub_group_name  << "must be unique");
+            }
+        }
+        return group;
+    };
+    parser["StatisticsTopic"] = [](const peg::SemanticValues& sv) {
+        // <String> WS* TopicList
+        T_stats_group  group;
+        group.group_name = peg::any_cast<std::string>(sv[0]);
+
+        T_stats_sub_group  sub_group = peg::any_cast<T_stats_sub_group>(sv[1]);
+        sub_group.full_name = group.group_name;
+
+        group.sub_groups.emplace_back(sub_group);
+        return group;
+    };
+
+    parser["STATISTICS"] = [](const peg::SemanticValues& sv, peg::any& dt) {
+        // WS+ ( StatisticsSubMenu / StatisticsTopic ) WS* EndOfLine
+        T_parse_final_result& parse_final_result = *peg::any_cast<T_parse_final_result*>(dt);
+        auto& stats = parse_final_result.stats;
+
+        T_stats_group  group = peg::any_cast<T_stats_group>(sv[0]);
+
+        // Check unicity of group.group_name
+        auto found_iter = std::find_if(begin(stats.groups), end(stats.groups),
+            [&group](const T_stats_group&  current_group)
+            {
+                return current_group.group_name == group.group_name;
+            });
+        if (found_iter != end(stats.groups))
+        {
+            M_FATAL_COMMENT("STATISTICS " << group.group_name << " must be unique");
+        }
+
+        stats.groups.emplace_back(group);
+    };
+
+    parser["RemainingContent"] = [](const peg::SemanticValues& sv, peg::any& dt) {
+        T_parse_final_result& parse_final_result = *peg::any_cast<T_parse_final_result*>(dt);
+
+        M_FATAL_IF_NE(sv.tokens.size(), 1);
+        parse_final_result.remaining_content = sv.token(0);
+    };
+
+    parser.enable_packrat_parsing();
+
+
+    const std::string     content{ std::istreambuf_iterator<char>(iss),
+                                   std::istreambuf_iterator<char>() };
+    T_parse_final_result  parse_final_result(stats);
+    peg::any              dt(&parse_final_result);
+
+    const bool parse_result = parser.parse(content.c_str(), dt);
+
+    if (!parse_result)
+    {
+        ostringstream  error;
+        error << "Parse fail, " << parser_error.msg << endl << endl;
+
+        const std::string  content_first_line = get_first_line(content);
+        error << "Starting on STATISTICS" << content_first_line << endl << endl;
+
+        if (parser_error.is_at_beginning() == false)
+        {
+            const std::string  content_at_error = get_remaining(content, parser_error);
+            const std::string  content_at_error_first_line = get_first_line(content_at_error);
+            error << "At/around " << content_at_error_first_line << endl << endl;
+        }
+        M_FATAL_COMMENT(error.str());
+    }
+
+    // Reset iss with the remaining content
+    iss.str(parse_final_result.remaining_content);
+}
diff --git a/plugins/epan/generic/T_generic_statistics.h b/plugins/epan/generic/T_generic_statistics.h
new file mode 100644
index 00000000000..74bc93cbc47
--- /dev/null
+++ b/plugins/epan/generic/T_generic_statistics.h
@@ -0,0 +1,74 @@
+/* 
+ * Copyright 2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#pragma once
+
+//*****************************************************************************
+// Includes
+//*****************************************************************************
+
+#include <string>
+#include <vector>
+#include <sstream>
+
+
+//*****************************************************************************
+// Stats
+//*****************************************************************************
+
+struct T_stats_topic
+{
+    std::string  topic_name;
+    std::string  variable_name;    // variable used for statistics
+    int          pivot_id = -1;    // stats_tree_create_pivot
+};
+
+struct T_stats_sub_group
+{
+    std::string                 sub_group_name;   // Sub menu of <group_name>
+    std::string                 full_name;        // stats_tree st->cfg->name
+    std::string                 node_name = "All messages";   // stats_tree_create_node param
+    int                         node_id = -1;                 // stats_tree_create_node result
+    std::vector<T_stats_topic>  topics;
+};
+
+struct T_stats_group
+{
+    std::string                     group_name;   // Appears into Statistics menu
+    std::vector<T_stats_sub_group>  sub_groups;
+};
+
+struct T_stats
+{
+    std::vector<T_stats_group>  groups;
+
+    T_stats_sub_group & get_sub_group_by_full_name(const std::string  & full_name);
+};
+
+
+//*****************************************************************************
+// read_file_wsgd_statistics
+// iss should be just after STATISTICS keyword
+//*****************************************************************************
+
+void    read_file_wsgd_statistics (std::istringstream   & iss,
+                                   T_stats              & stats);
diff --git a/plugins/epan/generic/T_interpret_byte_order.cpp b/plugins/epan/generic/T_interpret_byte_order.cpp
new file mode 100644
index 00000000000..bb1d8b9fc18
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_byte_order.cpp
@@ -0,0 +1,166 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "T_interpret_byte_order.h"
+#include "byte_interpret_common.h"
+using namespace std;
+
+
+//*****************************************************************************
+// NB: byte order     inverted : intel,    little endian
+//     byte order NOT inverted : motorola, big    endian, network
+//*****************************************************************************
+
+bool    is_host_byte_order_inverted ()
+{
+    const short  value = 1;
+    return  (*(const char*)&value) != 0;
+}
+
+//*****************************************************************************
+// T_interpret_byte_order
+//*****************************************************************************
+bool    T_interpret_byte_order::A_is_host_byte_order_inverted = ::is_host_byte_order_inverted();
+
+T_interpret_byte_order::T_interpret_byte_order ()
+    :A_must_invert_bytes (false)
+{
+}
+
+bool
+T_interpret_byte_order::is_little_endian() const
+{
+    if (A_is_host_byte_order_inverted)
+    {
+        if (A_must_invert_bytes)
+            return  false;
+        else
+            return  true;
+    }
+    else
+    {
+        if (A_must_invert_bytes)
+            return  true;
+        else
+            return  false;
+    }
+}
+
+void
+T_interpret_byte_order::set_big_endian()
+{
+    A_must_invert_bytes = A_is_host_byte_order_inverted;
+}
+
+void
+T_interpret_byte_order::set_little_endian()
+{
+    A_must_invert_bytes = ! A_is_host_byte_order_inverted;
+}
+
+void
+T_interpret_byte_order::set_as_host()
+{
+    A_must_invert_bytes = false;
+}
+
+void
+T_interpret_byte_order::set_data_order(const std::string  & byte_order)
+{
+    if (byte_order == "big_endian")
+    {
+        set_big_endian();
+    }
+    else if (byte_order == "little_endian")
+    {
+        set_little_endian();
+    }
+    else if (byte_order == "as_host")
+    {
+        set_as_host();
+    }
+    else
+    {
+        M_FATAL_COMMENT("Bad byte_order " << byte_order);
+    }
+}
+
+string
+T_interpret_byte_order::get_data_order() const
+{
+    if (A_is_host_byte_order_inverted)
+    {
+        if (A_must_invert_bytes)
+            return  "big_endian";
+        else
+            return  "little_endian";
+    }
+    else
+    {
+        if (A_must_invert_bytes)
+            return  "little_endian";
+        else
+            return  "big_endian";
+    }
+}
+
+string
+T_interpret_byte_order::get_host_order()
+{
+    if (A_is_host_byte_order_inverted)
+        return  "little_endian";
+    else
+        return  "big_endian";
+}
+
+//*****************************************************************************
+// C_interpret_byte_order_set_temporary
+//*****************************************************************************
+
+C_interpret_byte_order_set_temporary::C_interpret_byte_order_set_temporary(
+                                     T_interpret_byte_order  & interpret_byte_order,
+                               const std::string             & byte_order)
+    :A_interpret_byte_order(interpret_byte_order),
+     A_byte_order(byte_order),
+     A_previous_byte_order_is_little_endian(interpret_byte_order.is_little_endian())
+{
+    if (A_byte_order != "")
+    {
+        A_interpret_byte_order.set_data_order(A_byte_order);
+    }
+}
+
+C_interpret_byte_order_set_temporary::~C_interpret_byte_order_set_temporary()
+{
+    if (A_byte_order != "")
+    {
+        if (A_previous_byte_order_is_little_endian)
+        {
+            A_interpret_byte_order.set_little_endian();
+        }
+        else
+        {
+            A_interpret_byte_order.set_big_endian();
+        }
+    }
+}
diff --git a/plugins/epan/generic/T_interpret_byte_order.h b/plugins/epan/generic/T_interpret_byte_order.h
new file mode 100644
index 00000000000..bd38c6cbcd4
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_byte_order.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_interpret_byte_order_h
+#define T_interpret_byte_order_h
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <string>
+
+#include "byte_interpret_common.h"
+
+
+//*****************************************************************************
+// T_interpret_byte_order
+// Manage the current byte order
+//*****************************************************************************
+
+struct T_interpret_byte_order : public CT_debug_object_counter<T_interpret_byte_order>
+{
+    bool    must_invert_bytes() const            { return  A_must_invert_bytes; }
+
+    void    set_big_endian();
+    void    set_little_endian();
+    void    set_as_host();
+
+    bool    is_little_endian() const;
+
+    void         set_data_order(const std::string  & byte_order);
+    std::string  get_data_order() const;
+
+    static
+    std::string  get_host_order();
+    static
+    bool         is_host_byte_order_inverted ()  { return  A_is_host_byte_order_inverted; }
+
+    T_interpret_byte_order ();
+
+private:
+    bool    A_must_invert_bytes;
+
+    static bool    A_is_host_byte_order_inverted;
+};
+
+//*****************************************************************************
+// C_interpret_byte_order_set_temporary
+// Temporary change the byte order
+// Permits recursive call.
+// Permits exception and return (thanks to dtor).
+//*****************************************************************************
+
+class C_interpret_byte_order_set_temporary
+{
+public:
+    // Change the byte order
+    C_interpret_byte_order_set_temporary(T_interpret_byte_order  & interpret_byte_order,
+                                   const std::string             & byte_order);
+
+    // Restore the previous byte order
+    ~C_interpret_byte_order_set_temporary();
+
+private:
+    // Copy and assignment are forbidden
+    C_interpret_byte_order_set_temporary(const C_interpret_byte_order_set_temporary  &);
+    C_interpret_byte_order_set_temporary & operator=(const C_interpret_byte_order_set_temporary  &);
+
+    T_interpret_byte_order  & A_interpret_byte_order;
+    std::string               A_byte_order;
+    bool                      A_previous_byte_order_is_little_endian;
+};
+
+
+#endif /* T_interpret_byte_order_h */
diff --git a/plugins/epan/generic/T_interpret_chrono.cpp b/plugins/epan/generic/T_interpret_chrono.cpp
new file mode 100644
index 00000000000..ae92edacc36
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_chrono.cpp
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "T_interpret_chrono.h"
+using namespace std;
+
+
+//*****************************************************************************
+// T_interpret_chrono
+//*****************************************************************************
+
+#ifndef WIN32
+T_interpret_chrono::T_interpret_chrono()
+{
+}
+
+std::string
+T_interpret_chrono::compute_chrono_value_from_command(const std::string  & command)
+{
+    return  "NOT implemented (only on WIN32) " + command;
+}
+
+#else
+
+#include "byte_interpret_common.h"
+
+long    T_interpret_chrono::A_ms_cumulative = 0;
+
+
+//*****************************************************************************
+// T_interpret_chrono
+//*****************************************************************************
+
+T_interpret_chrono::T_interpret_chrono()
+{
+    A_timeb_last = A_timeb_ctor;
+}
+
+std::string
+T_interpret_chrono::compute_chrono_value_from_command(const std::string  & command)
+{
+    T_perf_time  timeb_val;
+
+    long    ms_diff_last = perf_time_diff_ms(timeb_val, A_timeb_last);
+    long    ms_diff_ctor = perf_time_diff_ms(timeb_val, A_timeb_ctor);
+    A_ms_cumulative += ms_diff_last;
+
+    string  str_diff_last = get_diff_time_ms_str(ms_diff_last);
+    string  str_diff_ctor = get_diff_time_ms_str(ms_diff_ctor);
+    string  str_diff_cumulative = get_diff_time_ms_str(A_ms_cumulative);
+
+    A_timeb_last = timeb_val;
+
+    string  str = command + " " + str_diff_last + "  msg=" + str_diff_ctor+ "  cumulative=" + str_diff_cumulative;
+
+    return  str;
+}
+
+#endif
diff --git a/plugins/epan/generic/T_interpret_chrono.h b/plugins/epan/generic/T_interpret_chrono.h
new file mode 100644
index 00000000000..a82e2b7c7a6
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_chrono.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_interpret_chrono_h
+#define T_interpret_chrono_h
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <string>
+
+#include "T_perf_time.h"
+#include "byte_interpret_common.h"
+
+
+//*****************************************************************************
+// T_interpret_chrono
+// For chrono command (perf debug only)
+//*****************************************************************************
+
+struct T_interpret_chrono : public CT_debug_object_counter<T_interpret_chrono>
+{
+    std::string  compute_chrono_value_from_command(const std::string  & command);
+
+    T_interpret_chrono ();
+
+private:
+
+    static long    A_ms_cumulative;
+    T_perf_time    A_timeb_ctor;
+    T_perf_time    A_timeb_last;
+};
+
+#endif /* T_interpret_chrono_h */
diff --git a/plugins/epan/generic/T_interpret_data.cpp b/plugins/epan/generic/T_interpret_data.cpp
new file mode 100644
index 00000000000..2d3d2441b5d
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_data.cpp
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+// Necessary for windows pre-compiled headers.
+// At the end, does NOT work : missing functions at link time
+// After other includes, does NOT work : does NOT compile
+#include "precomp.h"
+
+#include <cstdio>
+#include <cerrno>
+#include <cassert>
+#include <iostream>
+#include <string>
+#include <map>
+#include <vector>
+#include <queue>
+#include <fstream>
+#include <sstream>
+#include <algorithm>
+using namespace std;
+
+#include "C_value.h"
+#include "byte_interpret_common.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret_build_types.h"
+#include "byte_interpret_builder.h"
+#include "F_common_print.h"
+
+
+#include "T_interpret_data.h"
+
+
+//*****************************************************************************
+// T_interpret_data
+//*****************************************************************************
+
+void    swap(T_interpret_data  & lhs,
+             T_interpret_data  & rhs)
+{
+    swap(  (T_interpret_byte_order&)lhs,   (T_interpret_byte_order&)rhs);
+    swap(      (T_interpret_output&)lhs,       (T_interpret_output&)rhs);
+    swap( (T_interpret_read_values&)lhs,  (T_interpret_read_values&)rhs);
+    swap(      (T_interpret_decode&)lhs,       (T_interpret_decode&)rhs);
+    swap((T_interpret_inside_frame&)lhs, (T_interpret_inside_frame&)rhs);
+    swap(      (T_interpret_chrono&)lhs,       (T_interpret_chrono&)rhs);
+    
+}
+
+//*****************************************************************************
+// C_interpret_data_set_temporary
+//*****************************************************************************
+#if 0
+static T_interpret_data  * S_P_interpret_data = nullptr;    // recursive call ok
+
+C_interpret_data_set_temporary::C_interpret_data_set_temporary(T_interpret_data  & interpret_data)
+    :previous_value(S_P_interpret_data),
+     value_modified(false)
+{
+    set(interpret_data);
+}
+
+C_interpret_data_set_temporary::C_interpret_data_set_temporary()
+    :previous_value(S_P_interpret_data),
+     value_modified(false)
+{
+}
+
+C_interpret_data_set_temporary::~C_interpret_data_set_temporary()
+{
+    unset();
+}
+
+void
+C_interpret_data_set_temporary::set(T_interpret_data  & interpret_data)
+{
+    S_P_interpret_data = & interpret_data;
+    value_modified = true;
+}
+void
+C_interpret_data_set_temporary::unset()
+{
+    if (value_modified)
+    {
+        S_P_interpret_data = previous_value;
+        value_modified = false;
+    }
+}
+void
+C_interpret_data_set_temporary::forget()
+{
+    value_modified = false;
+}
+
+//*****************************************************************************
+// get_interpret_data
+//*****************************************************************************
+
+T_interpret_data  & get_interpret_data()
+{
+    M_FATAL_IF_FALSE(S_P_interpret_data != nullptr);
+    return  * S_P_interpret_data;
+}
+
+//*****************************************************************************
+// get_P_interpret_data
+//*****************************************************************************
+
+T_interpret_data  * get_P_interpret_data()
+{
+    return  S_P_interpret_data;
+}
+#endif
diff --git a/plugins/epan/generic/T_interpret_data.h b/plugins/epan/generic/T_interpret_data.h
new file mode 100644
index 00000000000..6a730f234fe
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_data.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_interpret_data_h
+#define T_interpret_data_h
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "T_interpret_read_values.h"
+#include "T_interpret_output.h"
+#include "T_interpret_byte_order.h"
+#include "T_interpret_decode.h"
+#include "T_interpret_inside_frame.h"
+#include "T_interpret_chrono.h"
+
+
+//*****************************************************************************
+// T_interpret_data
+//*****************************************************************************
+
+struct T_interpret_data :
+            public T_interpret_read_values,                   // values (field/variable) read
+            public T_interpret_output,                        // output level to hide/show data
+            public T_interpret_byte_order,                    // byte order (big/little endian)
+            public T_interpret_decode,                        // decoder status
+            public T_interpret_inside_frame,                  // used for decoded data or ...
+            public T_interpret_chrono,                        // time measurement for chrono command
+            public CT_debug_object_counter<T_interpret_data>  // debug only
+{
+};
+
+typedef C_reference_counter_ptr<T_interpret_data>        T_RCP_interpret_data;
+typedef C_reference_counter_ptr<const T_interpret_data>  T_RCP_const_interpret_data;
+
+
+void    swap(T_interpret_data  & lhs,
+             T_interpret_data  & rhs);
+
+//*****************************************************************************
+// Permits recursive call of generic dissector.
+// Mandatory for subdissector and inside dissector.
+//*****************************************************************************
+#if 0
+class C_interpret_data_set_temporary
+{
+public:
+    C_interpret_data_set_temporary(T_interpret_data  & interpret_data);
+    C_interpret_data_set_temporary();
+    ~C_interpret_data_set_temporary();
+
+    void    set(T_interpret_data  & interpret_data);
+    void    unset();
+    void    forget();
+
+private:
+    C_interpret_data_set_temporary(const C_interpret_data_set_temporary  &);
+
+    T_interpret_data  * previous_value;
+    bool                value_modified;
+};
+
+//*****************************************************************************
+// get_P_interpret_data
+//*****************************************************************************
+
+T_interpret_data  * get_P_interpret_data();
+
+//*****************************************************************************
+// get_interpret_data
+// FATAL if interpret_data has not been set (with C_interpret_data_set_temporary)
+//*****************************************************************************
+
+T_interpret_data  & get_interpret_data();
+#endif
+
+#endif /* T_interpret_data_h */
diff --git a/plugins/epan/generic/T_interpret_decode.cpp b/plugins/epan/generic/T_interpret_decode.cpp
new file mode 100644
index 00000000000..3f8a51298ad
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_decode.cpp
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "T_interpret_decode.h"
+
+
+//*****************************************************************************
+// T_interpret_decode
+//*****************************************************************************
+void
+T_interpret_decode::set_decode_function (string  decode_function)
+{
+    if (decode_function == "nil")
+    {
+        A_decode_function = "";
+    }
+    else
+    {
+        A_decode_function = decode_function;
+    }
+}
+
+//*****************************************************************************
+// C_interpret_decode_in_progress
+//*****************************************************************************
+
+C_interpret_decode_in_progress::C_interpret_decode_in_progress(
+                                            T_interpret_decode  & interpret_decode)
+    :A_interpret_decode(interpret_decode)
+{
+    A_interpret_decode.set_decode_in_progress(true);
+}
+
+C_interpret_decode_in_progress::~C_interpret_decode_in_progress()
+{
+    A_interpret_decode.set_decode_in_progress(false);
+}
+
+
+//*****************************************************************************
+// C_interpret_decode_set_temporary
+//*****************************************************************************
+
+C_interpret_decode_set_temporary::C_interpret_decode_set_temporary(
+                                     T_interpret_decode  & interpret_decode,
+                               const std::string         & decoder_function)
+    :A_interpret_decode(interpret_decode),
+     A_decoder_function(decoder_function),
+     A_previous_decoder_function(interpret_decode.get_decode_function())
+{
+    if (A_decoder_function != "")
+    {
+        A_interpret_decode.set_decode_function(A_decoder_function);
+    }
+}
+
+C_interpret_decode_set_temporary::~C_interpret_decode_set_temporary()
+{
+    if (A_decoder_function != "")
+    {
+        A_interpret_decode.set_decode_function(A_previous_decoder_function);
+    }
+}
diff --git a/plugins/epan/generic/T_interpret_decode.h b/plugins/epan/generic/T_interpret_decode.h
new file mode 100644
index 00000000000..b0686a58500
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_decode.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_interpret_decode_h
+#define T_interpret_decode_h
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <string>
+using namespace std;
+
+#include "byte_interpret_common.h"
+
+//*****************************************************************************
+// T_interpret_decode
+// Contains the decoding function name to use
+// Manage the decoding status (in progress or not) 
+//*****************************************************************************
+
+struct T_interpret_decode : public CT_debug_object_counter<T_interpret_decode>
+{
+    void            set_decode_function (string  decode_function);
+    const string &  get_decode_function () const                    { return  A_decode_function; }
+
+    void    set_decode_in_progress (bool  in_progress)  { A_decode_in_progress = in_progress; }
+    bool     is_decode_in_progress () const             { return  A_decode_in_progress; }
+
+    bool    must_decode () const              { return  A_decode_function != ""; }
+    bool    must_decode_now () const          { return  must_decode () && (is_decode_in_progress () == false); }
+
+    T_interpret_decode ()
+        :A_decode_in_progress (false)
+    {
+    }
+
+private:
+    string  A_decode_function;
+    bool    A_decode_in_progress;
+};
+
+//*****************************************************************************
+// C_interpret_decode_in_progress
+// Permits exception and return (thanks to dtor).
+//*****************************************************************************
+
+class C_interpret_decode_in_progress
+{
+public:
+    // Ctor set_decode_in_progress(true)
+    C_interpret_decode_in_progress(T_interpret_decode  & interpret_decode);
+
+    // Dtor set_decode_in_progress(false)
+    ~C_interpret_decode_in_progress();
+
+private:
+    // Copy and assignment are forbidden
+    C_interpret_decode_in_progress(const C_interpret_decode_in_progress  &);
+    C_interpret_decode_in_progress & operator=(const C_interpret_decode_in_progress  &);
+
+    T_interpret_decode  & A_interpret_decode;
+};
+
+//*****************************************************************************
+// C_interpret_decode_set_temporary
+// Permits recursive call.
+// Permits exception and return (thanks to dtor).
+//*****************************************************************************
+
+class C_interpret_decode_set_temporary
+{
+public:
+    // Change the decoder function
+    C_interpret_decode_set_temporary(T_interpret_decode  & interpret_decode,
+                               const std::string         & decoder_function);
+
+    // Restore the previous decoder function
+    ~C_interpret_decode_set_temporary();
+
+private:
+    // Copy and assignment are forbidden
+    C_interpret_decode_set_temporary(const C_interpret_decode_set_temporary  &);
+    C_interpret_decode_set_temporary & operator=(const C_interpret_decode_set_temporary  &);
+
+    T_interpret_decode  & A_interpret_decode;
+    std::string           A_decoder_function;
+    std::string           A_previous_decoder_function;
+};
+
+
+
+#endif /* T_interpret_decode_h */
diff --git a/plugins/epan/generic/T_interpret_inside_frame.cpp b/plugins/epan/generic/T_interpret_inside_frame.cpp
new file mode 100644
index 00000000000..22a7cd8c837
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_inside_frame.cpp
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2013-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "T_interpret_inside_frame.h"
+#include "T_frame_data_write.h"
+
+
+//*****************************************************************************
+// T_decode_stream_frame
+//*****************************************************************************
+void
+T_decode_stream_frame::synchronize()
+{
+    if (frame_data.get_remaining_bits() == 0)
+    {
+        reset();
+    }
+#if 0
+    else if (frame_data.get_remaining_bits() < decoded_data_bit_size)
+    {
+        // Some data has been read, and so can be removed
+        const long  move_bit_offset = frame_data.get_bit_offset();
+        const long  move_bit_size   = frame_data.get_remaining_bits();
+
+        if ((move_bit_offset % 8) == 0)
+        {
+            const long  move_byte_offset = move_bit_offset / 8;
+            const long  move_byte_size   = move_bit_size   / 8 + 1;
+
+            // Move entire bytes
+            memmove(&decoded_data[0], &decoded_data[move_byte_offset], move_byte_size);
+            decoded_data_bit_size = move_bit_size;
+            frame_data = T_frame_data(decoded_data, 0, decoded_data_bit_size);
+        }
+        else
+        {
+        }
+    }
+#endif
+}
+
+void
+T_decode_stream_frame::reset()
+{
+    decoded_data_bit_size = 0;
+    frame_data = T_frame_data(decoded_data, 0, 0);
+}
+
+void
+T_decode_stream_frame::write_n_bytes(const T_byte *  ptr, int  n_bytes)
+{
+    T_frame_data_write  frame_data_write(decoded_data, 0, sizeof(decoded_data) * 8);
+    frame_data_write.set_bit_offset(decoded_data_bit_size);
+
+    frame_data_write.write_n_bytes(n_bytes, ptr);
+    decoded_data_bit_size = frame_data_write.get_bit_offset();
+
+    frame_data.n_bits_data_appended(n_bytes * 8);
+}
+
+void
+T_decode_stream_frame::write_1_byte(T_byte  byte)
+{
+    T_frame_data_write  frame_data_write(decoded_data, 0, sizeof(decoded_data) * 8);
+    frame_data_write.set_bit_offset(decoded_data_bit_size);
+
+    frame_data_write.write_1_byte(byte);
+    decoded_data_bit_size = frame_data_write.get_bit_offset();
+
+    frame_data.n_bits_data_appended(8);
+}
+
+void
+T_decode_stream_frame::write_less_1_byte(T_byte  data, short  data_bit_size)
+{
+    T_frame_data_write  frame_data_write(decoded_data, 0, sizeof(decoded_data) * 8);
+    frame_data_write.set_bit_offset(decoded_data_bit_size);
+
+    if (data_bit_size <= 8)
+    {
+        frame_data_write.write_less_1_byte(data, data_bit_size);        // ICIOA signed !
+        decoded_data_bit_size = frame_data_write.get_bit_offset();
+
+        frame_data.n_bits_data_appended(data_bit_size);
+        return;
+    }
+
+    M_FATAL_COMMENT("write_less_1_byte  data_bit_size=" << data_bit_size << " must be <= 8");
+}
+
+
+//*****************************************************************************
+// T_interpret_inside_frame
+//*****************************************************************************
+T_decode_stream_frame &
+T_interpret_inside_frame::get_decode_stream_frame() const
+{
+    M_FATAL_IF_NULL(AP_decode_stream_frame);
+    return  * AP_decode_stream_frame;
+}
+
+void
+T_interpret_inside_frame::set_decode_stream_frame(T_decode_stream_frame *  P_rhs)
+{
+    AP_decode_stream_frame = P_rhs;
+}
+
+//*****************************************************************************
+// C_decode_stream_frame_set_temporary_if_necessary
+//*****************************************************************************
+
+C_decode_stream_frame_set_temporary_if_necessary::C_decode_stream_frame_set_temporary_if_necessary(
+                                                     T_interpret_inside_frame  & interpret_inside_frame,
+                                                     T_decode_stream_frame     & decode_stream_frame)
+    : A_interpret_inside_frame(interpret_inside_frame)
+    , A_decode_stream_frame(decode_stream_frame)
+    , A_value_set(false)
+{
+    // For now, we reject possible already set decode_stream_frame :
+    // - generic.cpp does NOT need it
+    // - UT does not need it (...interpret_bytes check there is no remaining data in it)
+    M_FATAL_IF_NE(interpret_inside_frame.get_P_decode_stream_frame(), nullptr);
+
+//    if (interpret_inside_frame.get_P_decode_stream_frame() == nullptr)
+    {
+        interpret_inside_frame.set_decode_stream_frame(&A_decode_stream_frame);
+        A_value_set = true;
+    }
+}
+
+C_decode_stream_frame_set_temporary_if_necessary::~C_decode_stream_frame_set_temporary_if_necessary()
+{
+    if (A_value_set == true)
+    {
+        A_interpret_inside_frame.set_decode_stream_frame(nullptr);
+    }
+}
diff --git a/plugins/epan/generic/T_interpret_inside_frame.h b/plugins/epan/generic/T_interpret_inside_frame.h
new file mode 100644
index 00000000000..7ef3401a193
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_inside_frame.h
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2013-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_interpret_inside_frame_h
+#define T_interpret_inside_frame_h
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <string>
+using namespace std;
+
+#include "byte_interpret_common.h"
+#include "T_frame_data.h"
+
+
+//*****************************************************************************
+// T_decode_stream_frame ******************************************************
+//*****************************************************************************
+
+struct T_decode_stream_frame
+{
+    T_byte           decoded_data[10000];       // ICIOA hard coded magic number, 1000000 NOT ok for ...shark
+    int              decoded_data_bit_size;
+    T_frame_data     frame_data;
+
+    T_decode_stream_frame()
+        :decoded_data_bit_size(0),
+         frame_data(decoded_data, 0, 0)
+    {
+    }
+
+    // Reset/remove all data
+    void            reset();
+
+    // Permits to reset frame_data & decoded_data_size when all data has been read.
+    // To avoid decoded_data_bit_size grows indefinitely.
+    void            synchronize();
+
+    void            write_n_bytes(const T_byte *  ptr, int  n_bytes);
+    void            write_1_byte(T_byte  byte);
+    void            write_less_1_byte(T_byte  byte, short  n_bits);
+};
+
+
+//*****************************************************************************
+// T_interpret_inside_frame
+//*****************************************************************************
+
+struct T_interpret_inside_frame : public CT_debug_object_counter<T_interpret_inside_frame>
+{
+    // Fatal if AP_decode_stream_frame is nullptr
+    T_decode_stream_frame &  get_decode_stream_frame() const;
+    T_decode_stream_frame *  get_P_decode_stream_frame() const { return  AP_decode_stream_frame; }
+
+    void                     set_decode_stream_frame(T_decode_stream_frame *  P_rhs);
+
+
+    T_interpret_inside_frame ()
+        :AP_decode_stream_frame (nullptr)
+    {
+    }
+
+private:
+    T_decode_stream_frame *  AP_decode_stream_frame;
+};
+
+
+//*****************************************************************************
+// C_decode_stream_frame_set_temporary_if_necessary
+//*****************************************************************************
+
+class C_decode_stream_frame_set_temporary_if_necessary
+{
+public:
+    C_decode_stream_frame_set_temporary_if_necessary(T_interpret_inside_frame  & interpret_inside_frame,
+                                                     T_decode_stream_frame     & decode_stream_frame);
+    ~C_decode_stream_frame_set_temporary_if_necessary();
+
+private:
+    C_decode_stream_frame_set_temporary_if_necessary(const C_decode_stream_frame_set_temporary_if_necessary  &);
+    C_decode_stream_frame_set_temporary_if_necessary& operator= (const C_decode_stream_frame_set_temporary_if_necessary  &);
+
+    T_interpret_inside_frame  & A_interpret_inside_frame;
+    T_decode_stream_frame     & A_decode_stream_frame;
+    bool                        A_value_set;
+};
+
+
+#endif /* T_interpret_inside_frame_h */
diff --git a/plugins/epan/generic/T_interpret_output.cpp b/plugins/epan/generic/T_interpret_output.cpp
new file mode 100644
index 00000000000..fb58636e933
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_output.cpp
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "T_interpret_output.h"
+
+
+//*****************************************************************************
+// C_interpret_output_level_move_temporary
+//*****************************************************************************
+
+C_interpret_output_level_move_temporary::C_interpret_output_level_move_temporary(
+                                            T_interpret_output  & interpret_output,
+                                            int                   output_level_offset)
+    :A_interpret_output(interpret_output),
+     A_output_level_offset(output_level_offset)
+{
+    A_interpret_output.set_output_level(A_interpret_output.get_output_level() + A_output_level_offset);
+}
+
+C_interpret_output_level_move_temporary::~C_interpret_output_level_move_temporary()
+{
+    A_interpret_output.set_output_level(A_interpret_output.get_output_level() - A_output_level_offset);
+}
+
diff --git a/plugins/epan/generic/T_interpret_output.h b/plugins/epan/generic/T_interpret_output.h
new file mode 100644
index 00000000000..9f2de6123cd
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_output.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_interpret_output_h
+#define T_interpret_output_h
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "byte_interpret_common.h"
+
+//*****************************************************************************
+// T_interpret_output
+// Manage current output level
+// A normal field is output if output_level >= 0
+// This output level can be changer for a specific field or at a given time
+//*****************************************************************************
+
+struct T_interpret_output : public CT_debug_object_counter<T_interpret_output>
+{
+    int     get_output_level  () const                { return  output_level; }
+    void    set_output_level  (int   val)             { output_level = val; }
+
+    bool    must_output_error () const          { return  output_level >= -1; }
+    bool    must_output       () const          { return  output_level >=  0; }
+    bool    must_output_debug () const          { return  output_level >=  1; }
+
+    bool    must_NOT_output   () const            { return  ! must_output (); }
+
+    void    incr_output_level ()                            { ++output_level; }
+    void    decr_output_level ()                            { --output_level; }
+
+    T_interpret_output ()
+        :output_level (0)
+    {
+    }
+
+private:
+    int    output_level;
+};
+
+//*****************************************************************************
+// C_interpret_output_level_move_temporary
+// Temporary change the output level
+// Permits recursive call.
+// Permits exception and return (thanks to dtor).
+//*****************************************************************************
+
+class C_interpret_output_level_move_temporary
+{
+public:
+    // Change the output level
+    C_interpret_output_level_move_temporary(T_interpret_output  & interpret_output,
+                                            int                   output_level_offset);
+
+    // Restore the previous output level
+    ~C_interpret_output_level_move_temporary();
+
+private:
+    // Copy and assignment are forbidden
+    C_interpret_output_level_move_temporary(const C_interpret_output_level_move_temporary  &);
+    C_interpret_output_level_move_temporary & operator=(const C_interpret_output_level_move_temporary  &);
+
+    T_interpret_output  & A_interpret_output;
+    int                   A_output_level_offset;
+};
+
+
+
+#endif /* T_interpret_output_h */
diff --git a/plugins/epan/generic/T_interpret_read_values.cpp b/plugins/epan/generic/T_interpret_read_values.cpp
new file mode 100644
index 00000000000..4f6b32abfc6
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_read_values.cpp
@@ -0,0 +1,1028 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "T_interpret_read_values.h"
+#include "byte_interpret_common.h"
+
+
+//*****************************************************************************
+// T_interpret_read_values
+//*****************************************************************************
+
+T_interpret_read_values::T_interpret_read_values()
+    : A_msg_global_idx_begin(0)
+    , A_msg_global_idx_end(-1)
+    , A_msg_pinfo_idx_begin(0)
+    , A_msg_pinfo_idx_end(-1)
+    , A_msg_other_idx_begin(0)
+    , A_this_msg_attribute_value(C_value(C_value::E_type_msg, nullptr))
+    , A_this_msg_attribute_value_used(false)
+{
+}
+
+bool
+T_interpret_read_values::is_read_variable (const string  & var_name) const
+{
+    const T_attribute_value  * P_attr = get_P_attribute_value_of_read_variable(var_name);
+    if (P_attr != nullptr)
+    {
+        return  true;
+    }
+
+    return  false;
+}
+
+const C_value *
+T_interpret_read_values::get_P_value_of_read_variable (const string   & var_name) const
+{
+    const T_attribute_value  * P_attr = get_P_attribute_value_of_read_variable(var_name);
+    if (P_attr != nullptr)
+    {
+        return  & P_attr->get_value();
+    }
+
+    return  nullptr;
+}
+
+bool
+T_interpret_read_values::get_value_of_read_variable (
+                                            const string   & var_name,
+                                                  C_value  & out_value) const
+{
+    const C_value  * P_value = get_P_value_of_read_variable (var_name);
+    if (P_value == nullptr)
+    {
+        out_value = C_value ();
+        return  false;
+    }
+    out_value = *P_value;
+    return  true;
+}
+
+const string &
+T_interpret_read_values::get_str_value_of_read_variable (
+                                               const string  & var_name) const
+{
+    const C_value  * P_value = get_P_value_of_read_variable (var_name);
+    if (P_value == nullptr)
+    {
+        static const string  default_str;
+        return  default_str;
+    }
+    return  P_value->as_string ();
+}
+
+bool
+T_interpret_read_values::get_int_value_of_read_variable (
+                                         const string     & var_name,
+                                               long long  & out_value) const
+{
+    const C_value  * P_value = get_P_value_of_read_variable (var_name);
+    if (P_value == nullptr)
+    {
+        return  false;
+    }
+
+    if (P_value->get_type () != C_value::E_type_integer)
+    {
+        return  false;
+    }
+
+    out_value = P_value->get_int ();
+    return  true;
+}
+
+T_interpret_read_values::T_id
+T_interpret_read_values::add_read_variable (const string   & var_name,
+                                            const C_value  & in_value)
+{
+    T_attribute_value    attribute_value(in_value);
+
+    return  add_read_variable(var_name, attribute_value);
+}
+
+void
+T_interpret_read_values::set_read_variable (const string   & var_name,
+                                            const C_value  & in_value)
+{
+    M_TRACE_ENTER("set_read_variable", A_current_path << " " << var_name << " = " << in_value.as_string());
+
+    T_attribute_value  * P_attr = const_cast<T_attribute_value*>(get_P_attribute_value_of_read_variable(var_name));
+    if (P_attr == nullptr)
+    {
+        M_FATAL_COMMENT("set of an unknow variable/field (" << var_name << ")");
+    }
+
+    P_attr->reset(in_value);
+    // reference !!!
+}
+
+void    
+T_interpret_read_values::sup_read_variable (T_id    var_id)
+{
+    M_TRACE_ENTER("sup_read_variable", A_current_path << " " << var_id);
+
+    if ((var_id < 0) ||
+        (static_cast<size_t>(var_id) >= A_msg.size()))
+    {
+        M_FATAL_COMMENT("suppress of an unknow variable/field id (" << var_id << ")");
+    }
+
+    T_interpret_value  & interpret_value = A_msg[var_id];
+
+    if (interpret_value.get_reference_counter() != 0)
+    {
+        // 2009/11/18 impossible since only function parameters could be reference
+        //  and they are supressed at the end of the function
+        M_FATAL_COMMENT("suppress of a still referenced variable/field id (" <<
+                        var_id << ", " <<
+                        A_msg[var_id].get_name() << ")");
+    }
+
+    if (interpret_value.get_type() == T_interpret_value::E_type_reference)
+    {
+        A_msg[interpret_value.get_attribute_value().get_value().get_int_size_t()].decr_reference_counter();
+    }
+
+    if (var_id == (A_msg.size() - 1))
+    {
+        A_msg.pop_back();
+    }
+    else
+    {
+      // To not erase the variable will lead to an accumulative effect.
+      // Exemple: decode function called very often, parameters never erased
+      // But the real problem must be the variable inside the function ?
+        A_msg.erase(A_msg.begin()+var_id);
+    }
+}
+
+void
+T_interpret_read_values::sup_read_variables (int     nb_of_var, T_id    var_id[])
+{
+    for (int   idx = nb_of_var - 1; idx >= 0; --idx)
+    {
+        sup_read_variable(var_id[idx]);
+    }
+}
+
+void
+T_interpret_read_values::sup_all_read_variables_after (T_id    var_id)
+{
+    M_TRACE_ENTER("sup_all_read_variables_after", var_id);
+
+    if (var_id < 0 || static_cast<size_t>(var_id) >= A_msg.size())
+    {
+        return;
+    }
+
+    A_msg.erase(A_msg.begin()+var_id+1, A_msg.end());
+}
+
+T_interpret_read_values::T_id
+T_interpret_read_values::add_read_variable (const string             & var_name,
+                                            const T_attribute_value  & in_value)
+{
+    M_TRACE_ENTER("add_read_variable", A_current_path << " " << var_name);
+
+    if (A_current_path == "")
+    {
+        A_msg.push_back(T_interpret_value(var_name, in_value));
+    }
+    else
+    {
+        string    full_name = A_current_path;
+        full_name += ".";
+        full_name += var_name;
+        A_msg.push_back(T_interpret_value(full_name, in_value));
+    }
+
+    return  A_msg.size() - 1;
+}
+
+T_interpret_read_values::T_id
+T_interpret_read_values::get_id_of_last_read_variable () const
+{
+    return  A_msg.size() - 1;
+}
+
+T_interpret_read_values::T_id
+T_interpret_read_values::add_ref_variable(const string  & ref_name,
+                                          const string  & var_name)
+{
+    M_TRACE_ENTER("add_ref_variable", A_current_path << " " << ref_name << " -> " << var_name);
+
+    T_id                       var_id;
+    const T_attribute_value  * P_attribute_value = get_P_attribute_value_of_read_variable(var_name, var_id);
+
+    if (P_attribute_value == nullptr)
+    {
+        M_FATAL_COMMENT("in_out parameter on an unknow variable/field (" << var_name << ")");
+    }
+
+    if (var_id < 0)
+    {
+        M_FATAL_COMMENT("in_out parameter on variable/field of another msg (" << var_name << ")");
+    }
+
+    T_interpret_read_values::T_id  ref_id =
+        add_read_variable (ref_name, C_value(var_id));
+
+    A_msg[ref_id].set_type(T_interpret_value::E_type_reference);
+    A_msg[var_id].incr_reference_counter();
+
+    return  ref_id;
+}
+
+//const T_interpret_read_values  * get_P_interpret_read_values_of_msg(int   msg_id);
+
+const T_attribute_value *
+T_interpret_read_values::get_P_attribute_value_of_read_variable (
+                                               const string  & var_name,
+                                                     T_id    & var_id) const
+{
+    const int  A_msg_size = A_msg.size();
+
+    if ((A_msg_global_idx_end > A_msg_global_idx_begin) &&
+        (var_name.compare(0, 7, "global.") == 0))
+    {
+        return  get_P_attribute_value_of_read_variable(var_name, var_id,
+                                                       A_msg.rbegin() + (A_msg_size - A_msg_global_idx_end),
+                                                       A_msg.rend()                 - A_msg_global_idx_begin,
+                                                       true /*full_name_only*/);
+    }
+
+    if ((A_msg_pinfo_idx_end > A_msg_pinfo_idx_begin) &&
+        (var_name.compare(0, 6, "pinfo.") == 0))
+    {
+        return  get_P_attribute_value_of_read_variable(var_name, var_id,
+                                                       A_msg.rbegin() + (A_msg_size - A_msg_pinfo_idx_end),
+                                                       A_msg.rend()                 - A_msg_pinfo_idx_begin,
+                                                       true /*full_name_only*/);
+    }
+
+    return  get_P_attribute_value_of_read_variable(var_name, var_id,
+                                                   A_msg.rbegin(),
+                                                   A_msg.rend() - A_msg_other_idx_begin,
+                                                   false /*full_name_only*/);
+}
+
+const T_attribute_value *
+T_interpret_read_values::get_P_attribute_value_of_read_variable (
+                                               const string                                      & var_name,
+                                                     T_id                                        & var_id,
+                                                     T_interpret_values::const_reverse_iterator    A_msg_rstart,
+                                                     T_interpret_values::const_reverse_iterator    A_msg_rstop,
+                                                     bool                                          full_name_only) const
+{
+    if ((A_current_path != "") && (full_name_only == false))
+    {
+        string    full_name = A_current_path;
+        full_name += ".";
+        full_name += var_name;
+
+        for (T_interpret_values::const_reverse_iterator
+                                                iter  = A_msg_rstart;
+                                                iter != A_msg_rstop;
+                                              ++iter)
+        {
+            const T_interpret_value  & interpret_value = *iter;
+            const string             & interpret_value_name = interpret_value.get_name();
+
+            if ((full_name == interpret_value_name) ||
+                (var_name == interpret_value_name))
+            {
+                if (interpret_value.get_type() == T_interpret_value::E_type_reference)
+                {
+                    var_id = interpret_value.get_attribute_value().get_value().get_int_int();
+                    return  & A_msg[var_id].get_attribute_value();
+                }
+                else
+                {
+                    var_id = A_msg.size() - (iter - A_msg.rbegin()) - 1;
+                    return  & interpret_value.get_attribute_value();
+                }
+            }
+            else if (interpret_value.get_type() == T_interpret_value::E_type_msg)
+            {
+                const char  * following_name = nullptr;
+                if (full_name.find(interpret_value_name) == 0)
+                {
+                    following_name = full_name.c_str() + interpret_value_name.length() + 1;
+                }
+                else if (var_name.find(interpret_value_name) == 0)
+                {
+                    following_name = var_name.c_str() + interpret_value_name.length() + 1;
+                }
+                if (following_name != nullptr)
+                {
+                    C_value::T_msg    msg = interpret_value.get_attribute_value().get_value().get_msg();
+                    if (msg == nullptr)
+                    {
+                        M_FATAL_COMMENT("Message reference " << var_name << " not initialized");
+                    }
+
+                    const T_interpret_read_values  * P_interpret_read_values_msg = 
+                                                 static_cast<const T_interpret_read_values  *>(msg);
+//                    if (P_interpret_read_values_msg == nullptr)
+//                    {
+//                        M_FATAL_COMMENT("Message id=" << msg_id << " (" <<
+//                                        var_name << ") not found. Bug");
+//                        return  nullptr;
+//                    }
+                    const T_attribute_value  * P_attribute_value =
+                        P_interpret_read_values_msg->get_P_attribute_value_of_read_variable(following_name);
+
+                    // could not reference a value of another msg.
+                    // At this time reference is only for in_out parameter, and
+                    //  since I do not want to modify data of another msg,
+                    //  it is normal.
+//                    var_id = A_msg.size() - (iter - A_msg.rbegin()) - 1;
+                    var_id = -1;
+
+                    return  P_attribute_value;
+                }
+            }
+            else
+            {
+                // Search value from end of name.
+                int  idx_dot = interpret_value_name.size() - var_name.size() -1;
+                if ((idx_dot >= 0) &&
+                    (interpret_value_name[idx_dot] == '.') &&
+                    (strcmp(var_name.c_str(), interpret_value_name.c_str()+(idx_dot+1)) == 0))
+                {
+                    // Forbidden access.
+                    if ((strncmp(interpret_value.get_name().c_str(), "global.", 7) == 0) ||
+                        (strncmp(interpret_value.get_name().c_str(), "pinfo.", 6) == 0))
+                        continue;
+
+                    return  & interpret_value.get_attribute_value();
+                }
+            }
+        }
+    }
+    else
+    {
+        for (T_interpret_values::const_reverse_iterator
+                                                iter  = A_msg_rstart;
+                                                iter != A_msg_rstop;
+                                              ++iter)
+        {
+            const T_interpret_value  & interpret_value = *iter;
+            const string             & interpret_value_name = interpret_value.get_name();
+
+            if (var_name == interpret_value_name)
+            {
+                if (interpret_value.get_type() == T_interpret_value::E_type_reference)
+                {
+                    var_id = interpret_value.get_attribute_value().get_value().get_int_int();
+                    return  & A_msg[var_id].get_attribute_value();
+                }
+                else
+                {
+                    var_id = A_msg.size() - (iter - A_msg.rbegin()) - 1;
+                    return  & interpret_value.get_attribute_value();
+                }
+            }
+            else if (interpret_value.get_type() == T_interpret_value::E_type_msg)
+            {
+                const char  * following_name = nullptr;
+                if (var_name.find(interpret_value_name) == 0)
+                {
+                    following_name = var_name.c_str() + interpret_value_name.length() + 1;
+                }
+                if (following_name != nullptr)
+                {
+                    C_value::T_msg    msg = interpret_value.get_attribute_value().get_value().get_msg();
+                    if (msg == nullptr)
+                    {
+                        M_FATAL_COMMENT("Message reference " << var_name << " not initialized");
+                    }
+
+                    const T_interpret_read_values  * P_interpret_read_values_msg =
+                                                 static_cast<const T_interpret_read_values  *>(msg);
+//                    if (P_interpret_read_values_msg == nullptr)
+//                    {
+//                        M_FATAL_COMMENT("Message id=" << msg_id << " (" <<
+//                                        var_name << ") not found. Bug");
+//                        return  nullptr;
+//                    }
+                    const T_attribute_value  * P_attribute_value =
+                        P_interpret_read_values_msg->get_P_attribute_value_of_read_variable(following_name);
+
+                    // could not reference a value of another msg.
+                    // At this time reference is only for in_out parameter, and
+                    //  since I do not want to modify data of another msg,
+                    //  it is normal.
+//                    var_id = A_msg.size() - (iter - A_msg.rbegin()) - 1;
+                    var_id = -1;
+
+                    return  P_attribute_value;
+                }
+            }
+            else if (full_name_only == false)
+            {
+                // Search value from end of name.
+                int  idx_dot = interpret_value_name.size() - var_name.size() -1;
+                if ((idx_dot >= 0) &&
+                    (interpret_value_name[idx_dot] == '.') &&
+                    (strcmp(var_name.c_str(), interpret_value_name.c_str()+(idx_dot+1)) == 0))
+                {
+                    // Forbidden access.
+                    if ((strncmp(interpret_value_name.c_str(), "global.", 7) == 0) ||
+                        (strncmp(interpret_value_name.c_str(), "pinfo.", 6) == 0))
+                        continue;
+
+                    return  & interpret_value.get_attribute_value();
+                }
+            }
+        }
+    }
+
+    if (var_name == "this_msg")
+    {
+        // Check that this_msg has been set.
+        // If not, we are into pre-computation, so this_msg is NOT defined.
+        if (A_this_msg_attribute_value.get_value().get_msg() != nullptr)
+        {
+            T_interpret_read_values  * this_not_const = const_cast<T_interpret_read_values*>(this);
+            this_not_const->A_this_msg_attribute_value_used = true;
+            var_id = -1;
+            M_TRACE_DEBUG("A_this_msg_attribute_value_used=" << A_this_msg_attribute_value_used);
+            return  & A_this_msg_attribute_value;
+        }
+    }
+
+    return  nullptr;
+}
+
+const T_interpret_read_values *
+T_interpret_read_values::get_P_interpret_read_values_min_max (
+                                              const string  & var_name,
+                                                    int     & var_idx_min,
+                                                    int     & var_idx_max,
+                                                    int     & idx_end_var_name) const
+{
+    const T_interpret_read_values  * P_result = nullptr;
+    var_idx_min = -1;
+    var_idx_max = -1;
+    idx_end_var_name = -1;
+
+    string    full_name = A_current_path;
+    full_name += ".";
+    full_name += var_name;
+
+    string    end_name = ".";
+    end_name += var_name;
+
+    for (T_interpret_values::const_reverse_iterator
+                                            iter  = A_msg.rbegin();
+                                            iter != A_msg.rend();
+                                          ++iter)
+    {
+        const T_interpret_value  & interpret_value = *iter;
+
+        if ((full_name == interpret_value.get_name()) ||
+            (var_name == interpret_value.get_name()))
+        {
+            if (interpret_value.get_type() == T_interpret_value::E_type_reference)
+            {
+                continue;
+            }
+            else
+            {
+                var_idx_min = A_msg.size() - (iter - A_msg.rbegin()) - 1;
+                if (var_idx_max < 0)
+                    var_idx_max = var_idx_min;
+                idx_end_var_name = interpret_value.get_name().size();
+                P_result = this;
+            }
+        }
+        else if ((strncmp(var_name.c_str(), interpret_value.get_name().c_str(), var_name.size()) == 0) &&
+                 ((interpret_value.get_name()[var_name.size()] == '.') ||
+                  (interpret_value.get_name()[var_name.size()] == '[')))
+        {
+            if (interpret_value.get_type() == T_interpret_value::E_type_reference)
+            {
+                continue;
+            }
+            else
+            {
+                var_idx_min = A_msg.size() - (iter - A_msg.rbegin()) - 1;
+                if (var_idx_max < 0)
+                    var_idx_max = var_idx_min;
+                idx_end_var_name = var_name.size();
+                P_result = this;
+            }
+        }
+        else if ((strncmp(full_name.c_str(), interpret_value.get_name().c_str(), full_name.size()) == 0) &&
+                 ((interpret_value.get_name()[full_name.size()] == '.') ||
+                  (interpret_value.get_name()[full_name.size()] == '[')))
+        {
+            if (interpret_value.get_type() == T_interpret_value::E_type_reference)
+            {
+                continue;
+            }
+            else
+            {
+                var_idx_min = A_msg.size() - (iter - A_msg.rbegin()) - 1;
+                if (var_idx_max < 0)
+                    var_idx_max = var_idx_min;
+                idx_end_var_name = full_name.size();
+                P_result = this;
+            }
+        }
+        else if (interpret_value.get_type() == T_interpret_value::E_type_msg)
+        {
+            const char  * following_name = nullptr;
+            if (full_name.find(interpret_value.get_name()) == 0)
+            {
+                following_name = full_name.c_str() + interpret_value.get_name().length() + 1;
+            }
+            else if (var_name.find(interpret_value.get_name()) == 0)
+            {
+                following_name = var_name.c_str() + interpret_value.get_name().length() + 1;
+            }
+            if (following_name != nullptr)
+            {
+                C_value::T_msg    msg = interpret_value.get_attribute_value().get_value().get_msg();
+                if (msg == nullptr)
+                {
+                    M_FATAL_COMMENT("Message reference " << var_name << " not initialized");
+                }
+
+                const T_interpret_read_values  * P_interpret_read_values_msg = 
+                                             static_cast<const T_interpret_read_values  *>(msg);
+//                if (P_interpret_read_values_msg == nullptr)
+//                {
+//                    M_FATAL_COMMENT("Message id=" << msg_id << " (" <<
+//                                    var_name << ") not found. Bug");
+//                    return  nullptr;
+//                }
+                P_result =
+                    P_interpret_read_values_msg->
+                    get_P_interpret_read_values_min_max(following_name, var_idx_min, var_idx_max, idx_end_var_name);
+
+                return  P_result;
+            }
+        }
+        else
+        {
+            // ICIOA
+
+            // Search value from end of name.
+            const string::size_type  idx_rfind = interpret_value.get_name().rfind(end_name);
+            if ((idx_rfind != string::npos) &&
+                ((idx_rfind + end_name.size()) == interpret_value.get_name().length()))
+            {
+                // Forbidden access for global et pinfo.
+                if ((strncmp(interpret_value.get_name().c_str(), "global.", 7) != 0) &&
+                    (strncmp(interpret_value.get_name().c_str(), "pinfo.", 6) != 0))
+                {
+                    var_idx_min = A_msg.size() - (iter - A_msg.rbegin()) - 1;
+                    if (var_idx_max < 0)
+                        var_idx_max = var_idx_min;
+                    idx_end_var_name = interpret_value.get_name().size();
+                    P_result = this;
+                }
+            }
+        }
+
+        if ((var_idx_max > 0) &&
+            (var_idx_min != (A_msg.size() - (iter - A_msg.rbegin()) - 1)))
+        {
+            // Fin de sequence
+            break;
+        }
+    }
+
+    return  P_result;
+}
+
+void
+T_interpret_read_values::duplicate_multiple_values(
+                      const std::string                var_name_src,
+                      const std::string                var_name_dst)
+{
+    M_TRACE_ENTER("duplicate_multiple_values", "src=" << var_name_src << "  dst=" << var_name_dst);
+
+    int   var_idx_min = -1;
+    int   var_idx_max = -1;
+    int   idx_end_var_name = -1;
+    const T_interpret_read_values  * P_result = 
+        get_P_interpret_read_values_min_max (var_name_src, var_idx_min, var_idx_max, idx_end_var_name);
+
+    if (P_result == nullptr)
+    {
+        M_FATAL_COMMENT("Field/variable " << var_name_src << " not found.");
+    }
+
+    string  full_var_name_dst = A_current_path;
+    if ((full_var_name_dst != "") && (var_name_dst != ""))
+    {
+        full_var_name_dst += '.';
+    }
+    full_var_name_dst += var_name_dst;
+
+    for (int   idx = var_idx_min; idx <= var_idx_max; ++idx)
+    {
+        const T_interpret_value  & interpret_value_src = P_result->A_msg[idx];
+
+        // Copy
+        T_interpret_value    interpret_value = interpret_value_src;
+
+        // Name replacement
+        string  new_name = interpret_value.get_name();
+        new_name.replace(0, idx_end_var_name, full_var_name_dst);
+        interpret_value.set_name(new_name);
+
+        A_msg.push_back(interpret_value);
+    }
+}
+
+void
+T_interpret_read_values::copy_global_values(
+                      const T_interpret_read_values  & interpret_read_values_src)
+{
+    if (A_msg_global_idx_end >= A_msg_global_idx_begin)
+    {
+        // already exist
+        copy_multiple_values(interpret_read_values_src, "global.*", A_msg_global_idx_begin, A_msg_global_idx_end);
+    }
+    else
+    {
+        // append
+        A_msg_global_idx_begin = A_msg.size();
+        copy_multiple_values(interpret_read_values_src, "global.*", -1, -1);
+        A_msg_global_idx_end = A_msg.size();
+        A_msg_other_idx_begin = A_msg_global_idx_end;
+    }
+}
+
+void
+T_interpret_read_values::copy_multiple_values(
+                      const T_interpret_read_values  & interpret_read_values_src,
+                      const std::string                var_name_with_star,
+                            int                        dest_idx_begin,
+                      const int                        dest_idx_end)
+{
+    M_TRACE_ENTER("copy_multiple_values", var_name_with_star);
+
+    const string::size_type  pos_star = var_name_with_star.find('*');
+
+    if (pos_star == string::npos)
+    {
+        M_FATAL_COMMENT("* not found at the end of the field/variable name.");
+    }
+
+    if (pos_star != var_name_with_star.size()-1)
+    {
+        M_FATAL_COMMENT("* must be only at the end of the field/variable name.");
+    }
+
+    if (&interpret_read_values_src == (const T_interpret_read_values *)this)
+    {
+        M_FATAL_COMMENT("Impossible to copy on itself.");
+    }
+
+    int    nb_of_values_copied = 0;
+    for (T_interpret_values::const_iterator    iter  = interpret_read_values_src.A_msg.begin();
+                                               iter != interpret_read_values_src.A_msg.end();
+                                             ++iter)
+    {
+        const string             & long_name = iter->get_name();
+        const string::size_type    long_name_size = long_name.size();
+
+        if (long_name_size < pos_star)
+        {
+            if (nb_of_values_copied > 0)
+            {
+                // End of copy sequence
+                break;
+            }
+            continue;
+        }
+        if (strncmp(long_name.c_str(), var_name_with_star.c_str(), pos_star) == 0)
+        {
+            if (dest_idx_end >= 0)
+            {
+                // already exist
+                if (dest_idx_begin >= dest_idx_end)
+                {
+                    M_FATAL_COMMENT("More global data than before !");
+                }
+
+                A_msg[dest_idx_begin] = *iter;
+                ++dest_idx_begin;
+            }
+            else
+            {
+                // append
+                A_msg.push_back(*iter);
+            }
+            ++nb_of_values_copied;
+        }
+        else if (nb_of_values_copied > 0)
+        {
+            // End of copy sequence
+            break;
+        }
+    }
+
+    M_TRACE_LEAVE("from nb_values_src=" << interpret_read_values_src.A_msg.size() <<
+                  " nb_of_values_copied=" << nb_of_values_copied <<
+                  " gives nb_values_dst=" << A_msg.size());
+}
+
+void    
+T_interpret_read_values::get_multiple_P_attribute_value_of_read_variable (
+                            const string               & var_name_with_star,
+                                  T_var_name_P_values  & name_values) const
+{
+    M_TRACE_ENTER("get_multiple_P_attribute_value_of_read_variable", var_name_with_star);
+
+    const string::size_type  pos_star = var_name_with_star.find('*');
+
+    if (pos_star == string::npos)
+    {
+        M_FATAL_COMMENT("* not found at the end of the field/variable name.");
+    }
+
+    if (pos_star != var_name_with_star.size()-1)
+    {
+        M_FATAL_COMMENT("* must be only at the end of the field/variable name.");
+    }
+
+    for (T_interpret_values::const_iterator    iter  = A_msg.begin();
+                                               iter != A_msg.end();
+                                             ++iter)
+    {
+        const string             & long_name = iter->get_name();
+        const string::size_type    long_name_size = long_name.size();
+
+        if (long_name_size < pos_star)
+        {
+            continue;
+        }
+        if (strncmp(long_name.c_str(), var_name_with_star.c_str(), pos_star) == 0)
+        {
+            T_var_name_P_value    var_name_P_value;
+            var_name_P_value.var_name = long_name;
+            var_name_P_value.P_value  = &iter->get_attribute_value();
+
+            name_values.push_back(var_name_P_value);
+        }
+    }
+}
+
+const T_attribute_value *
+T_interpret_read_values::get_P_attribute_value_of_read_variable (
+                                               const string  & var_name) const
+{
+    T_id    id_do_not_care;
+
+    return  get_P_attribute_value_of_read_variable(var_name, id_do_not_care);
+}
+
+const T_attribute_value &
+T_interpret_read_values::get_attribute_value_of_read_variable (
+                                               const string  & var_name) const
+{
+    const T_attribute_value  * P_attr = get_P_attribute_value_of_read_variable(var_name);
+    if (P_attr == nullptr)
+    {
+        static const T_attribute_value  default_attr;
+        return  default_attr;
+    }
+
+    return  * P_attr;
+}
+
+//*****************************************************************************
+// get_full_str_value_of_read_variable
+//*****************************************************************************
+string
+T_interpret_read_values::get_full_str_value_of_read_variable (const string  & var_name) const
+{
+    const T_attribute_value &  attribute_value =
+          get_attribute_value_of_read_variable(var_name);
+
+    return  attribute_value_to_string(attribute_value);
+}
+
+//*****************************************************************************
+// reset
+//*****************************************************************************
+void    
+T_interpret_read_values::reset()
+{
+    M_TRACE_ENTER("reset", "");
+
+    A_msg.clear();
+    A_current_path = "";
+    A_msg_global_idx_begin = 0;
+    A_msg_global_idx_end = -1;
+    A_msg_pinfo_idx_begin = 0;
+    A_msg_pinfo_idx_end = -1;
+    A_msg_other_idx_begin = 0;
+    A_this_msg_attribute_value.reset();
+}
+
+//*****************************************************************************
+// reset_position_offset_sizes
+//*****************************************************************************
+void
+T_interpret_read_values::reset_position_offset_sizes()
+{
+    M_TRACE_ENTER("reset_position_offset_sizes", "");
+
+    // Reset position size.
+    // Not used once the msg is finished.
+    // No sense to use it in another msg and crash possible.
+    for (T_interpret_values::iterator    iter  = A_msg.begin();
+                                         iter != A_msg.end();
+                                       ++iter)
+    {
+        T_interpret_value &  interpret_value = *iter;
+        T_attribute_value &  attribute_value = const_cast<T_attribute_value&>(interpret_value.get_attribute_value());
+        attribute_value.set_bit_position_offset_size(-1, -1);
+    }
+}
+
+//*****************************************************************************
+// msg_is_ended
+//*****************************************************************************
+// Interpretation of the msg is terminated.
+// So content is useless, except for :
+// - global : all global must be kept
+// - global + this_msg : all data must be kept
+//*****************************************************************************
+void
+T_interpret_read_values::msg_is_ended()
+{
+    M_TRACE_ENTER("msg_is_ended", "");
+
+    // Check there is some global data.
+    if (A_msg_global_idx_end <= A_msg_global_idx_begin)
+    {
+        // No global data, so nothing to do, this object will be deleted (or reseted)
+        M_TRACE_LEAVE("No global data  A_msg_global_idx_begin=" << A_msg_global_idx_begin << "  A_msg_global_idx_end=" << A_msg_global_idx_end);
+        return;
+    }
+
+    // Check this_msg has been used
+    if (A_this_msg_attribute_value_used == false)
+    {
+        M_TRACE_DEBUG("Remove all data (except global) : from idx " << A_msg_global_idx_end << " to " << A_msg.size()-1);
+
+        // We can remove every data (except global)
+        //  because they will NOT be accessed (through this_msg in global)
+        A_msg.erase(A_msg.begin() + A_msg_global_idx_end, A_msg.end());
+
+        A_current_path = "";
+        A_msg_pinfo_idx_begin = 0;
+        A_msg_pinfo_idx_end = -1;
+        A_msg_other_idx_begin = A_msg_global_idx_end;
+        A_this_msg_attribute_value.reset();
+        A_this_msg_attribute_value_used = false;
+    }
+    else
+    {
+        // this_msg has been used.
+        // It could have been save inside global data.
+        // So can not remove any data.
+        M_TRACE_DEBUG("this_msg has been used");
+    }
+
+    // position and size are no more necessary
+    reset_position_offset_sizes();
+}
+
+//*****************************************************************************
+// add_this_msg
+//*****************************************************************************
+void
+T_interpret_read_values::add_this_msg()
+{
+    A_this_msg_attribute_value.reset(C_value(C_value::E_type_msg, this));
+    A_this_msg_attribute_value_used = false;
+}
+
+//*****************************************************************************
+// swap
+//*****************************************************************************
+void    swap(T_interpret_read_values  & lhs,
+             T_interpret_read_values  & rhs)
+{
+    swap(lhs.A_msg,                           rhs.A_msg);
+    swap(lhs.A_msg_global_idx_begin,          rhs.A_msg_global_idx_begin);
+    swap(lhs.A_msg_global_idx_end,            rhs.A_msg_global_idx_end);
+    swap(lhs.A_msg_pinfo_idx_begin,           rhs.A_msg_pinfo_idx_begin);
+    swap(lhs.A_msg_pinfo_idx_end,             rhs.A_msg_pinfo_idx_end);
+    swap(lhs.A_msg_other_idx_begin,           rhs.A_msg_other_idx_begin);
+    swap(lhs.A_current_path,                  rhs.A_current_path);
+    swap(lhs.A_this_msg_attribute_value,      rhs.A_this_msg_attribute_value);
+    swap(lhs.A_this_msg_attribute_value_used, rhs.A_this_msg_attribute_value_used);
+}
+
+
+
+
+
+
+
+
+
+
+void
+T_interpret_read_values::read_variable_group_begin(const std::string        & name)
+{
+    M_TRACE_ENTER("read_variable_group_begin", A_current_path << " " << name);
+
+    if (A_current_path != "")
+    {
+        A_current_path += ".";
+    }
+
+    A_current_path += name;
+}
+
+void
+T_interpret_read_values::read_variable_group_end()
+{
+    M_TRACE_ENTER("read_variable_group_end", A_current_path);
+
+    M_FATAL_IF_EQ(A_current_path, "");
+
+    string::size_type  idx_separator = A_current_path.find_last_of('.');
+    if (idx_separator == string::npos)
+    {
+        A_current_path = "";
+    }
+    else
+    {
+        A_current_path.erase(idx_separator);
+    }
+}
+
+void
+T_interpret_read_values::global_variable_group_begin()
+{
+    M_TRACE_ENTER("global_variable_group_begin", A_current_path);
+
+    // global must be at root level
+    M_FATAL_IF_NE(A_current_path, "");
+
+    read_variable_group_begin("global");
+    A_msg_global_idx_begin = A_msg.size();
+}
+
+void
+T_interpret_read_values::global_variable_group_end()
+{
+    M_TRACE_ENTER("global_variable_group_end", A_current_path);
+    A_msg_global_idx_end = A_msg.size();
+    A_msg_other_idx_begin = A_msg_global_idx_end;
+    read_variable_group_end();
+}
+
+void
+T_interpret_read_values::pinfo_variable_group_begin()
+{
+    M_TRACE_ENTER("pinfo_variable_group_begin", A_current_path);
+
+    // pinfo must be at root level
+    M_FATAL_IF_NE(A_current_path, "");
+
+    read_variable_group_begin("pinfo");
+    A_msg_pinfo_idx_begin = A_msg.size();
+}
+
+void
+T_interpret_read_values::pinfo_variable_group_end()
+{
+    M_TRACE_ENTER("pinfo_variable_group_end", A_current_path);
+    A_msg_pinfo_idx_end = A_msg.size();
+    A_msg_other_idx_begin = A_msg_pinfo_idx_end;
+    read_variable_group_end();
+}
diff --git a/plugins/epan/generic/T_interpret_read_values.h b/plugins/epan/generic/T_interpret_read_values.h
new file mode 100644
index 00000000000..db1ac1522cd
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_read_values.h
@@ -0,0 +1,183 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_interpret_read_values_h
+#define T_interpret_read_values_h
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <string>
+#include <map>
+using namespace std;
+
+#include "C_reference_counter.h"
+#include "C_reference_counter_ptr.h"
+#include "T_attribute_value.h"
+
+#include "T_interpret_value.h"
+
+
+//*****************************************************************************
+// T_interpret_read_values
+// Contains named data (T_interpret_value)
+// Data could be :
+// - global data                        optional, wireshark only
+// - pinfo data                         optional, wireshark only
+// - fields read from input data
+// - variables
+// For wireshark, data is about 1 msg/pdu
+//*****************************************************************************
+
+struct T_interpret_read_values : public C_reference_counter,
+                                 public CT_debug_object_counter<T_interpret_read_values>
+{
+    typedef int       T_id;         // value identifier, -1 is invalid
+
+    T_interpret_read_values();
+
+    bool              is_read_variable (const string   & var_name) const;
+    bool    get_value_of_read_variable (const string   & var_name,
+                                              C_value  & out_value) const;
+    const C_value  * get_P_value_of_read_variable (const string   & var_name) const;
+
+
+    const string &  get_str_value_of_read_variable (
+                                              const string  & var_name) const;
+    bool    get_int_value_of_read_variable (
+                                      const string     & var_name,
+                                            long long  & out_value) const;
+
+    T_id    add_read_variable (const string   & var_name,
+                               const C_value  & in_value);
+
+    void    set_read_variable (const string   & var_name,
+                               const C_value  & in_value);
+
+    // 
+    void    sup_read_variable (T_id    var_id);
+    void    sup_read_variables (int     nb_of_var, T_id    var_id[]);
+    void    sup_all_read_variables_after (T_id    var_id);
+
+    // 2008/11/12 new T_attribute_value interface
+    T_id    add_read_variable (const string             & var_name,
+                               const T_attribute_value  & in_value);
+
+//    T_id    get_id_of_read_variable (const string   & var_name);
+    T_id    get_id_of_last_read_variable () const;
+
+    const T_attribute_value &  get_attribute_value_of_read_variable (
+                                              const string  & var_name) const;
+    const T_attribute_value *  get_P_attribute_value_of_read_variable (
+                                              const string  & var_name) const;
+
+    string    get_full_str_value_of_read_variable (
+                                              const string  & var_name) const;
+
+    // ref_name is a reference to (the value of) var_name.
+    T_id    add_ref_variable(const string  & ref_name,
+                             const string  & var_name);
+
+    // msg_name is a reference to msg data.
+//    T_id    add_msg_variable(const string  & msg_name,
+//                             const string  & var_name);
+
+    void    reset();
+    void    reset_position_offset_sizes();
+    void    msg_is_ended();
+    void    add_this_msg();
+
+    struct T_var_name_P_value : public CT_debug_object_counter<T_var_name_P_value>
+    {
+        string               var_name;
+        const T_attribute_value  * P_value;
+    };
+    typedef vector<T_var_name_P_value>    T_var_name_P_values;
+
+    // NB: interpret_read_values_src could not be this
+    void        copy_global_values(
+                      const T_interpret_read_values  & interpret_read_values_src);
+    void        copy_multiple_values(
+                      const T_interpret_read_values  & interpret_read_values_src,
+                      const std::string                var_name_with_star,
+                            int                        dest_idx_begin,
+                      const int                        dest_idx_end);
+
+    void        get_multiple_P_attribute_value_of_read_variable (
+                            const string               & var_name_with_star,
+                                  T_var_name_P_values  & name_values) const;
+
+    void        duplicate_multiple_values(
+                      const std::string                var_name_src,
+                      const std::string                var_name_dst);
+
+
+    // Variable group (ie struct ...)
+    void    read_variable_group_begin(const std::string  & name);
+    void    read_variable_group_end();
+    void    global_variable_group_begin();    // only 1 global group and at the beginning
+    void    global_variable_group_end();
+    void    pinfo_variable_group_begin();     // only 1 pinfo group and at the beginning
+    void    pinfo_variable_group_end();
+
+    vector<T_interpret_value>  DEBUG_get_msg() const { return  A_msg;}
+    std::string                DEBUG_get_current_path() const { return  A_current_path;}
+
+private:
+    typedef vector<T_interpret_value>      T_interpret_values;
+    T_interpret_values           A_msg;
+    int                          A_msg_global_idx_begin;    // optional
+    int                          A_msg_global_idx_end;
+    int                          A_msg_pinfo_idx_begin;     // optional
+    int                          A_msg_pinfo_idx_end;
+    int                          A_msg_other_idx_begin;     // other data start after global and pinfo
+    std::string                  A_current_path;
+
+
+    // ICIOA msg
+    T_attribute_value            A_this_msg_attribute_value;
+    bool                         A_this_msg_attribute_value_used;
+
+    const T_attribute_value *  get_P_attribute_value_of_read_variable (
+                                              const string  & var_name,
+                                                    T_id    & var_id) const;
+    const T_attribute_value *  get_P_attribute_value_of_read_variable (
+                                               const string                                      & var_name,
+                                                     T_id                                        & var_id,
+                                                     T_interpret_values::const_reverse_iterator    A_msg_rstart,
+                                                     T_interpret_values::const_reverse_iterator    A_msg_rstop,
+                                                     bool                                          full_name_only) const;
+
+    const T_interpret_read_values *  get_P_interpret_read_values_min_max (
+                                              const string  & var_name,
+                                                    int     & var_idx_min,
+                                                    int     & var_idx_max,
+                                                    int     & idx_end_var_name) const;
+
+    friend void    swap(T_interpret_read_values  & lhs,
+                        T_interpret_read_values  & rhs);
+};
+
+typedef C_reference_counter_ptr<T_interpret_read_values>        T_RCP_interpret_read_values;
+typedef C_reference_counter_ptr<const T_interpret_read_values>  T_RCP_const_interpret_read_values;
+
+void    swap(T_interpret_read_values  & lhs,
+             T_interpret_read_values  & rhs);
+
+#endif /* T_interpret_read_values_h */
diff --git a/plugins/epan/generic/T_interpret_value.cpp b/plugins/epan/generic/T_interpret_value.cpp
new file mode 100644
index 00000000000..54330fda554
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_value.cpp
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "T_interpret_value.h"
+#include "byte_interpret_common.h"
+
+
+//*****************************************************************************
+// T_interpret_value
+//*****************************************************************************
+
+T_interpret_value::T_interpret_value()
+    :A_reference_counter(0),
+     A_type(E_type_group)
+{
+}
+
+T_interpret_value::T_interpret_value(const std::string        & name)
+    :A_reference_counter(0),
+     A_type(E_type_group),
+     A_name(name)
+{
+}
+
+// Element
+T_interpret_value::T_interpret_value(
+                               const std::string        & name,
+                               const T_attribute_value  & attribute_value)
+    :A_reference_counter(0),
+     A_type(E_type_value),
+     A_name(name),
+     A_attribute_value(attribute_value)
+     
+{
+    if (attribute_value.get_value().get_type() == C_value::E_type_msg)
+    {
+        A_type = E_type_msg;
+    }
+}
+#if 0
+T_interpret_value::T_interpret_value(const T_interpret_value  & rhs)
+    :A_reference_counter(rhs.A_reference_counter),   // reference_counter(0) specific behavior does NOT work
+     A_type(rhs.A_type),
+     A_name(rhs.A_name),
+     A_attribute_value(rhs.A_attribute_value)
+{
+}
+
+T_interpret_value &
+T_interpret_value::operator=(const T_interpret_value  & rhs)
+{
+    A_reference_counter = rhs.A_reference_counter;  // reference_counter specific behavior does NOT work
+    A_type = rhs.A_type;
+    A_name = rhs.A_name;
+    A_attribute_value = rhs.A_attribute_value;
+
+    return  * this;
+}
+
+T_interpret_value::~T_interpret_value()
+{
+    if (A_reference_counter != 0)
+    {
+        M_FATAL_COMMENT("type=" << A_type << " " <<
+                        "name=" << A_name << " " <<
+                        "reference_counter=" << A_reference_counter << " != 0");
+    }
+}
+#endif
+
+//*****************************************************************************
+// swap
+//*****************************************************************************
+
+void    swap(T_interpret_value  & lhs,
+             T_interpret_value  & rhs)
+{
+    swap(lhs.A_reference_counter, rhs.A_reference_counter);
+    swap(lhs.A_type,              rhs.A_type);
+    swap(lhs.A_name,              rhs.A_name);
+    swap(lhs.A_attribute_value,   rhs.A_attribute_value);
+}
+
diff --git a/plugins/epan/generic/T_interpret_value.h b/plugins/epan/generic/T_interpret_value.h
new file mode 100644
index 00000000000..37312541f74
--- /dev/null
+++ b/plugins/epan/generic/T_interpret_value.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_interpret_value_h
+#define T_interpret_value_h
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <string>
+#include <vector>
+
+#include "T_attribute_value.h"
+#include "byte_interpret_common.h"
+
+
+//*****************************************************************************
+// T_interpret_value
+// - value
+// - group        a voir 
+// - reference
+// And flags :
+// - local               plus tard
+//*****************************************************************************
+
+struct T_interpret_value : public CT_debug_object_counter<T_interpret_value>
+{
+    enum E_type
+    {
+        E_type_value,
+        E_type_group,           // not used
+        E_type_reference,       // out/in_out function parameter
+        E_type_msg
+    };
+
+    T_interpret_value();
+    T_interpret_value(const std::string        & name);
+    T_interpret_value(const std::string        & name,
+                      const T_attribute_value  & attribute_value);
+
+//    T_interpret_value(const T_interpret_value  & rhs);
+//    T_interpret_value &  operator=(const T_interpret_value  & rhs);
+//    ~T_interpret_value();
+
+    E_type                     get_type() const             { return  (E_type)A_type; }
+    const std::string        & get_name() const             { return  A_name; }
+    const T_attribute_value  & get_attribute_value() const  { return  A_attribute_value; }
+    int                        get_reference_counter() const{ return  A_reference_counter; }
+
+    void    set_type(const E_type         type)             { A_type = type; }
+    void    set_name(const std::string  & name)             { A_name = name; }
+    void    set_attribute_value(const T_attribute_value  & attribute_value);
+
+    void    incr_reference_counter()                        { ++A_reference_counter; }
+    void    decr_reference_counter()                        { --A_reference_counter; }
+
+private:
+
+    // VCEE2008 & 32bits
+    // Size = 2 + 2 +     28 +  96 = 128 bytes
+
+    // VCEE2008 & 64bits
+    // Size = 2 + 2 + 4 + 40 + 120 = 168 bytes
+
+    unsigned short       A_reference_counter;
+    /*E_type*/short      A_type;                 // short permits to save 4 bytes (32bits)
+    std::string          A_name;
+    T_attribute_value    A_attribute_value;
+
+    friend void    swap(T_interpret_value  & lhs,
+                        T_interpret_value  & rhs);
+};
+
+void    swap(T_interpret_value  & lhs,
+             T_interpret_value  & rhs);
+
+
+#endif /* T_interpret_value_h */
diff --git a/plugins/epan/generic/T_perf_time.cpp b/plugins/epan/generic/T_perf_time.cpp
new file mode 100644
index 00000000000..4ed66cd792c
--- /dev/null
+++ b/plugins/epan/generic/T_perf_time.cpp
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "T_perf_time.h"
+
+#ifdef WIN32
+#else
+#include <stdio.h>
+
+#define WSGD_USE_TIMES
+#ifdef  WSGD_USE_TIMES
+extern long int __sysconf (int);
+//#define WSGD_CLK_TCK  __sysconf (_SC_CLK_TCK)
+#define WSGD_CLK_TCK  100
+#else
+#define WSGD_CLK_TCK  CLOCKS_PER_SEC
+#endif
+#endif
+using namespace std;
+
+
+//*****************************************************************************
+// T_perf_time
+//*****************************************************************************
+
+bool
+T_perf_time::operator!= (const T_perf_time  & rhs) const
+{
+#ifdef WIN32
+    if ((A_perf_time.time != rhs.A_perf_time.time) ||
+        (A_perf_time.millitm != rhs.A_perf_time.millitm))
+    {
+        return  true;
+    }
+
+    return  false;
+#else
+#ifdef  WSGD_USE_TIMES
+    if (A_perf_times != rhs.A_perf_times)
+#else
+    if (A_perf_clock != rhs.A_perf_clock)
+#endif
+    {
+        return  true;
+    }
+
+    return  false;
+#endif
+}
+
+ostream &  operator<<(ostream & os, const T_perf_time  & rhs)
+{
+    char  time_str[99+1];
+#ifdef WIN32
+#ifdef _USE_32BIT_TIME_T
+    sprintf(time_str, "%d.%03d", rhs.A_perf_time.time, rhs.A_perf_time.millitm);
+#else
+    sprintf(time_str, "%lld.%03d", rhs.A_perf_time.time, rhs.A_perf_time.millitm);
+#endif
+#else
+#ifdef  WSGD_USE_TIMES
+    clock_t    modulo = rhs.A_perf_times % WSGD_CLK_TCK;
+    sprintf(time_str, "%ld.%03ld", (rhs.A_perf_times - modulo ) / WSGD_CLK_TCK, modulo * 1000 / WSGD_CLK_TCK);
+#else
+    clock_t    modulo = rhs.A_perf_clock % WSGD_CLK_TCK;
+    sprintf(time_str, "%ld.%03ld", (rhs.A_perf_clock - modulo ) / WSGD_CLK_TCK, modulo * 1000 / WSGD_CLK_TCK);
+#endif
+#endif
+    os << time_str;
+    return  os;
+}
+
+long    perf_time_diff_ms(const T_perf_time  & timeb_val_lhs,
+                          const T_perf_time  & timeb_val_rhs)
+{
+#ifdef WIN32
+    long  diff_total_ms = static_cast<long>((timeb_val_lhs.A_perf_time.time - timeb_val_rhs.A_perf_time.time) * 1000 +
+                                            (timeb_val_lhs.A_perf_time.millitm - timeb_val_rhs.A_perf_time.millitm));
+#else
+#ifdef  WSGD_USE_TIMES
+    long  diff_total_ms = (timeb_val_lhs.A_perf_times - timeb_val_rhs.A_perf_times) * 1000 / WSGD_CLK_TCK;
+#else
+    long  diff_total_ms = (timeb_val_lhs.A_perf_clock - timeb_val_rhs.A_perf_clock) * 1000 / WSGD_CLK_TCK;
+#endif
+#endif
+    return  diff_total_ms;
+}
+
+string  get_diff_time_ms_str(const long  diff_total_ms)
+{
+    long  diff_ms  =  diff_total_ms % 1000;
+    long  diff_sec = (diff_total_ms - diff_ms) / 1000;
+
+    char  diff_str[99+1];
+#ifdef WIN32
+    sprintf(diff_str, "%d.%03d", diff_sec, diff_ms);
+#else
+    sprintf(diff_str, "%ld.%03ld", diff_sec, diff_ms);
+#endif
+
+    return  diff_str;
+}
+
+string  perf_time_diff_ms_str(const T_perf_time  & timeb_val_lhs,
+                              const T_perf_time  & timeb_val_rhs)
+{
+    long  diff_total_ms = perf_time_diff_ms(timeb_val_lhs, timeb_val_rhs);
+
+    return  get_diff_time_ms_str(diff_total_ms);
+}
+
diff --git a/plugins/epan/generic/T_perf_time.h b/plugins/epan/generic/T_perf_time.h
new file mode 100644
index 00000000000..f03c4b57b1a
--- /dev/null
+++ b/plugins/epan/generic/T_perf_time.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_perf_time_h
+#define T_perf_time_h
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <string>
+#include <iostream>
+
+#ifdef WIN32
+#include <sys/timeb.h>
+#else
+#include <time.h> 
+#include <sys/times.h> 
+#endif
+
+//*****************************************************************************
+// T_perf_time
+//*****************************************************************************
+
+class T_perf_time
+{
+public:
+    T_perf_time()
+    {
+#ifdef WIN32
+        ftime (&A_perf_time);
+#else
+        A_perf_times = times(nullptr);
+        A_perf_clock = clock();
+#endif
+    }
+
+    bool  operator!= (const T_perf_time  & rhs) const;
+
+private:
+
+#ifdef WIN32
+    struct timeb  A_perf_time;
+#else
+    clock_t       A_perf_times;
+    clock_t       A_perf_clock;
+#endif
+
+    friend std::ostream &  operator<<(std::ostream & os, const T_perf_time  & rhs);
+    friend long    perf_time_diff_ms(const T_perf_time  & timeb_val_lhs,
+                                     const T_perf_time  & timeb_val_rhs);
+};
+
+
+std::ostream &  operator<<(std::ostream & os, const T_perf_time  & rhs);
+
+
+long    perf_time_diff_ms(const T_perf_time  & timeb_val_lhs,
+                          const T_perf_time  & timeb_val_rhs);
+
+std::string  get_diff_time_ms_str(const long  diff_total_ms);
+
+std::string  perf_time_diff_ms_str(const T_perf_time  & timeb_val_lhs,
+                                   const T_perf_time  & timeb_val_rhs);
+
+
+#endif /* T_perf_time_h */
diff --git a/plugins/epan/generic/T_static_executor.cpp b/plugins/epan/generic/T_static_executor.cpp
new file mode 100644
index 00000000000..07945cba45b
--- /dev/null
+++ b/plugins/epan/generic/T_static_executor.cpp
@@ -0,0 +1,14 @@
+
+#include "T_static_executor.h"
+#include "T_static_executor_manager.h"
+
+
+void T_static_executor::do_register()
+{
+    T_static_executor_manager::getInstance().add(*this);
+}
+
+void T_static_executor::execute()
+{
+    m_test_fct();
+}
diff --git a/plugins/epan/generic/T_static_executor.h b/plugins/epan/generic/T_static_executor.h
new file mode 100644
index 00000000000..61e63715121
--- /dev/null
+++ b/plugins/epan/generic/T_static_executor.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include <string>
+
+
+// FCT :
+// - have NO parameters
+// - returns nothing
+#define M_static_executor(FCT)  \
+static T_static_executor M_static_executor_##FCT(FCT, std::string(__FILE__), #FCT);
+
+
+class T_static_executor
+{
+public:
+    T_static_executor(void(*test_fct)(), const std::string& file_name, const std::string& fct_name)
+        : m_test_fct(test_fct)
+        , m_file_name(file_name)
+        , m_fct_name(fct_name)
+        , m_label(file_name + " " + fct_name)
+    {
+        do_register();
+    }
+
+    void execute();
+
+    const std::string &  get_fct_name() const { return m_fct_name; }
+    const std::string &  get_file_name() const { return m_file_name; }
+
+private:
+    void do_register();
+
+    void(*m_test_fct)() = nullptr;
+    std::string m_file_name;
+    std::string m_fct_name;
+    std::string m_label;
+};
diff --git a/plugins/epan/generic/T_static_executor_manager.cpp b/plugins/epan/generic/T_static_executor_manager.cpp
new file mode 100644
index 00000000000..feca5e0fa99
--- /dev/null
+++ b/plugins/epan/generic/T_static_executor_manager.cpp
@@ -0,0 +1,135 @@
+
+#include <iostream>
+#include <algorithm>
+
+#include "T_static_executor.h"
+#include "T_static_executor_manager.h"
+
+
+bool ends_with(const std::string& str, const std::string& suffix)
+{
+    return str.size() >= suffix.size() && 0 == str.compare(str.size() - suffix.size(), suffix.size(), suffix);
+}
+bool ends_with_case_insensitive(const std::string& str, const std::string& suffix)
+{
+    if (suffix.size() > str.size())
+    {
+        return false;
+    }
+    return std::equal(suffix.rbegin(), suffix.rend(), str.rbegin(),
+        [](const char a, const char b)
+        {
+            return tolower(a) == tolower(b);
+        }
+    );
+}
+bool starts_with(const std::string& str, const std::string& prefix)
+{
+    return str.size() >= prefix.size() && 0 == str.compare(0, prefix.size(), prefix);
+}
+
+
+
+T_static_executor_manager& T_static_executor_manager::getInstance()
+{
+    static T_static_executor_manager instance;
+    return instance;
+}
+
+void T_static_executor_manager::add(T_static_executor& staticExecutor)
+{
+    m_static_executors.push_back(staticExecutor);
+}
+
+int T_static_executor_manager::execute(const int           argc,
+                                       const char * const  argv[],
+                                       const int           arg_idx)
+{
+    T_execution_filters  execution_filters = build_execution_filters(argc, argv, arg_idx);
+
+    int execution_counter = 0;
+    for (T_static_executor& executor : m_static_executors)
+    {
+        if (execution_filters.must_execute(executor))
+        {
+            ++execution_counter;
+            executor.execute();
+        }
+    }
+
+    if (execution_counter <= 0)
+    {
+        std::cerr << "!!! No function executed !!!" << std::endl;
+    }
+
+    return execution_counter;
+}
+
+T_static_executor_manager::T_execution_filters
+T_static_executor_manager::build_execution_filters(const int           argc,
+                                                   const char * const  argv[],
+                                                         int           arg_idx)
+{
+    T_execution_filters  execution_filters;
+
+    for (; arg_idx < argc; ++arg_idx)
+    {
+        std::string  filter = argv[arg_idx];
+        if (ends_with(filter, ".cpp"))
+        {
+            execution_filters.filter_file_name_ends.push_back(filter);
+        }
+        else if (ends_with(filter, "*"))
+        {
+            filter.pop_back();
+            execution_filters.filter_function_name_starts.push_back(filter);
+        }
+        else
+        {
+            execution_filters.filter_function_names.push_back(filter);
+        }
+    }
+
+    return execution_filters;
+}
+
+bool
+T_static_executor_manager::T_execution_filters::must_execute(const T_static_executor& executor) const
+{
+    bool must_match = false;   // will be true if any filter is specified
+
+    if (!filter_function_names.empty())
+    {
+        must_match = true;
+        if (find(begin(filter_function_names), end(filter_function_names), executor.get_fct_name()) != end(filter_function_names))
+        {
+            return  true;
+        }
+    }
+
+    if (!filter_function_name_starts.empty())
+    {
+        must_match = true;
+        for (const auto& filter_function_name_start : filter_function_name_starts)
+        {
+            if (starts_with(executor.get_fct_name(), filter_function_name_start))
+            {
+                return  true;
+            }
+        }
+    }
+
+    if (!filter_file_name_ends.empty())
+    {
+        must_match = true;
+        for (const auto& filter_file_name_end : filter_file_name_ends)
+        {
+            if (ends_with_case_insensitive(executor.get_file_name(), filter_file_name_end))
+            {
+                return  true;
+            }
+        }
+    }
+
+    return  !must_match;
+}
diff --git a/plugins/epan/generic/T_static_executor_manager.h b/plugins/epan/generic/T_static_executor_manager.h
new file mode 100644
index 00000000000..29e5a012e7d
--- /dev/null
+++ b/plugins/epan/generic/T_static_executor_manager.h
@@ -0,0 +1,41 @@
+#pragma once
+
+#include <vector>
+#include <string>
+#include "T_static_executor.h"
+
+
+class T_static_executor_manager
+{
+public:
+    static T_static_executor_manager& getInstance();
+
+    void add(T_static_executor& static_executor);
+
+    // Return the number of executions done
+    // Remaining arguments permits to choose executors to execute
+    // - file_name.cpp   : execute executors defined into file which ends by ...
+    // - function_name   : execute executor called ...
+    // - function_name*  : execute executors beginning by ...
+    int execute(const int           argc,
+                const char * const  argv[],
+                const int           arg_idx);
+
+public:  // for UT
+    struct T_execution_filters
+    {
+        std::vector<std::string>  filter_file_name_ends;
+        std::vector<std::string>  filter_function_names;
+        std::vector<std::string>  filter_function_name_starts;
+
+        bool  must_execute(const T_static_executor& executor) const;
+    };
+
+    static
+    T_execution_filters  build_execution_filters(const int           argc,
+                                                 const char * const  argv[],
+                                                 const int           arg_idx);
+
+private:
+    std::vector<T_static_executor> m_static_executors;
+};
diff --git a/plugins/epan/generic/T_type_definitions.cpp b/plugins/epan/generic/T_type_definitions.cpp
new file mode 100644
index 00000000000..14b48430c3b
--- /dev/null
+++ b/plugins/epan/generic/T_type_definitions.cpp
@@ -0,0 +1,1421 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+// ****************************************************************************
+// Includes.
+// ****************************************************************************
+
+#include <iostream>
+#include <string>
+#include <map>
+#include <vector>
+
+#include "precomp.h"
+#include "byte_interpret_common.h"
+#include "byte_interpret_parse.h"
+#include "T_type_definitions.h"
+#include "F_common_print.h"
+
+// FRHED needs this after previous include to find "std::find" !
+#include <algorithm>
+using namespace std;
+
+
+//*****************************************************************************
+// Identifier syntax.
+//*****************************************************************************
+
+bool    is_a_valid_identifier_name (const string   & var_name,
+                                    const char       also_authorized)
+{
+    // Must not be empty
+    if (var_name.empty())
+        return  false;
+
+    // Must start with a letter or an _
+    if ((isalpha(var_name[0]) == 0) && (var_name[0] != '_'))
+        return  false;
+
+    // Must only contain letter, number or _
+    // NB: ":" is reserved to enums (<Enum_type_name>::<enum_symbolic_value>)
+    // NB: "." is reserved to <name1>.<name2>
+    for (unsigned int  idx = 0; idx < var_name.size(); ++idx)
+    {
+        if ((isalnum(var_name[idx]) == 0) &&
+            (var_name[idx] != '_') &&
+            (var_name[idx] != also_authorized))
+        {
+            return  false;
+        }
+    }
+
+    return  true;
+}
+#if 0
+bool    is_a_valid_short_identifier_name (const string   & var_name)
+{
+    // Must not be empty
+    if (var_name.empty())
+        return  false;
+
+    // Must start with a letter or an _
+    if ((isalpha(var_name[0]) == 0) && (var_name[0] != '_'))
+        return  false;
+
+    // Must only contain letter, number or _
+    // NB: ":" is reserved to enums (<Enum_type_name>::<enum_symbolic_value>)
+    // NB: "." is reserved to <name1>.<name2>
+    for (int  idx = 0; idx < var_name.size(); ++idx)
+    {
+        if ((isalnum(var_name[0]) == 0) && (var_name[0] != '_'))
+            return  false;
+    }
+
+    return  true;
+}
+#endif
+
+//*****************************************************************************
+// 
+//*****************************************************************************
+T_type_definitions::T_type_definitions()
+    : trailer_sizeof_bits(0)
+{
+}
+
+//*****************************************************************************
+// Aliases.
+//*****************************************************************************
+
+void
+T_type_definitions::add_alias( const string      & alias_name,
+                               const string      & already_existent_type,
+                               const E_override    must_override)
+{
+    // Check it is possible to define a new enum type with this name.
+    // No returned value, FATAL is called if it is not possible.
+    could_define_new_type(alias_name, T_type_definitions::E_type_alias, must_override);
+
+    map_alias_type[alias_name] = already_existent_type;    // possible override ok
+}
+
+// Search recursively into the map of aliases to find the final type to be
+//  used.
+const string &
+T_type_definitions::get_final_type (const string  & orig_type) const
+{
+    T_map_alias_type::const_iterator  iter = map_alias_type.find (orig_type);
+    if (iter != map_alias_type.end ())
+    {
+        return  get_final_type (iter->second);
+    }
+    else
+    {
+        return  orig_type;
+    }
+}
+
+//*****************************************************************************
+// Field base
+//*****************************************************************************
+bool
+T_field_type_name_base::has_post_treatment() const
+{
+    bool  has_post_treatment = false;
+
+    if ((no_statement.as_string() != "") ||
+        (transform_expression.is_defined()) ||
+        (transform_quantum.as_string() != "") ||
+        (transform_offset.as_string() != "") ||
+        (str_display != "") ||
+        (str_display_expression != "") ||
+        (constraints.empty() == false) ||
+        (str_size_or_parameter != ""))
+    {
+        has_post_treatment = true;
+    }
+
+    return  has_post_treatment;
+}
+
+//*****************************************************************************
+// Field
+//*****************************************************************************
+
+T_field_type_name::T_field_type_name()
+    :must_forget(false),
+     output_directive(E_output_directive_none),
+     A_is_a_variable(false),
+     wsgd_field_idx (-1),
+     pf_frame_to_any(nullptr),
+     pf_frame_to_field(nullptr),
+     P_type_enum_def(nullptr),
+     P_type_struct_def(nullptr),
+     P_type_switch_def(nullptr),
+     P_type_bitfield_def(nullptr)
+{
+}
+
+// Because of transform (or ...), the resulting value could change.
+// NB: the value is no more read from the packet by wireshark.
+bool
+T_field_type_name::must_force_manage_as_biggest_float() const
+{
+    if (transform_expression.is_defined())
+    {
+        if (transform_expression_type == C_value::E_type_float)
+        {
+            return  true;
+        }
+        else if ((transform_expression_type == C_value::E_type_msg) &&
+                 (strncmp(type.c_str(), "float", 5) == 0))
+        {
+            return  true;
+        }
+    }
+
+    if ((transform_quantum.as_string() != "") ||
+        (transform_offset.as_string() != ""))
+    {
+        if ((transform_quantum.get_type() == C_value::E_type_float) ||
+            (transform_offset.get_type() == C_value::E_type_float))
+        {
+            return  true;
+        }
+        else if (strncmp(type.c_str(), "float", 5) == 0)
+        {
+            return  true;
+        }
+    }
+
+    // ICIOA 2010/12/30 temporary since when ?
+    // currently necessary because it seems that var expression
+    //  are automatically managed as float64
+    //  independenty of the type specified.
+    // See coment into C_byte_interpret_wsgd_builder::value
+    // So "var float64  toto = 12.3" is identic to :
+    //    "var float32  toto = 12.3"
+    if ((new_expression.is_defined() == true) &&
+        (strncmp(type.c_str(), "float", 5) == 0))
+    {
+        return  true;
+    }
+
+    return  false;
+}
+
+bool
+T_field_type_name::must_force_manage_as_biggest_int() const
+{
+    if (must_force_manage_as_biggest_float() == false)
+    {
+        if (transform_expression.is_defined())
+        {
+            return  true;
+        }
+        if ((transform_quantum.as_string() != "") ||
+            (transform_offset.as_string() != ""))
+        {
+            return  true;
+        }
+
+        // ICIOA 2010/12/30 see comment into must_force_manage_as_biggest_float
+        if ((new_expression.is_defined() == true) &&
+            (strncmp(type.c_str(), "float", 5) != 0) &&
+            (strncmp(type.c_str(), "string", 6) != 0))
+        {
+            return  true;
+        }
+    }
+
+    return  false;
+}
+
+ostream &  operator<< (ostream & os, const T_field_type_name  & rhs)
+{
+    if (rhs.is_a_variable())
+        os << "var ";
+
+    os << rhs.type;
+
+    if (rhs.transform_quantum.as_string() != "")
+    {
+        os << "{q=" << rhs.transform_quantum.as_string();
+        if (rhs.transform_offset.as_string() != "")
+        {
+            os << ":o=" << rhs.transform_offset.as_string();
+        }
+        os << "}";
+    }
+    else if (rhs.transform_offset.as_string() != "")
+    {
+        os << "{o=" << rhs.transform_offset.as_string() << "}";
+    }
+
+    for (vector<T_field_constraint>::const_iterator  iter  = rhs.constraints.begin();
+                                                     iter != rhs.constraints.end();
+                                                   ++iter)
+    {
+        const T_field_constraint  & constraint = *iter;
+
+        if (constraint.equal.as_string() != "")
+        {
+            os << "{val=" << constraint.equal.as_string() << "}";
+        }
+        else if (constraint.min.as_string() != "")
+        {
+            os << "{min=" << constraint.min.as_string();
+            if (constraint.max.as_string() != "")
+            {
+                os << ":max=" << constraint.max.as_string();
+            }
+            os << "}";
+        }
+        else if (constraint.max.as_string() != "")
+        {
+            os << "{max=" << constraint.max.as_string() << "}";
+        }
+    }
+
+    if (rhs.str_display != "")
+    {
+        os << "{d=" << rhs.str_display << "}";
+    }
+    else if (rhs.str_display_expression != "")
+    {
+        os << "{de=" << rhs.str_display_expression << "}";
+    }
+
+    if (rhs.str_size_or_parameter != "")
+    {
+        os << "(" << rhs.str_size_or_parameter << ")";
+    }
+
+    os << "    ";
+    os << rhs.name;
+
+    if (rhs.new_expression.is_defined())
+    {
+        os << " = " << rhs.new_expression.get_original_string_expression();
+    }
+
+    if (rhs.P_bitfield_inline)
+    {
+        os << "bitfield";
+    }
+    else if (rhs.P_switch_inline)
+    {
+        os << "switch";
+    }
+    else if (rhs.P_sub_struct)
+    {
+        os << endl;
+        os << "{" << endl;
+        print (os, *rhs.P_sub_struct, "");
+        os << "}";
+
+        if (rhs.sub_struct_2.empty () == false)
+        {
+            os << endl;
+            os << "else" << endl;
+            os << "{" << endl;
+            print (os, rhs.sub_struct_2, "");
+            os << "}";
+        }
+    }
+    else
+    {
+        os << " ;";
+    }
+
+    if (!rhs.fct_parameters.empty())
+    {
+        os << endl;
+        print(os, rhs.fct_parameters, "fct_parameter : ");
+    }
+
+    return  os;
+}
+
+//*****************************************************************************
+// Struct 
+//*****************************************************************************
+
+ostream &  operator<< (ostream & os, const T_struct_fields  & rhs)
+{
+  for (T_struct_fields::const_iterator  iter  = rhs.begin ();
+                                        iter != rhs.end ();
+                                      ++iter)
+  {
+    os << *iter << endl;
+  }
+  return  os;
+}
+
+ostream &  operator<< (ostream & os, const T_struct_definition  & rhs)
+{
+  os << "field_struct_idx " << rhs.field_struct_idx << endl;
+  os << "printf_args " << rhs.printf_args << endl;
+  os << rhs.fields;
+  return  os;
+}
+
+//*****************************************************************************
+// Enums
+//*****************************************************************************
+
+ostream &  operator<< (ostream & os, const T_enum_name_val  & rhs)
+{
+    return  os << rhs.name << "    " << rhs.value;
+}
+
+ostream &  operator<< (ostream & os,
+                 const T_enum_definition_representation  & rhs)
+{
+    print (os, rhs.definition, "");
+    os << rhs.bit_size << " ";
+    os << rhs.is_signed << " ";
+    os << rhs.representation_type;
+    return  os;
+}
+
+bool
+T_enum_definition_representation::get_integer_value(const string     & symbolic_name,
+                                                          long long  & integer_value) const
+{
+    const T_enum_definition  & enum_def = definition;
+
+    for (T_enum_definition::const_iterator  iter  = enum_def.begin ();
+                                            iter != enum_def.end ();
+                                          ++iter)
+    {
+        if (symbolic_name == iter->name)
+        {
+            integer_value = iter->value;
+            return  true;
+        }
+    }
+
+    return  false;
+}
+
+const string &
+T_enum_definition_representation::get_symbolic_name(long long    integer_value) const
+{
+    const T_enum_definition  & enum_def = definition;
+
+    for (T_enum_definition::const_iterator  iter  = enum_def.begin ();
+                                            iter != enum_def.end ();
+                                          ++iter)
+    {
+        if (integer_value == iter->value)
+        {
+            return  iter->name;
+        }
+    }
+
+    static const string    not_found;
+    return  not_found;
+}
+
+#if 0
+// returns false if value does NOT match
+bool    print_enum_value (ostream            & os,
+                          long long            value,
+                    const T_enum_definition  & enum_definition)
+{
+    for (int  idx = 0; idx < enum_definition.size (); ++idx)
+    {
+        if (enum_definition[idx].value == value)
+        {
+            os << enum_definition[idx].name << " ("
+               << value << ")";
+            return  true;
+        }
+    }
+
+    os << "Enum_unknown_value" << " ("
+       << value << ")";
+    return  false;
+}
+#endif
+
+#if 0
+// returns 
+string    enum_value_to_string (long long            value,
+                          const T_enum_definition  & enum_definition,
+                                bool               & no_error)
+{
+    for (uint  idx = 0; idx < enum_definition.size (); ++idx)
+    {
+        if (enum_definition[idx].value == value)
+        {
+            no_error = true;
+            return  enum_definition[idx].name + " (" + get_string(value) + ")";
+        }
+    }
+
+    no_error = false;
+    return  "Enum_unknown_value (" + get_string(value) + ")";
+}
+#endif
+
+//*****************************************************************************
+// Switchs
+//*****************************************************************************
+
+ostream &  operator<< (ostream        & os,
+                 const T_switch_case  & rhs)
+{
+  if (rhs.is_default_case)
+    os << "default : ";
+  else
+      os << "case " << rhs.case_value.as_string() << " : ";
+
+  if (rhs.fields.size () > 1)
+    os << endl;
+    
+  os << rhs.fields;
+  
+  return  os;
+}
+
+ostream &  operator<< (ostream              & os,
+                 const T_switch_definition  & rhs)
+{
+    for (T_switch_cases::const_iterator  iter  = rhs.switch_cases.begin ();
+                                         iter != rhs.switch_cases.end ();
+                                       ++iter)
+    {
+      os << *iter << endl;
+    }
+  return  os;
+}
+
+//*****************************************************************************
+// check_function_parameter_value *********************************************
+//*****************************************************************************
+
+void    check_function_parameter_value(
+                const T_type_definitions    & type_definitions,
+                const T_function_parameter  & function_parameter,
+                const C_value               & obj_value)
+{
+    // Check value type.
+    if (obj_value.get_type() == C_value::E_type_float)
+    {
+        if ((function_parameter.type != "any") &&
+            (function_parameter.type != "float32") &&
+            (function_parameter.type != "float64"))
+        {
+            M_FATAL_COMMENT("Float value for parameter " << function_parameter.name << ". Expecting " << function_parameter.type);
+        }
+    }
+    else if (obj_value.get_type() == C_value::E_type_string)
+    {
+        if ((function_parameter.type != "any") &&
+            (function_parameter.type != "string"))
+        {
+            M_FATAL_COMMENT("String value for parameter " << function_parameter.name << ". Expecting " << function_parameter.type);
+        }
+    }
+    else if (obj_value.get_type() == C_value::E_type_msg)
+    {
+        if ((function_parameter.type != "any") &&
+            (function_parameter.type != "msg"))
+        {
+            M_FATAL_COMMENT("msg value for parameter " << function_parameter.name << ". Expecting " << function_parameter.type);
+        }
+    }
+    else // integer
+    {
+#define M_READ_SIMPLE_TYPE_BASE(TYPE_NAME,TYPE_SIZE,TYPE_IMPL,TYPE_IMPL_SIZE) \
+    else if (function_parameter.type == TYPE_NAME)                            \
+    {                                                                         \
+        M_FATAL_IF_GT (TYPE_SIZE, TYPE_IMPL_SIZE);                            \
+                                                                              \
+        TYPE_IMPL    value = static_cast<TYPE_IMPL>(obj_value.get_int());     \
+        C_value  value_to_compare(value);                                     \
+        if (value_to_compare != obj_value)                                    \
+        {                                                                     \
+            M_FATAL_COMMENT("Overflow value " << obj_value.get_int() << " on parameter " << function_parameter.type << " " << function_parameter.name);         \
+        }                                                                     \
+    }
+
+#define M_READ_SIMPLE_TYPE(TYPE_NAME,TYPE_SIZE,TYPE_IMPL)                     \
+    M_READ_SIMPLE_TYPE_BASE(TYPE_NAME, (TYPE_SIZE / 8), TYPE_IMPL, sizeof (TYPE_IMPL))
+
+        const T_enum_definition_representation  * P_enum = nullptr;
+
+        if (function_parameter.type == "any") ;
+        else if (function_parameter.type == "pointer") ;
+        M_READ_SIMPLE_TYPE ( "int8",    8,    signed char)
+        M_READ_SIMPLE_TYPE ("uint8",    8,  unsigned char)
+        M_READ_SIMPLE_TYPE ( "int16",  16,    signed short)
+        M_READ_SIMPLE_TYPE ("uint16",  16,  unsigned short)
+        M_READ_SIMPLE_TYPE ( "int24",  24,    signed int)
+        M_READ_SIMPLE_TYPE ("uint24",  24,  unsigned int)
+        M_READ_SIMPLE_TYPE ( "int32",  32,    signed int)
+        M_READ_SIMPLE_TYPE ("uint32",  32,  unsigned int)
+        M_READ_SIMPLE_TYPE ( "int40",  40,    signed long long)
+        M_READ_SIMPLE_TYPE ("uint40",  40,  unsigned long long)
+        M_READ_SIMPLE_TYPE ( "int48",  48,    signed long long)
+        M_READ_SIMPLE_TYPE ("uint48",  48,  unsigned long long)
+        M_READ_SIMPLE_TYPE ( "int64",  64,    signed long long)
+        M_READ_SIMPLE_TYPE ("uint64",  64,  unsigned long long)
+        else if ((P_enum = type_definitions.get_P_enum(function_parameter.type)) != nullptr)
+        {
+            if (P_enum->get_symbolic_name(obj_value.get_int()) == "")
+            {
+                M_FATAL_COMMENT("Bad integer value " << obj_value.get_int() << " for parameter " << function_parameter.type << " " << function_parameter.name);
+            }
+        }
+        else
+        {
+            M_FATAL_COMMENT("Integer value for parameter " << function_parameter.name << ". Expecting " << function_parameter.type);
+        }
+
+#undef  M_READ_SIMPLE_TYPE_BASE
+#undef  M_READ_SIMPLE_TYPE
+    }
+}
+
+//****************************************************************************
+// Functions
+//****************************************************************************
+void
+T_function_parameter::set_default_value(const C_value  & rhs)
+{
+    A_default_value = rhs;
+    A_has_default_value = true;
+}
+
+ostream &  operator<< (ostream               & os,
+                 const T_function_parameter  & rhs)
+{
+  os << "  " << rhs.direction << rhs.type << "  " << rhs.name;
+  return  os;
+}
+
+T_function_prototype_definition::T_function_prototype_definition()
+    :A_nb_of_mandatory_parameters(0)
+{
+}
+
+void
+T_function_prototype_definition::add_function_parameter(const T_function_parameter  & function_parameter)
+{
+    function_parameters.push_back(function_parameter);
+
+    if (function_parameter.has_default_value() == false)
+    {
+      ++A_nb_of_mandatory_parameters;
+    }
+}
+
+ostream &  operator<< (ostream                          & os,
+                 const T_function_prototype_definition  & rhs)
+{
+    os << rhs.return_type << "  (";
+
+    for (T_function_parameters::const_iterator  iter  = rhs.function_parameters.begin ();
+                                                iter != rhs.function_parameters.end ();
+                                              ++iter)
+    {
+      os << *iter << endl;
+    }
+
+    os << ")" << endl;
+    return  os;
+}
+
+ostream &  operator<< (ostream                & os,
+                 const T_function_definition  & rhs)
+{
+    return  os << (const T_function_prototype_definition  &)rhs;
+}
+
+//*****************************************************************************
+// T_type_definitions << ******************************************************
+//*****************************************************************************
+ostream &  operator<< (ostream & os,
+                 const T_type_definitions  & rhs)
+{
+  for (T_map_alias_type::const_iterator  iter  = rhs.map_alias_type.begin ();
+                                         iter != rhs.map_alias_type.end ();
+                                       ++iter)
+  {
+    os << "alias " << iter->first << " " << iter->second << endl;
+  }
+  os << endl;
+  
+  for (T_map_struct_definition::const_iterator  iter  = rhs.map_struct_definition.begin ();
+                                                iter != rhs.map_struct_definition.end ();
+                                              ++iter)
+  {
+    os << "struct " << iter->first << endl;
+    os << "{" << endl;
+
+    for (T_struct_fields::const_iterator  iter_s  = iter->second.fields.begin ();
+                                          iter_s != iter->second.fields.end ();
+                                        ++iter_s)
+    {
+      os << "  " << *iter_s << endl;
+    }
+    os << "}" << endl;
+  }
+  os << endl;
+
+  for (T_map_enum_definition_representation::const_iterator
+                  iter  = rhs.map_enum_definition_representation.begin ();
+                  iter != rhs.map_enum_definition_representation.end ();
+                ++iter)
+  {
+    os << "enum" << iter->second.bit_size << "  " << iter->first << endl;
+    os << "{" << endl;
+    os << "  " << iter->second << endl;
+    os << "}" << endl;
+  }
+  os << endl;
+
+  for (T_map_switch_definition::const_iterator  iter  = rhs.map_switch_definition.begin ();
+                                                iter != rhs.map_switch_definition.end ();
+                                              ++iter)
+  {
+    os << "switch " << iter->first << endl;
+    os << "{" << endl;
+    os << "  " << iter->second << endl;
+    os << "}" << endl;
+  }
+  os << endl;
+
+
+
+  os << "Pas fini" << endl;
+  return  os;
+}
+
+//*****************************************************************************
+// string_to_numeric **********************************************************
+//*****************************************************************************
+
+#include "byte_interpret_compute_expression.h"
+
+C_value    string_to_numeric(const T_type_definitions  & type_definitions,
+                             const string              & str_to_convert_to_numeric,
+                             const string              & UNUSED(field_name),
+                             const char                * UNUSED(attr))
+{
+    C_value    val = str_to_convert_to_numeric;
+
+    val.promote();
+
+    if (val.is_numeric() == false)
+    {
+        // Could be a static expression (without any attribute/variable).
+        val = compute_expression_static (type_definitions, val.as_string());
+//        M_FATAL_COMMENT(attr << " (" << str << ") is not a numeric value");
+    }
+
+    return  val;
+}
+
+//*****************************************************************************
+// T_type_definitions Field
+//*****************************************************************************
+void 
+T_type_definitions::set_field_type(T_field_type_name_base  & field,
+                     const string             & type_param) const
+{
+//    M_FATAL_IF_NE(field.type, "");
+    field.type = this->get_final_type (type_param);
+}
+
+void 
+T_type_definitions::set_field_name(T_field_type_name_base  & field,
+                     const string             & name_param) const
+{
+//    M_FATAL_IF_NE(field.name, "");
+    field.name = name_param;
+}
+
+void 
+T_type_definitions::set_field_condition_expression(T_field_type_name_base  & field,
+                     const string             & name_param) const
+{
+//    M_FATAL_IF_NE(field.name, "");
+    field.name = name_param;
+}
+
+void 
+T_type_definitions::set_field_type_size_or_parameter(T_field_type_name_base  & field,
+                          const string             & size_param) const
+{
+    M_FATAL_IF_NE(field.str_size_or_parameter, "");
+
+    field.str_size_or_parameter = size_param;
+
+    if ((field.str_size_or_parameter == "") &&
+        (field.type != "string") &&
+        (field.type != "string_nl"))
+    {
+        M_FATAL_COMMENT("() forbidden for " << field.type);
+    }
+
+    if ((field.str_size_or_parameter == "*") &&
+        (field.type != "raw") &&
+        (field.type != "subproto") &&
+        (field.type != "insproto"))
+    {
+        M_FATAL_COMMENT("(*) forbidden for " << field.type);
+    }
+}
+
+void 
+T_type_definitions::set_field_no_statement(T_field_type_name_base  & field,
+                                  const string             & val_param) const
+{
+    M_FATAL_IF_NE(field.no_statement.as_string(), "");
+
+    field.no_statement = string_to_numeric(*this, val_param, field.name, "no_statement");
+}
+
+void 
+T_type_definitions::set_field_transform_quantum(T_field_type_name_base  & field,
+                                  const string             & val_param) const
+{
+    M_FATAL_IF_NE(field.transform_quantum.as_string(), "");
+    M_FATAL_IF_NE(field.transform_offset.as_string(), "");
+    M_FATAL_IF_NE(field.transform_expression.is_defined(), false);
+
+    field.transform_quantum = string_to_numeric(*this, val_param, field.name, "quantum");
+}
+
+void 
+T_type_definitions::set_field_transform_offset (T_field_type_name_base  & field,
+                                  const string             & val_param) const
+{
+    M_FATAL_IF_NE(field.transform_offset.as_string(), "");
+    M_FATAL_IF_NE(field.transform_expression.is_defined(), false);
+
+    field.transform_offset = string_to_numeric(*this, val_param, field.name, "offset");
+}
+
+void 
+T_type_definitions::set_field_transform_expression_integer (
+                                        T_field_type_name_base  & field,
+                                  const string                  & expr_param) const
+{
+    M_FATAL_IF_NE(field.transform_quantum.as_string(), "");
+    M_FATAL_IF_NE(field.transform_offset.as_string(), "");
+    M_FATAL_IF_NE(field.transform_expression.is_defined(), false);
+
+    field.transform_expression.build_expression(*this, expr_param);
+    field.transform_expression_type = C_value::E_type_integer;
+}
+
+void 
+T_type_definitions::set_field_transform_expression_float (
+                                        T_field_type_name_base  & field,
+                                  const string                  & expr_param) const
+{
+    M_FATAL_IF_NE(field.transform_quantum.as_string(), "");
+    M_FATAL_IF_NE(field.transform_offset.as_string(), "");
+    M_FATAL_IF_NE(field.transform_expression.is_defined(), false);
+
+    field.transform_expression.build_expression(*this, expr_param);
+    field.transform_expression_type = C_value::E_type_float;
+}
+
+void 
+T_type_definitions::add_field_constraint_min_max(T_field_type_name_base  & field,
+                                           const string                  & min_param,
+                                           const string                  & max_param) const
+{
+    T_field_constraint    constraint;
+    constraint.min = string_to_numeric(*this, min_param, field.name, "min");
+    constraint.max = string_to_numeric(*this, max_param, field.name, "max");
+
+    field.constraints.push_back(constraint);
+}
+
+void 
+T_type_definitions::add_field_constraint_min  (T_field_type_name_base  & field,
+                                 const string             & val_param) const
+{
+    T_field_constraint    constraint;
+    constraint.min = string_to_numeric(*this, val_param, field.name, "min");
+
+    field.constraints.push_back(constraint);
+}
+
+void 
+T_type_definitions::add_field_constraint_max  (T_field_type_name_base  & field,
+                                 const string             & val_param) const
+{
+    T_field_constraint    constraint;
+    constraint.max = string_to_numeric(*this, val_param, field.name, "max");
+
+    field.constraints.push_back(constraint);
+}
+
+void 
+T_type_definitions::add_field_constraint_equal(T_field_type_name_base  & field,
+                                 const string             & val_param) const
+{
+    T_field_constraint    constraint;
+    constraint.equal = string_to_numeric(*this, val_param, field.name, "equal");
+
+    field.constraints.push_back(constraint);
+}
+
+void 
+T_type_definitions::prepend_field_constraint_min_max(T_field_type_name_base  & field,
+                                           const string                  & min_param,
+                                           const string                  & max_param) const
+{
+    T_field_constraint    constraint;
+    constraint.min = string_to_numeric(*this, min_param, field.name, "min");
+    constraint.max = string_to_numeric(*this, max_param, field.name, "max");
+
+    field.constraints.insert(field.constraints.begin(), constraint);
+}
+
+void 
+T_type_definitions::prepend_field_constraint_min  (T_field_type_name_base  & field,
+                                 const string             & val_param) const
+{
+    T_field_constraint    constraint;
+    constraint.min = string_to_numeric(*this, val_param, field.name, "min");
+
+    field.constraints.insert(field.constraints.begin(), constraint);
+}
+
+void 
+T_type_definitions::prepend_field_constraint_max  (T_field_type_name_base  & field,
+                                 const string             & val_param) const
+{
+    T_field_constraint    constraint;
+    constraint.max = string_to_numeric(*this, val_param, field.name, "max");
+
+    field.constraints.insert(field.constraints.begin(), constraint);
+}
+
+void 
+T_type_definitions::prepend_field_constraint_equal(T_field_type_name_base  & field,
+                                 const string             & val_param) const
+{
+    T_field_constraint    constraint;
+    constraint.equal = string_to_numeric(*this, val_param, field.name, "equal");
+
+    field.constraints.insert(field.constraints.begin(), constraint);
+}
+
+void 
+T_type_definitions::set_field_display           (T_field_type_name_base  & field,
+                                   const string             & val_param) const
+{
+    M_FATAL_IF_NE(field.str_display, "");
+    M_FATAL_IF_NE(field.str_display_expression, "");
+
+    field.str_display = val_param;
+
+    promote_printf_string_to_64bits(field.str_display);
+}
+
+void 
+T_type_definitions::set_field_display_expression(T_field_type_name_base  & field,
+                                   const string             & val_param) const
+{
+    M_FATAL_IF_NE(field.str_display, "");
+    M_FATAL_IF_NE(field.str_display_expression, "");
+
+    field.str_display_expression = val_param;
+}
+
+void 
+T_type_definitions::set_field_subdissector(T_field_type_name_base  & field,
+                                   const string             & val_param) const
+{
+    M_FATAL_IF_NE(field.str_dissector, "");
+
+    field.str_dissector = val_param;
+
+    const_cast<T_type_definitions*>(this)->add_subdissector(val_param);
+}
+
+void
+T_type_definitions::add_subdissector(const string             & val_param)
+{
+    if (find(vector_subdissector_name.begin(),
+             vector_subdissector_name.end(),
+             val_param) == vector_subdissector_name.end())
+    {
+        vector_subdissector_name.push_back(val_param);
+    }
+}
+
+void 
+T_type_definitions::set_field_decoder(T_field_type_name_base  & field,
+                                const string                  & val_param) const
+{
+    M_FATAL_IF_NE(field.str_decoder_function, "");
+
+    field.str_decoder_function = val_param;
+}
+
+void 
+T_type_definitions::set_field_byte_order(T_field_type_name_base  & field,
+                                   const string                  & val_param) const
+{
+    M_FATAL_IF_NE(field.str_byte_order, "");
+
+    field.str_byte_order = val_param;
+}
+
+//*****************************************************************************
+// Global
+//*****************************************************************************
+
+const T_enum_definition_representation  *
+T_type_definitions::get_P_enum(const string      & type_name) const
+{
+    T_map_enum_definition_representation::const_iterator  iter =
+        map_enum_definition_representation.find(type_name);
+
+    if (iter != map_enum_definition_representation.end ())
+    {
+        return  &iter->second;
+    }
+
+    return  nullptr;
+}
+
+bool
+T_type_definitions::is_an_enum   (const string      & type_name) const
+{
+    return  get_P_enum(type_name) != nullptr;
+}
+
+const T_struct_definition  *
+T_type_definitions::get_P_struct(const string      & type_name) const
+{
+    T_map_struct_definition::const_iterator  iter =
+        map_struct_definition.find(type_name);
+
+    if (iter != map_struct_definition.end ())
+    {
+        return  &iter->second;
+    }
+
+    return  nullptr;
+}
+
+T_struct_definition  *
+T_type_definitions::get_P_struct(const string      & type_name)
+{
+    T_map_struct_definition::iterator  iter =
+        map_struct_definition.find(type_name);
+
+    if (iter != map_struct_definition.end ())
+    {
+        return  &iter->second;
+    }
+
+    return  nullptr;
+}
+
+bool
+T_type_definitions::is_a_struct   (const string      & type_name) const
+{
+    return  get_P_struct(type_name) != nullptr;
+}
+
+const T_bitfield_definition *
+T_type_definitions::get_P_bitfield(const string      & type_name) const
+{
+    T_map_bitfield_definition::const_iterator  iter =
+        map_bitfield_definition.find(type_name);
+
+    if (iter != map_bitfield_definition.end ())
+    {
+        return  &iter->second;
+    }
+
+    return  nullptr;
+}
+
+bool
+T_type_definitions::is_a_bitfield (const string      & type_name) const
+{
+    return  get_P_bitfield(type_name) != nullptr;
+}
+
+const T_switch_definition &
+T_type_definitions::get_switch  (const string      & type_name) const
+{
+    const T_switch_definition  * P_switch_def = get_P_switch(type_name);
+
+    if (P_switch_def == nullptr)
+    {
+        M_FATAL_COMMENT("Switch " << type_name << " unknow.");
+    }
+
+    return  *P_switch_def;
+}
+
+const T_switch_definition *
+T_type_definitions::get_P_switch  (const string      & type_name) const
+{
+    T_map_switch_definition::const_iterator  iter =
+        map_switch_definition.find(type_name);
+
+    if (iter != map_switch_definition.end ())
+    {
+        return  &iter->second;
+    }
+
+    return  nullptr;
+}
+
+bool
+T_type_definitions::is_a_switch   (const string      & type_name) const
+{
+    return  get_P_switch(type_name) != nullptr;
+}
+bool
+T_type_definitions::is_a_switch_value   (const string      & type_name) const
+{
+    T_switch_definition const *  ptr = get_P_switch(type_name);
+    if ((ptr != nullptr) && (ptr->is_switch_expr == false))
+        return  true;
+    return  false;
+}
+bool
+T_type_definitions::is_a_switch_expr   (const string      & type_name) const
+{
+    T_switch_definition const *  ptr = get_P_switch(type_name);
+    if ((ptr != nullptr) && (ptr->is_switch_expr == true))
+        return  true;
+    return  false;
+}
+
+const T_function_definition &
+T_type_definitions::get_function  (const string      & type_name) const
+{
+    const T_function_definition  * P_fct_def = get_P_function(type_name);
+
+    if (P_fct_def == nullptr)
+    {
+        M_FATAL_COMMENT("Function " << type_name << " unknow.");
+    }
+
+    return  *P_fct_def;
+}
+
+const T_function_definition *
+T_type_definitions::get_P_function(const string      & type_name) const
+{
+    T_map_function_definition::const_iterator  iter =
+        map_function_definition.find(type_name);
+
+    if (iter != map_function_definition.end ())
+    {
+        return  &iter->second;
+    }
+
+    return  nullptr;
+}
+
+bool
+T_type_definitions::is_a_function (const string      & type_name) const
+{
+    return  get_P_function(type_name) != nullptr;
+}
+
+// Enum  : get integer value from symbolic value.
+// Const : get value 
+// Returns false if nothing found.
+bool
+T_type_definitions::get_type_value (const string   & in_symbolic_name,
+                                          C_value  & out_value) const
+{
+    string    str_left;
+    string    str_right;
+    if (get_before_separator_after (in_symbolic_name,
+                                    "::",
+                                    str_left,
+                                    str_right) == E_rc_ok)
+    {
+        const T_enum_definition_representation  * P_enum = get_P_enum(str_left);
+        if (P_enum != nullptr)
+        {
+            long long    integer_value = -1;
+            if (P_enum->get_integer_value(str_right, integer_value))
+            {
+                out_value = C_value(integer_value);
+                out_value.set_str(str_right);
+                return  true;
+            }
+            else
+            {
+                // M_FATAL_COMMENT ?
+            }
+        }
+        else
+        {
+            T_map_const_value::const_iterator  iter = map_const_value.find(in_symbolic_name);
+            if (iter != map_const_value.end())
+            {
+                out_value = iter->second;
+                return  true;
+            }
+        }
+    }
+    else if (in_symbolic_name == "nil")
+    {
+        out_value = C_value(C_value::E_type_msg);
+        return  true;
+    }
+
+    return  false;
+}
+
+T_type_definitions::E_type_kind
+T_type_definitions::get_defined_type_kind(const string   & type_name) const
+{
+   if (map_alias_type.find (type_name) != map_alias_type.end ())
+        return  E_type_alias;
+   if (map_const_value.find (type_name) != map_const_value.end ())
+        return  E_type_const;
+    if (map_struct_definition.find (type_name) != map_struct_definition.end ())
+        return  E_type_struct;
+    if (map_bitfield_definition.find (type_name) != map_bitfield_definition.end ())
+        return  E_type_bitfield;
+    if (map_enum_definition_representation.find (type_name) != map_enum_definition_representation.end ())
+        return  E_type_enum;
+    if (map_switch_definition.find (type_name) != map_switch_definition.end ())
+        return  E_type_switch;
+    if (map_function_definition.find (type_name) != map_function_definition.end ())
+        return  E_type_function;
+
+    return  E_type_none;
+}
+
+bool
+T_type_definitions::is_a_defined_type_name(const string   & type_name) const
+{
+    return  get_defined_type_kind(type_name) != E_type_none;
+}
+
+T_type_definitions::E_type_kind
+T_type_definitions::get_forward_type_kind(const string   & type_name) const
+{
+    T_map_forward_type::const_iterator  iter = map_forward_type.find (type_name);
+    if (iter != map_forward_type.end ())
+        return  iter->second;
+
+    return  E_type_none;
+}
+
+bool
+T_type_definitions::is_a_forward_type_name(const string   & type_name) const
+{
+    return  get_forward_type_kind(type_name) != E_type_none;
+}
+
+bool
+T_type_definitions::is_a_basic_type_name(const string   & type_name) const
+{
+    if ((type_name ==  "int8")  ||
+        (type_name == "uint8")  ||
+        (type_name ==  "int16") ||
+        (type_name == "uint16") ||
+        (type_name ==  "int24") ||
+        (type_name == "uint24") ||
+        (type_name ==  "int32") ||
+        (type_name == "uint32") ||
+        (type_name ==  "int40") ||
+        (type_name == "uint40") ||
+        (type_name ==  "int48") ||
+        (type_name == "uint48") ||
+        (type_name ==  "int64") ||
+//        (type_name == "uint64") ||
+        (type_name == "float32") ||
+        (type_name == "float64") ||
+//        (type_name == "bool8") ||
+//        (type_name == "bool16") ||
+//        (type_name == "bool32") ||
+        (type_name == "spare") ||
+        (type_name ==  "char") ||
+        (type_name == "schar") ||
+        (type_name == "uchar") ||
+        (type_name == "string") ||
+        (type_name == "string_nl") ||
+        (type_name == "raw") ||
+        (type_name == "subproto") ||
+        (type_name == "insproto"))
+    {
+        return  true;
+    }
+
+    long    bit_size = 0;
+    if ((strncmp(type_name.c_str(), "uint", 4) == 0) &&
+        (get_number(type_name.c_str()+4, &bit_size) == true) &&
+        (bit_size >   0) &&
+        (bit_size <  32))
+    {
+        /* bsew uintXX */
+        return  true;
+    }
+    if ((strncmp(type_name.c_str(), "int", 3) == 0) &&
+        (get_number(type_name.c_str()+3, &bit_size) == true) &&
+        (bit_size >   1) &&
+        (bit_size <  32))        // bsew limitation (byte_order)
+    {
+        /* bsew intXX */
+        return  true;
+    }
+
+    return  false;
+}
+
+bool
+T_type_definitions::is_a_type_name(const string   & type_name) const
+{
+    return  is_a_defined_type_name(type_name) ||
+            is_a_basic_type_name(type_name) ||
+            is_a_forward_type_name(type_name);
+}
+
+// 
+void             
+T_type_definitions::add_forward_declaration(const E_type_kind   type_kind,
+                                            const string      & type_name)
+{
+    M_FATAL_IF_EQ(type_kind, E_type_none);
+    M_FATAL_IF_EQ(type_kind, E_type_alias);
+    M_FATAL_IF_EQ(type_name, "");
+
+    const E_type_kind    existing_type_kind = get_defined_type_kind(type_name);
+    const E_type_kind    forward_type_kind  = get_forward_type_kind(type_name);
+
+    // Verify it already exist.
+    if ((existing_type_kind == type_kind) ||
+        (forward_type_kind == type_kind))
+        return;
+
+    // Verify it already exist with a different kind.
+    if (existing_type_kind != E_type_none)
+    {
+        M_FATAL_COMMENT ("A " << existing_type_kind << " type named " << type_name << " already exist (override will not work)");
+    }
+
+    if (forward_type_kind  != E_type_none)
+    {
+        M_FATAL_COMMENT ("A " << forward_type_kind << " type named " << type_name << " already declared (override will not work)");
+    }
+
+    // Add it.
+    map_forward_type[type_name] = type_kind;
+}
+                                  
+void
+T_type_definitions::could_define_new_type(const string      & type_name,
+                                          const E_type_kind   type_kind,
+                                          const E_override    must_override) const
+{
+    M_FATAL_IF_EQ(type_kind, E_type_none);
+    M_FATAL_IF_EQ(type_name, "");
+
+    {
+        const E_type_kind    forward_type_kind  = get_forward_type_kind(type_name);
+        if (forward_type_kind != E_type_none)
+        {
+            if (type_kind != forward_type_kind)
+            {
+                M_FATAL_COMMENT ("A " << forward_type_kind << " type named " << type_name << " already declared (override will not work)");
+            }
+
+            // ICIOA remove  (do not care)
+        }
+    }
+
+    const E_type_kind    existing_type_kind = get_defined_type_kind(type_name);
+
+    if (existing_type_kind == E_type_none)
+        return;
+
+    // A type with the given name already exist.
+
+    // Check that the already existent type has the same kind.
+    if (existing_type_kind != type_kind)
+    {
+        M_FATAL_COMMENT ("A " << existing_type_kind << " type named " << type_name << " already exist (override will not work)");
+    }
+
+    // Could NOT override alias since 
+    //  since alias could already have been be used (by build_field).
+    if (existing_type_kind == E_type_alias)
+    {
+        M_FATAL_COMMENT (type_kind << " " << type_name << " already exist (and override is forbidden for " << type_kind << ")");
+    }
+
+    // Could NOT override const since 
+    //  since const could already have been be used (by other const).
+    if (existing_type_kind == E_type_const)
+    {
+        M_FATAL_COMMENT (type_kind << " " << type_name << " already exist (and override is forbidden for " << type_kind << ")");
+    }
+
+    // Is override specified ?
+    if (must_override == E_override_no)
+    {
+        M_FATAL_COMMENT (type_kind << " " << type_name << " already exist (try override ?)");
+    }
+
+    // Could we have other problems on override ???
+    // Normally no.
+}
+
+ostream &  operator<< (ostream                          & os,
+                 const T_type_definitions::E_type_kind  & rhs)
+{
+    if (rhs == T_type_definitions::E_type_none)
+        os << "none";
+    else if (rhs == T_type_definitions::E_type_alias)
+        os << "alias";
+    else if (rhs == T_type_definitions::E_type_const)
+        os << "const";
+    else if (rhs == T_type_definitions::E_type_struct)
+        os << "struct";
+    else if (rhs == T_type_definitions::E_type_bitfield)
+        os << "bitfield";
+    else if (rhs == T_type_definitions::E_type_enum)
+        os << "enum";
+    else if (rhs == T_type_definitions::E_type_switch)
+        os << "switch";
+    else if (rhs == T_type_definitions::E_type_function)
+        os << "function";
+    else
+    {
+        M_FATAL_COMMENT("Unexpected value (" << (int)rhs << ") for T_type_definitions::E_type_kind");
+    }
+
+    return  os;
+}
diff --git a/plugins/epan/generic/T_type_definitions.h b/plugins/epan/generic/T_type_definitions.h
new file mode 100644
index 00000000000..e869a061689
--- /dev/null
+++ b/plugins/epan/generic/T_type_definitions.h
@@ -0,0 +1,719 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_type_definitions_h
+#define T_type_definitions_h
+
+//****************************************************************************
+// Includes.
+//****************************************************************************
+
+#include "C_value.h"
+#include "T_expression.h"
+
+#include <string>
+#include <map>
+#include <vector>
+
+using namespace std;
+
+
+//****************************************************************************
+// Override.
+//****************************************************************************
+
+enum E_override
+{
+    E_override_no,
+    E_override_yes
+};
+
+//*****************************************************************************
+// Identifier syntax.
+//*****************************************************************************
+
+bool    is_a_valid_identifier_name (const string   & var_name,
+                                    const char       also_authorized = '\0');
+
+#define is_a_valid_short_identifier_name    is_a_valid_identifier_name
+#define is_a_valid_short_variable_name      is_a_valid_short_identifier_name
+#define is_a_valid_type_name                is_a_valid_short_identifier_name
+
+#define is_a_valid_const_variable_name(NAME)  is_a_valid_identifier_name(NAME, ':')
+#define is_a_valid_long_variable_name(NAME)   is_a_valid_identifier_name(NAME, '.')
+
+//****************************************************************************
+// Aliases.
+//****************************************************************************
+
+// Alias name -> type name to be used instead
+typedef map<string,string>    T_map_alias_type;
+
+
+//****************************************************************************
+// Const.
+//****************************************************************************
+
+// Const name -> value
+typedef map<string,C_value>    T_map_const_value;
+
+
+//****************************************************************************
+// Field constraint.
+//****************************************************************************
+
+struct T_field_constraint
+{
+    C_value        min;
+    C_value        max;
+    C_value        equal;
+};
+
+//****************************************************************************
+// Field (for struct ...).
+//****************************************************************************
+
+struct T_field_type_name_base
+{
+    string         orig_type;          // original field type, only for trace
+
+    string         type;
+    string         name;
+
+    string         display_name;
+    string         filter_name;
+    string         extended_name;
+
+    const string &  get_display_name()  const  { return  display_name.empty()  ? name : display_name; }
+    const string &  get_filter_name()   const  { return  filter_name.empty()   ? name : filter_name; }
+    const string &  get_extended_name() const  { return  extended_name.empty() ? name : extended_name; }
+
+    // only for basic types (int, float, char) and enum
+    // NOT for struct ...
+    int            basic_type_bit_size;
+
+    // string/raw/subproto/insproto size or switch parameter
+    string         str_size_or_parameter;
+
+    //------------------------------------------------------------
+    // Pre treatment (raw data extraction)
+    //------------------------------------------------------------
+
+    // byte order
+    string         str_byte_order;
+
+    // decoder function name
+    string         str_decoder_function;
+
+    //------------------------------------------------------------
+    // Wireshark specific treatment
+    //------------------------------------------------------------
+
+    // subproto/insproto dissector name
+    string         str_dissector;
+
+    //------------------------------------------------------------
+    // Post treatment
+    //------------------------------------------------------------
+
+    // integer/float no_statement
+    C_value        no_statement;
+
+    // integer/float transform
+    C_value          transform_quantum;
+    C_value          transform_offset;
+    T_expression     transform_expression;
+    C_value::E_type  transform_expression_type;
+
+    // integer/float constraints
+    std::vector<T_field_constraint>    constraints;
+
+    // display
+    string         str_display;
+    string         str_display_expression;
+
+    // return true if no_statement or transform or constraints or display exist
+    bool    has_post_treatment() const;
+
+    //------------------------------------------------------------
+    //------------------------------------------------------------
+
+    T_field_type_name_base()
+        : basic_type_bit_size (-1)
+        , transform_expression_type(C_value::E_type_msg)  // not set
+    {
+    }
+};
+
+//****************************************************************************
+// Field (for struct ...).
+//****************************************************************************
+
+#include "scoped_copyable_ptr.h"
+struct T_enum_definition_representation;
+struct T_struct_definition;
+struct T_switch_definition;
+struct T_bitfield_definition;
+struct T_field_type_name;
+
+typedef bool    (*T_pf_frame_to_any)
+                     (const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & os_out,
+                            ostream               & os_err);
+
+typedef bool    (*T_pf_frame_to_field)(
+                         const T_type_definitions    & type_definitions,
+                               T_frame_data          & in_out_frame_data,
+                               T_interpret_data      & interpret_data,
+                         const T_field_type_name     & field_type_name,
+                         const string                & data_name,
+                         const string                & data_simple_name,
+                               ostream               & os_out,
+                               ostream               & os_err);
+
+struct T_field_type_name : public T_field_type_name_base
+{
+    bool                         must_forget;       // field immediately removed (for perf reasons)
+
+    enum E_output_directive
+    {
+        // Do NOT change values, directly used to change output level.
+        E_output_directive_hide = -1,
+        E_output_directive_none = 0,
+        E_output_directive_show = 1
+    };
+
+    E_output_directive           output_directive;
+
+    struct T_array
+    {
+        enum E_size_type
+        {
+            E_size_normal,
+            E_size_unknow_any,
+            E_size_unknow_at_least_1,
+        };
+
+        E_size_type        size_type;
+        T_expression       size_expression;
+    };
+    vector<T_array>              str_arrays;
+
+    bool                         A_is_a_variable;
+    T_expression                 new_expression;  // expression for variable, set, call
+    T_expression                 condition_expression;
+    T_expression                 return_expression;
+    vector<T_expression>         fct_parameters;
+    scoped_copyable_ptr<T_struct_definition>     P_sub_struct;      // struct fields or if/while bloc  
+//    vector<T_field_type_name>    sub_struct;      // struct fields or if/while bloc
+    vector<T_field_type_name>    sub_struct_2;    // else bloc
+    scoped_copyable_ptr<T_bitfield_definition>   P_bitfield_inline;    // inline bitfield
+    scoped_copyable_ptr<T_switch_definition>     P_switch_inline;      // inline switch
+
+    //
+    bool    is_an_array() const          { return  str_arrays.empty() == false; }
+    bool    is_a_variable() const        { return  A_is_a_variable; }
+
+    //
+    const T_expression  & get_var_expression() const { return  new_expression; }
+    const T_expression  & get_set_expression() const { return  new_expression; }
+    const T_expression  & get_condition_expression() const { return  condition_expression; }
+    const T_expression  & get_return_expression() const    { return  return_expression; }
+
+    // Because of transform (or ...), the resulting value could change.
+    bool    must_force_manage_as_biggest_float() const;
+    bool    must_force_manage_as_biggest_int() const;
+
+    // Output directive
+    E_output_directive     get_output_directive()    const { return  output_directive; }
+    int                    get_output_level_offset() const { return  output_directive; }
+    bool    must_hide() const    { return  output_directive == E_output_directive_hide; }
+    bool    must_show() const    { return  output_directive == E_output_directive_show; }
+
+    // Field external data.
+    int                          wsgd_field_idx;
+    // Should be intialized at the end of init.
+    // But can also be initialized during interpretation.
+    T_pf_frame_to_any                         pf_frame_to_any;
+    T_pf_frame_to_field                       pf_frame_to_field;
+    const T_enum_definition_representation  * P_type_enum_def;
+    const T_struct_definition               * P_type_struct_def;
+    const T_switch_definition               * P_type_switch_def;
+    const T_bitfield_definition             * P_type_bitfield_def;
+
+    T_field_type_name();
+};
+
+ostream &  operator<< (ostream & os, const T_field_type_name  & rhs);
+
+//****************************************************************************
+// Struct
+//****************************************************************************
+
+// A Struct is mainly an array of fields.
+typedef vector<T_field_type_name>                 T_struct_fields;
+
+struct T_struct_definition
+{
+    T_struct_fields    fields;
+    string             printf_args;
+#if 1
+    // This is absolutely NOT finished due to bug 2402.
+    int                field_struct_idx;
+
+    bool               is_a_field_struct() const  { return  field_struct_idx >= 0; }
+
+    T_struct_definition()
+        :field_struct_idx(-1)
+    {
+    }
+#endif
+};
+
+
+ostream &  operator<< (ostream & os, const T_struct_definition  & rhs);
+
+// Struct name -> struct definition
+typedef map<string,T_struct_definition>           T_map_struct_definition;
+
+//****************************************************************************
+// Bitfield
+//****************************************************************************
+
+struct T_bitfield_definition
+{
+    bool                   is_a_bitstream;
+    T_field_type_name      master_field;
+    T_struct_fields        fields_definition;
+
+    T_bitfield_definition()
+        :is_a_bitstream(false)
+    {
+    }
+};
+
+// Bitfield name -> struct definition
+typedef map<string,T_bitfield_definition>           T_map_bitfield_definition;
+
+//****************************************************************************
+// Enums
+//****************************************************************************
+
+struct T_enum_name_val
+{
+    string       name;     // symbolic name
+    long long    value;    // numeric value
+
+    T_enum_name_val () : value (0) {}
+};
+
+ostream &  operator<< (ostream & os, const T_enum_name_val  & rhs);
+
+// An Enum is an array of values (symbolic name + numeric value).
+typedef vector<T_enum_name_val>                   T_enum_definition;
+
+struct T_enum_definition_representation
+{
+    T_enum_definition    definition;    // array of values
+    size_t               bit_size;      // size in bits
+    bool                 is_signed;     // 
+    string               representation_type;
+    int                  wsgd_enum_values_idx;
+
+    bool    get_integer_value(const string     & symbolic_name,
+                                    long long  & integer_value) const;
+    const string &  get_symbolic_name(long long    integer_value) const;
+
+    T_enum_definition_representation ()
+        : bit_size (0),
+          is_signed (false),
+          wsgd_enum_values_idx (-1)
+    {}
+};
+
+ostream &  operator<< (ostream & os,
+                 const T_enum_definition_representation  & rhs);
+
+// Enum name -> enum definition representation
+typedef map<string,T_enum_definition_representation>    T_map_enum_definition_representation;
+
+
+//****************************************************************************
+// Switchs
+//****************************************************************************
+
+struct T_switch_case
+{
+    T_expression           case_expr;     // expression (if is_switch_expr)
+    C_value                case_value;    // value could be string, int, enum symbolic value
+    bool                   is_default_case;
+    T_struct_fields        fields;        // def
+
+    T_switch_case () : is_default_case (false) {}
+};
+
+ostream &  operator<< (ostream        & os,
+                 const T_switch_case  & rhs);
+
+// An switch_cases is an array of switch_case values
+typedef vector<T_switch_case>                   T_switch_cases;
+
+struct T_switch_definition
+{
+    bool                 is_switch_expr;       // for switch_expr
+    string               case_type;
+    T_switch_cases       switch_cases;
+
+    T_switch_definition()
+        : is_switch_expr(false)
+    {
+    }
+};
+
+ostream &  operator<< (ostream              & os,
+                 const T_switch_definition  & rhs);
+
+// Switch name -> switch definition representation
+typedef map<string,T_switch_definition>    T_map_switch_definition;
+
+//****************************************************************************
+// Functions
+//****************************************************************************
+
+enum E_parameter_direction
+{
+    E_parameter_in     = 1,
+    E_parameter_out    = 2,
+    E_parameter_in_out = 3
+};
+
+struct T_function_parameter : public T_field_type_name_base
+{
+    E_parameter_direction  direction;
+//    string                 type;
+//    string                 name;
+
+    bool                   has_default_value() const    { return  A_has_default_value; }
+    const C_value &        get_default_value() const    { return  A_default_value; }
+    void                   set_default_value(const C_value  & rhs); 
+
+    T_function_parameter()
+        :direction(E_parameter_in),
+         A_has_default_value(false)
+    {
+    }
+
+private:
+    bool                   A_has_default_value;
+    C_value                A_default_value;
+};
+
+void    check_function_parameter_value(
+                const T_type_definitions    & type_definitions,
+                const T_function_parameter  & function_parameter,
+                const C_value               & obj_value);
+
+ostream &  operator<< (ostream               & os,
+                 const T_function_parameter  & rhs);
+
+typedef vector<T_function_parameter>                   T_function_parameters;
+
+struct T_function_prototype_definition
+{
+    string                 return_type;
+
+    const T_function_parameters  & get_function_parameters() const { return  function_parameters; }
+    int                    get_nb_of_mandatory_parameters() const  { return  A_nb_of_mandatory_parameters; }
+    void                   add_function_parameter(const T_function_parameter  & function_parameter);
+
+    T_function_prototype_definition();
+
+private:
+    T_function_parameters  function_parameters;
+    int                    A_nb_of_mandatory_parameters;
+
+    friend ostream &  operator<< (ostream                          & os,
+                            const T_function_prototype_definition  & rhs);
+};
+
+struct T_library_definition;
+struct T_library_function_definition;
+
+struct T_function_definition : public T_function_prototype_definition
+{
+    T_struct_fields        fields;
+
+    T_library_definition  * P_library_def;
+    int                     idx_library_function_def;
+
+    T_function_definition()
+        : P_library_def(nullptr)
+        , idx_library_function_def(-1)
+    {
+    }
+};
+
+ostream &  operator<< (ostream                & os,
+                 const T_function_definition  & rhs);
+
+// Function name -> function definition representation
+typedef map<string,T_function_definition>    T_map_function_definition;
+
+//****************************************************************************
+// Plugin output
+//****************************************************************************
+
+#include "byte_interpret_plugin_output.h"
+
+struct T_plugin_output_definition
+{
+    std::string    library_name;
+    std::string    user_data;
+
+    T_byte_interpret_plugin_output_begin_cb              byte_interpret_plugin_output_begin_cb;
+    T_byte_interpret_plugin_output_value_integer_cb      byte_interpret_plugin_output_value_integer_cb;
+    T_byte_interpret_plugin_output_value_float_cb        byte_interpret_plugin_output_value_float_cb;
+    T_byte_interpret_plugin_output_value_string_cb       byte_interpret_plugin_output_value_string_cb;
+    T_byte_interpret_plugin_output_raw_data_cb           byte_interpret_plugin_output_raw_data_cb;
+    T_byte_interpret_plugin_output_group_begin_cb        byte_interpret_plugin_output_group_begin_cb;
+    T_byte_interpret_plugin_output_group_append_text_cb  byte_interpret_plugin_output_group_append_text_cb;
+    T_byte_interpret_plugin_output_group_end_cb          byte_interpret_plugin_output_group_end_cb;
+    T_byte_interpret_plugin_output_error_cb              byte_interpret_plugin_output_error_cb;
+    T_byte_interpret_plugin_output_missing_data_cb       byte_interpret_plugin_output_missing_data_cb;
+    T_byte_interpret_plugin_output_cmd_error_cb          byte_interpret_plugin_output_cmd_error_cb;
+    T_byte_interpret_plugin_output_cmd_print_cb          byte_interpret_plugin_output_cmd_print_cb;
+
+    T_byte_interpret_plugin_output_context               context;
+};
+
+ostream &  operator<< (ostream                     & os,
+                 const T_plugin_output_definition  & rhs);
+
+typedef vector<T_plugin_output_definition>    T_vector_plugin_output_definition;
+
+//****************************************************************************
+// Library
+//****************************************************************************
+
+struct T_library_function_definition
+{
+    std::string    name;
+    void *         funptr;
+
+    T_library_function_definition()
+        : funptr(nullptr)
+    {
+    }
+};
+
+struct T_library_definition
+{
+    std::string    full_name;
+    void *         DLLib_handle;
+
+    vector<T_library_function_definition>  library_functions;
+
+    T_library_definition()
+        : DLLib_handle(nullptr)
+    {
+    }
+};
+
+ostream &  operator<< (ostream                     & os,
+                 const T_library_definition        & rhs);
+
+// library name -> library definition representation
+typedef map<string,T_library_definition>    T_map_library_definition;
+
+//****************************************************************************
+// T_type_definitions
+//****************************************************************************
+
+struct T_type_definitions
+{
+    enum E_type_kind
+    {
+        E_type_none,
+        E_type_alias,
+        E_type_const,
+        E_type_struct,
+        E_type_bitfield,
+        E_type_enum,
+        E_type_switch,
+        E_type_function
+    };
+
+    // trailer size: used only for [*] [+] (*)
+    int                                   trailer_sizeof_bits;
+
+    typedef map<string,E_type_kind>     T_map_forward_type;
+    T_map_forward_type                    map_forward_type;
+
+    T_map_alias_type                      map_alias_type;
+    T_map_const_value                     map_const_value;
+    T_map_struct_definition               map_struct_definition;
+    T_map_bitfield_definition             map_bitfield_definition;
+    T_map_enum_definition_representation  map_enum_definition_representation;
+    T_map_switch_definition               map_switch_definition;
+    T_map_function_definition             map_function_definition;
+
+    T_vector_plugin_output_definition     vector_plugin_output_definition;
+    T_map_library_definition              map_library_definition;
+
+    typedef vector<string>              T_vector_dissector_name;
+    T_vector_dissector_name               vector_subdissector_name;
+
+    // 
+    void             add_alias(const string      & new_type,
+                               const string      & already_existent_type,
+                               const E_override    must_override = E_override_no);
+
+    //
+    void    set_field_type(T_field_type_name_base  & field,
+                     const string             & type_param) const;
+    void    set_field_name(T_field_type_name_base  & field,
+                     const string             & name_param) const;
+
+    void    set_field_condition_expression(T_field_type_name_base  & field,
+                     const string             & name_param) const;
+
+    void    set_field_type_size_or_parameter(T_field_type_name_base  & field,
+                               const string             & parameter_param) const;
+
+    void    set_field_no_statement(T_field_type_name_base  & field,
+                                  const string             & no_statement_param) const;
+
+    void    set_field_transform_quantum(T_field_type_name_base  & field,
+                                  const string             & quantum_param) const;
+    void    set_field_transform_offset (T_field_type_name_base  & field,
+                                  const string             & offset_param) const;
+
+    void    set_field_transform_expression_integer (T_field_type_name_base  & field,
+                                      const string             & expr_param) const;
+    void    set_field_transform_expression_float (T_field_type_name_base  & field,
+                                      const string             & expr_param) const;
+
+    void    add_field_constraint_min_max(T_field_type_name_base  & field,
+                                   const string                  & min_param,
+                                   const string                  & max_param) const;
+    void    add_field_constraint_min  (T_field_type_name_base  & field,
+                                 const string             & val_param) const;
+    void    add_field_constraint_max  (T_field_type_name_base  & field,
+                                 const string             & val_param) const;
+    void    add_field_constraint_equal(T_field_type_name_base  & field,
+                                 const string             & val_param) const;
+    void    prepend_field_constraint_min_max(T_field_type_name_base  & field,
+                                   const string                  & min_param,
+                                   const string                  & max_param) const;
+    void    prepend_field_constraint_min  (T_field_type_name_base  & field,
+                                 const string             & val_param) const;
+    void    prepend_field_constraint_max  (T_field_type_name_base  & field,
+                                 const string             & val_param) const;
+    void    prepend_field_constraint_equal(T_field_type_name_base  & field,
+                                 const string             & val_param) const;
+
+    void    set_field_display           (T_field_type_name_base  & field,
+                                   const string             & val_param) const;
+    void    set_field_display_expression(T_field_type_name_base  & field,
+                                   const string             & val_param) const;
+
+    void    set_field_subdissector      (T_field_type_name_base  & field,
+                                   const string             & val_param) const;
+    void    add_subdissector(const string             & val_param);
+
+    void    set_field_decoder           (T_field_type_name_base  & field,
+                                   const string                  & val_param) const;
+
+    void    set_field_byte_order        (T_field_type_name_base  & field,
+                                   const string                  & val_param) const;
+
+    // 
+    const T_enum_definition_representation  * get_P_enum    (const string      & type_name) const;
+          bool                                is_an_enum    (const string      & type_name) const;
+
+    const T_struct_definition               * get_P_struct  (const string      & type_name) const;
+          T_struct_definition               * get_P_struct  (const string      & type_name);
+          bool                                is_a_struct   (const string      & type_name) const;
+
+    const T_bitfield_definition             * get_P_bitfield(const string      & type_name) const;
+          bool                                is_a_bitfield (const string      & type_name) const;
+
+    const T_switch_definition               & get_switch    (const string      & type_name) const;
+    const T_switch_definition               * get_P_switch  (const string      & type_name) const;
+          bool                                is_a_switch   (const string      & type_name) const;
+          bool                                is_a_switch_value(const string      & type_name) const;
+          bool                                is_a_switch_expr (const string      & type_name) const;
+
+    const T_function_definition             & get_function  (const string      & type_name) const;
+    const T_function_definition             * get_P_function(const string      & type_name) const;
+          bool                                is_a_function (const string      & type_name) const;
+
+
+    // Enum  : get integer value from symbolic value (<enum type>::<enum symbolic value>).
+    // Const : get value 
+    // Returns false if nothing found.
+    bool    get_type_value (const string   & in_symbolic_name,
+                                  C_value  & out_value) const;
+
+    // Search recursively into the map of aliases to find the final type to
+    //  be used.
+    // If nothing found, returns orig_type.
+    const string &   get_final_type (const string  & orig_type) const;
+
+    // NB: returns none for basic types (uint8, float32, string ...).
+    E_type_kind    get_defined_type_kind(const string   & type_name) const;
+    bool          is_a_defined_type_name(const string   & type_name) const;
+
+    E_type_kind    get_forward_type_kind(const string   & type_name) const;
+    bool          is_a_forward_type_name(const string   & type_name) const;
+
+    // returns true for basic types (uint8, float32, string ...).
+    bool          is_a_basic_type_name(const string   & type_name) const;
+
+    // returns true for any valid type and forward declaration.
+    bool          is_a_type_name(const string   & type_name) const;
+
+
+    // 
+    void             add_forward_declaration(const E_type_kind   type_kind,
+                                             const string      & type_name);
+                                  
+    // Triggers fatal if could NOT define a new type.
+    // NB: must be called only when you are going to create the corresponding type.
+    // NB: no fatal for basic types (uint8, float32, string ...) !!!
+    void    could_define_new_type(const string      & type_name,
+                                  const E_type_kind   type_kind,
+                                  const E_override    must_override = E_override_no) const;
+
+    T_type_definitions();
+};
+
+ostream &  operator<< (ostream                          & os,
+                 const T_type_definitions::E_type_kind  & rhs);
+
+ostream &  operator<< (ostream             & os,
+                 const T_type_definitions  & rhs);
+
+
+
+#endif /* T_type_definitions_h */
diff --git a/plugins/epan/generic/T_type_definitions_build_interface.h b/plugins/epan/generic/T_type_definitions_build_interface.h
new file mode 100644
index 00000000000..a016332d015
--- /dev/null
+++ b/plugins/epan/generic/T_type_definitions_build_interface.h
@@ -0,0 +1,462 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef T_type_definitions_build_interface_h
+#define T_type_definitions_build_interface_h
+
+//****************************************************************************
+// Includes.
+//****************************************************************************
+
+NOT USED
+
+//****************************************************************************
+// Global
+//****************************************************************************
+
+struct T_type_definitions;
+struct T_struct_fields;
+struct T_field_type_name;
+
+//****************************************************************************
+// Aliases.
+//****************************************************************************
+
+void    type_definitions_add_alias(T_type_definitions  * P_type_definitions, 
+                                   const char          * new_type_name, 
+                                   const char          * already_existent_type);
+
+//****************************************************************************
+// Field (for struct ...).
+//****************************************************************************
+
+struct T_field_type_name_base
+{
+    string         orig_type;          // original field type, only for trace
+
+    string         type;
+    string         name;
+
+    // string/raw/subproto/insproto size or switch parameter
+    string         str_size_or_parameter;
+
+    // integer/float
+    C_value        transform_quantum;
+    C_value        transform_offset;
+
+    C_value        constraint_min;
+    C_value        constraint_max;
+    C_value        constraint_equal;
+
+    string         str_display;
+    string         str_display_expression;
+};
+
+//****************************************************************************
+// Field (for struct ...).
+//****************************************************************************
+
+#include "scoped_copyable_ptr.h"
+struct T_struct_definition;
+struct T_bitfield_definition;
+
+struct T_field_type_name : public T_field_type_name_base
+{
+#if 0
+    // Qu'est-ce que ca change ?
+    // -> interpretation lors du build (donc check)
+    // -> gain de vitesse a l'interpretation ? combien ? comment est-ce que je peux mesurer ?
+    // -> meilleur code car centralisation du type
+    // -> code moins ouvert car centralisation du type
+    // -> code suivant la "classe" :
+    //    - print (print, debug_print, error, fatal)
+    //    - donnee
+    //    - ???
+    // -> implique un nouveau champ
+    enum E_type
+    {
+        K_type_cmd    = 0x1000,
+        K_type_print  = 0x2000,
+        K_type_ctrl   = 0x4000,
+        K_type_data   = 0x8000,
+        K_type_field  = 0x10000,
+
+        E_type_cmd_debug_print          = K_type_cmd & K_type_print + 1,
+        E_type_cmd_print                ,
+        E_type_cmd_error                ,
+        E_type_cmd_fatal                ,
+        E_type_cmd_output               = K_type_cmd + 1,
+        E_type_cmd_byte_order           ,
+        E_type_cmd_save_position        ,
+        E_type_cmd_goto_position        ,
+        E_type_cmd_move_position        ,
+        E_type_cmd_check_eof_distance   ,
+        E_type_ctrl_if                  = K_type_ctrl & K_type_data + 1,
+        E_type_ctrl_while               ,
+        E_type_ctrl_do_while            ,
+        E_type_ctrl_loop_size           ,
+        E_type_ctrl_return              = K_type_ctrl + 1,
+        E_type_ctrl_break               ,
+        E_type_ctrl_continue            ,
+        E_type_var_declare,                    // pas fait
+        E_type_var_assign,                    // pas fait
+
+        E_type_field_switch             = K_type_field + K_type_data +  1,
+        E_type_field_struct             ,
+
+        E_type_field_enum               ,
+        E_type_field_string             ,
+        E_type_field_string_nl          ,
+        E_type_field_raw                ,
+        E_type_field_subproto           ,
+        E_type_field_insproto           ,
+
+        E_type_field_struct_inline      ,
+        E_type_field_basic              ,
+        E_type_none                     = 0,
+    };
+#endif
+
+    enum E_output_directive
+    {
+        // Do NOT change values, directly used to change output level.
+        E_output_directive_hide = -1,
+        E_output_directive_none = 0,
+        E_output_directive_display = 1
+    };
+
+    E_output_directive           output_directive;
+    vector<string>               str_arrays;
+
+    string                       new_expression;  // expression for variable, set, call
+    vector<string>               fct_parameters;
+    scoped_copyable_ptr<T_struct_definition>     P_sub_struct;      // struct fields or if/while bloc  
+//    vector<T_field_type_name>    sub_struct;      // struct fields or if/while bloc
+    vector<T_field_type_name>    sub_struct_2;    // else bloc
+    scoped_copyable_ptr<T_bitfield_definition>   P_bitfield;
+
+    //
+    bool    is_an_array() const          { return  str_arrays.empty() == false; }
+    bool    is_a_variable() const        { return  (new_expression.empty() == false) && (type != "set"); }
+
+    //
+    const string  & get_var_expression() const { return  new_expression; }
+    const string  & get_set_expression() const { return  new_expression; }
+
+    // Because of transform (or ...), the resulting value could change.
+    bool    must_force_manage_as_biggest_float() const;
+    bool    must_force_manage_as_biggest_int() const;
+
+    // Output directive
+    bool    must_hide() const       { return  output_directive == E_output_directive_hide; }
+    bool    must_display() const    { return  output_directive == E_output_directive_display; }
+
+    // Field external data.
+    int                          wsgd_field_idx;
+
+    
+};
+
+struct T_field_type_name;
+
+T_field_type_name *  type_definitions_add_field(T_type_definitions  * P_type_definitions,
+                                                T_struct_fields     * P_struct_fields);
+
+//****************************************************************************
+// Struct
+//****************************************************************************
+
+struct T_struct_definition;
+
+T_struct_definition *  type_definitions_create_struct(T_type_definitions  * P_type_definitions, 
+                                                      const char          * new_type_name);
+
+void    type_definitions_struct_set_printf_args(T_type_definitions  * P_type_definitions,
+                                                T_struct_definition * P_struct_definition,
+                                          const char                * printf_args);
+
+void    type_definitions_struct_valid(T_type_definitions  * P_type_definitions,
+                                      T_struct_definition * P_struct_definition);
+
+T_struct_fields *  type_definitions_struct_get_fields(T_type_definitions  * P_type_definitions,
+                                                      T_struct_definition * P_struct_definition);
+
+
+//****************************************************************************
+// Bitfield
+//****************************************************************************
+
+struct T_bitfield_definition;
+struct T_bitstream_definition;
+
+
+T_bitfield_definition *  type_definitions_create_bitfield(T_type_definitions  * P_type_definitions, 
+                                                        const char          * new_type_name);
+T_bitstream_definition *  type_definitions_create_bitstream(T_type_definitions  * P_type_definitions, 
+                                                        const char          * new_type_name);
+
+void    type_definitions_bitfield_set_byte_size(T_type_definitions     * P_type_definitions,
+                                                T_bitfield_definition  * P_bitfield_definition,
+                                          const int                      byte_size);
+void    type_definitions_bitstream_set_byte_size(T_type_definitions     * P_type_definitions,
+                                                T_bitstream_definition  * P_bitstream_definition,
+                                          const int                      byte_size);
+
+void    type_definitions_bitfield_valid(T_type_definitions  * P_type_definitions,
+                                      T_bitfield_definition * P_bitfield_definition);
+void    type_definitions_bitstream_valid(T_type_definitions  * P_type_definitions,
+                                      T_bitstream_definition * P_bitstream_definition);
+
+T_struct_fields *  type_definitions_bitfield_get_fields(T_type_definitions  * P_type_definitions,
+                                                      T_bitfield_definition * P_bitfield_definition);
+T_struct_fields *  type_definitions_bitstream_get_fields(T_type_definitions  * P_type_definitions,
+                                                      T_bitstream_definition * P_bitstream_definition);
+
+
+
+//****************************************************************************
+// Enums
+//****************************************************************************
+
+struct T_enum_name_val
+{
+    string       name;     // symbolic name
+    long long    value;    // numeric value
+
+    T_enum_name_val () : value (0) {}
+};
+
+ostream &  operator<< (ostream & os, const T_enum_name_val  & rhs);
+
+// An Enum is an array of values (symbolic name + numeric value).
+typedef vector<T_enum_name_val>                   T_enum_definition;
+
+struct T_enum_definition_representation
+{
+    T_enum_definition    definition;    // array of values
+    size_t               bit_size;      // size in bits
+    bool                 is_signed;     // 
+    string               representation_type;
+    int                  wsgd_enum_values_idx;
+
+    bool    get_integer_value(const string     & symbolic_name,
+                                    long long  & integer_value) const;
+    const string &  get_symbolic_name(long long    integer_value) const;
+
+    T_enum_definition_representation ()
+        : bit_size (0),
+          is_signed (false),
+          wsgd_enum_values_idx (-1)
+    {}
+};
+
+ostream &  operator<< (ostream & os,
+                 const T_enum_definition_representation  & rhs);
+
+// Enum name -> enum definition representation
+typedef map<string,T_enum_definition_representation>    T_map_enum_definition_representation;
+
+
+//****************************************************************************
+// Switchs
+//****************************************************************************
+
+struct T_switch_case_value
+{
+    C_value                case_value;   // value could be string, int, enum symbolic value
+    bool                   is_default_case;
+    T_struct_fields        fields;        // def
+
+    T_switch_case_value () : is_default_case (false) {}
+};
+
+ostream &  operator<< (ostream              & os,
+                 const T_switch_case_value  & rhs);
+
+// An switch_case is an array of switch_case values
+typedef vector<T_switch_case_value>                   T_switch_case;
+
+struct T_switch_definition
+{
+    string               case_type;
+    T_switch_case        switch_case;
+};
+
+ostream &  operator<< (ostream              & os,
+                 const T_switch_definition  & rhs);
+
+// Switch name -> switch definition representation
+typedef map<string,T_switch_definition>    T_map_switch_definition;
+
+//****************************************************************************
+// Functions
+//****************************************************************************
+
+enum E_parameter_direction
+{
+    E_parameter_in     = 1,
+    E_parameter_out    = 2,
+    E_parameter_in_out = 3
+};
+
+struct T_function_parameter : public T_field_type_name_base
+{
+    E_parameter_direction  direction;
+//    string                 type;
+//    string                 name;
+};
+
+ostream &  operator<< (ostream               & os,
+                 const T_function_parameter  & rhs);
+
+typedef vector<T_function_parameter>                   T_function_parameters;
+
+struct T_function_definition
+{
+    string                 return_type;
+    T_function_parameters  function_parameters;
+    T_struct_fields        fields;
+};
+
+ostream &  operator<< (ostream                & os,
+                 const T_function_definition  & rhs);
+
+// Function name -> function definition representation
+typedef map<string,T_function_definition>    T_map_function_definition;
+
+//****************************************************************************
+// T_type_definitions
+//****************************************************************************
+
+struct T_type_definitions
+{
+    enum E_type_kind
+    {
+        E_type_none,
+        E_type_alias,
+        E_type_struct,
+        E_type_bitfield,
+        E_type_enum,
+        E_type_switch,
+        E_type_function
+    };
+
+    typedef map<string,E_type_kind>     T_map_forward_type;
+    T_map_forward_type                    map_forward_type;
+
+    T_map_alias_type                      map_alias_type;
+    T_map_struct_definition               map_struct_definition;
+    T_map_bitfield_definition             map_bitfield_definition;
+    T_map_enum_definition_representation  map_enum_definition_representation;
+    T_map_switch_definition               map_switch_definition;
+    T_map_function_definition             map_function_definition;
+
+    // 
+    void             add_alias(const string      & new_type,
+                               const string      & already_existent_type,
+                               const E_override    must_override = E_override_no);
+
+    //
+    void    set_field_type(T_field_type_name_base  & field,
+                     const string             & type_param) const;
+    void    set_field_name(T_field_type_name_base  & field,
+                     const string             & name_param) const;
+
+    void    set_field_type_size_or_parameter(T_field_type_name_base  & field,
+                               const string             & parameter_param) const;
+
+    void    set_field_transform_quantum(T_field_type_name_base  & field,
+                                  const string             & quantum_param) const;
+    void    set_field_transform_offset (T_field_type_name_base  & field,
+                                  const string             & offset_param) const;
+
+    void    set_field_constraint_min  (T_field_type_name_base  & field,
+                                 const string             & val_param) const;
+    void    set_field_constraint_max  (T_field_type_name_base  & field,
+                                 const string             & val_param) const;
+    void    set_field_constraint_equal(T_field_type_name_base  & field,
+                                 const string             & val_param) const;
+
+    void    set_field_display           (T_field_type_name_base  & field,
+                                   const string             & val_param) const;
+    void    set_field_display_expression(T_field_type_name_base  & field,
+                                   const string             & val_param) const;
+
+    // 
+    const T_enum_definition_representation  * get_P_enum    (const string      & type_name) const;
+          bool                                is_an_enum    (const string      & type_name) const;
+
+    const T_struct_definition               * get_P_struct  (const string      & type_name) const;
+          T_struct_definition               * get_P_struct  (const string      & type_name);
+          bool                                is_a_struct   (const string      & type_name) const;
+
+    const T_bitfield_definition             * get_P_bitfield(const string      & type_name) const;
+
+    const T_switch_definition               & get_switch    (const string      & type_name) const;
+    const T_switch_definition               * get_P_switch  (const string      & type_name) const;
+          bool                                is_a_switch   (const string      & type_name) const;
+
+    const T_function_definition             & get_function  (const string      & type_name) const;
+    const T_function_definition             * get_P_function(const string      & type_name) const;
+
+
+    // Enum : get integer value from symbolic value (<enum type>::<enum symbolic value>).
+    // Returns false if nothing found.
+    bool    get_type_value (const string   & in_symbolic_name,
+                                  C_value  & out_value) const;
+
+    // Search recursively into the map of aliases to find the final type to
+    //  be used.
+    // If nothing found, returns orig_type.
+    const string &   get_final_type (const string  & orig_type) const;
+
+    // NB: returns none for basic types (uint8, float32, string ...).
+    E_type_kind    get_defined_type_kind(const string   & type_name) const;
+    bool          is_a_defined_type_name(const string   & type_name) const;
+
+    E_type_kind    get_forward_type_kind(const string   & type_name) const;
+    bool          is_a_forward_type_name(const string   & type_name) const;
+
+    // returns true for basic types (uint8, float32, string ...).
+    bool          is_a_basic_type_name(const string   & type_name) const;
+
+    // returns true for any valid type and forward declaration.
+    bool          is_a_type_name(const string   & type_name) const;
+
+
+    // 
+    void             add_forward_declaration(const E_type_kind   type_kind,
+                                             const string      & type_name);
+                                  
+    // Triggers fatal if could NOT define a new type.
+    // NB: must be called only when you are going to create the corresponding type.
+    // NB: no fatal for basic types (uint8, float32, string ...) !!!
+    void    could_define_new_type(const string      & type_name,
+                                  const E_type_kind   type_kind,
+                                  const E_override    must_override = E_override_no) const;
+};
+
+ostream &  operator<< (ostream                          & os,
+                 const T_type_definitions::E_type_kind  & rhs);
+
+ostream &  operator<< (ostream             & os,
+                 const T_type_definitions  & rhs);
+
+
+
+#endif /* T_type_definitions_build_interface_h */
diff --git a/plugins/epan/generic/byte_interpret.cpp b/plugins/epan/generic/byte_interpret.cpp
new file mode 100644
index 00000000000..60b844a100e
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret.cpp
@@ -0,0 +1,6575 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+// Necessary for windows pre-compiled headers.
+// At the end, does NOT work : missing functions at link time
+// After other includes, does NOT work : does NOT compile
+#include "precomp.h"
+
+#include <cstdio>
+#include <cerrno>
+#include <cassert>
+#include <iostream>
+#include <string>
+#include <map>
+#include <vector>
+#include <queue>
+#include <fstream>
+#include <sstream>
+#include <algorithm>
+using namespace std;
+
+#include "C_setlocale_numeric_C_guard.h"
+#include "C_value.h"
+#include "byte_interpret.h"
+#include "byte_interpret_common.h"
+#include "byte_interpret_compute_expression.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret_build_types.h"
+#include "byte_interpret_build_types_read_token.h"
+#include "byte_interpret_builder.h"
+#include "F_common_print.h"
+#include "T_interpret_data.h"
+#include "T_frame_data_write.h"
+#include "T_expression.h"
+
+
+//*****************************************************************************
+//*****************************************************************************
+
+#define  K_ATTRIBUTE_SEPARATOR  "."
+
+
+//****************************************************************************
+// Exceptions
+//****************************************************************************
+
+// A normal exception, ie does not correspond to an error
+class C_byte_interpret_exception_normal : public C_byte_interpret_exception
+{
+public:
+    C_byte_interpret_exception_normal(
+                         const char                        * file_name,
+                               int                           file_line,
+                               E_byte_interpret_exception    bie,
+                         const std::string                 & str)
+        :C_byte_interpret_exception(file_name, file_line, bie, str)
+    {
+    }
+    C_byte_interpret_exception_normal()
+        :C_byte_interpret_exception(M_WHERE, E_byte_interpret_exception_fatal, "NOT initialized exception explanation")
+    {
+    }
+
+    ~C_byte_interpret_exception_normal() throw() { }
+};
+
+// A normal exception throwed on break/continue command
+class C_byte_interpret_exception_loop : public C_byte_interpret_exception_normal
+{
+public:
+    C_byte_interpret_exception_loop(
+                         const char                        * file_name,
+                               int                           file_line,
+                               E_byte_interpret_exception    bie,
+                         const std::string                 & str)
+        :C_byte_interpret_exception_normal(file_name, file_line, bie, str)
+    {
+    }
+    C_byte_interpret_exception_loop()
+        :C_byte_interpret_exception_normal(M_WHERE, E_byte_interpret_exception_fatal, "NOT initialized exception explanation")
+    {
+    }
+
+    ~C_byte_interpret_exception_loop() throw() { }
+};
+
+// A normal exception throwed on return command
+class C_byte_interpret_exception_return : public C_byte_interpret_exception_normal
+{
+public:
+    C_byte_interpret_exception_return(
+                         const char                        * file_name,
+                               int                           file_line,
+                               E_byte_interpret_exception    bie,
+                         const std::string                 & str,
+                         const C_value                     & returned_value_param)
+        :C_byte_interpret_exception_normal(file_name, file_line, bie, str),
+         is_returned_value_set(true),
+         returned_value(returned_value_param)
+    {
+    }
+    C_byte_interpret_exception_return(
+                         const char                        * file_name,
+                               int                           file_line,
+                               E_byte_interpret_exception    bie,
+                         const std::string                 & str)
+        :C_byte_interpret_exception_normal(file_name, file_line, bie, str),
+         is_returned_value_set(false)
+    {
+    }
+    C_byte_interpret_exception_return()
+        :C_byte_interpret_exception_normal(M_WHERE, E_byte_interpret_exception_fatal, "NOT initialized exception explanation"),
+         is_returned_value_set(false)
+    {
+    }
+
+    ~C_byte_interpret_exception_return() throw() { }
+
+    bool       is_returned_value_set;
+    C_value    returned_value;
+};
+
+
+//*****************************************************************************
+// ----------------------------------------------------------------------------
+// Format :
+// <value>
+// <value> could be :
+//   <int_value>
+//   <enum_value>                           NOT IMPLEMENTED
+//   <variable_value>
+//*****************************************************************************
+
+E_return_code    get_complex_variable_integer_value (
+                                        const T_interpret_data  & interpret_data,
+                                        const string            & value_str,
+                                              long long         & value_int)
+{
+    if (get_number (value_str.c_str (), value_int))
+    {
+    }
+    else if (interpret_data.get_int_value_of_read_variable (
+                                           value_str, value_int) == false)
+    {
+        return  E_rc_not_integer;
+    }
+
+    return  E_rc_ok;
+}
+
+//*****************************************************************************
+// ----------------------------------------------------------------------------
+// Format :
+// <left_part><separator_left><value_str><separator_right>
+//*****************************************************************************
+
+E_return_code    decompose_type_sep_value_sep (
+                        const T_type_definitions  & type_definitions,
+                              T_interpret_data    & interpret_data,
+                        const string              & orig_type,
+                        const char                  separator_left,
+                        const char                  separator_right,
+                              string              & left_part,
+                              string              & value_str,
+                              long long           & value_int)
+{
+    E_return_code  rc = decompose_type_sep_value_sep (orig_type,
+                                                      separator_left,
+                                                      separator_right,
+                                                      left_part,
+                                                      value_str);
+    if (rc != E_rc_ok)
+        return  rc;
+
+    C_value    value = compute_expression_no_io(type_definitions, interpret_data, value_str);
+
+    if (value.get_type () != C_value::E_type_integer)
+        return  E_rc_not_integer;
+
+    value_int = value.get_int ();
+    return  E_rc_ok;
+}
+
+//*****************************************************************************
+// ----------------------------------------------------------------------------
+// Returns :
+// <array_name>[<idx>]
+// OR if <array_name> is <begin_array_name>[...][...][...]
+//  returns :
+// <begin_array_name>[<idx>][...][...][...] 
+//*****************************************************************************
+
+string  get_array_idx_name (const string  & array_name,
+                            const int       idx)
+{
+    if ((array_name.empty ()) ||
+        (array_name[array_name.size () - 1] != ']'))
+        return  array_name + "[" + get_string (idx) + "]";
+
+    // array_name already contains one or more sequence [ ]
+    // Must put [<idx>] at the 1st place of this sequence.
+
+    // Search the beginning of the sequence [ ].
+    const char  * P_begin = array_name.c_str ();
+    const char  * P_current = P_begin + array_name.size ();
+
+    while ((P_current > P_begin) && (*--P_current == ']'))
+    {
+        while ((P_current > P_begin) && (*--P_current != '['))
+        {
+        }
+        M_ASSERT (*P_current == '[');
+    }
+
+    // Put P_current on the 1st [ of the sequence [ ].
+    ++P_current;
+
+    return  array_name.substr (0, P_current - P_begin) +
+            "[" + get_string (idx) + "]" +
+            string (P_current);
+}
+
+//*****************************************************************************
+// size_expression_to_int
+//*****************************************************************************
+
+long    size_expression_to_int(   const T_type_definitions  & type_definitions,
+                                        T_interpret_data    & interpret_data,
+                                  const string              & str_size)
+{
+    if (str_size == "")    // forbidden for raw/subproto/insproto
+        return  0;
+
+    if (str_size == "*")   // forbidden for string...
+        return  0;
+
+    // Compute the string size.
+    const C_value    value = compute_expression_no_io(type_definitions, interpret_data, str_size);
+
+    if (value.get_type () != C_value::E_type_integer)
+    {
+        // Error trace/display done by caller.
+        return  -1;
+    }
+
+    return  static_cast<long>(value.get_int ());
+}
+
+//*****************************************************************************
+// ----------------------------------------------------------------------------
+// Format :
+// <final_simple_type>(<discriminant>)
+// NB: <discriminant> is :
+//     - an integer or
+//     - a string or
+//     - the name of the variable which contains the data
+//*****************************************************************************
+
+bool    is_a_switch_value (const T_type_definitions  & type_definitions,
+                           const string              & orig_type,
+                                 string              & final_simple_type,
+                                 string              & discriminant)
+{
+    if (decompose_type_sep_value_sep (orig_type, '(', ')',
+                                      final_simple_type,
+                                      discriminant) != E_rc_ok)
+    {
+        return false;
+    }
+
+    // reproductible fails without this line
+    final_simple_type = type_definitions.get_final_type (final_simple_type);
+
+    return  type_definitions.map_switch_definition.find (final_simple_type) !=
+            type_definitions.map_switch_definition.end ();
+}
+
+//*****************************************************************************
+// return the symbolic_name of an <enum_value> of <orig_type> enum type.
+// return "" if :
+// - <orig_type> is NOT an enum
+// - <enum_value> is NOT found
+// NB: <enum_value> could already be a symbolic value
+// NB: take care of aliases
+//*****************************************************************************
+
+string  get_enum_symbolic_name (const T_type_definitions  & type_definitions,
+                                const string              & orig_type,
+                                const string              & enum_value)
+{
+    const T_enum_definition_representation  * P_enum = type_definitions.get_P_enum(orig_type);
+    if (P_enum == nullptr)
+        return  "";
+
+    const T_enum_definition  & enum_def = P_enum->definition;
+
+    for (T_enum_definition::const_iterator  iter  = enum_def.begin ();
+                                            iter != enum_def.end ();
+                                          ++iter)
+    {
+        if ((enum_value == iter->name) ||
+            (enum_value == get_string (iter->value)))
+            return  iter->name;
+    }
+
+    return  "";
+}
+string  get_enum_symbolic_name (const T_type_definitions  & type_definitions,
+                                const string              & orig_type,
+                                const long long             enum_value)
+{
+    return  get_enum_symbolic_name (type_definitions,
+                                    orig_type,
+                                    get_string (enum_value));
+}
+
+// ICIOA a revoir ?
+void    promote_enum_symbolic_name (const T_type_definitions  & type_definitions,
+                                    const string              & orig_type,
+                                          C_value             & enum_value)
+{
+    const T_enum_definition_representation  * P_enum_def_rep = type_definitions.get_P_enum(orig_type);
+    if (P_enum_def_rep == nullptr)
+        return;
+
+    const T_enum_definition  & enum_def = P_enum_def_rep->definition;
+
+    if (enum_value.get_type() == C_value::E_type_string)
+    {
+        for (T_enum_definition::const_iterator  iter  = enum_def.begin ();
+                                                iter != enum_def.end ();
+                                              ++iter)
+        {
+            if ((enum_value.as_string() == iter->name) ||
+                (enum_value.as_string() == get_string (iter->value)))
+            {
+                enum_value = C_value(iter->value);
+                enum_value.set_str(iter->name);
+                return;
+            }
+        }
+    }
+    else if (enum_value.get_type() == C_value::E_type_integer)
+    {
+        for (T_enum_definition::const_iterator  iter  = enum_def.begin ();
+                                                iter != enum_def.end ();
+                                              ++iter)
+        {
+            if (enum_value.get_int() == iter->value)
+            {
+                enum_value = C_value(iter->value);
+                enum_value.set_str(iter->name);
+                return;
+            }
+        }
+    }
+
+    return;
+}
+
+//*****************************************************************************
+// printf_args_to_string ******************************************************
+//*****************************************************************************
+
+C_value    printf_args_to_string (const T_type_definitions      & type_definitions,
+                                        T_interpret_data        & interpret_data,
+                                        T_frame_data            & in_out_frame_data,
+                                  const std::string             & print_args,
+                                  const std::string             & data_name,
+                                  const std::string             & data_simple_name,
+                                        std::ostream            & os_out,
+                                        std::ostream            & os_err)
+{
+    string    printf_result = print_args;
+
+    remove_string_limits(printf_result);
+
+    if (printf_result != print_args)
+    {
+        // There was "...", so it is a simple string.
+        // Nothing more to do.
+    }
+    else if ((printf_result != "") &&
+             (printf_result[0] == '(') &&
+             (printf_result[printf_result.size()-1] == ')'))
+    {
+        // There is (...), so it is a printf.
+
+        // Remove ( and ).
+        printf_result.erase(0, 1);
+        printf_result.erase(printf_result.size()-1);
+
+        // Split on ,.
+        vector<string>    words;
+        string_to_words(printf_result, words, K_parser_cfg_parameters);
+
+        //
+        remove_string_limits(words[0]);
+        promote_printf_string_to_64bits(words[0]);
+
+        // Compute values to print.
+        vector<C_value>    values_to_print;
+        for (unsigned int   idx = 1; idx < words.size(); ++idx)
+        {
+            values_to_print.push_back(compute_expression(type_definitions, interpret_data, in_out_frame_data,
+                                                         words[idx],
+                                                         data_name, data_simple_name, os_out, os_err));
+        }
+
+        // printf.
+        return  C_value::sprintf_values(words[0], values_to_print);
+    }
+    else
+    {
+        // There is no "", so it is a value.
+        C_value       value;
+        if (get_complex_value (type_definitions, interpret_data, printf_result, value) == E_rc_ok)
+        {
+            printf_result += " -> ";
+            printf_result += value.as_string();
+        }
+    }
+
+    return  printf_result;
+}
+
+//*****************************************************************************
+// printf_args_to_string ******************************************************
+//*****************************************************************************
+
+C_value    printf_args_to_string (const T_type_definitions      & type_definitions,
+                                        T_interpret_data        & interpret_data,
+                                        T_frame_data            & in_out_frame_data,
+                                  const std::string             & print_args,
+                                  const std::string             & data_name,
+                                  const std::string             & data_simple_name,
+                                        std::ostream            & os_out,
+                                        std::ostream            & os_err,
+                                        T_interpret_read_values::T_var_name_P_values  & var_name_P_values)
+{
+    string    printf_result = print_args;
+
+    remove_string_limits(printf_result);
+
+    if (printf_result != print_args)
+    {
+        // There was "...", so it is a simple string.
+        // Nothing more to do.
+    }
+    else if ((printf_result != "") &&
+             (printf_result[0] == '(') &&
+             (printf_result[printf_result.size()-1] == ')'))
+    {
+        // There is (...), so it is a printf.
+
+        // Remove ( and ).
+        printf_result.erase(0, 1);
+        printf_result.erase(printf_result.size()-1);
+
+        // Split on ,.
+        vector<string>    words;
+        string_to_words(printf_result, words, K_parser_cfg_parameters);
+
+        //
+        remove_string_limits(words[0]);
+        promote_printf_string_to_64bits(words[0]);
+
+        // Compute values to print.
+        vector<C_value>    values_to_print;
+        for (unsigned int   idx = 1; idx < words.size(); ++idx)
+        {
+            values_to_print.push_back(compute_expression(type_definitions, interpret_data, in_out_frame_data,
+                                                         words[idx],
+                                                         data_name, data_simple_name, os_out, os_err));
+        }
+
+        // printf.
+        return  C_value::sprintf_values(words[0], values_to_print);
+    }
+    else
+    {
+        // There is no "", so it is a value.
+        C_value        value;
+        E_return_code  return_code = get_complex_value (type_definitions, interpret_data, printf_result, value);
+        if (return_code == E_rc_ok)
+        {
+            T_interpret_read_values::T_var_name_P_value    var_name_P_value;
+            var_name_P_value.var_name = printf_result;
+            var_name_P_value.P_value = & interpret_data.get_attribute_value_of_read_variable(printf_result);
+            var_name_P_values.push_back(var_name_P_value);
+        }
+        else if (return_code == E_rc_multiple_value)
+        {
+            interpret_data.get_multiple_P_attribute_value_of_read_variable(printf_result, var_name_P_values);
+        }
+    }
+
+    return  printf_result;
+}
+
+//*****************************************************************************
+// 
+//*****************************************************************************
+
+#define M_FATAL_MISSING_DATA()                                         \
+    throw  C_byte_interpret_exception(M_WHERE, E_byte_interpret_exception_missing_data, "stop on error because nothing more to read")
+
+//*****************************************************************************
+// read the specified bit size of data
+//*****************************************************************************
+
+bool    read_data_bits (     T_frame_data  & in_out_frame_data,
+                             void          * P_value_param,
+                       const char          * UNUSED(TYPE_NAME),
+                       const size_t          TYPE_BIT_SIZE,
+                       const char          * UNUSED(TYPE_IMPL_STR),
+                       const size_t          TYPE_IMPL_BIT_SIZE,
+                       const bool            must_invert_bytes,
+                       const bool            is_signed_integer)
+{
+    const size_t    TYPE_SIZE = (TYPE_BIT_SIZE / 8) + ((TYPE_BIT_SIZE % 8) ? 1 : 0);
+
+    T_byte  * P_value_orig = (T_byte *)P_value_param;
+    T_byte  * P_value = P_value_orig;
+    if (TYPE_IMPL_BIT_SIZE > 8)
+    {
+        if (T_interpret_byte_order::is_host_byte_order_inverted() == false)
+        {
+            P_value += (TYPE_IMPL_BIT_SIZE / 8) - TYPE_SIZE;
+        }
+    }
+
+    if (TYPE_BIT_SIZE < 8)
+    {
+        *P_value = in_out_frame_data.read_less_1_byte(static_cast<short>(TYPE_BIT_SIZE));
+#if 0
+        if (is_signed_integer == false)
+            return  true;
+
+        M_FATAL_IF_LE(TYPE_BIT_SIZE, 1);
+
+        // The bit sign is the higher bit.
+        const T_byte    sign_mask = 1 << (TYPE_BIT_SIZE-1);
+        if (*P_value & sign_mask)
+        {
+            // The value is signed.
+            // I must set to 1 all the bits higher to the sign bit.
+            // If sign is on the 4th bit :
+            // sign_mask   is    00001000
+            // sign_mask-1 gives 00000111
+            // ^ 0xff      gives 11111000
+            const T_byte    move_sign_mask = (sign_mask-1) ^ 0xff;
+            *P_value |= move_sign_mask;
+        }
+#endif
+    }
+    else
+    {
+        in_out_frame_data.read_n_bits(static_cast<short>(TYPE_BIT_SIZE), P_value, static_cast<short>(TYPE_SIZE));
+
+        if (must_invert_bytes)
+        {
+            T_byte  * P_swap = (T_byte *)P_value;
+            for (size_t  idx = 0; idx < (TYPE_SIZE/2); ++idx)
+                swap (P_swap[idx], P_swap[TYPE_SIZE-1-idx]);
+        }
+    }
+
+    if (is_signed_integer == false)
+        return  true;
+
+    M_FATAL_IF_LE(TYPE_BIT_SIZE, 1);
+
+#define M_READ_DATA_MOVE_SIGN(TYPE_IMPL)                                      \
+        {                                                                     \
+            TYPE_IMPL  * P_value_sign = (TYPE_IMPL *)P_value_param;           \
+            /* The bit sign is the higher bit. */                             \
+            const TYPE_IMPL    sign_mask = uint64_t(1) << (TYPE_BIT_SIZE-1);  \
+            if (*P_value_sign & sign_mask)                                    \
+            {                                                                 \
+                /* The value is signed.                                       \
+                 * I must set to 1 all the bits higher to the sign bit.       \
+                 * If sign is on the 4th bit :                                \
+                 * sign_mask   is    00001000                                 \
+                 * sign_mask-1 gives 00000111                                 \
+                 * ^ 0xff      gives 11111000                                 \
+                 */                                                           \
+                const TYPE_IMPL    move_sign_mask = (sign_mask-1) ^ 0xffffffffffffffffLL;     \
+                *P_value_sign |= move_sign_mask;                              \
+            }                                                                 \
+        }
+
+#define M_READ_DATA_MOVE_SIGN_SIZE(TYPE_IMPL_BIT_SIZE_to_check,TYPE_IMPL)     \
+    if (TYPE_IMPL_BIT_SIZE == TYPE_IMPL_BIT_SIZE_to_check)                    \
+    {                                                                         \
+        M_READ_DATA_MOVE_SIGN(TYPE_IMPL)                                      \
+    }
+
+
+    M_READ_DATA_MOVE_SIGN_SIZE(8, signed char)
+    else M_READ_DATA_MOVE_SIGN_SIZE(16, signed short)
+    else M_READ_DATA_MOVE_SIGN_SIZE(32, signed int)
+    else M_READ_DATA_MOVE_SIGN_SIZE(64, signed long long)
+    else
+    {
+        M_FATAL_COMMENT("Unexpected implementation bit size " << TYPE_IMPL_BIT_SIZE);
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// read the specified size of data
+// - throw if there is NOT enough data to read
+// - invert bytes readed if specified
+//   Consequently, this function must be used only for integers or float.
+// Returns true if ok.
+// Returns false if NOT enough data.
+//*****************************************************************************
+
+bool    read_data (      T_frame_data  & in_out_frame_data,
+                         void          * P_value_param,
+                   const char          * TYPE_NAME,
+                   const size_t          TYPE_BIT_SIZE,
+                   const char          * TYPE_IMPL_STR,
+                   const size_t          TYPE_IMPL_BIT_SIZE,
+                   const bool            must_invert_bytes,
+                   const bool            is_signed_integer)
+{
+    if (in_out_frame_data.can_move_bit_forward(TYPE_BIT_SIZE) != true)
+    {
+        M_TRACE_FATAL ("Not enough bits ("
+               << in_out_frame_data.get_remaining_bits() << " instead of " << TYPE_BIT_SIZE
+               << ") for read " << TYPE_NAME
+               << " (" << TYPE_IMPL_STR << ") !");
+        return  false;
+    }
+
+    M_FATAL_IF_NE(TYPE_IMPL_BIT_SIZE % 8, 0);
+
+    if ((TYPE_BIT_SIZE % 8) != 0)
+    {
+        return  read_data_bits(in_out_frame_data,
+                   P_value_param, TYPE_NAME, TYPE_BIT_SIZE,
+                   TYPE_IMPL_STR, TYPE_IMPL_BIT_SIZE,
+                   must_invert_bytes,
+                   is_signed_integer);
+    }
+
+    const size_t    TYPE_IMPL_SIZE = TYPE_IMPL_BIT_SIZE / 8;
+    const size_t    TYPE_SIZE = TYPE_BIT_SIZE / 8;
+
+    T_byte  * P_value_orig = (T_byte *)P_value_param;
+    T_byte  * P_value = P_value_orig;
+    if (TYPE_BIT_SIZE < TYPE_IMPL_BIT_SIZE)
+    {
+        if (T_interpret_byte_order::is_host_byte_order_inverted() == false)
+        {
+            P_value += TYPE_IMPL_SIZE - TYPE_SIZE;
+        }
+    }
+
+    in_out_frame_data.read_n_bytes(static_cast<short>(TYPE_SIZE), P_value);
+
+    if (must_invert_bytes)
+    {
+        T_byte  * P_swap = (T_byte *)P_value;
+        for (size_t  idx = 0; idx < (TYPE_SIZE/2); ++idx)
+            swap (P_swap[idx], P_swap[TYPE_SIZE-1-idx]);
+    }
+
+    if (TYPE_BIT_SIZE >= TYPE_IMPL_BIT_SIZE)
+        return  true;
+
+    // only (u)int24 at this time
+
+    if (is_signed_integer == false)
+        return  true;
+
+    // only int24 at this time
+
+    T_byte  * P_where_sign_bit_is      = nullptr;
+    T_byte  * P_ff_begin = nullptr;
+    T_byte  * P_ff_end = nullptr;
+
+    // hope it is ok !
+    if (T_interpret_byte_order::is_host_byte_order_inverted())
+    {
+        P_where_sign_bit_is      = P_value      + (TYPE_SIZE - 1);
+        P_ff_begin = P_value_orig + TYPE_SIZE;
+        P_ff_end   = P_value_orig + TYPE_IMPL_SIZE;
+    }
+    else
+    {
+        P_where_sign_bit_is      = P_value;
+        P_ff_begin = P_value_orig;
+        P_ff_end   = P_value;
+    }
+
+    int    is_bit_sign_set = *P_where_sign_bit_is & 0x80;
+    if (is_bit_sign_set)
+    {
+        for (T_byte  * P_ff = P_ff_begin; P_ff < P_ff_end; ++P_ff)
+        {
+            *P_ff = 0xff;
+        }
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// read_data
+//*****************************************************************************
+
+void    read_data (const T_type_definitions  & type_definitions,
+                         T_frame_data        & in_out_frame_data,
+                   const T_interpret_data    & interpret_data,
+                   const T_field_type_name   & field_type_name,
+                   const string              & data_name,
+                   const string              & data_simple_name,
+                         void                * P_value_param,
+                   const char                * TYPE_NAME,
+                   const size_t                TYPE_BIT_SIZE,
+                   const char                * TYPE_IMPL_STR,
+                   const size_t                TYPE_IMPL_BIT_SIZE,
+                   const bool                  must_invert_bytes,
+                   const bool                  is_signed_integer)
+{
+    if (read_data (in_out_frame_data,
+                   P_value_param, TYPE_NAME, TYPE_BIT_SIZE,
+                   TYPE_IMPL_STR, TYPE_IMPL_BIT_SIZE,
+                   must_invert_bytes,
+                   is_signed_integer) != true)
+    {
+        interpret_builder_missing_data(type_definitions, in_out_frame_data, interpret_data,
+                                field_type_name, data_name, data_simple_name,
+                                "not enough data to read " + data_simple_name);
+        M_FATAL_MISSING_DATA();
+    }
+}
+
+
+//*****************************************************************************
+// frame_to_function_base *****************************************************
+//*****************************************************************************
+
+enum E_return_value_indicator
+{
+    E_return_value_mandatory,
+    E_return_value_forbidden,
+    E_return_value_do_not_care
+};
+
+bool    frame_to_function_base (const T_type_definitions      & type_definitions,
+                                      T_interpret_data        & in_out_interpret_data,
+                                      T_frame_data            & in_out_frame_data,
+                                const T_function_definition   & fct_def,
+                                const vector<T_expression>    & fct_parameters,
+                                const string                  & data_name,
+                                const string                  & data_simple_name,
+                                      ostream                 & os_out,
+                                      ostream                 & os_err,
+                                      E_return_value_indicator  return_value_indicator,
+                                      C_value                 & returned_value);
+
+
+//*****************************************************************************
+// frame_append_byte **********************************************************
+//*****************************************************************************
+
+void    frame_append_byte(T_decode_stream_frame  * P_decode_stream_frame,
+                          unsigned char            byte)
+{
+    if (P_decode_stream_frame == nullptr)
+    {
+        M_FATAL_COMMENT("frame_append_byte no data");
+    }
+
+    P_decode_stream_frame->write_1_byte(byte);
+}
+
+//*****************************************************************************
+// frame_append_data **********************************************************
+//*****************************************************************************
+
+void    frame_append_data(T_decode_stream_frame  * P_decode_stream_frame,
+                          long long                data,
+                          int                      data_bit_size)
+{
+    M_TRACE_ENTER ("frame_append_data", "data=" << data << "  data_bit_size=" << data_bit_size);
+
+    if (P_decode_stream_frame == nullptr)
+    {
+        M_FATAL_COMMENT("frame_append_data no data");
+    }
+
+    P_decode_stream_frame->write_less_1_byte(static_cast<T_byte>(data), data_bit_size);      // ICIOA signed !
+}
+
+//*****************************************************************************
+// frame_append_data **********************************************************
+//*****************************************************************************
+
+bool    frame_append_data (const T_type_definitions    & type_definitions,
+                               T_frame_data            & in_out_frame_data,
+                               T_interpret_data        & interpret_data,
+                         const T_function_definition   & UNUSED(fct_def),
+                         const T_field_type_name       & field_type_name,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err)
+{
+    M_TRACE_ENTER ("frame_append_data", "");
+
+    if (field_type_name.fct_parameters.size() != 2)
+    {
+        M_FATAL_COMMENT("frame_append_data expect 2 parameters");
+        return  false;
+    }
+
+    // Compute frame address.
+    T_decode_stream_frame  * P_decode_stream_frame = nullptr;
+    {
+        const C_value  & frame_value = field_type_name.fct_parameters[0].compute_expression(
+                                       type_definitions, interpret_data, in_out_frame_data,
+                                       data_name, data_simple_name, os_out, os_err);
+        if (frame_value.get_type() == C_value::E_type_integer)
+        {
+            P_decode_stream_frame = (T_decode_stream_frame*)frame_value.get_int();
+        }
+        else
+        {
+            M_FATAL_COMMENT("frame_append_data expect param1 = frame (= int)");
+            return  false;
+        }
+    }
+
+    // Compute value of byte.
+    const C_value  & obj_value = field_type_name.fct_parameters[1].compute_expression(
+                                   type_definitions, interpret_data, in_out_frame_data,
+                                   data_name, data_simple_name, os_out, os_err);
+    if (obj_value.get_type() == C_value::E_type_integer)
+    {
+//        M_TRACE_DEBUG("obj_value.external_type=" << obj_value.get_external_type());
+        M_FATAL_IF_EQ(obj_value.get_external_type_bit_size(), 0);
+
+        frame_append_data(P_decode_stream_frame,
+                            obj_value.get_int(),
+                            obj_value.get_external_type_bit_size());  // ICIOA signe ???
+    }
+    else if ((obj_value.get_type() == C_value::E_type_string) &&
+             (obj_value.get_str().size() == 1))
+    {
+        frame_append_byte(P_decode_stream_frame, obj_value.get_str()[0]);
+    }
+    else
+    {
+        M_FATAL_COMMENT("frame_append_byte expect param2 = int (or string(1))");
+        return  false;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_append_data_array ****************************************************
+//*****************************************************************************
+
+bool    frame_append_data_array (
+                         const T_type_definitions      & type_definitions,
+                               T_frame_data            & in_out_frame_data,
+                               T_interpret_data        & interpret_data,
+                         const T_function_definition   & UNUSED(fct_def),
+                         const T_field_type_name       & field_type_name,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err)
+{
+    M_TRACE_ENTER ("frame_append_data_array", "");
+
+    if (field_type_name.fct_parameters.size() != 3)
+    {
+        M_FATAL_COMMENT("frame_append_data_array expect 3 parameters");
+        return  false;
+    }
+
+    // Compute frame address.
+    T_decode_stream_frame  * P_decode_stream_frame = nullptr;
+    {
+        const C_value  & frame_value = field_type_name.fct_parameters[0].compute_expression(
+                                       type_definitions, interpret_data, in_out_frame_data,
+                                       data_name, data_simple_name, os_out, os_err);
+        if (frame_value.get_type() == C_value::E_type_integer)
+        {
+            P_decode_stream_frame = (T_decode_stream_frame*)frame_value.get_int();
+            if (P_decode_stream_frame == nullptr)
+            {
+                M_FATAL_COMMENT("frame_append_data_array expect param1 = frame (= int) != nullptr");
+                return  false;
+            }
+        }
+        else
+        {
+            M_FATAL_COMMENT("frame_append_data_array expect param1 = frame (= int)");
+            return  false;
+        }
+    }
+
+    // Compute value of data pointer.
+    const T_byte *  ptr = nullptr;
+    {
+        const C_value  & obj_value = field_type_name.fct_parameters[1].compute_expression(
+                                       type_definitions, interpret_data, in_out_frame_data,
+                                       data_name, data_simple_name, os_out, os_err);
+        if (obj_value.get_type() == C_value::E_type_integer)
+        {
+            ptr = (const T_byte *)obj_value.get_int();
+            if (ptr == nullptr)
+            {
+                M_FATAL_COMMENT("frame_append_data_array expect param2 = data pointer != nullptr");
+                return  false;
+            }
+        }
+        else
+        {
+            M_FATAL_COMMENT("frame_append_data_array expect param2 = data pointer (int64)");
+            return  false;
+        }
+    }
+
+    // Compute value of data size.
+    int        data_size = 0;
+    {
+        const C_value  & obj_value = field_type_name.fct_parameters[2].compute_expression(
+                                       type_definitions, interpret_data, in_out_frame_data,
+                                       data_name, data_simple_name, os_out, os_err);
+        if (obj_value.get_type() == C_value::E_type_integer)
+        {
+            data_size = obj_value.get_int_int();
+            if (data_size < 0)
+            {
+                M_FATAL_COMMENT("frame_append_data_array expect param3 = data size (integer) >= 0");
+                return  false;
+            }
+        }
+        else
+        {
+            M_FATAL_COMMENT("frame_append_data_array expect param3 = data size (integer)");
+            return  false;
+        }
+    }
+
+    // Copy data into frame.
+    P_decode_stream_frame->write_n_bytes(ptr, data_size);
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_append_hexa_data *****************************************************
+//*****************************************************************************
+
+bool    frame_append_hexa_data (
+                         const T_type_definitions      & type_definitions,
+                               T_frame_data            & in_out_frame_data,
+                               T_interpret_data        & interpret_data,
+                         const T_function_definition   & UNUSED(fct_def),
+                         const T_field_type_name       & field_type_name,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err)
+{
+    M_TRACE_ENTER ("frame_append_hexa_data", "");
+
+    if (field_type_name.fct_parameters.size() != 2)
+    {
+        M_FATAL_COMMENT("frame_append_hexa_data expect 2 parameters");
+        return  false;
+    }
+
+    // Compute frame address.
+    T_decode_stream_frame  * P_decode_stream_frame = nullptr;
+    {
+        const C_value  & frame_value = field_type_name.fct_parameters[0].compute_expression(
+                                       type_definitions, interpret_data, in_out_frame_data,
+                                       data_name, data_simple_name, os_out, os_err);
+        if (frame_value.get_type() == C_value::E_type_integer)
+        {
+            P_decode_stream_frame = (T_decode_stream_frame*)frame_value.get_int();
+        }
+        else
+        {
+            M_FATAL_COMMENT("frame_append_hexa_data expect param1 = frame (= int)");
+            return  false;
+        }
+    }
+
+    // Compute value of byte.
+    const C_value  & obj_value = field_type_name.fct_parameters[1].compute_expression(
+                                   type_definitions, interpret_data, in_out_frame_data,
+                                   data_name, data_simple_name, os_out, os_err);
+    if (obj_value.get_type() == C_value::E_type_string)
+    {
+        string    hexa_str = obj_value.get_str();
+        if (hexa_str.find(' ') != string::npos)
+        {
+            mod_replace_all(hexa_str, " ", "");
+        }
+
+        T_byte_vector    byte_vector;
+        string_hexa_to_frame(hexa_str, byte_vector);
+
+        for (T_byte_vector::const_iterator  iter  = byte_vector.begin();
+                                            iter != byte_vector.end();
+                                          ++iter)
+        {
+            frame_append_byte(P_decode_stream_frame, *iter);
+        }
+    }
+    else
+    {
+        M_FATAL_COMMENT("frame_append_hexa_data expect param2 = string with hexadecimal data");
+        return  false;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// decoder_aes ****************************************************************
+//*****************************************************************************
+#include <glib.h>
+extern "C"
+{
+#include "shark_wsutil_aes.h"
+}
+// NOT multi-thread, NOT reentrant, NOT multi dissectors 
+//static rijndael_ctx   S_rijndael_ctx;
+
+bool    decoder_aes (    const T_type_definitions      & UNUSED(type_definitions),
+                               T_frame_data            & in_out_frame_data,
+                               T_interpret_data        & interpret_data,
+                               T_decode_stream_frame   & decode_stream_frame,
+                               long long                 nb_of_bits_needed,
+                         const string                  & UNUSED(decode_function_name),
+                         const T_function_definition   & UNUSED(fct_def),
+                         const vector<T_expression>    & UNUSED(fct_parameters),
+                         const string                  & UNUSED(data_name),
+                         const string                  & UNUSED(data_simple_name),
+                               ostream                 & UNUSED(os_out),
+                               ostream                 & UNUSED(os_err))
+{
+    M_TRACE_ENTER ("decoder_aes", nb_of_bits_needed);
+
+    while (nb_of_bits_needed > 0)
+    {
+        // Always read 16 bytes
+        T_byte  bytes_in[16];
+        in_out_frame_data.read_n_bytes(sizeof (bytes_in), bytes_in);
+
+        // ICIOA key is string only !!!
+        const string  & key = interpret_data.get_str_value_of_read_variable("decoder_aes_key");
+
+        // Check key size
+        const int       key_size = key.length() * 8;
+        if ((key_size != 128) && (key_size != 192) && (key_size != 256))
+        {
+            M_FATAL_COMMENT("Bad decoder_aes_key=>" << key << "<, length should be 128, 192 or 256 bits");
+            return  false;
+        }
+
+        // ICIOA key is rebuild each 16 bytes !!!
+        rijndael_ctx   S_rijndael_ctx;
+        fdesc_rijndael_set_key(&S_rijndael_ctx, (const guchar*)key.c_str(), key_size);
+
+        T_byte  bytes_out[16];
+        fdesc_rijndael_decrypt(&S_rijndael_ctx, bytes_in, bytes_out);
+
+        // Copy all bytes data into frame.
+        decode_stream_frame.write_n_bytes(bytes_out, sizeof(bytes_out));
+     
+        nb_of_bits_needed -= sizeof(bytes_out) * 8;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// convert_base64 *************************************************************
+//*****************************************************************************
+// Complement = must not appear, must have been filtered/managed before
+//*****************************************************************************
+
+T_byte  convert_base64(T_byte  byte_encoded)
+{
+    T_byte  val = 100;
+    if (byte_encoded >= 'A' && byte_encoded <= 'Z')
+    {
+        val = byte_encoded - 'A';
+    }
+    else if (byte_encoded >= 'a' && byte_encoded <= 'z')
+    {
+        val = (byte_encoded - 'a') + 26;
+    }
+    else if (byte_encoded >= '0' && byte_encoded <= '9')
+    {
+        val = (byte_encoded - '0') + 26 + 26;
+    }
+    else if (byte_encoded == '+')
+    {
+        val = 62;
+    }
+    else if (byte_encoded == '/')
+    {
+        val = 63;
+    }
+    else
+    {
+        M_FATAL_COMMENT("unexpected Base64 character " << (int)byte_encoded);
+    }
+
+    return  val;
+}
+
+//*****************************************************************************
+// decoder_base64_read_byte ***************************************************
+//*****************************************************************************
+// Read 1 byte, ignore all space, \t, \n, \r
+//*****************************************************************************
+
+T_byte  decoder_base64_read_byte(T_frame_data            & in_out_frame_data)
+{
+    T_byte  byte_encoded;
+
+    do
+    {
+        byte_encoded = in_out_frame_data.read_1_byte();
+    } while ((byte_encoded == ' ') ||
+             (byte_encoded == '\t') ||
+             (byte_encoded == '\n') ||
+             (byte_encoded == '\r'));
+
+    return  byte_encoded;
+}
+
+//*****************************************************************************
+// decoder_base64 *************************************************************
+//*****************************************************************************
+bool    decoder_base64 ( const T_type_definitions      & UNUSED(type_definitions),
+                               T_frame_data            & in_out_frame_data,
+                               T_interpret_data        & UNUSED(interpret_data),
+                               T_decode_stream_frame   & decode_stream_frame,
+                               long long                 nb_of_bits_needed,
+                         const string                  & UNUSED(decode_function_name),
+                         const T_function_definition   & UNUSED(fct_def),
+                         const vector<T_expression>    & UNUSED(fct_parameters),
+                         const string                  & UNUSED(data_name),
+                         const string                  & UNUSED(data_simple_name),
+                               ostream                 & UNUSED(os_out),
+                               ostream                 & UNUSED(os_err))
+{
+    M_TRACE_ENTER ("decoder_base64", nb_of_bits_needed);
+
+    while (nb_of_bits_needed > 0)
+    {
+        // Always read 4 characters 
+        const T_byte  byte_encoded1 = decoder_base64_read_byte(in_out_frame_data);
+        const T_byte  byte_encoded2 = decoder_base64_read_byte(in_out_frame_data);
+        const T_byte  byte_encoded3 = decoder_base64_read_byte(in_out_frame_data);
+        const T_byte  byte_encoded4 = decoder_base64_read_byte(in_out_frame_data);
+
+        // Copy 6 bit data into frame.
+        decode_stream_frame.write_less_1_byte(convert_base64(byte_encoded1), 6);
+        nb_of_bits_needed -= 6;
+//        M_TRACE_DEBUG ("xxxx 1) -6 = ", nb_of_bits_needed);
+
+        if ((byte_encoded4 == '=') && (byte_encoded3 == '='))
+        {
+            const int  nb_of_bits_available = 2;
+
+            T_byte  val = convert_base64(byte_encoded2);
+            val >>= (6 - nb_of_bits_available);
+
+            decode_stream_frame.write_less_1_byte(val, nb_of_bits_available);
+            nb_of_bits_needed -= nb_of_bits_available;
+//            M_TRACE_DEBUG ("xx== 2) -2 = ", nb_of_bits_needed);
+        }
+        else if (byte_encoded4 == '=')
+        {
+            decode_stream_frame.write_less_1_byte(convert_base64(byte_encoded2), 6);
+            nb_of_bits_needed -= 6;
+//            M_TRACE_DEBUG ("xxx= 2) -6 = ", nb_of_bits_needed);
+
+            const int  nb_of_bits_available = 4;
+
+            T_byte  val = convert_base64(byte_encoded3);
+            val >>= (6 - nb_of_bits_available);
+
+            decode_stream_frame.write_less_1_byte(val, nb_of_bits_available);
+            nb_of_bits_needed -= nb_of_bits_available;
+//            M_TRACE_DEBUG ("xxx= 3) -4 = ", nb_of_bits_needed);
+        }
+        else
+        {
+            decode_stream_frame.write_less_1_byte(convert_base64(byte_encoded2), 6);
+            nb_of_bits_needed -= 6;
+//            M_TRACE_DEBUG ("xxxx 2) -6 = ", nb_of_bits_needed);
+            decode_stream_frame.write_less_1_byte(convert_base64(byte_encoded3), 6);
+            nb_of_bits_needed -= 6;
+//            M_TRACE_DEBUG ("xxxx 3) -6 = ", nb_of_bits_needed);
+            decode_stream_frame.write_less_1_byte(convert_base64(byte_encoded4), 6);
+            nb_of_bits_needed -= 6;
+//            M_TRACE_DEBUG ("xxxx 4) -6 = ", nb_of_bits_needed);
+        }
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// decoder_utf16be ************************************************************
+//*****************************************************************************
+
+bool    decoder_utf16be (const T_type_definitions      & UNUSED(type_definitions),
+                               T_frame_data            & in_out_frame_data,
+                               T_interpret_data        & UNUSED(interpret_data),
+                               T_decode_stream_frame   & decode_stream_frame,
+                               long long                 nb_of_bits_needed,
+                         const string                  & UNUSED(decode_function_name),
+                         const T_function_definition   & UNUSED(fct_def),
+                         const vector<T_expression>    & UNUSED(fct_parameters),
+                         const string                  & UNUSED(data_name),
+                         const string                  & UNUSED(data_simple_name),
+                               ostream                 & UNUSED(os_out),
+                               ostream                 & UNUSED(os_err))
+{
+    M_TRACE_ENTER ("decoder_utf16be", nb_of_bits_needed);
+
+    if ((nb_of_bits_needed % 8) != 0)
+    {
+        M_FATAL_COMMENT("Only entire byte");
+        return  false;
+    }
+
+    while (nb_of_bits_needed > 0)
+    {
+        // inverted read
+        const T_byte  byte2 = in_out_frame_data.read_1_byte();
+              T_byte  byte1 = in_out_frame_data.read_1_byte();
+
+        if (byte2 != 0)
+        {
+            byte1 = '.';   // means unknow char
+
+            if ((byte2 & 0xfc) == 0xd8)
+            {
+                /*T_byte  byte3 =*/ in_out_frame_data.read_1_byte();
+                /*T_byte  byte4 =*/ in_out_frame_data.read_1_byte();
+            }
+        }
+
+        decode_stream_frame.write_1_byte(byte1);
+
+        nb_of_bits_needed -= 8;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// decoder_utf16le ************************************************************
+//*****************************************************************************
+
+bool    decoder_utf16le (const T_type_definitions      & UNUSED(type_definitions),
+                               T_frame_data            & in_out_frame_data,
+                               T_interpret_data        & UNUSED(interpret_data),
+                               T_decode_stream_frame   & decode_stream_frame,
+                               long long                 nb_of_bits_needed,
+                         const string                  & UNUSED(decode_function_name),
+                         const T_function_definition   & UNUSED(fct_def),
+                         const vector<T_expression>    & UNUSED(fct_parameters),
+                         const string                  & UNUSED(data_name),
+                         const string                  & UNUSED(data_simple_name),
+                               ostream                 & UNUSED(os_out),
+                               ostream                 & UNUSED(os_err))
+{
+    M_TRACE_ENTER ("decoder_utf16le", nb_of_bits_needed);
+
+    if ((nb_of_bits_needed % 8) != 0)
+    {
+        M_FATAL_COMMENT("Only entire byte");
+        return  false;
+    }
+
+    while (nb_of_bits_needed > 0)
+    {
+              T_byte  byte1 = in_out_frame_data.read_1_byte();
+        const T_byte  byte2 = in_out_frame_data.read_1_byte();
+
+        if (byte2 != 0)
+        {
+            byte1 = '.';   // means unknow char
+
+            if ((byte2 & 0xfc) == 0xd8)
+            {
+                /*T_byte  byte3 =*/ in_out_frame_data.read_1_byte();
+                /*T_byte  byte4 =*/ in_out_frame_data.read_1_byte();
+            }
+        }
+
+        decode_stream_frame.write_1_byte(byte1);
+
+        nb_of_bits_needed -= 8;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// decoder_utf8 ***************************************************************
+//*****************************************************************************
+
+bool    decoder_utf8 (   const T_type_definitions      & UNUSED(type_definitions),
+                               T_frame_data            & in_out_frame_data,
+                               T_interpret_data        & UNUSED(interpret_data),
+                               T_decode_stream_frame   & decode_stream_frame,
+                               long long                 nb_of_bits_needed,
+                         const string                  & UNUSED(decode_function_name),
+                         const T_function_definition   & UNUSED(fct_def),
+                         const vector<T_expression>    & UNUSED(fct_parameters),
+                         const string                  & UNUSED(data_name),
+                         const string                  & UNUSED(data_simple_name),
+                               ostream                 & UNUSED(os_out),
+                               ostream                 & UNUSED(os_err))
+{
+    M_TRACE_ENTER ("decoder_utf8", nb_of_bits_needed);
+
+    if ((nb_of_bits_needed % 8) != 0)
+    {
+        M_FATAL_COMMENT("Only entire byte");
+        return  false;
+    }
+
+    while (nb_of_bits_needed > 0)
+    {
+        T_byte  byte1 = in_out_frame_data.read_1_byte();
+
+        if ((byte1 & 0x80) != 0)
+        {
+            if ((byte1 & 0xF0) == 0xF0)
+            {
+                /*T_byte  byte2 =*/ in_out_frame_data.read_1_byte();
+                /*T_byte  byte3 =*/ in_out_frame_data.read_1_byte();
+                /*T_byte  byte4 =*/ in_out_frame_data.read_1_byte();
+            }
+            else
+            {
+                if ((byte1 & 0xE0) == 0xE0)
+                {
+                    /*T_byte  byte2 =*/ in_out_frame_data.read_1_byte();
+                    /*T_byte  byte3 =*/ in_out_frame_data.read_1_byte();
+                }
+                else
+                {
+                    /*T_byte  byte2 =*/ in_out_frame_data.read_1_byte();
+                }
+            }
+ 
+            byte1 = '.';   // means unknow char
+        }
+
+        decode_stream_frame.write_1_byte(byte1);
+
+        nb_of_bits_needed -= 8;
+    }
+
+    return  true;
+}
+
+
+//*****************************************************************************
+// frame_to_function_base_decoder *********************************************
+//*****************************************************************************
+// Call possible built-in decoder
+// Call frame_to_function_base in other cases
+//*****************************************************************************
+
+bool    frame_to_function_base_decoder (
+                         const T_type_definitions        & type_definitions,
+                               T_interpret_data          & interpret_data,
+                               T_frame_data              & in_out_frame_data,
+                         const string                    & decode_function_name,
+                         const T_function_definition     & fct_def,
+                         const vector<T_expression>      & fct_parameters,
+                         const string                    & data_name,
+                         const string                    & data_simple_name,
+                               ostream                   & os_out,
+                               ostream                   & os_err,
+                               E_return_value_indicator    return_value_indicator,
+                               C_value                   & returned_value)
+{
+    // List of built-in decoders
+    static const
+    struct {
+        string  decode_function_name;
+        bool  (*ptr_function)( const T_type_definitions      & type_definitions,
+                               T_frame_data            & in_out_frame_data,
+                               T_interpret_data        & interpret_data,
+                               T_decode_stream_frame   & decode_stream_frame,
+                               long long                 nb_of_bits_needed,
+                         const string                  & decode_function_name,
+                         const T_function_definition   & fct_def,
+                         const vector<T_expression>    & fct_parameters,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err);
+    } decoder_builtin[] = {
+        { "decoder_aes",     decoder_aes  },
+        { "decoder_base64",  decoder_base64  },
+        { "decoder_utf16be", decoder_utf16be },
+        { "decoder_utf16le", decoder_utf16le },
+        { "decoder_utf8",    decoder_utf8    },
+    };
+
+    // Search for built-in decoder
+    for (size_t idx = 0; idx < M_SIZE_TAB(decoder_builtin); ++idx)
+    {
+        if (decode_function_name == decoder_builtin[idx].decode_function_name)
+        {
+            // Built-in decoder found
+
+            if (fct_parameters.size() != 2)
+            {
+                M_FATAL_COMMENT(decode_function_name << " expect 2 parameters");
+                return  false;
+            }
+
+            // Compute frame address.
+            T_decode_stream_frame  * P_decode_stream_frame = nullptr;
+            {
+                const C_value  & frame_value = fct_parameters[0].compute_expression(
+                                               type_definitions, interpret_data, in_out_frame_data,
+                                               data_name, data_simple_name, os_out, os_err);
+                if (frame_value.get_type() == C_value::E_type_integer)
+                {
+                    P_decode_stream_frame = (T_decode_stream_frame*)frame_value.get_int();
+                }
+                else
+                {
+                    M_FATAL_COMMENT(decode_function_name << " expect param1 = frame (= int)");
+                    return  false;
+                }
+            }
+
+            // Compute value of nb_of_bits_needed_uint.
+            long long        nb_of_bits_needed = 0;
+            {
+                const C_value  & obj_value = fct_parameters[1].compute_expression(
+                                               type_definitions, interpret_data, in_out_frame_data,
+                                               data_name, data_simple_name, os_out, os_err);
+                if (obj_value.get_type() == C_value::E_type_integer)
+                {
+                    nb_of_bits_needed = obj_value.get_int();
+                    if (nb_of_bits_needed < 0)
+                    {
+                        M_FATAL_COMMENT(decode_function_name << " expect param2 = nb_of_bits_needed_uint (integer) >= 0");
+                        return  false;
+                    }
+                }
+                else
+                {
+                    M_FATAL_COMMENT(decode_function_name << " expect param2 = nb_of_bits_needed_uint (integer)");
+                    return  false;
+                }
+            }
+
+            return  decoder_builtin[idx].ptr_function(
+                                       type_definitions,
+                                       in_out_frame_data,
+                                       interpret_data,
+                                      *P_decode_stream_frame,
+                                       nb_of_bits_needed,
+                                       decode_function_name,
+                                       fct_def,
+                                       fct_parameters,
+                                       data_name,
+                                       data_simple_name,
+                                       os_out,
+                                       os_err);
+
+            // Must call interpret_data.sup_all_read_variables_after(last_data_id);
+            //  like in frame_to_function_base.
+            // But current built-in decoders do NOT create variable.
+            // They use normal c variable.
+            // If they create variable, perhaps they want to keep them after the end of the function. 
+        }
+    }
+
+    // Not a built-in decoder
+
+    return  frame_to_function_base (type_definitions,
+                                   interpret_data,
+                                   in_out_frame_data,
+                                   fct_def,
+                                   fct_parameters,
+                                   data_name,
+                                   data_simple_name,
+                                   os_out,
+                                   os_err,
+                                   return_value_indicator,
+                                   returned_value);
+}
+
+//*****************************************************************************
+// decode_data_size
+//*****************************************************************************
+
+void    decode_data_size (
+                   const T_type_definitions     & type_definitions,
+                         T_frame_data           & in_out_frame_data,
+                         T_interpret_data       & interpret_data,
+                   const T_field_type_name      & UNUSED(field_type_name),
+                   const string                 & data_name,
+                   const string                 & data_simple_name,
+                         ostream                & os_out,
+                         ostream                & os_err,
+                         T_decode_stream_frame  & decode_stream_frame,
+                   const char                   * UNUSED(TYPE_NAME),
+                   const int                      TYPE_BIT_SIZE)  // could be decorelated of TYPE_NAME
+{
+    M_TRACE_ENTER ("decode_data_size", interpret_data.get_decode_function() << " " << TYPE_BIT_SIZE);
+
+    C_interpret_decode_in_progress  idip(interpret_data);
+
+    const long    bit_offset_into_initial_frame = in_out_frame_data.get_bit_offset_into_initial_frame();
+    const long    remaining_bits = decode_stream_frame.frame_data.get_remaining_bits();
+
+    const T_function_definition  & fct_def = type_definitions.get_function(interpret_data.get_decode_function());
+
+    vector<T_expression>     fct_parameters(2);
+    // Memory address of the frame (cast to avoid hexa number).
+    fct_parameters[0].build_expression(C_value((long long)&decode_stream_frame));
+    // Bit size requested.
+    fct_parameters[1].build_expression(C_value(TYPE_BIT_SIZE));
+
+    C_value    return_value_do_not_care;
+    bool       result = frame_to_function_base_decoder (
+                               type_definitions,
+                               interpret_data,
+                               in_out_frame_data,
+                               interpret_data.get_decode_function(),
+                               fct_def,
+                               fct_parameters,
+                               data_name,
+                               data_simple_name,
+                               os_out,
+                               os_err,
+                               E_return_value_do_not_care,
+                               return_value_do_not_care);
+    if (result == false)
+    {
+        M_FATAL_COMMENT("frame_to_function_base_decoder");
+    }
+
+    // Check that the decoded size is >= at the asked size
+    const long  decoded_bits = decode_stream_frame.frame_data.get_remaining_bits() - remaining_bits;
+    if (decoded_bits < TYPE_BIT_SIZE)
+    {
+        M_FATAL_COMMENT("decoded_bits(" <<
+            decode_stream_frame.decoded_data_bit_size << ") < TYPE_BIT_SIZE(" <<
+            TYPE_BIT_SIZE << ")");
+    }
+
+    decode_stream_frame.frame_data.set_initial_frame_starting_bit_offset(bit_offset_into_initial_frame);
+}
+
+//*****************************************************************************
+// decode_data_bytes_until
+//*****************************************************************************
+
+void    decode_data_bytes_until (
+                   const T_type_definitions     & type_definitions,
+                         T_frame_data           & in_out_frame_data,
+                         T_interpret_data       & interpret_data,
+                   const T_field_type_name      & UNUSED(field_type_name),
+                   const string                 & data_name,
+                   const string                 & data_simple_name,
+                         ostream                & os_out,
+                         ostream                & os_err,
+                         T_decode_stream_frame  & decode_stream_frame,
+                   const char                   * UNUSED(TYPE_NAME),
+                   const char                   * p_ending_char_1,
+                   const char                   * p_ending_char_2)
+{
+    M_TRACE_ENTER ("decode_data_bytes_until", interpret_data.get_decode_function());
+//    M_TRACE_DEBUG("p_ending_char_x "
+//                  << (const void *)p_ending_char_1 << " and "
+//                  << (const void *)p_ending_char_2);
+
+    C_interpret_decode_in_progress  idip(interpret_data);
+
+    long    bit_offset_into_initial_frame = in_out_frame_data.get_bit_offset_into_initial_frame();
+
+    const T_function_definition  & fct_def = type_definitions.get_function(interpret_data.get_decode_function());
+
+    vector<T_expression>     fct_parameters(2);
+    // Memory address of the frame (cast to avoid hexa number).
+    fct_parameters[0].build_expression(C_value((long long)&decode_stream_frame));
+    // Bit size requested.
+    fct_parameters[1].build_expression(C_value(8));
+
+    C_value    return_value_do_not_care;
+
+    while (in_out_frame_data.get_remaining_bits() >= 8)
+    {
+        const long  current_decoded_data_bit_size = decode_stream_frame.decoded_data_bit_size;
+
+        bool  result = frame_to_function_base_decoder (
+                                   type_definitions,
+                                   interpret_data,
+                                   in_out_frame_data,
+                                   interpret_data.get_decode_function(),
+                                   fct_def,
+                                   fct_parameters,
+                                   data_name,
+                                   data_simple_name,
+                                   os_out,
+                                   os_err,
+                                   E_return_value_do_not_care,
+                                   return_value_do_not_care);
+        if (result == false)
+        {
+            M_FATAL_COMMENT("frame_to_function_base_decoder");
+        }
+
+        // Check that the decoded size is >= at the asked size
+        const long  decoded_bits = decode_stream_frame.decoded_data_bit_size - current_decoded_data_bit_size;
+        if (decoded_bits < 8)
+        {
+            M_FATAL_COMMENT("decoded_bits(" << decoded_bits << ") < 8");
+        }
+
+        if ((p_ending_char_1 != nullptr) || (p_ending_char_2 != nullptr))
+        {
+            const char  ending_char_1 = (p_ending_char_1 != nullptr) ? *p_ending_char_1 : *p_ending_char_2;
+            const char  ending_char_2 = (p_ending_char_2 != nullptr) ? *p_ending_char_2 : *p_ending_char_1;
+
+            // Because T_decode_stream_frame::synchronize() only manage reset,
+            //  the interesting data can start at offset != 0 and not %8
+
+            // Save the current position
+            const long  frame_data_current_bit_offset = decode_stream_frame.frame_data.get_bit_offset();
+
+            bool  is_final_character_found = false;
+            while (decode_stream_frame.frame_data.can_move_1_byte_forward() == true)
+            {
+                const T_byte  decoded_byte = decode_stream_frame.frame_data.read_1_byte();
+//                M_TRACE_DEBUG("Decoded byte " << (int)decoded_byte << " 0x" << hex << (int)decoded_byte);
+
+                if ((decoded_byte == ending_char_1) ||
+                    (decoded_byte == ending_char_2))
+                {
+                    is_final_character_found = true;
+//                    M_TRACE_DEBUG("found");
+                    break;
+                }
+            }
+
+            // Restore the current position
+            decode_stream_frame.frame_data.set_bit_offset(frame_data_current_bit_offset);
+
+            if (is_final_character_found == true)
+            {
+//                M_TRACE_DEBUG("found so break");
+                break;
+            }
+        }
+    }
+
+    decode_stream_frame.frame_data.set_initial_frame_starting_bit_offset(bit_offset_into_initial_frame);
+}
+
+//*****************************************************************************
+// read_decode_data
+//*****************************************************************************
+
+void    read_decode_data (
+                   const T_type_definitions  & type_definitions,
+                         T_frame_data        & in_out_frame_data_param,
+                         T_interpret_data    & interpret_data,
+                   const T_field_type_name   & field_type_name,
+                   const string              & data_name,
+                   const string              & data_simple_name,
+                         ostream             & os_out,
+                         ostream             & os_err,
+                         void                * P_value_param,
+                   const char                * TYPE_NAME,
+                   const size_t                TYPE_BIT_SIZE,
+                   const char                * TYPE_IMPL_STR,
+                   const size_t                TYPE_IMPL_BIT_SIZE,
+                   const bool                  must_invert_bytes,
+                   const bool                  is_signed_integer)
+{
+    T_frame_data           * P_in_out_frame_data = & in_out_frame_data_param;
+
+    if (interpret_data.is_decode_in_progress() == false)
+    {
+        T_decode_stream_frame  & decode_stream_frame = interpret_data.get_decode_stream_frame();
+        T_frame_data           & inside_frame = decode_stream_frame.frame_data;
+        if (inside_frame.get_remaining_bits() >= static_cast<long>(TYPE_BIT_SIZE))
+        {
+            // Enough data into inside_frame, so simply use it (decoder is useless for now)
+            P_in_out_frame_data = & inside_frame;
+        }
+        else if (interpret_data.must_decode_now() == false)
+        {
+            if (inside_frame.get_remaining_bits() > 0)
+            {
+                // For code simplification, do not manage this case.
+                // And seems non-sense : 1st part of data is decoded and 2nd part no.
+                M_FATAL_COMMENT("Not enough data into inside_frame (" << inside_frame.get_remaining_bits() << " bits < " <<
+                                TYPE_BIT_SIZE << ") and no decoder to fill it");
+            }
+            else
+            {
+                // No data into inside_frame and no decoder, so simply use normal frame
+            }
+        }
+        else
+        {
+            // Not enough data into inside_frame, so use decoder to fill it
+            M_TRACE_ENTER ("read_decode_data must_decode_stream", TYPE_BIT_SIZE);
+
+            decode_data_size (type_definitions, in_out_frame_data_param, interpret_data,
+                              field_type_name, data_name, data_simple_name,
+                              os_out, os_err,
+                              decode_stream_frame,
+                              TYPE_NAME, TYPE_BIT_SIZE - inside_frame.get_remaining_bits());
+
+            P_in_out_frame_data = & inside_frame;
+        }
+    }
+    else
+    {
+        // inside_frame and decoder not used during decoding
+    }
+
+
+    T_frame_data          & in_out_frame_data = * P_in_out_frame_data;
+
+    read_data (    type_definitions, in_out_frame_data, interpret_data,
+                   field_type_name, data_name, data_simple_name,
+                   P_value_param, TYPE_NAME, TYPE_BIT_SIZE,
+                   TYPE_IMPL_STR, TYPE_IMPL_BIT_SIZE,
+                   must_invert_bytes,
+                   is_signed_integer);
+
+    interpret_data.get_decode_stream_frame().synchronize();  // mandatory each time something has been read into its frame_data
+}
+
+//*****************************************************************************
+// Forward declarations.
+//*****************************************************************************
+
+bool    frame_to_any (const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & os_out,
+                            ostream               & os_err);
+
+bool    frame_to_fields (const T_type_definitions    & type_definitions,
+                               T_frame_data          & in_out_frame_data,
+                               T_interpret_data      & interpret_data,
+                         const T_struct_fields       & struct_fields,
+                         const string                & data_name,
+                         const string                & data_simple_name,
+                               ostream               & os_out,
+                               ostream               & os_err);
+
+bool    frame_to_struct_inline (const T_type_definitions    & type_definitions,
+                                      T_frame_data          & in_out_frame_data,
+                                      T_interpret_data      & interpret_data,
+                                const T_struct_definition   & struct_definition,
+                                const string                & data_name,
+                                const string                & data_simple_name,
+                                      ostream               & os_out,
+                                      ostream               & os_err);
+
+bool    frame_to_bitfield_inline (const T_type_definitions      & type_definitions,
+                                        T_frame_data            & in_out_frame_data,
+                                        T_interpret_data        & interpret_data,
+                                  const T_bitfield_definition   & bitfield_definition,
+                                  const string                  & data_name,
+                                  const string                  & data_simple_name,
+                                        ostream                 & os_out,
+                                        ostream                 & os_err);
+
+bool    frame_to_switch (const T_type_definitions      & type_definitions,
+                               T_frame_data            & in_out_frame_data,
+                               T_interpret_data        & interpret_data,
+                         const T_switch_definition     & switch_def,
+                         const string                  & discriminant_str,
+                         const T_field_type_name       & field_type_name,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err);
+
+//*****************************************************************************
+// frame_to_field *************************************************************
+//*****************************************************************************
+
+void    build_types_finalize_itself(const T_type_definitions  & type_definitions,
+                                    const T_field_type_name   & field_type_name);
+
+//*****************************************************************************
+// frame_to_field_deep_break **************************************************
+//*****************************************************************************
+
+bool    frame_to_field_deep_break(
+                         const T_type_definitions    & UNUSED(type_definitions),
+                               T_frame_data          & UNUSED(in_out_frame_data),
+                               T_interpret_data      & UNUSED(interpret_data),
+                         const T_field_type_name     & UNUSED(field_type_name),
+                         const string                & UNUSED(data_name),
+                         const string                & UNUSED(data_simple_name),
+                               ostream               & UNUSED(os_out),
+                               ostream               & UNUSED(os_err))
+{
+    M_TRACE_ENTER ("frame_to_field_deep_break", "");
+
+    throw  C_byte_interpret_exception_loop(M_WHERE, E_byte_interpret_exception_loop_deep_break, "deep_break called outside any loop");
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_field_deep_continue ***********************************************
+//*****************************************************************************
+
+bool    frame_to_field_deep_continue(
+                         const T_type_definitions    & UNUSED(type_definitions),
+                               T_frame_data          & UNUSED(in_out_frame_data),
+                               T_interpret_data      & UNUSED(interpret_data),
+                         const T_field_type_name     & UNUSED(field_type_name),
+                         const string                & UNUSED(data_name),
+                         const string                & UNUSED(data_simple_name),
+                               ostream               & UNUSED(os_out),
+                               ostream               & UNUSED(os_err))
+{
+    M_TRACE_ENTER ("frame_to_field_deep_continue", "");
+
+    throw  C_byte_interpret_exception_loop(M_WHERE, E_byte_interpret_exception_loop_deep_continue, "deep_continue called outside any loop");
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_field_break *******************************************************
+//*****************************************************************************
+
+bool    frame_to_field_break(
+                         const T_type_definitions    & UNUSED(type_definitions),
+                               T_frame_data          & UNUSED(in_out_frame_data),
+                               T_interpret_data      & UNUSED(interpret_data),
+                         const T_field_type_name     & UNUSED(field_type_name),
+                         const string                & UNUSED(data_name),
+                         const string                & UNUSED(data_simple_name),
+                               ostream               & UNUSED(os_out),
+                               ostream               & UNUSED(os_err))
+{
+    M_TRACE_ENTER ("frame_to_field_break", "");
+
+    throw  C_byte_interpret_exception_loop(M_WHERE, E_byte_interpret_exception_loop_break, "break called outside a loop");
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_field_continue ****************************************************
+//*****************************************************************************
+
+bool    frame_to_field_continue(
+                         const T_type_definitions    & UNUSED(type_definitions),
+                               T_frame_data          & UNUSED(in_out_frame_data),
+                               T_interpret_data      & UNUSED(interpret_data),
+                         const T_field_type_name     & UNUSED(field_type_name),
+                         const string                & UNUSED(data_name),
+                         const string                & UNUSED(data_simple_name),
+                               ostream               & UNUSED(os_out),
+                               ostream               & UNUSED(os_err))
+{
+    M_TRACE_ENTER ("frame_to_field_continue", "");
+
+    throw  C_byte_interpret_exception_loop(M_WHERE, E_byte_interpret_exception_loop_continue, "continue called outside a loop");
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_field_return ******************************************************
+//*****************************************************************************
+
+bool    frame_to_field_return(
+                         const T_type_definitions    & type_definitions,
+                               T_frame_data          & in_out_frame_data,
+                               T_interpret_data      & interpret_data,
+                         const T_field_type_name     & field_type_name,
+                         const string                & data_name,
+                         const string                & data_simple_name,
+                               ostream               & os_out,
+                               ostream               & os_err)
+{
+    M_TRACE_ENTER ("frame_to_field_return", "data_name=" << data_name);
+
+    const T_expression  & return_expression = field_type_name.get_return_expression();
+
+    if (return_expression.is_defined() == false)
+    {
+        // No return value.
+        throw  C_byte_interpret_exception_return(M_WHERE, E_byte_interpret_exception_return, "return called outside a struct");
+    }
+
+    // Return value.
+    throw  C_byte_interpret_exception_return(M_WHERE,
+                                             E_byte_interpret_exception_return,
+                                             "return called outside a struct",
+                                             return_expression.compute_expression(type_definitions, interpret_data, in_out_frame_data,
+                                                                data_name, data_simple_name, os_out, os_err));
+
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_field_while *******************************************************
+//*****************************************************************************
+
+bool    frame_to_field_while(
+                         const T_type_definitions    & type_definitions,
+                               T_frame_data          & in_out_frame_data,
+                               T_interpret_data      & interpret_data,
+                         const T_field_type_name     & field_type_name,
+                         const string                & data_name,
+                         const string                & data_simple_name,
+                               ostream               & os_out,
+                               ostream               & os_err)
+{
+    M_TRACE_ENTER ("frame_to_field_while", "data_name=" << data_name);
+
+    const string  & type = field_type_name.type;
+
+    const T_expression  & condition_expression = field_type_name.get_condition_expression();
+
+    string    new_data_name = data_name;
+    if (new_data_name != "")
+        new_data_name += K_ATTRIBUTE_SEPARATOR;
+
+    bool      must_not_test_1st_time = (type == "do_while");
+    size_t    idx_while = 0;
+    while (must_not_test_1st_time ||
+           condition_expression.compute_expression(type_definitions, interpret_data, in_out_frame_data,
+                              data_name, data_simple_name, os_out, os_err).get_bool ())
+    {
+        must_not_test_1st_time = false;
+
+        try {
+            if (frame_to_struct_inline (type_definitions,
+                                 in_out_frame_data,
+                                 interpret_data,
+                                *field_type_name.P_sub_struct,
+                                 get_array_idx_name (new_data_name,
+                                                     idx_while),
+                                 "",
+                                 os_out,
+                                 os_err) != true)
+            {
+                os_err << "Error field data= " << data_name << endl;
+            }
+        }
+        catch(C_byte_interpret_exception_loop  & val)
+        {
+            if ((val.get_cause() == E_byte_interpret_exception_loop_break) ||
+                (val.get_cause() == E_byte_interpret_exception_loop_deep_break))
+                break;
+            // nothing to do on continue
+        }
+        ++idx_while;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_field_loop_size ***************************************************
+//*****************************************************************************
+
+bool    frame_to_field_loop_size(
+                         const T_type_definitions    & type_definitions,
+                               T_frame_data          & in_out_frame_data,
+                               T_interpret_data      & interpret_data,
+                         const T_field_type_name     & field_type_name,
+                         const string                & data_name,
+                         const string                & data_simple_name,
+                               ostream               & os_out,
+                               ostream               & os_err)
+{
+    M_TRACE_ENTER ("frame_to_field_loop_size", "data_name=" << data_name);
+
+    const string  & type = field_type_name.type;
+
+    const T_expression  & condition_expression = field_type_name.get_condition_expression();
+
+    string    new_data_name = data_name;
+    if (new_data_name != "")
+        new_data_name += K_ATTRIBUTE_SEPARATOR;
+
+    long long   bit_size_to_reach = condition_expression.compute_expression(type_definitions, interpret_data,
+                                                       in_out_frame_data,
+                                                       data_name, data_simple_name,
+                                                       os_out, os_err).get_int ();
+    if (type == "loop_size_bytes")
+    {
+        bit_size_to_reach *= 8;
+    }
+
+    T_frame_data    orig_frame_data = in_out_frame_data;
+    size_t          idx_while = 0;
+    while ((in_out_frame_data.get_bit_offset() - orig_frame_data.get_bit_offset()) < bit_size_to_reach)
+    {
+        try {
+            if (frame_to_struct_inline (type_definitions,
+                                 in_out_frame_data,
+                                 interpret_data,
+                                *field_type_name.P_sub_struct,
+                                 get_array_idx_name (new_data_name,
+                                                     idx_while),
+                                 "",
+                                 os_out,
+                                 os_err) != true)
+            {
+                os_err << "Error field data= " << data_name << endl;
+            }
+        }
+        catch(C_byte_interpret_exception_loop  & val)
+        {
+            if ((val.get_cause() == E_byte_interpret_exception_loop_break) ||
+                (val.get_cause() == E_byte_interpret_exception_loop_deep_break))
+                break;
+            // nothing to do on continue
+        }
+        ++idx_while;
+    }
+
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_field_loop_nb_times ***********************************************
+//*****************************************************************************
+
+bool    frame_to_field_loop_nb_times(
+                         const T_type_definitions    & type_definitions,
+                               T_frame_data          & in_out_frame_data,
+                               T_interpret_data      & interpret_data,
+                         const T_field_type_name     & field_type_name,
+                         const string                & data_name,
+                         const string                & data_simple_name,
+                               ostream               & os_out,
+                               ostream               & os_err)
+{
+    M_TRACE_ENTER ("frame_to_field_loop_nb_times", "data_name=" << data_name);
+
+    const T_expression  & condition_expression = field_type_name.get_condition_expression();
+
+    string    new_data_name = data_name;
+    if (new_data_name != "")
+        new_data_name += K_ATTRIBUTE_SEPARATOR;
+
+    const long long  nb_times = condition_expression.compute_expression(type_definitions,
+                                                                        interpret_data, in_out_frame_data,
+                                                                        data_name, data_simple_name,
+                                                                        os_out, os_err).get_int ();
+    for (int idx_while = 0; idx_while < nb_times; ++idx_while)
+    {
+        try {
+            if (frame_to_struct_inline (type_definitions,
+                                 in_out_frame_data,
+                                 interpret_data,
+                                *field_type_name.P_sub_struct,
+                                 get_array_idx_name (new_data_name,
+                                                     idx_while),
+                                 "",
+                                 os_out,
+                                 os_err) != true)
+            {
+                os_err << "Error field data= " << data_name << endl;
+            }
+        }
+        catch(C_byte_interpret_exception_loop  & val)
+        {
+            if ((val.get_cause() == E_byte_interpret_exception_loop_break) ||
+                (val.get_cause() == E_byte_interpret_exception_loop_deep_break))
+                break;
+            // nothing to do on continue
+        }
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_field_if **********************************************************
+//*****************************************************************************
+
+bool    frame_to_field_if(
+                         const T_type_definitions    & type_definitions,
+                               T_frame_data          & in_out_frame_data,
+                               T_interpret_data      & interpret_data,
+                         const T_field_type_name     & field_type_name,
+                         const string                & data_name,
+                         const string                & data_simple_name,
+                               ostream               & os_out,
+                               ostream               & os_err)
+{
+    M_TRACE_ENTER ("frame_to_field_if", "data_name=" << data_name);
+
+    const T_expression  & condition_expression = field_type_name.get_condition_expression();
+
+    if (condition_expression.compute_expression(type_definitions, interpret_data, in_out_frame_data,
+                           data_name, data_simple_name, os_out, os_err).get_bool ())
+    {
+        if (frame_to_struct_inline (type_definitions,
+                             in_out_frame_data,
+                             interpret_data,
+                            *field_type_name.P_sub_struct,
+                             data_name,
+                             "",
+                             os_out,
+                             os_err) != true)
+        {
+            os_err << "Error field data= " << data_name << endl;
+        }
+    }
+    else if (field_type_name.sub_struct_2.empty () == false)
+    {
+        if (frame_to_fields (type_definitions,
+                             in_out_frame_data,
+                             interpret_data,
+                             field_type_name.sub_struct_2,
+                             data_name,
+                             "",
+                             os_out,
+                             os_err) != true)
+        {
+            os_err << "Error field data= " << data_name << endl;
+        }
+    }
+
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_field_other *******************************************************
+//*****************************************************************************
+
+bool    frame_to_field_other(
+                         const T_type_definitions    & type_definitions,
+                               T_frame_data          & in_out_frame_data,
+                               T_interpret_data      & interpret_data,
+                         const T_field_type_name     & field_type_name,
+                         const string                & data_name,
+                         const string                & data_simple_name,
+                               ostream               & os_out,
+                               ostream               & os_err)
+{
+    M_TRACE_ENTER ("frame_to_field_other", "data_name=" << data_name);
+
+    const string  & type = field_type_name.type;
+    const string  & name = field_type_name.name;
+
+    M_TRACE_DEBUG ("type=" << type << "  name=" << name);
+
+    string    new_data_name = data_name;
+
+    {
+        if (name != "")
+        {
+            if (new_data_name != "")
+                new_data_name += K_ATTRIBUTE_SEPARATOR;
+            new_data_name += name;
+        }
+
+        // Compute all arrays size and total size.
+#define K_ARRAY_MAGIC_NUMBER  50
+        long    array_sizes[K_ARRAY_MAGIC_NUMBER];
+        long    array_indexes[K_ARRAY_MAGIC_NUMBER];
+        long    number_of_elements = 1;
+        long    number_of_elements_before_LONG_MAX = 1;
+        bool    LONG_MAX_is_plus = false;
+
+        const bool    is_an_array = field_type_name.is_an_array();
+        const int     number_of_arrays = field_type_name.str_arrays.size();
+
+        for (int   array_idx = 0; array_idx < number_of_arrays; ++array_idx)
+        {
+            const T_field_type_name::T_array  & field_array = field_type_name.str_arrays[array_idx];
+            long                                array_size = -1;
+
+            if (field_array.size_type != T_field_type_name::T_array::E_size_normal)
+            {
+                if (array_idx != (number_of_arrays - 1))
+                {
+                    // NB: already tested into build_field
+                    M_FATAL_COMMENT("[*] or [+] are only accepted on the last array level");
+                }
+
+                array_size = LONG_MAX;
+                if (field_array.size_type == T_field_type_name::T_array::E_size_unknow_at_least_1)
+                {
+                    LONG_MAX_is_plus = true;
+                }
+            }
+            else
+            {
+                // Compute the array size.
+                const C_value  & value = field_array.size_expression.compute_expression(
+                                                      type_definitions, interpret_data, in_out_frame_data,
+                                                      data_name, data_simple_name, os_out, os_err);
+
+                if (value.get_type () == C_value::E_type_integer)
+                {
+                    array_size = static_cast<long>(value.get_int ());
+                }
+
+                if (array_size < 0)  /* taille variable == 0 OK */
+                {
+                    const string  & str_array_size = field_array.size_expression.get_original_string_expression();
+                    os_err << "Error array size= " << str_array_size
+                           << " data= " << data_name << endl;
+                    interpret_builder_error(type_definitions, in_out_frame_data,
+                                            field_type_name, data_name, data_simple_name,
+                                            "Error array size= " + str_array_size + " for " + data_simple_name);
+                    return  false;
+                }
+            }
+
+            array_sizes[array_idx] = array_size;
+            array_indexes[array_idx] = 0;
+            if (array_size == LONG_MAX)
+            {
+                if (number_of_elements == LONG_MAX)
+                {
+                    // NB: already tested into build_field and before in this loop
+                    M_FATAL_COMMENT("Could not have 2 [*] or [+] in multiple array");
+                }
+                number_of_elements_before_LONG_MAX = number_of_elements;
+                number_of_elements = LONG_MAX;
+            }
+            else
+            {
+                number_of_elements *= array_size;
+                number_of_elements_before_LONG_MAX = number_of_elements;
+            }
+
+            M_TRACE_DEBUG("[" << array_idx << "]  " <<
+                          "array_size=" << array_sizes[array_idx] << "  " <<
+                          "number_of_elements=" << number_of_elements);
+
+            if (array_size == 0)
+            {
+                number_of_elements = 0;  // in case it was LONG_MAX
+                break;
+            }
+        }
+
+        // Take care of trailer only when [*] or [+]
+        // In other cases :
+        // - trailer is not our problem, it should be read normally
+        // - and so, we can be inside the trailer
+        const long  trailer_sizeof_bits = (number_of_elements == LONG_MAX) ? type_definitions.trailer_sizeof_bits : 0;
+
+        // Read all elements of all arrays (1 elt if no array).
+        for (long  element_idx = 0; element_idx < number_of_elements; ++element_idx)
+        {
+            const long    sizeof_bits = in_out_frame_data.get_remaining_bits();
+            const long    without_trailer_sizeof_bits = sizeof_bits - trailer_sizeof_bits;
+
+            // Compute data_simple_array_name
+            string  new_data_array_name    = new_data_name;
+            string  data_simple_array_name = field_type_name.name;
+            for (int   array_idx = 0; array_idx < number_of_arrays; ++array_idx)
+            {
+                new_data_array_name += "[";
+                new_data_array_name += get_string(array_indexes[array_idx]);
+                new_data_array_name += "]";
+                data_simple_array_name += "[";
+                data_simple_array_name += get_string(array_indexes[array_idx]);
+                data_simple_array_name += "]";
+            }
+
+            // Check remaining data size
+            // Only for array and not for variable.
+            // Only if no decode or decode in progress.   2011/03/31
+            if ((without_trailer_sizeof_bits <= 0) &&
+                (is_an_array == true) &&
+                (field_type_name.is_a_variable() == false) &&
+                ((interpret_data.must_decode() == false) ||
+                 (interpret_data.is_decode_in_progress() == true)))
+            {
+                // Error except if * or +
+                if ((number_of_elements == LONG_MAX) &&
+                    ((element_idx % number_of_elements_before_LONG_MAX) == 0))
+                {
+                    if ((LONG_MAX_is_plus == false) || (element_idx > 0))
+                    {
+                        break;
+                    }
+                }
+
+                // Triggers invalid error on array of struct containing only variables.  2013/10/06
+#if 0
+                os_err << "Error array"
+                       << " data= " << data_simple_array_name
+                       << " : no more data to read" << endl;
+                interpret_builder_missing_data(type_definitions, in_out_frame_data, interpret_data,
+                                        field_type_name, new_data_array_name, data_simple_array_name,
+                                        "End array : no more data to read " + data_simple_array_name);
+                M_FATAL_MISSING_DATA();
+                return  false;
+#endif
+            }
+
+// ICIOA il faut supprimer les tests fait dans C_byte_interpret_wsgd_builder::group_begin ?
+            bool  is_a_group_and_not_inline = true;
+            if ((field_type_name.basic_type_bit_size >= 0) ||        // known size = not a group
+
+                // Blocks which are not VISUALLY groups
+                (field_type_name.name == "") ||                      // inline
+                (field_type_name.type == "call") ||                  // function (ie inline)
+//                (field_type_name.type == "if") ||
+//                (field_type_name.type == "while") ||
+//                (field_type_name.type == "do") ||
+//                (field_type_name.type == "do_while") ||
+//                (field_type_name.type == "loop_size_bytes") ||
+//                (field_type_name.type == "loop_size_bits") ||
+//                (field_type_name.type == "loop_nb_items") ||
+
+                (field_type_name.type == "msg") ||
+
+                // Commands
+                (field_type_name.type == "set") ||
+                (field_type_name.type == "save_position") ||
+                (field_type_name.type == "goto_position") ||
+                (field_type_name.type == "move_position_bytes") ||
+                (field_type_name.type == "move_position_bits") ||
+                (field_type_name.type == "chrono") ||
+                (field_type_name.type == "byte_order") ||
+                (field_type_name.type == "debug_print") ||
+                (field_type_name.type == "print") ||
+                (field_type_name.type == "chat") ||
+                (field_type_name.type == "note") ||
+                (field_type_name.type == "warning") ||
+                (field_type_name.type == "error") ||
+                (field_type_name.type == "fatal") ||
+                (field_type_name.type == "check_eof_distance_bytes") ||
+                (field_type_name.type == "check_eof_distance_bits") ||
+                (field_type_name.type == "output") ||
+                
+                // Data (without known size) which are not group
+                (field_type_name.type == "padding_bits") ||
+                (field_type_name.type == "raw") ||
+                (field_type_name.type == "subproto") ||
+                (field_type_name.type == "insproto") ||
+                (field_type_name.type == "string") ||
+                (field_type_name.type == "string_nl"))
+// ICIOA systeme A REVOIR
+            {
+                is_a_group_and_not_inline = false;
+            }
+
+            if (is_a_group_and_not_inline)
+            {
+                interpret_data.read_variable_group_begin(data_simple_array_name);
+
+                if (interpret_data.must_output ())
+                {
+                    interpret_builder_group_begin (type_definitions,
+                                                in_out_frame_data,
+                                                field_type_name,
+                                                new_data_array_name /*data_name*/,
+                                                data_simple_array_name /*field_type_name.name*/ /*data_simple_name*/);
+                }
+            }
+
+            bool                               is_exception_loop_catched = false;
+            C_byte_interpret_exception_loop       exception_loop_catched;
+            bool                               is_exception_return_catched = false;
+            C_byte_interpret_exception_return     exception_return_catched;
+
+            try
+            {
+                if (type == "struct")
+                {
+                    // Inline struct
+                    if (frame_to_struct_inline (type_definitions,
+                                         in_out_frame_data,
+                                         interpret_data,
+                                        *field_type_name.P_sub_struct,
+                                         new_data_array_name /*new_data_name*/,
+                                         data_simple_array_name /*field_type_name.name*/,
+                                         os_out,
+                                         os_err) != true)
+                    {
+                        os_err << "Error field data= " << data_name << endl;
+                    }
+                }
+                else if (type == "bitfield")
+                {
+                    // Inline bitfield
+                    if (frame_to_bitfield_inline (type_definitions,
+                                         in_out_frame_data,
+                                         interpret_data,
+                                        *field_type_name.P_bitfield_inline,
+                                         new_data_array_name /*new_data_name*/,
+                                         data_simple_array_name /*field_type_name.name*/,
+                                         os_out,
+                                         os_err) != true)
+                    {
+                        os_err << "Error field data= " << data_name << endl;
+                    }
+                }
+                else if (type == "switch")
+                {
+                    // Inline switch
+//                    if (frame_to_switch_inline (type_definitions,
+                    if (frame_to_switch (type_definitions,
+                                         in_out_frame_data,
+                                         interpret_data,
+                                        *field_type_name.P_switch_inline,
+                                         field_type_name.str_size_or_parameter,
+                                         field_type_name,
+                                         new_data_array_name /*new_data_name*/,
+                                         data_simple_array_name /*field_type_name.name*/,
+                                         os_out,
+                                         os_err) != true)
+                    {
+                        os_err << "Error field data= " << data_name << endl;
+                    }
+                }
+                else if (frame_to_any (type_definitions,
+                                  in_out_frame_data,
+                                  interpret_data,
+                                  field_type_name,
+                                  new_data_array_name /*new_data_name*/,
+                                  data_simple_array_name /*field_type_name.name*/,
+                                  os_out,
+                                  os_err) != true)
+                {
+                    os_err << "Error field data= " << data_name << endl;
+                }
+            }
+            catch(C_byte_interpret_exception_loop  & val)
+            {
+                is_exception_loop_catched = true;
+                exception_loop_catched = val;
+                // nothing to do here
+            }
+            catch(C_byte_interpret_exception_return  & val)
+            {
+                is_exception_return_catched = true;
+                exception_return_catched = val;
+                // nothing to do here
+            }
+
+            if (is_a_group_and_not_inline)
+            {
+                interpret_data.read_variable_group_end();
+
+                if (interpret_data.must_output ())
+                {
+                    interpret_builder_group_end (type_definitions,
+                                                in_out_frame_data,
+                                                field_type_name,
+                                                new_data_array_name /*data_name*/,
+                                                data_simple_array_name /*field_type_name.name*/ /*data_simple_name*/,
+                                                sizeof_bits - in_out_frame_data.get_remaining_bits());
+                }
+            }
+
+            if (is_exception_loop_catched)
+                throw  exception_loop_catched;
+
+            if (is_exception_return_catched)
+                throw  exception_return_catched;
+
+            // Compute new indexes for next element.
+            for (int   array_idx = 0; array_idx < number_of_arrays; ++array_idx)
+            {
+                ++array_indexes[array_idx];
+                if ((array_indexes[array_idx] % array_sizes[array_idx]) != 0)
+                {
+                    break;
+                }
+                array_indexes[array_idx] = 0;
+            }
+        }
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_field *************************************************************
+//*****************************************************************************
+
+bool    frame_to_field  (const T_type_definitions    & type_definitions,
+                               T_frame_data          & in_out_frame_data,
+                               T_interpret_data      & interpret_data,
+                         const T_field_type_name     & field_type_name,
+                         const string                & data_name,
+                         const string                & data_simple_name,
+                               ostream               & os_out,
+                               ostream               & os_err)
+{
+    M_TRACE_ENTER ("frame_to_field", "data_name=" << data_name);
+
+    if (field_type_name.pf_frame_to_field == nullptr)
+    {
+        // Normally set at initialisation time for all types into type_definitions.
+        // But some field_type_name could be created on the fly.
+        build_types_finalize_itself(type_definitions, field_type_name);
+
+        if (field_type_name.pf_frame_to_field == nullptr)
+        {
+            //-------------------------------------------------------------------------
+            // Error
+            //-------------------------------------------------------------------------
+            interpret_builder_error(type_definitions, in_out_frame_data,
+                                    field_type_name, data_name, data_simple_name,
+                                    "Not valid type " + field_type_name.type);
+            return  false;
+        }
+    }
+
+    return  field_type_name.pf_frame_to_field(type_definitions,
+                                               in_out_frame_data,
+                                               interpret_data,
+                                               field_type_name,
+                                               data_name,
+                                               data_simple_name,
+                                               os_out, os_err);
+}
+
+//*****************************************************************************
+// frame_to_fields ************************************************************
+//*****************************************************************************
+
+bool    frame_to_fields (const T_type_definitions    & type_definitions,
+                               T_frame_data          & in_out_frame_data,
+                               T_interpret_data      & interpret_data,
+                         const T_struct_fields       & struct_fields,
+                         const string                & data_name,
+                         const string                & data_simple_name,
+                               ostream               & os_out,
+                               ostream               & os_err)
+{
+    M_TRACE_ENTER ("frame_to_fields", "");
+
+    for (T_struct_fields::size_type  idx = 0;
+                                     idx < struct_fields.size ();
+                                   ++idx)
+    {
+        if (frame_to_field (type_definitions,
+                            in_out_frame_data,
+                            interpret_data,
+                            struct_fields[idx],
+                            data_name,
+                            data_simple_name,
+                            os_out,
+                            os_err) != true)
+        {
+            os_err << "Error struct idx= " << idx
+                   << " data= " << data_name << endl;
+        }
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_struct_base *******************************************************
+//*****************************************************************************
+
+bool    frame_to_struct_base (const T_type_definitions    & type_definitions,
+                               T_frame_data          & in_out_frame_data,
+                               T_interpret_data      & interpret_data,
+                         const T_struct_definition   & struct_definition,
+                         const string                & data_name,
+                         const string                & data_simple_name,
+                               ostream               & os_out,
+                               ostream               & os_err,
+                               bool                    must_catch_return)
+{
+    M_TRACE_ENTER ("frame_to_struct_base", "must_catch_return=" << must_catch_return);
+
+    bool    result = true;
+
+    try
+    {
+        result = frame_to_fields(type_definitions, in_out_frame_data, interpret_data,
+                            struct_definition.fields,
+                            data_name, data_simple_name,
+                            os_out, os_err);
+    }
+    catch (C_byte_interpret_exception_normal  & val)
+    {
+//        catched_exception = val;        // slicing pb
+//        P_catched_exception = &val;     // scope pb
+
+        // Even with a normal exception, I try to print the text.
+        // But it is possible (because of break, continue, return ...)
+        //  that the data to print is not available
+        // -> fatal
+        // It is not my problem (at least for now) : the user must manage it.
+        // Other possibilities are :
+        // - do not print the text (but I do not see why)
+        // - print and catch possible exception (and warn the user)
+        if ((struct_definition.printf_args != "") && (interpret_data.must_output ()))
+        {
+            const C_value   printf_result_value = printf_args_to_string(type_definitions, interpret_data, in_out_frame_data,
+                                                                        struct_definition.printf_args,
+                                                                        data_name, data_simple_name, os_out, os_err);
+            const string    printf_result = printf_result_value.as_string();
+
+            interpret_builder_group_append_text(type_definitions, in_out_frame_data,
+                                                data_name, data_simple_name,
+                                                printf_result);
+        }
+
+        if ((must_catch_return != true) ||                 // inline struct
+            (val.get_cause() == E_byte_interpret_exception_loop_deep_break) ||
+            (val.get_cause() == E_byte_interpret_exception_loop_deep_continue))
+        {
+            throw;    // re-throw the exception
+        }
+
+        // We are inside a normal struct, ie not inline,
+        //  so ...
+        if (val.get_cause() == E_byte_interpret_exception_return)
+        {
+            // return exception stops here : ok
+            return  true;
+        }
+        if ((val.get_cause() == E_byte_interpret_exception_loop_break) ||
+            (val.get_cause() == E_byte_interpret_exception_loop_continue))
+        {
+            // loop_break and loop_continue exceptions stop here : NOT ok
+            //  supposed to be catched before -> fatal
+            M_FATAL_COMMENT(val.get_explanation());
+        }
+
+        throw;    // re-throw the other exceptions
+    }
+
+    if ((struct_definition.printf_args != "") && (interpret_data.must_output ()))
+    {
+        const C_value   printf_result_value = printf_args_to_string(type_definitions, interpret_data, in_out_frame_data,
+                                                                    struct_definition.printf_args,
+                                                                    data_name, data_simple_name, os_out, os_err);
+        const string    printf_result = printf_result_value.as_string();
+
+        interpret_builder_group_append_text(type_definitions, in_out_frame_data,
+                                            data_name, data_simple_name,
+                                            printf_result);
+    }
+
+    return  result;
+}
+
+//*****************************************************************************
+// frame_to_struct_inline *****************************************************
+//*****************************************************************************
+
+bool    frame_to_struct_inline (const T_type_definitions    & type_definitions,
+                               T_frame_data          & in_out_frame_data,
+                               T_interpret_data      & interpret_data,
+                         const T_struct_definition   & struct_definition,
+                         const string                & data_name,
+                         const string                & data_simple_name,
+                               ostream               & os_out,
+                               ostream               & os_err)
+{
+    return  frame_to_struct_base(type_definitions,
+                                   in_out_frame_data,
+                                   interpret_data,
+                                   struct_definition,
+                                   data_name, data_simple_name,
+                                   os_out, os_err,
+                                   false /* must_catch_return */);
+}
+
+//*****************************************************************************
+// frame_to_struct ************************************************************
+//*****************************************************************************
+
+bool    frame_to_struct (const T_type_definitions    & type_definitions,
+                               T_frame_data          & in_out_frame_data,
+                               T_interpret_data      & interpret_data,
+                         const T_struct_definition   & struct_definition,
+                         const string                & data_name,
+                         const string                & data_simple_name,
+                               ostream               & os_out,
+                               ostream               & os_err)
+{
+    return  frame_to_struct_base(type_definitions,
+                                   in_out_frame_data,
+                                   interpret_data,
+                                   struct_definition,
+                                   data_name, data_simple_name,
+                                   os_out, os_err,
+                                   true /* must_catch_return */);
+}
+
+//*****************************************************************************
+// frame_to_bitfield_inline ***************************************************
+//*****************************************************************************
+
+bool    frame_to_bitfield_inline (
+                         const T_type_definitions      & type_definitions,
+                               T_frame_data            & in_out_frame_data,
+                               T_interpret_data        & interpret_data,
+                         const T_bitfield_definition   & bitfield_definition,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err)
+{
+    M_TRACE_ENTER ("frame_to_bitfield_inline", "");
+
+    bool                is_little_endian = interpret_data.is_little_endian();
+
+    if (bitfield_definition.is_a_bitstream && is_little_endian)
+    {
+        interpret_data.set_big_endian();
+    }
+
+    if (frame_to_any (type_definitions,
+                         in_out_frame_data,
+                         interpret_data,
+                         bitfield_definition.master_field,
+                         data_name,
+                       /*  data_simple_name, */
+                         bitfield_definition.master_field.name,
+                         os_out, os_err) != true)
+    {
+        os_err << "Error bitfield master_field"
+               << " data= " << data_name << endl;
+        return  false;
+    }
+
+    if (bitfield_definition.is_a_bitstream && is_little_endian)
+    {
+        interpret_data.set_little_endian();
+    }
+
+    if (frame_to_fields (type_definitions,
+                         in_out_frame_data,
+                         interpret_data,
+                         bitfield_definition.fields_definition,
+                         data_name,
+                         data_simple_name,
+                         os_out, os_err) != true)
+    {
+        os_err << "Error bitfield fields_definition"
+               << " data= " << data_name << endl;
+        return  false;
+    }
+
+    if (interpret_data.must_output ())
+    {
+        const C_value   printf_result_value = printf_args_to_string(type_definitions, interpret_data, in_out_frame_data,
+                                                                    "(\"  %s\", last_bitfield_value)",
+                                                                    data_name, data_simple_name, os_out, os_err);
+        const string    printf_result = printf_result_value.as_string();
+
+        interpret_builder_group_append_text(type_definitions, in_out_frame_data,
+                                            data_name, data_simple_name,
+                                            printf_result);
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_bitfield **********************************************************
+//*****************************************************************************
+
+bool    frame_to_bitfield (
+                         const T_type_definitions      & type_definitions,
+                               T_frame_data            & in_out_frame_data,
+                               T_interpret_data        & interpret_data,
+                         const T_bitfield_definition   & bitfield_definition,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err)
+{
+    return  frame_to_bitfield_inline(type_definitions,
+                                   in_out_frame_data,
+                                   interpret_data,
+                                   bitfield_definition,
+                                   data_name, data_simple_name,
+                                   os_out, os_err);
+}
+
+//*****************************************************************************
+// frame_to_switch ************************************************************
+//*****************************************************************************
+
+bool    frame_to_switch (const T_type_definitions      & type_definitions,
+                               T_frame_data            & in_out_frame_data,
+                               T_interpret_data        & interpret_data,
+                         const T_switch_definition     & switch_def,
+                         const string                  & discriminant_str,
+                         const T_field_type_name       & field_type_name,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err)
+{
+    M_TRACE_ENTER ("frame_to_switch", "");
+
+    const T_switch_cases       & switch_cases = switch_def.switch_cases;
+
+    C_value    discriminant_value = switch_def.is_switch_expr ?
+                                               C_value() :
+                                               compute_expression_no_io (type_definitions,
+                                                                         interpret_data,
+                                                                         discriminant_str);
+
+    const bool    is_discriminant_value_int = discriminant_value.get_type() == C_value::E_type_integer;
+
+    for (T_switch_cases::size_type  idx = 0; idx < switch_cases.size (); ++idx)
+    {
+        bool    case_found = false;
+
+        if (switch_cases[idx].is_default_case)
+        {
+            case_found = true;
+        }
+        else if (switch_def.is_switch_expr == true)
+        {
+            T_expression const &   case_expr = switch_cases[idx].case_expr;
+            C_value const &        case_value = case_expr.compute_expression(
+                                                                  type_definitions,
+                                                                  interpret_data,
+                                                                  in_out_frame_data,
+                                                                  data_name,
+                                                                  data_simple_name,
+                                                                  os_out,
+                                                                  os_err);
+            M_FATAL_IF_NE(case_value.get_type(), C_value::E_type_integer);
+            if (case_value.get_int() != 0 /*false*/)
+            {
+                case_found = true;
+            }
+        }
+        else
+        {
+            M_FATAL_IF_NE(discriminant_value.get_type(), switch_cases[idx].case_value.get_type());
+
+            if (is_discriminant_value_int)
+            {
+                if (switch_cases[idx].case_value.get_int() == discriminant_value.get_int())
+                {
+                    case_found = true;
+                }
+            }
+            else
+            {
+                if (switch_cases[idx].case_value.get_str() == discriminant_value.get_str())
+                {
+                    case_found = true;
+                }
+            }
+        }
+
+        if (case_found)
+        {
+            if (frame_to_fields (type_definitions,
+                                 in_out_frame_data,
+                                 interpret_data,
+                                 switch_cases[idx].fields,
+                                 data_name,
+                                 data_simple_name,
+                                 os_out, os_err) != true)
+            {
+                os_err << "Error switch idx= " << idx
+                       << " data= " << data_name << endl;
+            }
+
+            return  true;
+        }
+    }
+
+    os_err << "Error switch bad value " << discriminant_value.as_string()
+           << " data= " << data_name << endl;
+    interpret_builder_error(type_definitions, in_out_frame_data,
+                            field_type_name, data_name, data_simple_name,
+                            "Error switch bad value " + discriminant_value.as_string() + " data= " + data_simple_name);
+
+    return  false;
+}
+
+//*****************************************************************************
+// post_treatment_value_transform *********************************************
+//*****************************************************************************
+
+void    post_treatment_value_transform (
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                         const T_field_type_name_base  & field_type_name,
+                               T_attribute_value       & attribute_value)
+{
+    C_value  value = attribute_value.get_value();
+    bool     modified = false;
+
+    // Transform
+    if (field_type_name.transform_expression.is_defined())
+    {
+        // Add this value into the interpret_data (to be accessible inside compute_expression).
+        T_interpret_read_values::T_id  this_id = interpret_data.add_read_variable("this", value);
+
+        // Compute specified expression.
+        value = field_type_name.transform_expression.compute_expression_no_io(type_definitions, interpret_data);
+
+        // Suppress this variable
+        interpret_data.sup_read_variable(this_id);
+        modified = true;
+    }
+
+    if (field_type_name.transform_quantum.as_string() != "")
+    {
+        value *= field_type_name.transform_quantum;
+        modified = true;
+    }
+
+    if (field_type_name.transform_offset.as_string() != "")
+    {
+        value += field_type_name.transform_offset;
+        modified = true;
+    }
+
+    if (modified)
+    {
+        attribute_value.set_value_transformed(value);
+    }
+}
+
+//*****************************************************************************
+// post_treatment_value_display ***********************************************
+//*****************************************************************************
+
+void    post_treatment_value_display (
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                         const T_field_type_name_base  & field_type_name,
+                               T_attribute_value       & attribute_value)
+{
+    // Display
+    if (field_type_name.str_display != "")
+    {
+        C_value  value = attribute_value.get_value();
+        value.format(field_type_name.str_display);
+        attribute_value.set_value_transformed(value);
+    }
+    else if (field_type_name.str_display_expression != "")
+    {
+//        M_TRACE_ENTER ("post_treatment_value", "display expression");
+        const C_value &  value = attribute_value.get_value();
+
+        // Add this value into the interpret_data (to be accessible inside compute_expression).
+        T_interpret_read_values::T_id  this_id = interpret_data.add_read_variable("this", value);
+
+        // Compute specified expression.
+        C_value  str_value = compute_expression_no_io(type_definitions, interpret_data, field_type_name.str_display_expression);
+
+        // The computed value must be a string.
+        attribute_value.change_value_str_only(str_value.get_str());
+
+        // Suppress this variable
+        interpret_data.sup_read_variable(this_id);
+    }
+}
+
+//*****************************************************************************
+// post_treatment_value_check *************************************************
+//*****************************************************************************
+
+bool    post_treatment_value_check (
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                         const T_field_type_name_base  & field_type_name,
+                         const T_attribute_value       & attribute_value,
+                               std::string             & error)
+{
+    const C_value  & value = attribute_value.get_value();
+
+    // Check constraints (the order is revelant)
+    for (vector<T_field_constraint>::const_iterator  iter  = field_type_name.constraints.begin();
+                                                     iter != field_type_name.constraints.end();
+                                                   ++iter)
+    {
+        const T_field_constraint  & constraint = *iter;
+
+        if (constraint.equal.as_string() != "")
+        {
+            if (value == constraint.equal)
+            {
+                error = "";
+                break;
+            }
+
+            if (value < constraint.equal)
+            {
+                if (error == "")
+                {
+                    error = "ERROR";
+                }
+                else
+                {
+                    error += " and";
+                }
+                error += " is != to " + constraint.equal.as_string();
+                return  false;
+            }
+            else
+            {
+                error = "ERROR is != to " + constraint.equal.as_string();
+            }
+        }
+
+        if (constraint.min.as_string() != "")
+        {
+            if (value < constraint.min)
+            {
+                if (error == "")
+                {
+                    error = "ERROR";
+                }
+                else
+                {
+                    error += " and";
+                }
+                error += " is < to " + constraint.min.as_string();
+                return  false;
+            }
+            error = "";
+        }
+
+        if (constraint.max.as_string() != "")
+        {
+            if (value > constraint.max)
+            {
+                error = "ERROR is > to " + constraint.max.as_string();
+            }
+            else
+            {
+                break;
+            }
+        }
+    }
+    if (error != "")
+    {
+        return  false;
+    }
+
+    // Check string length
+    if ((value.get_type() == C_value::E_type_string) &&
+        (field_type_name.str_size_or_parameter != ""))
+    {
+        // Compute specified expression.
+        C_value  size_value = compute_expression_no_io(type_definitions, interpret_data, field_type_name.str_size_or_parameter);
+
+        // The computed value must be a integer.
+        if (value.get_str().size() > size_value.get_int())
+        {
+            error = "ERROR length > to " + field_type_name.str_size_or_parameter;
+            return  false;
+        }
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// post_treatment_value *******************************************************
+//*****************************************************************************
+
+bool    post_treatment_value (
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                         const T_field_type_name_base  & field_type_name,
+                               T_attribute_value       & attribute_value,
+                               std::string             & error)
+{
+    // No statement value
+    if (field_type_name.no_statement.as_string() != "")
+    {
+        if (attribute_value.get_value() == field_type_name.no_statement)
+        {
+            attribute_value.change_value_str_only("No_Statement");
+            return  true;
+        }
+    }
+
+    // Transform
+    post_treatment_value_transform(type_definitions, interpret_data, field_type_name, attribute_value);
+
+    // Display
+    post_treatment_value_display(type_definitions, interpret_data, field_type_name, attribute_value);
+
+    // Check
+    return  post_treatment_value_check(type_definitions, interpret_data, field_type_name, attribute_value, error);
+}
+
+//*****************************************************************************
+//
+//*****************************************************************************
+#ifdef BYTE_INTERPRET_USE_LIBRARY_DYNCALL
+#include <dyncall.h>
+
+DC_API void  dcArgUChar (DCCallVM* vm, DCuchar     value) { return  dcArgChar (vm, (DCchar) value); }
+DC_API void  dcArgUShort(DCCallVM* vm, DCushort    value) { return  dcArgShort(vm, (DCshort)value); }
+DC_API void  dcArgUInt  (DCCallVM* vm, DCuint      value) { return  dcArgInt  (vm, (DCint)  value); }
+
+DC_API DCuchar   dcCallUChar (DCCallVM* vm, DCpointer funcptr) { return  dcCallChar (vm, funcptr); }
+DC_API DCushort  dcCallUShort(DCCallVM* vm, DCpointer funcptr) { return  dcCallShort(vm, funcptr); }
+DC_API DCuint    dcCallUInt  (DCCallVM* vm, DCpointer funcptr) { return  dcCallInt  (vm, funcptr); }
+#endif
+
+//*****************************************************************************
+// T_expression_frame_to_function_base2 ***************************************
+//*****************************************************************************
+
+bool    T_expression_frame_to_function_base2 (
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const T_function_definition   & fct_def,
+                         const vector<T_expression>    & fct_parameters,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err,
+                               E_return_value_indicator  return_value_indicator,
+                               C_value                 & returned_value,
+                               bool                      pre_compute,
+                               bool                    & pre_compute_result)
+{
+    M_TRACE_ENTER ("frame_to_function_base", "");
+
+    // Check return_value_indicator.
+    if (return_value_indicator == E_return_value_mandatory)
+    {
+        if (fct_def.return_type == "void")
+        {
+            M_FATAL_COMMENT("void function can not return a value.");
+        }
+    }
+    else if (return_value_indicator == E_return_value_forbidden)
+    {
+        if (fct_def.return_type != "void")
+        {
+            M_FATAL_COMMENT("not void function return a value.");
+        }
+    }
+
+    // Check the number of parameters
+    if (fct_parameters.size() < static_cast<size_t>(fct_def.get_nb_of_mandatory_parameters()))
+    {
+        M_FATAL_COMMENT("Too few parameters for function " << data_simple_name);
+    }
+    if (fct_parameters.size() > fct_def.get_function_parameters().size())
+    {
+        M_FATAL_COMMENT("Too many parameters for function " << data_simple_name);
+    }
+
+
+    // magic number
+#define K_NBMAX_PARAMETERS  50
+
+#ifdef BYTE_INTERPRET_USE_LIBRARY_DYNCALL
+    // dyncall
+    const bool    is_dyncall = (fct_def.P_library_def != nullptr);
+    DCCallVM    * vm = nullptr;
+    struct T_dyncall_parameter
+    {
+        char                 int8;
+        unsigned char       uint8;
+        short                int16;
+        unsigned short      uint16;
+        int                  int32;
+        unsigned int        uint32;
+        long long            int64;
+        unsigned long long  uint64;
+        float               float32;
+        double              float64;
+        string              str;
+        void              * ptr;
+    } dyncall_parameters[K_NBMAX_PARAMETERS];
+
+    if ((pre_compute == false) && (is_dyncall == true))
+    {
+        const int   CallingConvention = DC_CALL_C_DEFAULT;
+        vm = dcNewCallVM (4096);
+        dcMode (vm, CallingConvention);
+        dcReset (vm);
+    }
+#endif
+
+    // Compute values.
+    T_interpret_read_values::T_id    parameters_id[K_NBMAX_PARAMETERS];
+
+    for (unsigned int   idx = 0; idx < fct_def.get_function_parameters().size(); ++idx)
+    {
+        const T_function_parameter  & function_parameter = fct_def.get_function_parameters()[idx];
+
+        if (function_parameter.direction != E_parameter_in)
+        {
+            if (fct_parameters[idx].is_a_variable() == false)
+            {
+                M_FATAL_COMMENT("out or in_out parameter[" << idx << "] must be a variable");
+            }
+        }
+        
+        if ((idx < fct_parameters.size()) && (fct_parameters[idx].is_a_variable() == true))
+        {
+            if (pre_compute == true)
+            {
+                pre_compute_result = false;
+                continue;
+            }
+        }
+
+        // Compute value.
+        bool       pre_compute_result_local = true;
+        C_value    obj_value = (idx >= fct_parameters.size()) ?
+            function_parameter.get_default_value() :
+            fct_parameters[idx].compute_expression(
+                                    type_definitions, interpret_data, in_out_frame_data,
+                                    data_name, data_simple_name, os_out, os_err,
+                                    pre_compute, pre_compute_result_local);
+
+        pre_compute_result = pre_compute_result && pre_compute_result_local;
+        if ((pre_compute == true) && (pre_compute_result_local == false))
+        {
+            continue;
+        }
+
+        // Check value type.
+        check_function_parameter_value(type_definitions, function_parameter, obj_value);
+
+        // quantum/offset/min/max/display
+        string             error_on_value;
+        T_attribute_value  obj_attribute_value(obj_value);
+        if (post_treatment_value (type_definitions, interpret_data,
+                                  function_parameter,
+                                  obj_attribute_value, error_on_value) != true)
+        {
+            M_FATAL_COMMENT("Parameter " << function_parameter.name << " : " << error_on_value);
+        }
+
+
+
+#ifdef BYTE_INTERPRET_USE_LIBRARY_DYNCALL
+        if (is_dyncall == false)
+#endif
+        {
+            if (function_parameter.direction == E_parameter_in)
+            {
+                parameters_id[idx] = interpret_data.add_read_variable(function_parameter.name, obj_attribute_value);
+            }
+            else
+            {
+                parameters_id[idx] = interpret_data.add_ref_variable(function_parameter.name, fct_parameters[idx].get_variable_name());
+            }
+        }
+#ifdef BYTE_INTERPRET_USE_LIBRARY_DYNCALL
+        else if (vm != nullptr)
+        {
+            T_dyncall_parameter  & dyncall_parameter = dyncall_parameters[idx];
+
+#undef  M_FCT_READ_SIMPLE_TYPE
+#define M_FCT_READ_SIMPLE_TYPE(TYPE_NAME,DC_FCT,FCT)                               \
+            else if (function_parameter.type == #TYPE_NAME)                        \
+            {                                                                      \
+                dyncall_parameter. TYPE_NAME = obj_value. FCT ();                  \
+                if (function_parameter.direction == E_parameter_in)                \
+                    DC_FCT(vm , dyncall_parameter. TYPE_NAME);                     \
+                else                                                               \
+                    dcArgPointer(vm , &dyncall_parameter. TYPE_NAME );             \
+            }
+
+#undef  M_FCT_READ_SIMPLE_TYPE_INT
+#define M_FCT_READ_SIMPLE_TYPE_INT(TYPE_NAME,TYPE_DC)                              \
+            M_FCT_READ_SIMPLE_TYPE(TYPE_NAME,TYPE_DC,get_int)
+
+#undef  M_FCT_READ_SIMPLE_TYPE_FLT
+#define M_FCT_READ_SIMPLE_TYPE_FLT(TYPE_NAME,TYPE_DC)                              \
+            M_FCT_READ_SIMPLE_TYPE(TYPE_NAME,TYPE_DC,get_flt)
+
+
+            if (function_parameter.type == "string")
+            {
+                // string implementation could be shared,
+                //  so copy does not duplicate data and keeps the original pointer.
+                // Which means, if out parameter, that the original string will be modified !
+//                dyncall_parameter.str = obj_value.get_str();
+                // Using c_str() avoid share. Except if share implementation method works on raw pointer !
+                dyncall_parameter.str = obj_value.get_str().c_str();
+                // Called function will directly write on raw pointer of string object !
+                // Should NOT write more than the size of the input string !
+                dcArgPointer(vm , (DCpointer)dyncall_parameter.str.c_str());
+            }
+            M_FCT_READ_SIMPLE_TYPE_INT( int8 ,dcArgChar)
+            M_FCT_READ_SIMPLE_TYPE_INT(uint8 ,dcArgUChar)
+            M_FCT_READ_SIMPLE_TYPE_INT( int16,dcArgShort)
+            M_FCT_READ_SIMPLE_TYPE_INT(uint16,dcArgUShort)
+            M_FCT_READ_SIMPLE_TYPE_INT( int32,dcArgInt)
+            M_FCT_READ_SIMPLE_TYPE_INT(uint32,dcArgUInt)
+            M_FCT_READ_SIMPLE_TYPE_INT( int64,dcArgLongLong)
+            M_FCT_READ_SIMPLE_TYPE_FLT(float32,dcArgFloat)
+            M_FCT_READ_SIMPLE_TYPE_FLT(float64,dcArgDouble)
+            else if (function_parameter.type == "pointer")
+            {
+                const T_byte     * pointer = (const T_byte *)obj_value.get_int();
+
+                dyncall_parameter.ptr = (void*)pointer;
+                dcArgPointer(vm , (DCpointer)dyncall_parameter.ptr);
+            }
+            else
+            {
+                M_FATAL_COMMENT("unknow type (" << function_parameter.type << ") for dyncall parameter");
+            }
+        }
+#endif
+    }
+
+    if ((pre_compute == true) && (pre_compute_result == false))
+    {
+        // pre_compute of parameters does not succeed
+        return  true;
+    }
+
+    if (pre_compute == true) { pre_compute_result = false; return  true; }   /* ICIOA temporaire */
+
+
+#ifdef BYTE_INTERPRET_USE_LIBRARY_DYNCALL
+    if (is_dyncall == true)
+    {
+        const T_library_definition           & library_def = * fct_def.P_library_def;
+        const T_library_function_definition  & library_function_def = library_def.library_functions[fct_def.idx_library_function_def];
+
+        if (fct_def.return_type == "void")
+        {
+            dcCallVoid(vm, library_function_def.funptr);
+        }
+        else if (fct_def.return_type == "int8")
+        {
+            returned_value = dcCallChar(vm, library_function_def.funptr);
+        }
+        else if (fct_def.return_type == "uint8")
+        {
+            returned_value = dcCallUChar(vm, library_function_def.funptr);
+        }
+        else if (fct_def.return_type == "int16")
+        {
+            returned_value = dcCallShort(vm, library_function_def.funptr);
+        }
+        else if (fct_def.return_type == "uint16")
+        {
+            returned_value = dcCallUShort(vm, library_function_def.funptr);
+        }
+        else if (fct_def.return_type == "int32")
+        {
+            returned_value = dcCallInt(vm, library_function_def.funptr);
+        }
+        else if (fct_def.return_type == "uint32")
+        {
+            returned_value = dcCallUInt(vm, library_function_def.funptr);
+        }
+        else if (fct_def.return_type == "int64")
+        {
+            returned_value = dcCallLongLong(vm, library_function_def.funptr);
+        }
+        else if (fct_def.return_type == "float32")
+        {
+            returned_value = dcCallFloat(vm, library_function_def.funptr);
+        }
+        else if (fct_def.return_type == "float64")
+        {
+            returned_value = dcCallDouble(vm, library_function_def.funptr);
+        }
+        else if (fct_def.return_type == "string")
+        {
+            returned_value = (char*)dcCallPointer(vm, library_function_def.funptr);
+        }
+        else if (fct_def.return_type == "pointer")
+        {
+            returned_value = dcCallPointer(vm, library_function_def.funptr);
+        }
+        else
+        {
+            M_FATAL_COMMENT("unknow type (" << fct_def.return_type << ") for dyncall return value");
+        }
+
+        dcFree ( vm );
+
+        for (unsigned int   idx = 0; idx < fct_def.get_function_parameters().size(); ++idx)
+        {
+            const T_function_parameter  & function_parameter = fct_def.get_function_parameters()[idx];
+
+            if (function_parameter.direction == E_parameter_in)
+                continue;
+
+            const T_expression   & fct_parameter = fct_parameters[idx];
+            T_dyncall_parameter  & dyncall_parameter = dyncall_parameters[idx];
+
+            if (function_parameter.type == "int8")
+            {
+                interpret_data.set_read_variable(fct_parameter.get_variable_name(), dyncall_parameter.int8);
+            }
+            else if (function_parameter.type == "uint8")
+            {
+                interpret_data.set_read_variable(fct_parameter.get_variable_name(), dyncall_parameter.uint8);
+            }
+            else if (function_parameter.type == "int16")
+            {
+                interpret_data.set_read_variable(fct_parameter.get_variable_name(), dyncall_parameter.int16);
+            }
+            else if (function_parameter.type == "uint16")
+            {
+                interpret_data.set_read_variable(fct_parameter.get_variable_name(), dyncall_parameter.uint16);
+            }
+            else if (function_parameter.type == "int32")
+            {
+                interpret_data.set_read_variable(fct_parameter.get_variable_name(), dyncall_parameter.int32);
+            }
+            else if (function_parameter.type == "uint32")
+            {
+                interpret_data.set_read_variable(fct_parameter.get_variable_name(), dyncall_parameter.uint32);
+            }
+            else if (function_parameter.type == "int64")
+            {
+                interpret_data.set_read_variable(fct_parameter.get_variable_name(), dyncall_parameter.int64);
+            }
+            else if (function_parameter.type == "float32")
+            {
+                interpret_data.set_read_variable(fct_parameter.get_variable_name(), dyncall_parameter.float32);
+            }
+            else if (function_parameter.type == "float64")
+            {
+                interpret_data.set_read_variable(fct_parameter.get_variable_name(), dyncall_parameter.float64);
+            }
+            else if (function_parameter.type == "string")
+            {
+                interpret_data.set_read_variable(fct_parameter.get_variable_name(), dyncall_parameter.str.c_str());
+            }
+            else
+            {
+                M_FATAL_COMMENT("unknow type (" << function_parameter.type << ") for dyncall parameter");
+            }
+        }
+
+        return  true;
+    }
+#endif
+
+    bool    result = true;
+
+    try
+    {
+        result = frame_to_fields(type_definitions, in_out_frame_data, interpret_data, fct_def.fields,
+                            data_name, data_simple_name,
+                            os_out, os_err);
+
+        if (fct_def.return_type != "void")
+        {
+            M_FATAL_COMMENT("No return in a not void function");
+        }
+    }
+    catch (C_byte_interpret_exception_return  & val)
+    {
+        if (fct_def.return_type == "void")
+        {
+            if (val.is_returned_value_set == true)
+            {
+                M_FATAL_COMMENT("A value is returned from a void function (internal bug)");
+            }
+        }
+        else
+        {
+            if (val.is_returned_value_set == false)
+            {
+                M_FATAL_COMMENT("No value is returned from a not void function (internal bug)");
+            }
+
+            // ICIOA type verification ... (factoriser avec le code des parameters)
+            returned_value = val.returned_value;
+        }
+    }
+
+    // rollback on parameters
+    interpret_data.sup_read_variables(fct_parameters.size(), parameters_id);
+
+    return  result;
+}
+
+//*****************************************************************************
+// T_expression_frame_to_function_base ****************************************
+//*****************************************************************************
+
+bool    T_expression_frame_to_function_base (
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const T_function_definition   & fct_def,
+                               vector<T_expression>    & fct_parameters,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err,
+                               E_return_value_indicator  return_value_indicator,
+                               C_value                 & returned_value,
+                               bool                      pre_compute,
+                               bool                    & pre_compute_result)
+{
+    T_interpret_read_values::T_id    last_data_id = interpret_data.get_id_of_last_read_variable ();
+
+    bool    result = T_expression_frame_to_function_base2 (type_definitions,
+                                   interpret_data,
+                                   in_out_frame_data,
+                                   fct_def,
+                                   fct_parameters,
+                                   data_name,
+                                   data_simple_name,
+                                   os_out,
+                                   os_err,
+                                   return_value_indicator,
+                                   returned_value,
+                                   pre_compute,
+                                   pre_compute_result);
+
+    // 2010/09/25 function behavior modification
+    // Remove ALL datas created inside function !!!
+    interpret_data.sup_all_read_variables_after(last_data_id);
+
+
+    return  result;
+}
+
+//*****************************************************************************
+// T_expression_compute_function **********************************************
+//*****************************************************************************
+
+C_value    T_expression_compute_function (
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const T_function_definition   & fct_def,
+                               vector<T_expression>    & fct_parameters,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err,
+                               bool                      pre_compute,
+                               bool                    & pre_compute_result)
+{
+    M_TRACE_ENTER ("T_expression_compute_function", "");
+
+    C_value    return_value;
+
+    bool       result = T_expression_frame_to_function_base (type_definitions,
+                               interpret_data,
+                               in_out_frame_data,
+                               fct_def,
+                               fct_parameters,
+                               data_name,
+                               data_simple_name,
+                               os_out,
+                               os_err,
+                               E_return_value_mandatory,
+                               return_value,
+                               pre_compute,
+                               pre_compute_result);
+    if (result == false)
+    {
+        M_FATAL_COMMENT("Error when computing function.");
+    }
+
+    return  return_value;
+}
+
+//*****************************************************************************
+// frame_to_function_base *****************************************************
+//*****************************************************************************
+
+bool    frame_to_function_base (
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const T_function_definition   & fct_def,
+                         const vector<T_expression>    & fct_parameters,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err,
+                               E_return_value_indicator  return_value_indicator,
+                               C_value                 & returned_value)
+{
+    T_interpret_read_values::T_id    last_data_id = interpret_data.get_id_of_last_read_variable ();
+
+    bool  pre_compute_result = false;
+    bool  result = T_expression_frame_to_function_base2 (type_definitions,
+                                                    interpret_data,
+                                                    in_out_frame_data,
+                                                    fct_def,
+                                                    fct_parameters,
+                                                    data_name,
+                                                    data_simple_name,
+                                                    os_out,
+                                                    os_err,
+                                                    return_value_indicator,
+                                                    returned_value,
+                                                    false,
+                                                    pre_compute_result);
+
+    // 2010/09/25 function behavior modification
+    // Remove ALL datas created inside function !!!
+    interpret_data.sup_all_read_variables_after(last_data_id);
+
+
+    return  result;
+}
+
+//*****************************************************************************
+// frame_to_function **********************************************************
+//*****************************************************************************
+
+bool    frame_to_function (
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const T_function_definition   & fct_def,
+                         const T_field_type_name       & field_type_name,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err)
+{
+    M_TRACE_ENTER ("frame_to_function", "");
+
+    bool  result = false;
+    if (field_type_name.name == "frame_append_data")
+    {
+        result = frame_append_data (type_definitions, in_out_frame_data, interpret_data,
+                               fct_def,
+                               field_type_name, data_name, data_simple_name,
+                               os_out, os_err);
+    }
+    else if (field_type_name.name == "frame_append_data_array")
+    {
+        result = frame_append_data_array (type_definitions, in_out_frame_data, interpret_data,
+                               fct_def,
+                               field_type_name, data_name, data_simple_name,
+                               os_out, os_err);
+    }
+    else if (field_type_name.name == "frame_append_hexa_data")
+    {
+        result = frame_append_hexa_data (type_definitions, in_out_frame_data, interpret_data,
+                               fct_def,
+                               field_type_name, data_name, data_simple_name,
+                               os_out, os_err);
+    }
+    else
+    {
+        C_value    return_value_do_not_care;
+        result = frame_to_function_base (type_definitions,
+                                   interpret_data,
+                                   in_out_frame_data,
+                                   fct_def,
+                                   field_type_name.fct_parameters,
+                                   data_name,
+                                   data_simple_name,
+                                   os_out,
+                                   os_err,
+                                   E_return_value_do_not_care,
+                                   return_value_do_not_care);
+    }
+
+    return  result;
+}
+
+//*****************************************************************************
+// print_syntax ***************************************************************
+//*****************************************************************************
+
+void    print_syntax (ostream       & os_out)
+{
+    os_out <<
+"\n\
+This help could be uncomplete or not up-to-date : please refer to http://wsgd.free.fr/fdesc_format.html\n\
+\n\
+*** Rules\n\
+\n\
+- Define a type before using it\n\
+- For type name and field name :\n\
+--- Do not use keywords (int8, string, void, any, this, struct, enum, if, while ...)\n\
+--- Use only alphanumerics and _\n\
+--- Do not start with number\n\
+\n\
+*** Basic types\n\
+\n\
+- spare                                     not displayed byte\n\
+- char, schar, uchar\n\
+- bool1, bool8, bool16, bool32              take care of byte order\n\
+-  int2 to int32,  int64                    take care of byte order\n\
+- uint1 to uint32                           take care of byte order\n\
+- float32, float64                          take care of byte order\n\
+- string, string(<nb_bytes>)                manage zero as end of string\n\
+- string_nl, string_nl(<nb_bytes>)          idem string + manage \"\\n\" or \"\\r\\n\" as end of string\n\
+- raw(<nb_bytes>)                           dump hexa (nb_bytes could be * in some cases)\n\
+                                            must start on an entire byte position\n\
+- padding_bits                              permits to move to the next entire byte position\n\
+\n\
+*** No Statement value\n\
+\n\
+<int_or_float_type_name>{ns=<No Statement value>}       <field_name> ;\n\
+If the read value is equal to the specified value :\n\
+- No_Statement will be displayed.\n\
+- Transform, Display and Constrains specifications are ignored\n\
+NB: must be specified before the Transform, Display and Constrains specifications.\n\
+\n\
+*** Transform specifications\n\
+\n\
+<int_or_float_type_name>{q=<quantum>:o=<offset>}        <field_name> ;\n\
+<int_or_float_type_name>{q=<quantum>}                   <field_name> ;\n\
+<int_or_float_type_name>{o=<offset>}                    <field_name> ;\n\
+The resulting value = read_value * quantum + offset.\n\
+Quantum and offset values could be specified with an expression, e.g : 3.1415927/180.0\n\
+\n\
+<type_name>{tei=integer expression (use \"this\")}        <field_name> ;\n\
+<type_name>{tef=float   expression (use \"this\")}        <field_name> ;\n\
+The specified expression must return the appropriate type.\n\
+E.g:\n\
+uint16{tei=2*this-47}          <field_name> ;    # since this is an integer, the expression gives an integer\n\
+uint16{tef=2*this-47.0}        <field_name> ;    # because of 47.0, the expression gives a float\n\
+float32{tef=2*this-47}         <field_name> ;    # since this is a float, the expression gives a float\n\
+\n\
+<type_name>{tei=a_previous_field > 0 ? this/another_field : 2*this-47}    <field_name> ;\n\
+<type_name>{tef=a_function_which_returns_a_float(this)}                   <field_name> ;\n\
+\n\
+*** Display specifications\n\
+\n\
+<int_type_name>{d=hex}                                  <field_name> ;\n\
+<int_type_name>{d=oct}                                  <field_name> ;\n\
+<int_type_name>{d=bin}                                  <field_name> ;\n\
+<any_type_name>{d=printf format %22.32s}                <field_name> ;\n\
+<any_type_name>{de=string expression (use \"this\")}      <field_name> ;\n\
+NB: display specifications must always appears AFTER transform specifications (if any)\n\
+\n\
+*** Constraint specifications\n\
+\n\
+An error is displayed if the value does NOT match.\n\
+For int or float only.\n\
+\n\
+<int_or_float_type_name>{min=<val_min>:max=<val_max>}   <field_name> ;\n\
+<int_or_float_type_name>{min=<val_min>}                 <field_name> ;\n\
+<int_or_float_type_name>{max=<val_max>}                 <field_name> ;\n\
+NB: constraints specifications must always appears AFTER transform and display specifications (if any)\n\
+Min and max values could be specified with an expression, e.g : -(3.0/4)*3.1415927\n\
+\n\
+Could use many constaints (specified in the good order), e.g:\n\
+uint6{min=2:max=9}{min=12:max=19}\n\
+\n\
+*** Local byte order specification\n\
+\n\
+The global byte order is specified with byte_order command.\n\
+This byte order specification apply only to the specified field.\n\
+\n\
+<type_name>{byte_order=big_endian}      <field_name> ;\n\
+<type_name>{byte_order=little_endian}   <field_name> ;\n\
+\n\
+*** Arrays\n\
+\n\
+<type_name>[12]                                <array_field_name> ;\n\
+<type_name>[<field_name>]                      <array_field_name> ;\n\
+<type_name>[<field_name> - 12]                 <array_field_name> ;\n\
+<type_name>[<field_name> < 36 ? 0 : 16]        <array_field_name> ;\n\
+\n\
+Only at the end of the message AND if Generic Dissector knows the size of the message :\n\
+<type_name>[*]                                 <array_field_name> ;          * means any number of element\n\
+<type_name>[+]                                 <array_field_name> ;          + means any number of element, at least 1\n\
+If the array is not at the end of the message, look at loop_size.\n\
+\n\
+*** Alias\n\
+\n\
+alias  <new_type_name>    <already_existent_type_name> ;\n\
+alias  <new_type_name>    <already_existent_type_name>{q=<quantum>}{min=<val_min>:max=<val_max>} ;\n\
+alias  <new_type_name>    <already_existent_type_name>{d=hex}{min=<val_min>:max=<val_max>} ;\n\
+\n\
+*** Enum\n\
+\n\
+Take care of byte order\n\
+\n\
+enum<nb_bits 1 to 32>  <enum_type_name>\n\
+{\n\
+    <symbolic_value_name>  <integer_value or - >                   # - means last value + 1 (zero if first value)\n\
+    ...\n\
+}\n\
+\n\
+# To define an identic enum with a different size.\n\
+enum<nb_bits 1 to 32>  <enum_type_name>  as      <already_existent_enum_type_name> ;\n\
+\n\
+# To define a new enum starting from an existent one.\n\
+enum<nb_bits 1 to 32>  <enum_type_name>  expand  <already_existent_enum_type_name>\n\
+{\n\
+    <other_symbolic_value_name>  <integer_value>\n\
+    ...\n\
+}\n\
+\n\
+# Could use <enum_type_name>::<symbolic_value_name> in any expression/condition.\n\
+\n\
+*** Bit field\n\
+\n\
+bitfield must be understood like a C bitfield (even there is no standard about its implementation).\n\
+Take care of byte order.\n\
+Fields could be unsigned integers, bool1 or enum (without signed values).\n\
+\n\
+bitfield<nb_bits 8 16 24 or 32>  <bitfield_type_name>\n\
+{\n\
+  uint3{d=bin}                             field1 ;             # lower level bits\n\
+  hide uint2                               field2_unused ;\n\
+  uint15{q=2.34:o=-117.35}{min=-105.17}    field3 ;\n\
+  <enum_type>                              field4;\n\
+  bool1                                    field5 ;\n\
+  ...                                                           # higher level bits\n\
+}\n\
+\n\
+Could also use var and set inside Bit field.\n\
+More info at http://wsgd.free.fr/bitfield_more.txt\n\
+\n\
+*** Bit stream (Deprecated)\n\
+\n\
+Absolutely identic to bitfield, except :\n\
+- use bitstream keyword instead of bitfield !\n\
+- read bits from left to right (does not take care of byte order)\n\
+\n\
+Deprecated: use struct instead.\n\
+\n\
+*** Struct\n\
+\n\
+struct  <struct_type_name>\n\
+{\n\
+    <type_name>     <field_name> ;\n\
+    <command_name>  <command_parameter> ;\n\
+    if              ((<field_name> + 20 < 572) && (...) || (...))\n\
+    {\n\
+        <anything that could be specified in a struct>\n\
+    }\n\
+    else\n\
+    {\n\
+        <anything that could be specified in a struct>\n\
+    }\n\
+    while           ((<field_name> % 20 < 2**3) && (...) || (...))\n\
+    {\n\
+        <anything that could be specified in a struct>\n\
+        continue ;\n\
+        break ;\n\
+    }\n\
+    do\n\
+    {\n\
+        <anything that could be specified in a struct>\n\
+        continue ;\n\
+        break ;\n\
+    } while           ((to_string(<field_name>) + \"20\" != print(\"%d\", 572)) && (...) || (...)) ;\n\
+\n\
+    # repeat until the given size have been effectively read    \n\
+    # Use loop_size_bits if bit size is needed\n\
+    loop_size_bytes    <field_name>+20\n\
+    {\n\
+        <anything that could be specified in a struct>\n\
+        continue ;\n\
+        break ;\n\
+    }  \n\
+    \n\
+    # Inline struct and bitfield\n\
+    struct\n\
+    {\n\
+        <anything that could be specified in a struct>\n\
+    }   <field_name> ;\n\
+\n\
+    bitfield<nb_bits 8 16 24 or 32>\n\
+    {\n\
+        <anything that could be specified in a bitfield>\n\
+    }   <field_name> ;\n\
+    ...\n\
+}\n\
+\n\
+Optionaly, you can put a print specification :\n\
+struct  <struct_type_name>  print (<printf format and arguments>)\n\
+{\n\
+    ...\n\
+}\n\
+The printf arguments could be fields specified inside the struct.\n\
+\n\
+*** Switch\n\
+\n\
+switch  <switch_type_name>  <switched_type_name>\n\
+{\n\
+    case <value 1> :\n\
+    <anything that could be specified in a struct>\n\
+    ...\n\
+    case <value n> :\n\
+    <anything that could be specified in a struct>\n\
+    default :\n\
+    <anything that could be specified in a struct>\n\
+}\n\
+\n\
+# Example :\n\
+enum16 T_Operation\n\
+{\n\
+  CREATION      0\n\
+  MODIFICATION  1\n\
+  DELETION      2\n\
+}\n\
+switch T_Operation_switch  T_Operation\n\
+{\n\
+case  T_Operation::MODIFICATION  : print (\"MODIFICATION value\");\n\
+case  T_Operation::DELETION      : print (\"DELETION value\");\n\
+case  T_Operation::CREATION      : print (\"CREATION value\");\n\
+default                          : print (\"default value\");\n\
+}\n\
+struct  xxx\n\
+{\n\
+  ...\n\
+  T_Operation                   operation;\n\
+  ...\n\
+  T_Operation_switch(operation)  oper_switch;\n\
+  # or\n\
+  T_Operation_switch(operation)  \"\";\n\
+  # or directly inline without previous definition/declaration\n\
+  switch(operation)\n\
+  {\n\
+  case  T_Operation::MODIFICATION  : print (\"MODIFICATION value\");\n\
+  case  T_Operation::DELETION      : print (\"DELETION value\");\n\
+  case  T_Operation::CREATION      : print (\"CREATION value\");\n\
+  default                          : print (\"default value\");\n\
+  }\n\
+}\n\
+\n\
+*** Forward declarations\n\
+\n\
+- enum<nb_bits 1 to 32>  <enum_type_name>;\n\
+- bitfield<nb_bits 8 16 24 or 32>  <bitfield_type_name>;\n\
+- bitstream<nb_bits 8 16 24 or 32>  <bitfield_type_name>;\n\
+- struct  <struct_type_name>;\n\
+- switch  <switch_type_name>;\n\
+\n\
+"
+      << endl;  // avoir too long string for compiler
+      os_out <<
+"*** Commands\n\
+\n\
+- include     <file_name> ;\n\
+  include the specified description file\n\
+  Not available inside a struct, switch ...\n\
+- byte_order  (little_endian | big_endian | as_host) ;\n\
+  specify the data byte order for int (also enum and bitfield) and float\n\
+  - big endian (also known as network, motorola) : the bytes are not inverted\n\
+  - little endian (also known as intel) : the bytes are inverted\n\
+\n\
+*** Var command\n\
+\n\
+var  <type>  <variable name> = <value or expression> ;\n\
+ permits to declare, initialize and display a variable.\n\
+ variable = field except it is initialized from expression and not from the captured packet.\n\
+ <type> could be any int, float, string and enum\n\
+E.g:\n\
+var string                          str = \"Hello world!\";\n\
+var string[2]                       str_array = \"Hello both world!\";\n\
+var uint32{q=3}{d=the int=0x%04x}   integer = 23;\n\
+var float32                         flt = 136.234;\n\
+var float32[2]                      flt_array = 136.136;\n\
+var string                          str2 = print(\"flt = %3f and integer = \", flt) + to_string(integer);    \n\
+var <an enum type>                  oper = <an enum type>::<symbolic name>;\n\
+var uint8{d=bin}                    integer_bit_1     =  integer & 0x01;\n\
+var uint8{d=bin}                    integer_bit_2_3   = (integer & 0x06) >> 1;\n\
+\n\
+The variable must NOT already exist.\n\
+\n\
+Set command\n\
+\n\
+set  <variable name> = <expression> ;\n\
+E.g:\n\
+set    Size = 0xa * 3 + 3 ;\n\
+set    Size = Size-10 ;\n\
+set    Size_bit_part = (Size & 0xc) >> 2;\n\
+\n\
+The variable must already exist.\n\
+The variable could be a field (but does NOT change the value seen by wireshark).\n\
+\n\
+*** Const command\n\
+\n\
+const  <type>  <variable name> = <value or expression> ;\n\
+ permits to declare and initialize a constant.\n\
+ <type> could be any int, float, string and enum\n\
+Constants must be named with \"::\".\n\
+Constants could NOT have/be :\n\
+- array,\n\
+- specifications no_statement, transform, display, constrains ...\n\
+- struct, switch, ...\n\
+E.g:\n\
+const uint16           konst::int = 2;\n\
+const string           konst::str = \"abcdefgh - abcdefgh\";\n\
+const T_Type_message   konst::enum = T_Type_message::cs_start;\n\
+const float64          Math::PI = 3.1415927;\n\
+const float64          Math::deg_to_rad = Math::PI / 180;\n\
+const string           konst::str_fct = string.replace_all (konst::str, \"bc\", \"xyz\");\n\
+\n\
+The constant must NOT already exist.\n\
+\n\
+*** Variable/field name usage\n\
+\n\
+When you want to use a variable or field inside an expression or set command, you simply use its name.\n\
+But it could happen that there is many variables/fields with the same name.\n\
+In these cases, you can use the full name or the partial ending name.\n\
+E.g. :\n\
+\n\
+struct time\n\
+{\n\
+  uint32  value;\n\
+  var uin16 sec = ...;\n\
+  var uin16 min = ...;\n\
+  ...\n\
+}\n\
+struct T_my_msg\n\
+{\n\
+  ...\n\
+  struct {\n\
+    ...\n\
+    time    expected_time;\n\
+  }  expected_data ;\n\
+  struct {\n\
+    ...\n\
+    time    time;\n\
+  }  measured_data ;\n\
+  # \"value\" means the last variable/field called \"value\", so it is \"measured_data.time.value\"\n\
+  if (value != expected_data.expected_time.value)  { ... }    # full name\n\
+  if (value !=               expected_time.value)  { ... }    # partial ending name\n\
+}\n\
+\n\
+*** Functions\n\
+\n\
+function  <return_type>  <function_name> (<direction> <type>  <name> [ = <default_value> ], ...)\n\
+{\n\
+  <anything that could be specified in a struct>\n\
+  ...\n\
+  return  <expression>;\n\
+}\n\
+  \n\
+<direction>      = in, out, in_out\n\
+<type>           = any existing simple type (numeric or enum or string) or any \n\
+<return_type>    = <type> or void\n\
+<default_value>  = default value used if parameter is not specified\n\
+NB: if a default value is specified on a parameter, then all following parameters must have a default value.\n\
+\n\
+E.g.:\n\
+function string  sec_to_dhms (in int64{min=0}  value)\n\
+{\n\
+  hide var int64    value_work = value;\n\
+  hide var uint16   sec = value_work % 60;\n\
+       set          value_work = (value_work - sec) / 60;\n\
+  hide var uint16   min = value_work % 60;\n\
+       set          value_work = (value_work - min) / 60;\n\
+  hide var uint16   hour = value_work % 24;\n\
+       set          value_work = (value_work - hour) / 24;\n\
+  hide var uint16   days = value_work;\n\
+  return  print(\"%d days %02d:%02d:%02d\", days, hour, min, sec);\n\
+}\n\
+function string   ms_to_dhms (in int64{min=0}  value)\n\
+{\n\
+  hide var int64    value_work = value;\n\
+  hide var uint16   ms = value_work % 1000;\n\
+       set          value_work = (value_work - sec) / 1000;\n\
+  hide var string   str = sec_to_dhms(value_work) + print(\".%03d\", ms);\n\
+  return  str;\n\
+}\n\
+...\n\
+  int64          milli_sec_time;\n\
+  var string     milli_sec_time_str = ms_to_dhms(milli_sec_time);\n\
+  # or\n\
+  int64{de=ms_to_dhms(this)}       milli_sec_time;\n\
+\n\
+NB: a function which returns void (ie nothing) must be called like this :\n\
+  call  <function_name> (<the parameters>);\n\
+\n\
+*** Built-in functions\n\
+\n\
+- string          to_string (<field_variable_value_expression>) ;\n\
+- <int_or_float>  to_numeric (in string  str_source) ;\n\
+  fatal if result is not numeric\n\
+- <float>         to_float (in string  str_source) ;\n\
+  fatal if result is not numeric\n\
+- <int>           to_integer (in string  str_source) ;\n\
+  fatal if result is not numeric\n\
+- string          getenv (in string  env_variable_name) ;\n\
+- uint            string.length (in string  str_source);\n\
+-  int64          string.find   (in string  str_source, in string  str_to_find);\n\
+- string          string.substr (in string  str_source, in uint  index, in int64  count = string::npos);\n\
+- string          string.erase  (in string  str_source, in uint  index, in int64  count = string::npos);\n\
+- string          string.insert (in string  str_source, in uint  index, in string  str_to_insert);\n\
+- string          string.replace(in string  str_source, in uint  index, in int64  count, in string  str_to_insert);\n\
+- string          string.replace_all(in string  str_source, in string  str_old, in string  str_new);\n\
+\n\
+*** Decoder\n\
+\n\
+Sometimes, the input data is NOT directly usable (using int16, string ...) because it is encoded in a way that Generic dissector does NOT understand.\n\
+It is necessary to decode the input data before use it.\n\
+With decoder command, you can provide a function which decode the data following your rules.\n\
+Explanations at http://wsgd.free.fr/decoder_more.txt\n\
+\n\
+*** Specific commands\n\
+\n\
+- output            -- or ++ ;\n\
+  modify the output level\n\
+\n\
+- save_position          <position_name> ;\n\
+  save the current data packet position\n\
+- goto_position          <previously_saved_position_name> ;\n\
+- move_position_bytes    <position_offset> ;\n\
+- move_position_bits     <position_offset> ;\n\
+\n\
+- [debug_]print  \"<string>\" or <field name> or (\"<printf format string>\", <expression>, <expression> ...) ;\n\
+- chat           \"<string>\" or <field name> or (\"<printf format string>\", <expression>, <expression> ...) ;\n\
+- note           \"<string>\" or <field name> or (\"<printf format string>\", <expression>, <expression> ...) ;\n\
+- warning        \"<string>\" or <field name> or (\"<printf format string>\", <expression>, <expression> ...) ;\n\
+- error          \"<string>\" or <field name> or (\"<printf format string>\", <expression>, <expression> ...) ;\n\
+- fatal          \"<string>\" or <field name> or (\"<printf format string>\", <expression>, <expression> ...) ;\n\
+  print the specified string or the specified field value or printf\n\
+  chat, note and warning will appear on gray, blue and yellow lines\n\
+  error and fatal will declare an error and appear on red line\n\
+  colored lines will appear into \"Analyze/Expert info composite\" menu\n\
+  fatal is supposed to stop the dissection\n\
+  \n\
+- [debug_]print  (byte_order|output|position) ;\n\
+  print specified internal data\n\
+\n\
+*** Others commands\n\
+\n\
+WITHOUT any effect on wireshark at this time.\n\
+\n\
+- check_eof_distance_bytes  <number of bytes before end of data> ;\n\
+- check_eof_distance_bits   <number of bits  before end of data> ;\n\
+  verify the distance between the current position and the end of packet\n\
+- [debug_]print  (alias|struct|enum|switch) ;\n\
+  print specified internal data\n\
+- [debug_]print  all ;\n\
+  print all internal data specified above\n\
+- [debug_]print  (help | syntax) ;\n\
+\n\
+*** Modifiers\n\
+\n\
+- hide   <any_type>       <any_field> ;\n\
+  permits to hide the field/variable (NOT displayed and could NOT filter on it)\n\
+"
+      << endl;
+}
+
+//*****************************************************************************
+// print_help *****************************************************************
+//*****************************************************************************
+
+void    print_help (ostream       & os_out)
+{
+    print_syntax (os_out);
+}
+
+//*****************************************************************************
+// frame_to_print_any *********************************************************
+//*****************************************************************************
+
+bool    frame_to_print_any (
+                  const T_type_definitions  & type_definitions,
+                        T_frame_data        & in_out_frame_data,
+                        T_interpret_data    & interpret_data,
+                  const T_field_type_name   & field_type_name,
+                  const string              & final_type,
+                  const string              & data_name,
+                  const string              & data_simple_name,
+                        ostream             & os_out,
+                        ostream             & os_err,
+                        T_interpret_builder_cmd_print_cb    interpret_builder_cb)
+{
+    // NB: I'm supposed to ouput on os_err in case of error, but I do NOT really care.
+
+    T_interpret_read_values::T_var_name_P_values    var_name_P_values;
+    const C_value   printf_result_value = printf_args_to_string(type_definitions, interpret_data, in_out_frame_data,
+                                                                data_simple_name,
+                                                                data_name, data_simple_name, os_out, os_err,
+                                                                var_name_P_values);
+
+    if (var_name_P_values.empty())
+    {
+        string    printf_result = printf_result_value.as_string();
+
+        if (final_type != "print")
+        {
+            os_out << final_type << " : ";
+        }
+// useless because printf_result_value is a simple string
+//        if (final_type == "debug_print")
+//        {
+//            printf_result = get_string(printf_result_value);
+//        }
+
+        os_out << printf_result << endl;
+        interpret_builder_cb(type_definitions, in_out_frame_data,
+                             field_type_name, data_name, printf_result);
+    }
+    else
+    {
+        for (T_interpret_read_values::T_var_name_P_values::const_iterator
+                                        iter  = var_name_P_values.begin();
+                                        iter != var_name_P_values.end();
+                                      ++iter)
+        {
+            string    printf_result = iter->var_name + " -> " + iter->P_value->get_value().as_string();
+
+            if (final_type != "print")
+            {
+                os_out << final_type << " : ";
+            }
+            if (final_type == "debug_print")
+            {
+                printf_result += "  ";
+                printf_result += get_string(iter->P_value->get_value());
+            }
+
+            os_out << printf_result << endl;
+            interpret_builder_cb(type_definitions, in_out_frame_data,
+                                 field_type_name, data_name, printf_result);
+        }
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_print *************************************************************
+//*****************************************************************************
+
+bool    frame_to_print (
+                  const T_type_definitions  & type_definitions,
+                        T_frame_data        & in_out_frame_data,
+                        T_interpret_data    & interpret_data,
+                  const T_field_type_name   & field_type_name,
+                  const string              & final_type,
+                  const string              & data_name,
+                  const string              & data_simple_name,
+                        ostream             & os_out,
+                        ostream             & os_err)
+{
+    // Verify debug_print is available.
+    if ((final_type == "debug_print") &&
+        (interpret_data.must_output_debug () == false))
+    {
+        return  true;
+    }
+
+    // Verify print is available.
+    if ((final_type == "print") &&
+        (interpret_data.must_output () == false))
+    {
+        return  true;
+    }
+
+    if (data_simple_name == "alias")
+    {
+        // gcc 4.4.1 does not accept my templates on map
+#ifndef  __GNUC__
+        print (os_out, type_definitions.map_alias_type, "alias ");
+#endif
+    }
+    else if (data_simple_name == "struct")
+    {
+        print (os_out, type_definitions.map_struct_definition, "struct ");
+    }
+    else if (data_simple_name == "enum")
+    {
+        print (os_out, type_definitions.map_enum_definition_representation, "enum ");
+    }
+    else if (data_simple_name == "switch")
+    {
+        os_out << final_type << " " << data_simple_name
+               << " NOT implemented." << endl;
+    }
+    else if (data_simple_name == "byte_order")
+    {
+        string    host_byte_order = interpret_data.get_host_order();
+        string    data_byte_order = interpret_data.get_data_order();
+
+        string  str;
+        str += "data is " + data_byte_order + " and ";
+        str += "host is " + host_byte_order + " so ";
+        str += "integer or float read are ";
+        str += interpret_data.must_invert_bytes() ? "" : "not ";
+        str += "inverted.";
+
+        os_out << str << endl;
+        interpret_builder_cmd_print(type_definitions, in_out_frame_data,
+                                    field_type_name, data_name, str);
+    }
+    else if (data_simple_name == "output")
+    {
+        string  str = "output level = " + get_string(interpret_data.get_output_level());
+
+        os_out << str << endl;
+        interpret_builder_cmd_print(type_definitions, in_out_frame_data,
+                                    field_type_name, data_name, str);
+    }
+    else if (data_simple_name == "position")
+    {
+        os_out << "Ptr = " << (unsigned long)in_out_frame_data.get_P_bytes() << endl;
+        os_out << "Nb bits to read = " << in_out_frame_data.get_remaining_bits() << endl;
+
+        string  str;
+        str += "Ptr = " + get_string((unsigned long)in_out_frame_data.get_P_bytes());
+        str += "  " ;
+        str += "Nb bits to read = " + get_string(in_out_frame_data.get_remaining_bits());
+        interpret_builder_cmd_print(type_definitions, in_out_frame_data,
+                                    field_type_name, data_name, str);
+    }
+    else if (data_simple_name == "all")
+    {
+        frame_to_print (type_definitions,
+                      in_out_frame_data,
+                      interpret_data,
+                      field_type_name,
+                      final_type, data_name, "alias", os_out,os_err);
+        frame_to_print (type_definitions,
+                      in_out_frame_data,
+                      interpret_data,
+                      field_type_name,
+                      final_type, data_name, "struct", os_out,os_err);
+        frame_to_print (type_definitions,
+                      in_out_frame_data,
+                      interpret_data,
+                      field_type_name,
+                      final_type, data_name, "enum", os_out,os_err);
+        frame_to_print (type_definitions,
+                      in_out_frame_data,
+                      interpret_data,
+                      field_type_name,
+                      final_type, data_name, "switch", os_out,os_err);
+        frame_to_print (type_definitions,
+                      in_out_frame_data,
+                      interpret_data,
+                      field_type_name,
+                      final_type, data_name, "byte_order", os_out,os_err);
+        frame_to_print (type_definitions,
+                      in_out_frame_data,
+                      interpret_data,
+                      field_type_name,
+                      final_type, data_name, "output", os_out,os_err);
+        frame_to_print (type_definitions,
+                      in_out_frame_data,
+                      interpret_data,
+                      field_type_name,
+                      final_type, data_name, "position", os_out,os_err);
+    }
+    else if (data_simple_name == "help")
+    {
+        print_help (os_out);
+    }
+    else if (data_simple_name == "syntax")
+    {
+        print_syntax (os_out);
+    }
+    else
+    {
+        frame_to_print_any(type_definitions, in_out_frame_data, interpret_data,
+                           field_type_name, final_type, data_name, data_simple_name,
+                           os_out, os_err,
+                           interpret_builder_cmd_print);
+    }
+    
+    return  true;
+}
+
+//*****************************************************************************
+// simple_value_to_attribute_value_main ***************************************
+//*****************************************************************************
+
+string    simple_value_to_attribute_value_main (
+                         const T_type_definitions  & type_definitions,
+                               T_interpret_data    & interpret_data,
+                         const C_value             & value,
+                         const string              & UNUSED(final_type),
+                         const T_field_type_name   & field_type_name,
+                               T_attribute_value   & attribute_value,
+                               bool                & no_error)
+{
+    attribute_value.set_value_original_format_reset(value);
+
+    string  error_str;
+    no_error = post_treatment_value(type_definitions, interpret_data,
+                                    field_type_name,
+                                    attribute_value,
+                                    error_str);
+    if (no_error == false)
+    {
+        attribute_value.set_error(error_str);
+    }
+
+
+    return  attribute_value_to_string(attribute_value);
+}
+
+//*****************************************************************************
+// enum_value_to_attribute_value
+//*****************************************************************************
+
+string    enum_value_to_attribute_value (
+                         const T_type_definitions  & type_definitions,
+                               T_interpret_data    & interpret_data,
+                         const C_value             & obj_value,
+                         const T_enum_definition   & enum_definition,
+                         const T_field_type_name   & field_type_name,
+                               T_attribute_value   & attribute_value,
+                               bool                & no_error)
+{
+    no_error = false;
+    attribute_value.set_value_original(obj_value);
+
+    post_treatment_value_transform(type_definitions, interpret_data,
+                                    field_type_name,
+                                    attribute_value);
+
+    // Search symbolic value
+    const long long    value = attribute_value.get_value().get_int();
+
+    for (uint  idx = 0; idx < enum_definition.size (); ++idx)
+    {
+        if (enum_definition[idx].value == value)
+        {
+            no_error = true;
+            // NB: the value is still an integer
+            attribute_value.change_value_str_only(enum_definition[idx].name);
+            break;
+        }
+    }
+
+    if (no_error == false)
+    {
+        attribute_value.set_error("ERROR unknown enum value");
+    }
+    else
+    {
+        // apply display expressions ...
+        post_treatment_value_display(type_definitions, interpret_data,
+                                        field_type_name,
+                                        attribute_value);
+
+        // apply checks ...
+        string  error_str;
+        no_error = post_treatment_value_check(type_definitions, interpret_data,
+                                        field_type_name,
+                                        attribute_value,
+                                        error_str);
+        if (no_error == false)
+        {
+            attribute_value.set_error(error_str);
+        }
+    }
+
+    return  attribute_value_to_string(attribute_value);
+}
+
+//*****************************************************************************
+// frame_to_string ************************************************************
+//*****************************************************************************
+
+bool    frame_to_string (
+                      const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data_param,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & os_out,
+                            ostream               & os_err)
+{
+    const string   & final_type = field_type_name.type;
+
+    M_TRACE_ENTER ("frame_to_string", final_type);
+
+    M_FATAL_IF_FALSE ((final_type == "string") ||
+                      (final_type == "string_nl"));
+
+    //***************************************************************
+    // Compute and verify size
+    //***************************************************************
+    const string  & str_string_size = field_type_name.str_size_or_parameter;
+    long                string_size = -1;
+    
+    if (str_string_size != "")
+    {
+        string_size = size_expression_to_int(type_definitions, interpret_data, str_string_size);
+
+        if (string_size < 0)
+        {
+            os_err << "Error string size= " << str_string_size
+                   << " data= " << data_name << endl;
+            interpret_builder_error(type_definitions, in_out_frame_data_param,
+                                    field_type_name, data_name, data_simple_name,
+                                    "Not valid size for " + data_simple_name);
+            return  false;
+        }
+    }
+
+    //***************************************************************
+    // Decode
+    //***************************************************************
+    T_frame_data           * P_in_out_frame_data = & in_out_frame_data_param;
+    T_decode_stream_frame  & decode_stream_frame = interpret_data.get_decode_stream_frame();
+
+    if ((interpret_data.is_decode_in_progress() == false) &&
+        (field_type_name.is_a_variable() == false))
+    {
+        T_frame_data           & inside_frame = decode_stream_frame.frame_data;
+
+        if (string_size >= 0)
+        {
+            const long               TYPE_BIT_SIZE = string_size * 8;
+            if (inside_frame.get_remaining_bits() >= TYPE_BIT_SIZE)
+            {
+                // Enough data into inside_frame, so simply use it (decoder is useless for now)
+                P_in_out_frame_data = & inside_frame;
+            }
+            else if (interpret_data.must_decode_now() == false)
+            {
+                if (inside_frame.get_remaining_bits() > 0)
+                {
+                    // For code simplification, do not manage this case.
+                    // And seems non-sense : 1st part of data is decoded and 2nd part no.
+                    M_FATAL_COMMENT("Not enough data into inside_frame (" << inside_frame.get_remaining_bits() << " bits < " <<
+                                    TYPE_BIT_SIZE << ") and no decoder to fill it");
+                }
+                else
+                {
+                    // No data into inside_frame and no decoder, so simply use normal frame
+                }
+            }
+            else
+            {
+                // Not enough data into inside_frame, so use decoder to fill it
+                M_TRACE_ENTER ("read_decode_data must_decode_stream", TYPE_BIT_SIZE);
+
+                decode_data_size (type_definitions, in_out_frame_data_param, interpret_data,
+                                  field_type_name, data_name, data_simple_name,
+                                  os_out, os_err,
+                                  decode_stream_frame,
+                                  final_type.c_str(), TYPE_BIT_SIZE - inside_frame.get_remaining_bits());
+
+                P_in_out_frame_data = & inside_frame;
+            }
+        }
+        else
+        {
+            // ICIOA incomplet ?
+            if (interpret_data.must_decode_now())
+            {
+                decode_data_bytes_until (
+                          type_definitions, in_out_frame_data_param, interpret_data,
+                          field_type_name, data_name, data_simple_name,
+                          os_out, os_err,
+                          decode_stream_frame,
+                          final_type.c_str(),
+                          "\0", (final_type == "string_nl") ? "\n" : nullptr);
+                P_in_out_frame_data = & decode_stream_frame.frame_data;
+            }
+            else if (inside_frame.get_remaining_bits() > 0)
+            {
+                P_in_out_frame_data = & inside_frame;
+            }
+        }
+    }
+    else
+    {
+        // inside_frame and decoder not used during decoding
+    }
+
+
+    T_frame_data          & in_out_frame_data = * P_in_out_frame_data;
+
+    // NB: following code NOT optimized after decode implementation
+
+    {
+        if ((string_size >= 0) &&
+            (in_out_frame_data.get_remaining_bits() < string_size*8) &&
+            (field_type_name.is_a_variable() == false))
+        {
+            os_err << "Error not enough bytes (" << in_out_frame_data.get_remaining_entire_bytes()
+                   << " instead of " << string_size
+                   << ") for data= " << data_name << endl;
+            interpret_builder_missing_data(type_definitions, in_out_frame_data, interpret_data,
+                                    field_type_name, data_name, data_simple_name,
+                                    "End of packet : not enough data to read " + data_simple_name);
+            M_FATAL_MISSING_DATA();
+        }
+
+        int             type_bit_size_for_builder = 0;    /* to avoid hexa data highligth (-1 forbidden) */
+        int             bit_position_offset_into_initial_frame = -1;
+        int             bit_position_size = -1;
+        T_frame_data    in_out_frame_data_for_builder = in_out_frame_data;
+
+        string        value;
+
+        if (field_type_name.is_a_variable() == false)
+        {
+            // This is a field (not a variable).
+            bit_position_offset_into_initial_frame = in_out_frame_data.get_bit_offset_into_initial_frame();
+
+            const bool    manage_nl = (final_type == "string_nl");
+            if (string_size > 0)
+            {
+                if (in_out_frame_data.is_physically_at_beginning_of_byte() != true)
+                {
+                    value.reserve(string_size);
+                    for (int   idx_str = 0; idx_str < string_size; ++idx_str)
+                    {
+                        const char    current_char = in_out_frame_data.read_1_byte();
+                        if (current_char == '\0')
+                        {
+                            in_out_frame_data.move_forward(string_size - (value.length() + 1), 0);
+                            break;
+                        }
+                        value += current_char;
+                    }
+                }
+                else
+                {
+                    value = string ((const char *)in_out_frame_data.get_P_bytes(), 0, string_size);
+                    in_out_frame_data.move_forward(string_size, 0);
+                }
+
+                if (manage_nl)
+                {
+                    string::size_type  idx_sep = value.find ('\n');
+                    if (idx_sep != string::npos)
+                    {
+                        if ((idx_sep > 0) && (value[idx_sep-1] == '\r'))
+                            --idx_sep;
+
+                        value.resize(idx_sep-1);
+                    }
+                }
+            }
+            else if (string_size == 0)
+            {
+                value = "";
+            }
+            else
+            {
+                string_size = 0;
+                while (in_out_frame_data.can_move_1_byte_forward())
+                {
+                    const char    current_char = in_out_frame_data.read_1_byte();
+                    ++string_size;
+
+                    if (current_char == '\0')
+                    {
+                        break;
+                    }
+
+                    if (manage_nl)
+                    {
+                        if (current_char == '\n')
+                        {
+                            if ((string_size > 1) && (value[string_size-2] == '\r'))
+                            {
+                                value.resize(string_size-2);
+                            }
+
+                            break;
+                        }
+                    }
+
+                    value += current_char;
+                }
+
+                // It is NOT an error to NOT find the zero end of string
+            }
+
+            bit_position_size = string_size * 8;
+            type_bit_size_for_builder = bit_position_size;
+            in_out_frame_data_for_builder = in_out_frame_data;
+
+            // In case of decoding,
+            //  the current position could be not good into the orginal frame 
+#if 0
+            // ICIOA decoder fail
+            // il faudrait aussi modifier type_bit_size_for_builder ?
+            if (&in_out_frame_data == &decode_frame_data)
+            {
+                in_out_frame_data_for_builder.set_bit_offset_into_initial_frame(
+                    in_out_frame_data_param.get_bit_offset_into_initial_frame());
+            }
+#endif
+        }
+        else
+        {
+            // This is a variable (not a field)
+            C_value  obj_value = field_type_name.get_var_expression().
+                compute_expression(type_definitions, interpret_data, in_out_frame_data,
+                                                    data_name, data_simple_name, os_out, os_err);
+            M_FATAL_IF_NE(obj_value.get_type(), C_value::E_type_string);
+
+            value = obj_value.get_str();
+
+            if (string_size >= 0)
+            {
+                M_FATAL_IF_GT(value.size(), static_cast<size_t>(string_size));
+            }
+
+            bit_position_offset_into_initial_frame = obj_value.get_bit_position_offset();
+            bit_position_size = obj_value.get_bit_position_size();
+            if ((bit_position_offset_into_initial_frame >= 0) && (bit_position_size > 0))
+            {
+                type_bit_size_for_builder = bit_position_size;
+                if (in_out_frame_data_for_builder.get_initial_sizeof_bits() != 0) /* 2010/09/13 */
+                    in_out_frame_data_for_builder.set_bit_offset_into_initial_frame(bit_position_offset_into_initial_frame + type_bit_size_for_builder);
+            }
+        }
+
+        T_attribute_value    attribute_value(value);
+
+        attribute_value.set_bit_position_offset_size(bit_position_offset_into_initial_frame, bit_position_size);
+
+        string    error_on_value;
+        post_treatment_value(type_definitions, interpret_data, field_type_name,
+                             attribute_value, error_on_value);
+        value = attribute_value_to_string(attribute_value);
+
+        interpret_data.add_read_variable (data_simple_name, attribute_value);
+
+        if (interpret_data.must_output ())
+        {
+            os_out << data_name << " ";
+            os_out << "= ";
+            os_out << value;
+            os_out << endl;
+
+            interpret_builder_value(type_definitions, in_out_frame_data_for_builder,
+                                    field_type_name, data_name, data_simple_name,
+                                    attribute_value, value,
+                                    final_type, type_bit_size_for_builder,
+                                    interpret_data.is_little_endian(), false);  // no error
+        }
+
+        decode_stream_frame.synchronize();  // mandatory each time something has been read into its frame_data
+        return  true;
+    }
+}
+
+//*****************************************************************************
+// frame_to_raw ***************************************************************
+//*****************************************************************************
+
+bool    frame_to_raw (const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data_param,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & os_out,
+                            ostream               & os_err)
+{
+    const string   & final_type = field_type_name.type;
+
+    M_TRACE_ENTER ("frame_to_raw", final_type);
+
+    M_FATAL_IF_FALSE ((final_type == "raw") ||
+                      (final_type == "subproto") ||
+                      (final_type == "insproto"));
+
+    //***************************************************************
+    // Compute and verify size
+    //***************************************************************
+    const string  & str_string_size = field_type_name.str_size_or_parameter;
+    long                string_size = -1;
+    
+    if (str_string_size != "*")
+    {
+        string_size = size_expression_to_int(type_definitions, interpret_data, str_string_size);
+
+        if (string_size < 0)
+        {
+            os_err << "Error raw size= " << str_string_size
+                   << " data= " << data_name << endl;
+            interpret_builder_error(type_definitions, in_out_frame_data_param,
+                                    field_type_name, data_name, data_simple_name,
+                                    "Not valid size for " + data_simple_name);
+            return  false;
+        }
+    }
+
+    if (in_out_frame_data_param.is_physically_at_beginning_of_byte() != true)
+    {
+        M_FATAL_COMMENT(final_type << " managed only a entire byte position");  // bsew
+    }
+
+    //***************************************************************
+    // Decode
+    //***************************************************************
+    T_frame_data           * P_in_out_frame_data = & in_out_frame_data_param;
+    T_decode_stream_frame  & decode_stream_frame = interpret_data.get_decode_stream_frame();
+
+    bool  is_decoded_data = false;
+    if (interpret_data.is_decode_in_progress() == false)
+    {
+        T_frame_data           & inside_frame = decode_stream_frame.frame_data;
+
+        if (string_size >= 0)
+        {
+            const long               TYPE_BIT_SIZE = string_size * 8;
+            if (inside_frame.get_remaining_bits() >= TYPE_BIT_SIZE)
+            {
+                // Enough data into inside_frame, so simply use it (decoder is useless for now)
+                P_in_out_frame_data = & inside_frame;
+                is_decoded_data = true;
+            }
+            else if (interpret_data.must_decode_now() == false)
+            {
+                if (inside_frame.get_remaining_bits() > 0)
+                {
+                    // For code simplification, do not manage this case.
+                    // And seems non-sense : 1st part of data is decoded and 2nd part no.
+                    M_FATAL_COMMENT("Not enough data into inside_frame (" << inside_frame.get_remaining_bits() << " bits < " <<
+                                    TYPE_BIT_SIZE << ") and no decoder to fill it");
+                }
+                else
+                {
+                    // No data into inside_frame and no decoder, so simply use normal frame
+                    is_decoded_data = false;
+                }
+            }
+            else
+            {
+                // Not enough data into inside_frame, so use decoder to fill it
+                M_TRACE_ENTER ("read_decode_data must_decode_stream", TYPE_BIT_SIZE);
+
+                decode_data_size (type_definitions, in_out_frame_data_param, interpret_data,
+                                  field_type_name, data_name, data_simple_name,
+                                  os_out, os_err,
+                                  decode_stream_frame,
+                                  final_type.c_str(), TYPE_BIT_SIZE - inside_frame.get_remaining_bits());
+
+                P_in_out_frame_data = & inside_frame;
+                is_decoded_data = true;
+            }
+        }
+        else
+        {
+            // ICIOA complet, non ?
+            if (interpret_data.must_decode_now())
+            {
+                decode_data_bytes_until (
+                          type_definitions, in_out_frame_data_param, interpret_data,
+                          field_type_name, data_name, data_simple_name,
+                          os_out, os_err,
+                          decode_stream_frame,
+                          final_type.c_str(),
+                          nullptr, nullptr);
+                P_in_out_frame_data = & decode_stream_frame.frame_data;
+                is_decoded_data = true;
+            }
+            else if (inside_frame.get_remaining_bits() > 0)
+            {
+                if (in_out_frame_data_param.get_remaining_bits() > 0)
+                {
+                    // For code simplification, do not manage this case.
+                    // And seems non-sense : 1st part of data is decoded and 2nd part no.
+                    M_FATAL_COMMENT("Still data into inside_frame (" << inside_frame.get_remaining_bits() <<
+                                    " bits) and data into packet (" << in_out_frame_data_param.get_remaining_bits() << ")");
+                }
+                P_in_out_frame_data = & inside_frame;
+                is_decoded_data = true;
+            }
+        }
+    }
+    else
+    {
+        // inside_frame and decoder not used during decoding
+        is_decoded_data = true;
+    }
+
+
+    T_frame_data          & in_out_frame_data = * P_in_out_frame_data;
+
+    // NB: following code NOT optimized after decode implementation
+
+    {
+        const long  frame_data_byte_size = in_out_frame_data.get_remaining_bits() / 8;
+
+        if (str_string_size == "*")
+        {
+            string_size = frame_data_byte_size - (type_definitions.trailer_sizeof_bits / 8);
+        }
+
+        if (frame_data_byte_size < string_size)
+        {
+            os_err << "Error not enough bytes (" << frame_data_byte_size
+                   << " instead of " << string_size
+                   << ") for data= " << data_name << endl;
+            interpret_builder_missing_data(type_definitions, in_out_frame_data, interpret_data,
+                                    field_type_name, data_name, data_simple_name,
+                                    "End of packet : not enough data to read " + data_simple_name);
+            M_FATAL_MISSING_DATA();
+        }
+
+        // with    gives "Malformed packet: <proto>"
+        // without gives "Malformed packet: <proto>"
+        if (string_size == 0)
+        {
+            return  true;
+        }
+
+        if (interpret_data.must_output ())
+        {
+            os_out << data_name << " ";
+            os_out << "= ";
+            os_out << endl;
+            dump_buffer (os_out, in_out_frame_data.get_P_bytes(), string_size);
+        }
+
+        in_out_frame_data.move_forward(string_size, 0);
+
+        if (interpret_data.must_output ())
+        {
+            E_raw_data_type    raw_data_type = E_raw_data_any;
+            if (final_type == "subproto")
+                raw_data_type = E_raw_data_sub_proto;
+            else if (final_type == "insproto")
+                raw_data_type = E_raw_data_ins_proto;
+
+            interpret_builder_raw_data(type_definitions, in_out_frame_data, interpret_data,
+                                    field_type_name, data_name, data_simple_name,
+                                    string_size * 8,
+                                    raw_data_type,
+                                    is_decoded_data);
+        }
+
+        decode_stream_frame.synchronize();  // mandatory each time something has been read into its frame_data
+        return  true;
+    }
+}
+
+//*****************************************************************************
+// frame_to_any ***************************************************************
+//*****************************************************************************
+
+// When a struct is a variable, this flag is set to true.
+// Then all fields (recursively) of the struct become variable
+//  and are initialized to zero.
+bool    G_is_a_variable_ICIOA = false;
+
+//*****************************************************************************
+// frame_to_any simple type ***************************************************
+//*****************************************************************************
+
+    //-------------------------------------------------------------------------
+    // Macro for read a simple type ...
+    // NB: will NOT work if, for example, sizeof(unsigned int) != 32
+    //-------------------------------------------------------------------------
+
+#define M_READ_SIMPLE_TYPE_BASE_BEGIN(TYPE_NAME,TYPE_BIT_SIZE,TYPE_IMPL,TYPE_IMPL_BIT_SIZE,TYPE_IMPL_STR)    \
+    {
+
+#define M_READ_SIMPLE_TYPE_BASE_COMPUTE(TYPE_NAME,TYPE_BIT_SIZE,TYPE_IMPL,TYPE_IMPL_BIT_SIZE,TYPE_IMPL_STR)    \
+        M_FATAL_IF_GT (TYPE_BIT_SIZE, TYPE_IMPL_BIT_SIZE);                    \
+                                                                              \
+        int   type_bit_size_for_builder = TYPE_BIT_SIZE;                      \
+        T_frame_data    in_out_frame_data_for_builder = in_out_frame_data;    \
+                                                                              \
+        C_value      obj_value;                                               \
+        obj_value.set_external_type(final_type);                              \
+                                                                              \
+        if (field_type_name.is_a_variable() == true)                          \
+        {                                                                     \
+            type_bit_size_for_builder = 0;   /* to avoid hexa data highligth (-1 forbidden) */    \
+            if (is_enum)                                                      \
+                type_bit_size_for_builder = -1;   /* ICIOA trick to know it is an enum !!! */    \
+                                                                              \
+            obj_value = field_type_name.get_var_expression().                 \
+                compute_expression(type_definitions, interpret_data, in_out_frame_data,     \
+                                           data_name, data_simple_name, os_out, os_err);    \
+            if (strcmp(TYPE_NAME, "msg") == 0)                                \
+            {                                                                 \
+                if (obj_value.get_type() != C_value::E_type_msg)              \
+                {                                                             \
+                    M_FATAL_COMMENT("Expecting msg and expression gives " << obj_value.get_type());    \
+                }                                                             \
+            }                                                                 \
+            else                                                              \
+            if (strncmp(TYPE_NAME, "float", 5) != 0)                          \
+            {                                                                 \
+                TYPE_IMPL  value = static_cast<TYPE_IMPL>(obj_value.get_int());          \
+                C_value  value_to_compare(value);                             \
+                if (value_to_compare != obj_value)                            \
+                {                                                             \
+                    M_FATAL_COMMENT("Overflow : " << obj_value.get_int() << " gives " << value_to_compare.get_int());         \
+                }                                                             \
+            }                                                                 \
+            const int   bit_position_offset_into_initial_frame = obj_value.get_bit_position_offset();        \
+            const int   bit_position_size = obj_value.get_bit_position_size();            \
+            if ((bit_position_offset_into_initial_frame >= 0) && (bit_position_size > 0))        \
+            {                                                                 \
+                type_bit_size_for_builder = bit_position_size;                \
+                if (in_out_frame_data_for_builder.get_initial_sizeof_bits() != 0) /* 2010/09/13 */ \
+                    in_out_frame_data_for_builder.set_bit_offset_into_initial_frame(bit_position_offset_into_initial_frame + type_bit_size_for_builder);    \
+                if (is_enum)                                                  \
+                    type_bit_size_for_builder = -type_bit_size_for_builder;   /* ICIOA trick to know it is an enum !!! */    \
+            }                                                                 \
+        }                                                                     \
+        else if (G_is_a_variable_ICIOA == true)                               \
+        {                                                                     \
+            type_bit_size_for_builder = 0;   /* to avoid hexa data highligth (-1 forbidden) */    \
+            if (is_enum)                                                      \
+                type_bit_size_for_builder = -1;   /* ICIOA trick to know it is an enum !!! */    \
+                                                                              \
+            obj_value = C_value(0);                                           \
+            if (strcmp(TYPE_NAME, "msg") == 0)                                \
+            {                                                                 \
+                obj_value = C_value(C_value::E_type_msg, nullptr);            \
+            }                                                                 \
+            else                                                              \
+            if (strncmp(TYPE_NAME, "float", 5) != 0)                          \
+            {                                                                 \
+                obj_value = C_value(0.0);                                     \
+            }                                                                 \
+            const int   bit_position_offset_into_initial_frame = obj_value.get_bit_position_offset();        \
+            const int   bit_position_size = obj_value.get_bit_position_size();            \
+            if ((bit_position_offset_into_initial_frame >= 0) && (bit_position_size > 0))        \
+            {                                                                 \
+                type_bit_size_for_builder = bit_position_size;                \
+                if (in_out_frame_data_for_builder.get_initial_sizeof_bits() != 0) /* 2010/09/13 */ \
+                    in_out_frame_data_for_builder.set_bit_offset_into_initial_frame(bit_position_offset_into_initial_frame + type_bit_size_for_builder);    \
+                if (is_enum)                                                  \
+                    type_bit_size_for_builder = -type_bit_size_for_builder;   /* ICIOA trick to know it is an enum !!! */    \
+            }                                                                 \
+        }                                                                     \
+        else                                                                  \
+        {                                                                     \
+            const int   bit_position_offset_into_initial_frame = in_out_frame_data.get_bit_offset_into_initial_frame();   \
+            TYPE_IMPL    value = 0;                                           \
+            read_decode_data (type_definitions, in_out_frame_data,            \
+                       interpret_data,                                        \
+                       field_type_name, data_name, data_simple_name,          \
+                       os_out, os_err,                                        \
+                       &value,                                                \
+                       TYPE_NAME, TYPE_BIT_SIZE,                              \
+                       TYPE_IMPL_STR, TYPE_IMPL_BIT_SIZE,                     \
+                       interpret_data.must_invert_bytes(),                    \
+                       final_type[0] == 'i' /* != 'u' */);                    \
+            obj_value = value;                                                \
+            /* encoded size could differ from TYPE_BIT_SIZE */                \
+            obj_value.set_bit_position_offset_size(                           \
+                bit_position_offset_into_initial_frame,                       \
+                in_out_frame_data.get_bit_offset() - in_out_frame_data_for_builder.get_bit_offset());  \
+            in_out_frame_data_for_builder = in_out_frame_data;                \
+        }
+
+#define M_READ_SIMPLE_TYPE_BASE_ADD_OUTPUT(TYPE_NAME,TYPE_BIT_SIZE,TYPE_IMPL,TYPE_IMPL_BIT_SIZE,TYPE_IMPL_STR)    \
+        bool    no_error = true;                                              \
+        T_attribute_value    attribute_value;                                 \
+        string  str_value;                                                    \
+        if (is_enum)                                                          \
+            str_value = enum_value_to_attribute_value (                       \
+                                type_definitions, interpret_data,             \
+                                obj_value,                                    \
+                                P_enum_def->definition,                       \
+                                field_type_name, attribute_value, no_error);  \
+        else                                                                  \
+            str_value = simple_value_to_attribute_value_main (                \
+                                type_definitions, interpret_data,             \
+                                obj_value, final_type,                        \
+                                field_type_name, attribute_value, no_error);  \
+                                                                              \
+        interpret_data.add_read_variable (data_simple_name, attribute_value); \
+                                                                              \
+        if (interpret_data.must_NOT_output ())                                \
+            return  true;                                                     \
+                                                                              \
+        os_out << data_name << " ";                                           \
+        os_out << "= ";                                                       \
+        os_out << str_value << endl;                                          \
+        interpret_builder_value(type_definitions, in_out_frame_data_for_builder,          \
+                                field_type_name, data_name, data_simple_name, \
+                                attribute_value, str_value,                   \
+                                final_type, type_bit_size_for_builder,        \
+                                interpret_data.is_little_endian(), ! no_error);
+
+#define M_READ_SIMPLE_TYPE_BASE_END(TYPE_NAME,TYPE_BIT_SIZE,TYPE_IMPL,TYPE_IMPL_BIT_SIZE,TYPE_IMPL_STR)    \
+        return  true;                                                         \
+    }
+
+
+
+#define M_FCT_READ_SIMPLE_TYPE(TYPE_NAME,TYPE_BIT_SIZE,TYPE_IMPL)             \
+bool    frame_to_any_ ## TYPE_NAME                                            \
+                     (const T_type_definitions    & type_definitions,         \
+                            T_frame_data          & in_out_frame_data,        \
+                            T_interpret_data      & interpret_data,           \
+                      const T_field_type_name     & field_type_name,          \
+                      const string                & data_name,                \
+                      const string                & data_simple_name,         \
+                            ostream               & os_out,                   \
+                            ostream               & os_err)                   \
+{                                                                             \
+    M_TRACE_ENTER ("frame_to_any_" #TYPE_NAME,                                \
+                   (field_type_name.is_a_variable() ? "var " : "") <<         \
+                   "data_type=" << field_type_name.type << " data_name=" << data_name); \
+    const string                            & final_type = field_type_name.type;        \
+    bool                                      is_enum = false;                \
+    const T_enum_definition_representation  * P_enum_def = nullptr;           \
+    M_READ_SIMPLE_TYPE_BASE_BEGIN(#TYPE_NAME, TYPE_BIT_SIZE, TYPE_IMPL, sizeof(TYPE_IMPL)*8, #TYPE_IMPL)       \
+    M_READ_SIMPLE_TYPE_BASE_COMPUTE(#TYPE_NAME, TYPE_BIT_SIZE, TYPE_IMPL, sizeof(TYPE_IMPL)*8, #TYPE_IMPL)     \
+    M_READ_SIMPLE_TYPE_BASE_ADD_OUTPUT(#TYPE_NAME, TYPE_BIT_SIZE, TYPE_IMPL, sizeof(TYPE_IMPL)*8, #TYPE_IMPL)  \
+    M_READ_SIMPLE_TYPE_BASE_END(#TYPE_NAME, TYPE_BIT_SIZE, TYPE_IMPL, sizeof(TYPE_IMPL)*8, #TYPE_IMPL)         \
+}                                                                             \
+bool    frame_to_any_ ## TYPE_NAME ## _enum                                   \
+                     (const T_type_definitions    & type_definitions,         \
+                            T_frame_data          & in_out_frame_data,        \
+                            T_interpret_data      & interpret_data,           \
+                      const T_field_type_name     & field_type_name,          \
+                      const string                & data_name,                \
+                      const string                & data_simple_name,         \
+                            ostream               & os_out,                   \
+                            ostream               & os_err)                   \
+{                                                                             \
+    bool                                      is_enum = true;        \
+    const T_enum_definition_representation  * P_enum_def = field_type_name.P_type_enum_def;        \
+    const string                            & final_type = P_enum_def->representation_type;        \
+    M_READ_SIMPLE_TYPE_BASE_BEGIN(#TYPE_NAME, TYPE_BIT_SIZE, TYPE_IMPL, sizeof(TYPE_IMPL)*8, #TYPE_IMPL)       \
+    M_READ_SIMPLE_TYPE_BASE_COMPUTE(#TYPE_NAME, TYPE_BIT_SIZE, TYPE_IMPL, sizeof(TYPE_IMPL)*8, #TYPE_IMPL)     \
+    M_READ_SIMPLE_TYPE_BASE_ADD_OUTPUT(#TYPE_NAME, TYPE_BIT_SIZE, TYPE_IMPL, sizeof(TYPE_IMPL)*8, #TYPE_IMPL)  \
+    M_READ_SIMPLE_TYPE_BASE_END(#TYPE_NAME, TYPE_BIT_SIZE, TYPE_IMPL, sizeof(TYPE_IMPL)*8, #TYPE_IMPL)         \
+}
+
+
+
+M_FCT_READ_SIMPLE_TYPE (uint1,    1,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int2,    2,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint2,    2,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int3,    3,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint3,    3,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int4,    4,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint4,    4,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int5,    5,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint5,    5,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int6,    6,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint6,    6,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int7,    7,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint7,    7,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int8,    8,    signed char)
+M_FCT_READ_SIMPLE_TYPE (uint8,    8,  unsigned char)
+M_FCT_READ_SIMPLE_TYPE ( int9,    9,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint9,    9,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int10,  10,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint10,  10,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int11,  11,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint11,  11,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int12,  12,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint12,  12,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int13,  13,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint13,  13,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int14,  14,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint14,  14,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int15,  15,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint15,  15,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int16,  16,    signed short)
+M_FCT_READ_SIMPLE_TYPE (uint16,  16,  unsigned short)
+M_FCT_READ_SIMPLE_TYPE ( int17,  17,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint17,  17,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int18,  18,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint18,  18,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int19,  19,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint19,  19,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int20,  20,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint20,  20,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int21,  21,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint21,  21,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int22,  22,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint22,  22,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int23,  23,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint23,  23,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int24,  24,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint24,  24,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int25,  25,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint25,  25,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int26,  26,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint26,  26,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int27,  27,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint27,  27,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int28,  28,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint28,  28,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int29,  29,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint29,  29,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int30,  30,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint30,  30,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int31,  31,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint31,  31,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int32,  32,    signed int)
+M_FCT_READ_SIMPLE_TYPE (uint32,  32,  unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( int40,  40,    signed long long)
+M_FCT_READ_SIMPLE_TYPE (uint40,  40,  unsigned long long)
+M_FCT_READ_SIMPLE_TYPE ( int48,  48,    signed long long)
+M_FCT_READ_SIMPLE_TYPE (uint48,  48,  unsigned long long)
+M_FCT_READ_SIMPLE_TYPE ( int64,  64,    signed long long)
+M_FCT_READ_SIMPLE_TYPE (uint64,  64,  unsigned long long)
+M_FCT_READ_SIMPLE_TYPE (float32, 32, float)
+M_FCT_READ_SIMPLE_TYPE (float64, 64, double)
+// alias M_FCT_READ_SIMPLE_TYPE (bool,      sizeof(bool)*8,  bool)
+// enum  M_FCT_READ_SIMPLE_TYPE (bool8,    8, unsigned char)
+// enum  M_FCT_READ_SIMPLE_TYPE (bool16,  16, unsigned short)
+// enum  M_FCT_READ_SIMPLE_TYPE (bool32,  32, unsigned int)
+M_FCT_READ_SIMPLE_TYPE ( char,    8,          char)
+M_FCT_READ_SIMPLE_TYPE (schar,    8,   signed char)
+M_FCT_READ_SIMPLE_TYPE (uchar,    8, unsigned char)
+M_FCT_READ_SIMPLE_TYPE (msg,      1, unsigned char)
+
+#undef  M_READ_SIMPLE_TYPE_BASE_ADD_OUTPUT
+#define M_READ_SIMPLE_TYPE_BASE_ADD_OUTPUT(TYPE_NAME,TYPE_BIT_SIZE,TYPE_IMPL,TYPE_IMPL_BIT_SIZE,TYPE_IMPL_STR)  \
+    P_enum_def;  // avoid warning C4189 unused variable
+M_FCT_READ_SIMPLE_TYPE (spare,    8, unsigned char)
+
+//*****************************************************************************
+// frame_to_any_set ***********************************************************
+//*****************************************************************************
+
+bool    frame_to_any_set (
+                      const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & os_out,
+                            ostream               & os_err)
+{
+    // ICIOA must verify resulting value is compatible with already recorded value ?
+    const C_value    value = field_type_name.get_set_expression().
+        compute_expression(type_definitions, interpret_data, in_out_frame_data,
+                                data_name, data_simple_name, os_out, os_err);
+    // Manage expressions inside arrays
+    if (data_simple_name.rfind(']') != string::npos)
+    {
+        const string  new_name = compute_expressions_in_array(type_definitions, interpret_data, in_out_frame_data, data_simple_name, data_name, data_simple_name, os_out, os_err);
+        interpret_data.set_read_variable (new_name, value);
+    }
+    else
+    {
+        interpret_data.set_read_variable (data_simple_name, value);
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_any_call **********************************************************
+//*****************************************************************************
+
+bool    frame_to_any_call (
+                      const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & os_out,
+                            ostream               & os_err)
+{
+    const T_function_definition  & fct_def = type_definitions.get_function(field_type_name.name);
+
+    if (frame_to_function (type_definitions,
+                         interpret_data,
+                         in_out_frame_data,
+                         fct_def,
+                         field_type_name,
+                         data_name,
+                         data_simple_name,
+                         os_out, os_err) != true)
+    {
+        os_err << "Error function call "
+               << " data= " << data_name << endl;
+        return  false;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_any_struct ********************************************************
+//*****************************************************************************
+
+bool    frame_to_any_struct (
+                      const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & os_out,
+                            ostream               & os_err)
+{
+    const T_struct_definition  * P_struct_def = field_type_name.P_type_struct_def;
+
+    if ((field_type_name.is_a_variable() == true) &&
+        (field_type_name.get_var_expression().get_original_string_expression() != "zero"))
+    {
+        // Compute expression -> name of the original struct
+        C_value  obj_value = field_type_name.get_var_expression().
+            compute_expression(
+                                type_definitions, interpret_data, in_out_frame_data,
+                                data_name, data_simple_name, os_out, os_err);
+
+        // Duplicate with new name (which already specified into name group)
+        interpret_data.duplicate_multiple_values(obj_value.get_str(), "");
+
+        // ICIOA affichage !
+
+        return  true;
+    }
+
+    bool    save_G_is_a_variable_ICIOA = G_is_a_variable_ICIOA;
+    if (field_type_name.is_a_variable() == true)
+    {
+        // Behavior with commands, loops, conditional ...
+        //  is absolutely not guaranteed.
+        G_is_a_variable_ICIOA = true;
+    }
+
+    if (frame_to_struct (type_definitions,
+                         in_out_frame_data,
+                         interpret_data,
+                        *P_struct_def,
+                         data_name,
+                         data_simple_name,
+                         os_out, os_err) != true)
+    {
+        G_is_a_variable_ICIOA = save_G_is_a_variable_ICIOA;
+        os_err << "Error struct "
+               << " data= " << data_name << endl;
+        return  false;
+    }
+    G_is_a_variable_ICIOA = save_G_is_a_variable_ICIOA;
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_any_switch ********************************************************
+//*****************************************************************************
+
+bool    frame_to_any_switch (
+                      const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & os_out,
+                            ostream               & os_err)
+{
+    const T_switch_definition  * P_switch = field_type_name.P_type_switch_def;
+
+    if (frame_to_switch (type_definitions,
+                         in_out_frame_data,
+                         interpret_data,
+                        *P_switch,
+                         field_type_name.str_size_or_parameter,
+                         field_type_name,
+                         data_name,
+                         data_simple_name,
+                         os_out, os_err) != true)
+    {
+        // Error notification done into the function.
+        return  false;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_any_bitfield ******************************************************
+//*****************************************************************************
+
+bool    frame_to_any_bitfield (
+                      const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & os_out,
+                            ostream               & os_err)
+{
+    const T_bitfield_definition  * P_bitfield_def = field_type_name.P_type_bitfield_def;
+
+    if (frame_to_bitfield (type_definitions,
+                         in_out_frame_data,
+                         interpret_data,
+                        *P_bitfield_def,
+                         data_name,
+                         data_simple_name,
+                         os_out, os_err) != true)
+    {
+        os_err << "Error bitfield fields_definition"
+               << " data= " << data_name << endl;
+        return  false;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_any_padding_bits **************************************************
+//*****************************************************************************
+
+bool    frame_to_any_padding_bits (
+                      const T_type_definitions    & UNUSED(type_definitions),
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & UNUSED(interpret_data),
+                      const T_field_type_name     & UNUSED(field_type_name),
+                      const string                & UNUSED(data_name),
+                      const string                & UNUSED(data_simple_name),
+                            ostream               & UNUSED(os_out),
+                            ostream               & UNUSED(os_err))
+{
+    const short   remaining_bits_in_byte = in_out_frame_data.get_remaining_bits() % 8;
+    in_out_frame_data.move_bit_forward(remaining_bits_in_byte);
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_any_print *********************************************************
+//*****************************************************************************
+
+bool    frame_to_any_print (
+                      const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & os_out,
+                            ostream               & os_err)
+{
+    const string  & final_type = field_type_name.type;
+
+    return  frame_to_print (type_definitions,
+                            in_out_frame_data,
+                            interpret_data,
+                            field_type_name,
+                            final_type, data_name, data_simple_name,
+                            os_out, os_err);
+}
+
+//*****************************************************************************
+// frame_to_any_error *********************************************************
+//*****************************************************************************
+
+bool    frame_to_any_error (
+                      const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & os_out,
+                            ostream               & os_err)
+{
+    const string  & final_type = field_type_name.type;
+
+    return  frame_to_print_any(type_definitions, in_out_frame_data,
+                       interpret_data,
+                       field_type_name, final_type, data_name, data_simple_name,
+                       os_out, os_err,
+                       interpret_builder_cmd_error);
+}
+
+//*****************************************************************************
+// frame_to_any_fatal *********************************************************
+//*****************************************************************************
+
+bool    frame_to_any_fatal (
+                      const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & os_out,
+                            ostream               & os_err)
+{
+    const string  & final_type = field_type_name.type;
+
+    frame_to_print_any(type_definitions, in_out_frame_data,
+                       interpret_data,
+                       field_type_name, final_type, data_name, data_simple_name,
+                       os_out, os_err,
+                       interpret_builder_cmd_fatal);
+    return  false;
+}
+
+//*****************************************************************************
+// frame_to_any_output ********************************************************
+//*****************************************************************************
+
+bool    frame_to_any_output (
+                      const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & UNUSED(os_out),
+                            ostream               & os_err)
+{
+    //-------------------------------------------------------------------------
+    // Output (of data read) control.
+    //-------------------------------------------------------------------------
+
+    if (data_simple_name == "--")
+        interpret_data.decr_output_level ();
+    else if (data_simple_name == "++")
+        interpret_data.incr_output_level ();
+    else
+    {
+        os_err << "Error output  " << data_name << endl;
+        interpret_builder_error(type_definitions, in_out_frame_data,
+                                field_type_name, data_name, data_simple_name,
+                                "Error unknow output value " + data_simple_name);
+        return  false;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_any_byte_order ****************************************************
+//*****************************************************************************
+
+bool    frame_to_any_byte_order (
+                      const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & UNUSED(os_out),
+                            ostream               & os_err)
+{
+    const string  & final_type = field_type_name.type;
+
+    //-------------------------------------------------------------------------
+    // Byte order (of data read) control.
+    //-------------------------------------------------------------------------
+    if (data_simple_name == "big_endian")
+    {
+        interpret_data.set_big_endian();
+    }
+    else if (data_simple_name == "little_endian")
+    {
+        interpret_data.set_little_endian();
+    }
+    else if (data_simple_name == "as_host")
+    {
+        interpret_data.set_as_host();
+    }
+    else
+    {
+        os_err << "Error " <<  final_type << " " << data_name << endl;
+        interpret_builder_error(type_definitions, in_out_frame_data,
+                                field_type_name, data_name, data_simple_name,
+                                "Error unknow byte_order " + data_simple_name);
+        return  false;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_any_decoder *******************************************************
+//*****************************************************************************
+
+bool    frame_to_any_decoder (
+                      const T_type_definitions    & UNUSED(type_definitions),
+                            T_frame_data          & UNUSED(in_out_frame_data),
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & UNUSED(field_type_name),
+                      const string                & UNUSED(data_name),
+                      const string                & data_simple_name,
+                            ostream               & UNUSED(os_out),
+                            ostream               & UNUSED(os_err))
+{
+    interpret_data.set_decode_function(data_simple_name);
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_any_save_position *************************************************
+//*****************************************************************************
+
+bool    frame_to_any_save_position (
+                      const T_type_definitions    & UNUSED(type_definitions),
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & UNUSED(field_type_name),
+                      const string                & UNUSED(data_name),
+                      const string                & data_simple_name,
+                            ostream               & UNUSED(os_out),
+                            ostream               & UNUSED(os_err))
+{
+    //-------------------------------------------------------------------------
+    // Position into data to read.
+    //-------------------------------------------------------------------------
+    const string  & pos_name = data_simple_name;
+    interpret_data.add_read_variable (pos_name,
+                                      in_out_frame_data.get_bit_offset_into_initial_frame());
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_any_position ******************************************************
+//*****************************************************************************
+
+bool    frame_to_any_position (
+                      const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & UNUSED(os_out),
+                            ostream               & os_err)
+{
+    const string  & final_type = field_type_name.type;
+
+    //-------------------------------------------------------------------------
+    // Position into data to read.
+    //-------------------------------------------------------------------------
+    long                  bit_offset_pos = 0;
+
+    if (final_type == "goto_position")
+    {
+        const string  & pos_name = data_simple_name;
+        long long       value_int_ll;
+        if (get_complex_variable_integer_value (interpret_data,
+                                                pos_name,
+                                                value_int_ll) != E_rc_ok)
+        {
+            os_err << "Error unknow position " << data_name << endl;
+            interpret_builder_error(type_definitions, in_out_frame_data,
+                                    field_type_name, data_name, data_simple_name,
+                                    "Error unknow position " + data_simple_name);
+            return  false;
+        }
+
+        bit_offset_pos = static_cast<long>(value_int_ll) - in_out_frame_data.get_bit_offset_into_initial_frame();
+    }
+    else
+    {
+        const string  & offset_pos_name = data_simple_name;
+        long long       value_int_ll;
+        if (get_complex_variable_integer_value (interpret_data,
+                                                offset_pos_name,
+                                                value_int_ll) != E_rc_ok)
+        {
+            os_err << "Error unknow position " << data_name << endl;
+            interpret_builder_error(type_definitions, in_out_frame_data,
+                                    field_type_name, data_name, data_simple_name,
+                                    "Error unknow position " + data_simple_name);
+            return  false;
+        }
+
+        bit_offset_pos = static_cast<long>(value_int_ll);
+        if (final_type == "move_position_bytes")
+        {
+            bit_offset_pos *= 8;
+        }
+    }
+
+    const long    bit_offset_pos_after_end = bit_offset_pos - in_out_frame_data.get_remaining_bits();
+    if (bit_offset_pos_after_end > 0)
+    {
+        os_err << "Error " << final_type << " " << data_name
+               << " goes " << bit_offset_pos_after_end
+               << " bits after end of data." << endl;
+        interpret_builder_error(type_definitions, in_out_frame_data,
+                                field_type_name, data_name, data_simple_name,
+                                "Error " + final_type + " " + data_simple_name +
+                                " goes " + get_string(bit_offset_pos_after_end) +
+                                " bits after end of data.");
+        return  false;
+    }
+
+    const long    bit_offset_pos_before_begin = -bit_offset_pos - in_out_frame_data.get_bit_offset();
+    if (bit_offset_pos_before_begin > 0)
+    {
+        os_err << "Error " << final_type << " " << data_name
+               << " goes " << bit_offset_pos_before_begin
+               << " bits before beginning of data." << endl;
+        interpret_builder_error(type_definitions, in_out_frame_data,
+                                field_type_name, data_name, data_simple_name,
+                                "Error " + final_type + " " + data_simple_name +
+                                " goes " + get_string(bit_offset_pos_before_begin) +
+                                " bits before beginning of data.");
+        return  false;
+    }
+
+    in_out_frame_data.move_bit(bit_offset_pos);
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_any_check_eof_distance ********************************************
+//*****************************************************************************
+
+bool    frame_to_any_check_eof_distance (
+                      const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & UNUSED(interpret_data),
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & UNUSED(os_out),
+                            ostream               & os_err)
+{
+    const string  & final_type = field_type_name.type;
+
+    //-------------------------------------------------------------------------
+    // Check End Of Frame distance.
+    // I.e. check the number of bytes not already read.
+    //-------------------------------------------------------------------------
+
+    long    distance = -1;
+
+    if (get_number (data_simple_name.c_str (), &distance) == false)
+    {
+        os_err << "Error " << final_type << " " << data_name
+               << " is NOT a number." << endl;
+        interpret_builder_error(type_definitions, in_out_frame_data,
+                                field_type_name, data_name, data_simple_name,
+                                "Error " + final_type + " " + data_simple_name + " is not a number");
+        return  false;
+    }
+    if (final_type == "check_eof_distance_bytes")
+    {
+        distance *= 8;
+    }
+
+    if (distance != in_out_frame_data.get_remaining_bits())
+    {
+        os_err << "Error " << final_type << " " << distance
+               << " bits != " << in_out_frame_data.get_remaining_bits()
+               << " bits"
+               << endl;
+        interpret_builder_error(type_definitions, in_out_frame_data,
+                                field_type_name, data_name, data_simple_name,
+                                "Error " + final_type + " " + get_string(distance) + " bits != " +
+                                 get_string(in_out_frame_data.get_remaining_bits()) + " bits");
+        return  false;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// frame_to_any_chrono ********************************************************
+//*****************************************************************************
+
+bool    frame_to_any_chrono (
+                      const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & UNUSED(data_name),
+                      const string                & UNUSED(data_simple_name),
+                            ostream               & os_out,
+                            ostream               & os_err)
+{
+    //-------------------------------------------------------------------------
+    // Chrono.
+    // Display some performance measure.
+    // For integration only.
+    //-------------------------------------------------------------------------
+    const string  & chrono_cmd = field_type_name.name;
+    const string    chrono_val = interpret_data.compute_chrono_value_from_command(chrono_cmd);
+    if (chrono_val != "")
+    {
+        return  frame_to_print (type_definitions,
+                                in_out_frame_data,
+                                interpret_data,
+                                field_type_name,
+                                "print", chrono_val, chrono_val,
+                                os_out, os_err);
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// build_types_finalize_itself ************************************************
+//*****************************************************************************
+
+void    build_types_finalize_itself(T_type_definitions  & type_definitions,
+                                    T_field_type_name   & field_type_name)
+{
+    string    final_type = field_type_name.type;
+
+    // frame_to_field 1st
+
+    if (final_type == "deep_break")
+    {
+        field_type_name.pf_frame_to_field = frame_to_field_deep_break;
+        return;
+    }
+
+    if (final_type == "deep_continue")
+    {
+        field_type_name.pf_frame_to_field = frame_to_field_deep_continue;
+        return;
+    }
+
+    if (final_type == "break")
+    {
+        field_type_name.pf_frame_to_field = frame_to_field_break;
+        return;
+    }
+
+    if (final_type == "continue")
+    {
+        field_type_name.pf_frame_to_field = frame_to_field_continue;
+        return;
+    }
+
+    if (final_type == "return")
+    {
+        field_type_name.pf_frame_to_field = frame_to_field_return;
+        return;
+    }
+
+    if ((final_type == "while") ||
+        (final_type == "do_while"))
+    {
+        field_type_name.pf_frame_to_field = frame_to_field_while;
+        return;
+    }
+
+    if ((final_type == "loop_size_bytes") ||
+        (final_type == "loop_size_bits"))
+    {
+        field_type_name.pf_frame_to_field = frame_to_field_loop_size;
+        return;
+    }
+
+    if (final_type == "loop_nb_times")
+    {
+        field_type_name.pf_frame_to_field = frame_to_field_loop_nb_times;
+        return;
+    }
+
+    if (final_type == "if")
+    {
+        field_type_name.pf_frame_to_field = frame_to_field_if;
+        return;
+    }
+
+    // frame_to_field other
+
+    {
+        field_type_name.pf_frame_to_field = frame_to_field_other;
+        // no return;
+    }
+
+    // frame_to_any then
+
+    if (final_type == "set")
+    {
+        field_type_name.pf_frame_to_any = frame_to_any_set;
+        return;
+    }
+
+    if (final_type == "call")
+    {
+        field_type_name.pf_frame_to_any = frame_to_any_call;
+        return;
+    }
+
+    {
+        const T_struct_definition  * P_struct_def = type_definitions.get_P_struct(final_type);
+        if (P_struct_def != nullptr)
+        {
+            field_type_name.pf_frame_to_any = frame_to_any_struct;
+            field_type_name.P_type_struct_def = P_struct_def;
+            return;
+        }
+    }
+
+    //-------------------------------------------------------------------------
+    // Enum ?
+    //-------------------------------------------------------------------------
+    bool    is_enum = false;
+    {
+        const T_enum_definition_representation  * P_enum_def = type_definitions.get_P_enum(final_type);
+        if (P_enum_def != nullptr)
+        {
+            field_type_name.P_type_enum_def = P_enum_def;
+            is_enum = true;
+
+            final_type = P_enum_def->representation_type;
+        }
+    }
+
+    //-------------------------------------------------------------------------
+    // Macro for read a simple type ...
+    //-------------------------------------------------------------------------
+#undef  M_READ_SIMPLE_TYPE
+#define M_READ_SIMPLE_TYPE(TYPE_NAME,TYPE_BIT_SIZE,TYPE_IMPL)                 \
+    if (final_type == #TYPE_NAME)                                             \
+    {                                                                         \
+        field_type_name.pf_frame_to_any = frame_to_any_ ##  TYPE_NAME;        \
+        if (is_enum == true)                                                  \
+        {                                                                     \
+            field_type_name.pf_frame_to_any = frame_to_any_ ##  TYPE_NAME ## _enum;  \
+        }                                                                     \
+        return;                                                               \
+    }
+
+
+    M_READ_SIMPLE_TYPE (uint1,    1,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int2,    2,    signed int)
+    M_READ_SIMPLE_TYPE (uint2,    2,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int3,    3,    signed int)
+    M_READ_SIMPLE_TYPE (uint3,    3,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int4,    4,    signed int)
+    M_READ_SIMPLE_TYPE (uint4,    4,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int5,    5,    signed int)
+    M_READ_SIMPLE_TYPE (uint5,    5,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int6,    6,    signed int)
+    M_READ_SIMPLE_TYPE (uint6,    6,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int7,    7,    signed int)
+    M_READ_SIMPLE_TYPE (uint7,    7,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int8,    8,    signed char)
+    M_READ_SIMPLE_TYPE (uint8,    8,  unsigned char)
+
+    M_READ_SIMPLE_TYPE ( int9,    9,    signed int)
+    M_READ_SIMPLE_TYPE (uint9,    9,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int10,  10,    signed int)
+    M_READ_SIMPLE_TYPE (uint10,  10,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int11,  11,    signed int)
+    M_READ_SIMPLE_TYPE (uint11,  11,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int12,  12,    signed int)
+    M_READ_SIMPLE_TYPE (uint12,  12,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int13,  13,    signed int)
+    M_READ_SIMPLE_TYPE (uint13,  13,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int14,  14,    signed int)
+    M_READ_SIMPLE_TYPE (uint14,  14,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int15,  15,    signed int)
+    M_READ_SIMPLE_TYPE (uint15,  15,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int16,  16,    signed short)
+    M_READ_SIMPLE_TYPE (uint16,  16,  unsigned short)
+
+    M_READ_SIMPLE_TYPE ( int17,  17,    signed int)
+    M_READ_SIMPLE_TYPE (uint17,  17,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int18,  18,    signed int)
+    M_READ_SIMPLE_TYPE (uint18,  18,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int19,  19,    signed int)
+    M_READ_SIMPLE_TYPE (uint19,  19,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int20,  20,    signed int)
+    M_READ_SIMPLE_TYPE (uint20,  20,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int21,  21,    signed int)
+    M_READ_SIMPLE_TYPE (uint21,  21,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int22,  22,    signed int)
+    M_READ_SIMPLE_TYPE (uint22,  22,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int23,  23,    signed int)
+    M_READ_SIMPLE_TYPE (uint23,  23,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int24,  24,    signed int)
+    M_READ_SIMPLE_TYPE (uint24,  24,  unsigned int)
+
+    M_READ_SIMPLE_TYPE ( int25,  25,    signed int)
+    M_READ_SIMPLE_TYPE (uint25,  25,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int26,  26,    signed int)
+    M_READ_SIMPLE_TYPE (uint26,  26,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int27,  27,    signed int)
+    M_READ_SIMPLE_TYPE (uint27,  27,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int28,  28,    signed int)
+    M_READ_SIMPLE_TYPE (uint28,  28,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int29,  29,    signed int)
+    M_READ_SIMPLE_TYPE (uint29,  29,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int30,  30,    signed int)
+    M_READ_SIMPLE_TYPE (uint30,  30,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int31,  31,    signed int)
+    M_READ_SIMPLE_TYPE (uint31,  31,  unsigned int)
+    M_READ_SIMPLE_TYPE ( int32,  32,    signed int)
+    M_READ_SIMPLE_TYPE (uint32,  32,  unsigned int)
+
+    M_READ_SIMPLE_TYPE ( int40,  40,    signed long long)
+    M_READ_SIMPLE_TYPE (uint40,  40,  unsigned long long)
+    M_READ_SIMPLE_TYPE ( int48,  48,    signed long long)
+    M_READ_SIMPLE_TYPE (uint48,  48,  unsigned long long)
+    M_READ_SIMPLE_TYPE ( int64,  64,    signed long long)
+    M_READ_SIMPLE_TYPE (uint64,  64,  unsigned long long)
+    M_READ_SIMPLE_TYPE (float32, 32, float)
+    M_READ_SIMPLE_TYPE (float64, 64, double)
+// alias    M_READ_SIMPLE_TYPE ("bool",      sizeof(bool)*8,  bool)
+// enum     M_READ_SIMPLE_TYPE ("bool8",    8, unsigned char)
+// enum     M_READ_SIMPLE_TYPE ("bool16",  16, unsigned short)
+// enum     M_READ_SIMPLE_TYPE ("bool32",  32, unsigned int)
+    M_READ_SIMPLE_TYPE (spare,    8, unsigned char)
+    M_READ_SIMPLE_TYPE ( char,    8,          char)
+    M_READ_SIMPLE_TYPE (schar,    8,   signed char)
+    M_READ_SIMPLE_TYPE (uchar,    8, unsigned char)
+    M_READ_SIMPLE_TYPE (msg,      1, unsigned char)
+
+
+    if ((final_type == "string") ||
+        (final_type == "string_nl"))
+    {
+        field_type_name.pf_frame_to_any = frame_to_string;
+        return;
+    }
+
+    if ((final_type == "raw") ||
+        (final_type == "subproto") ||
+        (final_type == "insproto"))
+    {
+        field_type_name.pf_frame_to_any = frame_to_raw;
+        return;
+    }
+
+    {
+        const T_switch_definition  * P_switch = type_definitions.get_P_switch(final_type);
+        if (P_switch != nullptr)
+        {
+            field_type_name.pf_frame_to_any = frame_to_any_switch;
+            field_type_name.P_type_switch_def = P_switch;
+            return;
+        }
+    }
+
+    {
+        const T_bitfield_definition  * P_bitfield_def = type_definitions.get_P_bitfield(final_type);
+        if (P_bitfield_def != nullptr)
+        {
+            field_type_name.pf_frame_to_any = frame_to_any_bitfield;
+            field_type_name.P_type_bitfield_def = P_bitfield_def;
+            return;
+        }
+    }
+
+    if (final_type == "padding_bits")
+    {
+        field_type_name.pf_frame_to_any = frame_to_any_padding_bits;
+        return;
+    }
+
+    if ((final_type == "debug_print") || (final_type == "print"))
+    {
+        field_type_name.pf_frame_to_any = frame_to_any_print;
+        return;
+    }
+
+    if ((final_type == "chat") ||
+        (final_type == "note") ||
+        (final_type == "warning") ||
+        (final_type == "error"))
+    {
+        field_type_name.pf_frame_to_any = frame_to_any_error;
+        return;
+    }
+
+    if (final_type == "fatal")
+    {
+        field_type_name.pf_frame_to_any = frame_to_any_fatal;
+        return;
+    }
+
+    if (final_type == "output")
+    {
+        field_type_name.pf_frame_to_any = frame_to_any_output;
+        return;
+    }
+
+    if (final_type == "byte_order")
+    {
+        field_type_name.pf_frame_to_any = frame_to_any_byte_order;
+        return;
+    }
+
+    if (final_type == "decoder")
+    {
+        field_type_name.pf_frame_to_any = frame_to_any_decoder;
+        return;
+    }
+
+    if (final_type == "save_position")
+    {
+        field_type_name.pf_frame_to_any = frame_to_any_save_position;
+        return;
+    }
+
+    if ((final_type == "goto_position") ||
+        (final_type == "move_position_bytes") ||
+        (final_type == "move_position_bits"))
+    {
+        field_type_name.pf_frame_to_any = frame_to_any_position;
+        return;
+    }
+
+    if ((final_type == "check_eof_distance_bytes") ||
+        (final_type == "check_eof_distance_bits"))
+    {
+        field_type_name.pf_frame_to_any = frame_to_any_check_eof_distance;
+        return;
+    }
+
+    if (final_type == "chrono")
+    {
+        field_type_name.pf_frame_to_any = frame_to_any_chrono;
+        return;
+    }
+}
+
+void    build_types_finalize_itself(const T_type_definitions  & type_definitions,
+                                    const T_field_type_name   & field_type_name)
+{
+    build_types_finalize_itself(const_cast<T_type_definitions &>(type_definitions),
+                                const_cast<T_field_type_name &>(field_type_name));
+}
+
+//*****************************************************************************
+// C_interpret_forget_data
+// Destructor will remove ALL variables created after the contructor.
+// Permits recursive call.
+//*****************************************************************************
+
+class C_interpret_forget_data
+{
+public:
+    C_interpret_forget_data(T_interpret_read_values  & interpret_read_values,
+                            bool                       must_forget)
+        :A_interpret_read_values(interpret_read_values),
+         A_must_forget(must_forget),
+         A_read_variable_id(A_interpret_read_values.get_id_of_last_read_variable())
+    {
+    }
+    ~C_interpret_forget_data()
+    {
+        if (A_must_forget == true)
+        {
+            A_interpret_read_values.sup_all_read_variables_after(A_read_variable_id);
+        }
+    }
+
+private:
+    // Copy and assignment are forbidden
+    C_interpret_forget_data(const C_interpret_forget_data  &);
+    C_interpret_forget_data & operator=(const C_interpret_forget_data  &);
+
+    T_interpret_read_values        & A_interpret_read_values;
+    bool                             A_must_forget;
+    T_interpret_read_values::T_id    A_read_variable_id;
+};
+
+
+//*****************************************************************************
+// frame_to_any ***************************************************************
+//*****************************************************************************
+
+bool    frame_to_any (const T_type_definitions    & type_definitions,
+                            T_frame_data          & in_out_frame_data,
+                            T_interpret_data      & interpret_data,
+                      const T_field_type_name     & field_type_name,
+                      const string                & data_name,
+                      const string                & data_simple_name,
+                            ostream               & os_out,
+                            ostream               & os_err)
+{
+    M_TRACE_ENTER ("frame_to_any",
+                   "data_type=" << field_type_name.type << " data_name=" << data_name);
+
+    // Will forget data if asked.
+    C_interpret_forget_data    ifd(interpret_data, field_type_name.must_forget);
+
+    // Hide the field if asked.
+    const int   output_level_offset = field_type_name.get_output_level_offset();
+    C_interpret_output_level_move_temporary    iolmt(interpret_data, output_level_offset);
+
+    // Set temporary the decoder function
+    C_interpret_decode_set_temporary    idst(interpret_data, field_type_name.str_decoder_function);
+
+    // Set temporary the byte order
+    C_interpret_byte_order_set_temporary  ibost(interpret_data, field_type_name.str_byte_order);
+
+
+    //-------------------------------------------------------------------------
+    // Array ?   managed inside frame_to_field
+    //-------------------------------------------------------------------------
+
+
+    if (field_type_name.pf_frame_to_any == nullptr)
+    {
+        // Normally set at initialisation time for all types into type_definitions.
+        // But some field_type_name could be created on the fly.
+        build_types_finalize_itself(type_definitions, field_type_name);
+
+        if (field_type_name.pf_frame_to_any == nullptr)
+        {
+            //-------------------------------------------------------------------------
+            // Error
+            //-------------------------------------------------------------------------
+            interpret_builder_error(type_definitions, in_out_frame_data,
+                                    field_type_name, data_name, data_simple_name,
+                                    "Not valid type " + field_type_name.type);
+            return  false;
+        }
+    }
+
+    return  field_type_name.pf_frame_to_any(type_definitions,
+                                           in_out_frame_data,
+                                           interpret_data,
+                                           field_type_name,
+                                           data_name,
+                                           data_simple_name,
+                                           os_out, os_err);
+}
+
+//*****************************************************************************
+// frame_to_main **************************************************************
+//*****************************************************************************
+
+bool    frame_to_main (const T_type_definitions  & type_definitions,
+                             T_frame_data        & in_out_frame_data,
+                             T_interpret_data    & interpret_data,
+                             string              & last_extracted_word,       // in/out
+                             istream             & is,
+                             ostream             & os_out,
+                             ostream             & os_err)
+{
+    M_TRACE_ENTER ("frame_to_main",
+                   "sizeof_bits=" << in_out_frame_data.get_remaining_bits() <<
+                   " last_extracted_word=" << last_extracted_word);
+
+    T_field_type_name    field_type_name;
+    last_extracted_word = build_field (is, type_definitions, last_extracted_word, field_type_name);
+
+    if (frame_to_field (type_definitions,
+                      in_out_frame_data,
+                      interpret_data,
+                      field_type_name,
+                      "",                 // 20090430 instead of field_type_name.name : seems ok
+                      field_type_name.name,
+                      os_out, os_err) != true)
+    {
+        os_err << " type= " << field_type_name.type
+               << " variable= " << field_type_name.name << endl;
+        return  false;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// interpret_bytes ************************************************************
+//*****************************************************************************
+
+bool    interpret_bytes (const T_type_definitions  & type_definitions,
+                         const T_byte             *& in_out_P_bytes,
+                               size_t              & in_out_sizeof_bytes,
+                               istream             & is,
+                               ostream             & os_out,
+                               ostream             & os_err,
+                               T_interpret_data    & interpret_data)
+{
+    M_TRACE_ENTER ("interpret_bytes",
+                   "sizeof_bytes=" << in_out_sizeof_bytes);
+
+    C_setlocale_numeric_C_guard  locale_guard;
+
+//    C_interpret_data_set_temporary  interpret_data_set_temporary(interpret_data);  // ICIOA
+
+    T_frame_data           frame_data(in_out_P_bytes, 0, in_out_sizeof_bytes * 8);
+    T_decode_stream_frame                             decode_stream_frame;
+    C_decode_stream_frame_set_temporary_if_necessary  dsfstin(interpret_data, decode_stream_frame);
+//    interpret_data.set_decode_stream_frame(&decode_stream_frame);
+    interpret_data.add_read_variable("internal_frame", (long long)interpret_data.get_P_decode_stream_frame());
+
+    bool    result = false;
+
+    try
+    {
+        skip_blanks_and_comments(is);
+
+        string    last_extracted_word;
+        read_token_left_any (is, last_extracted_word);
+
+        while (true)
+        {
+            if (frame_to_main (type_definitions,
+                               frame_data,
+                               interpret_data,
+                               last_extracted_word,       // in/out
+                               is,
+                               os_out,
+                               os_err) != true)
+            {
+                break;
+            }
+
+            if (last_extracted_word.empty())
+            {
+                result = true;
+                break;
+            }
+        }
+    }
+    catch (C_byte_interpret_exception  & val)
+    {
+        const string  & str_interpret_fatal_text = val.get_explanation();
+
+        if (val.get_cause() != E_byte_interpret_exception_missing_data)    // already displayed exception
+        {
+            const string         str_interpret = "fatal  \"" + str_interpret_fatal_text + "\" ;";
+
+            interpret_bytes (   type_definitions,
+                                in_out_P_bytes,
+                                in_out_sizeof_bytes,
+                                str_interpret,
+                                os_out,
+                                os_err,
+                                interpret_data);
+        }
+    }
+
+    in_out_sizeof_bytes = frame_data.get_remaining_entire_bytes();
+
+    if (result && (frame_data.is_physically_at_beginning_of_byte() != true))
+    {
+        result = false;  // bsew ICIOA must do a fatal
+    }
+
+    if (result == true)
+    {
+        const long  inside_frame_remaining_bits = interpret_data.get_decode_stream_frame().frame_data.get_remaining_bits();
+        if (inside_frame_remaining_bits != 0)
+        {
+            M_TRACE_ERROR("inside_frame_remaining_bits=" << inside_frame_remaining_bits << " should be zero"); 
+            result = false;
+        }
+    }
+
+    return  result;
+}
+
+//*****************************************************************************
+// interpret_bytes ************************************************************
+//*****************************************************************************
+
+bool    interpret_bytes (const T_type_definitions  & type_definitions,
+                         const T_byte             *& in_out_P_bytes,
+                               size_t              & in_out_sizeof_bytes,
+                         const string              & in_input_string,
+                               ostream             & os_out,
+                               ostream             & os_err,
+                               T_interpret_data    & interpret_data)
+{
+    istringstream     is(in_input_string.c_str());
+
+    return  interpret_bytes (type_definitions,
+                             in_out_P_bytes,
+                             in_out_sizeof_bytes,
+                             is,
+                             os_out,
+                             os_err,
+                             interpret_data);
+}
+
+//*****************************************************************************
+// interpret_bytes ************************************************************
+//*****************************************************************************
+
+bool    interpret_bytes (const T_type_definitions  & type_definitions,
+                         const T_byte             *& in_out_P_bytes,
+                               size_t              & in_out_sizeof_bytes,
+                               istream             & is,
+                               ostream             & os_out,
+                               ostream             & os_err)
+{
+    T_interpret_data    interpret_data;
+
+    return  interpret_bytes (type_definitions,
+                             in_out_P_bytes,
+                             in_out_sizeof_bytes,
+                             is,
+                             os_out,
+                             os_err,
+                             interpret_data);
+}
+
+//*****************************************************************************
+// interpret_bytes ************************************************************
+//*****************************************************************************
+
+bool    interpret_bytes (const T_type_definitions  & type_definitions,
+                         const T_byte             *& in_out_P_bytes,
+                               size_t              & in_out_sizeof_bytes,
+                         const string              & in_input_string,
+                               ostream             & os_out,
+                               ostream             & os_err)
+{
+    istringstream     is(in_input_string.c_str());
+
+    return  interpret_bytes (type_definitions,
+                             in_out_P_bytes,
+                             in_out_sizeof_bytes,
+                             is,
+                             os_out,
+                             os_err);
+}
+
+//*****************************************************************************
+// build_types_and_interpret_bytes ********************************************
+//*****************************************************************************
+
+bool    build_types_and_interpret_bytes (
+                        T_type_definitions  & type_definitions,
+                        T_frame_data        & in_out_frame_data,
+                        istream             & is,
+                        ostream             & os_out,
+                        ostream             & os_err)
+{
+    M_TRACE_ENTER ("build_types_and_interpret_bytes",
+                   "sizeof_bits=" << in_out_frame_data.get_remaining_bits());
+
+    C_setlocale_numeric_C_guard  locale_guard;
+
+    // Set the interpret_data.
+    T_interpret_data    interpret_data;
+//    C_interpret_data_set_temporary    idst(interpret_data);
+    T_decode_stream_frame                             decode_stream_frame;
+    C_decode_stream_frame_set_temporary_if_necessary  dsfstin(interpret_data, decode_stream_frame);
+//    interpret_data.set_decode_stream_frame(&decode_stream_frame);
+    interpret_data.add_read_variable("internal_frame", get_string((long long)interpret_data.get_P_decode_stream_frame()));
+
+    // Reads type definitions.
+    // Returns the 1st not understood word (i.e. a word which is NOT a type definition).
+    string    last_extracted_word = build_types (is, type_definitions);
+    bool    result = true;
+
+    while (last_extracted_word != "")
+    {
+        if (frame_to_main (type_definitions,
+                           in_out_frame_data,
+                           interpret_data,
+                           last_extracted_word,       // in/out
+                           is,
+                           os_out,
+                           os_err) != true)
+        {
+          result = false;
+          break;
+        }
+    }
+
+    if (result == true)
+    {
+        // Verify that this is the end of stream.
+        M_FATAL_IF_NE (last_extracted_word, "");
+        M_ASSERT (is.eof ());
+
+        const long  inside_frame_remaining_bits = interpret_data.get_decode_stream_frame().frame_data.get_remaining_bits();
+        if (inside_frame_remaining_bits != 0)
+        {
+            M_TRACE_ERROR("inside_frame_remaining_bits=" << inside_frame_remaining_bits << " should be zero"); 
+            result = false;
+        }
+    }
+  
+    return  result;
+}
+
+//*****************************************************************************
+// build_types_and_interpret_bytes ********************************************
+//*****************************************************************************
+
+bool    build_types_and_interpret_bytes (
+                  const T_byte             *& in_out_P_bytes,
+                        size_t              & in_out_sizeof_bytes,
+                        istream             & is,
+                        ostream             & os_out,
+                        ostream             & os_err)
+{
+    T_frame_data    frame_data(in_out_P_bytes, 0, in_out_sizeof_bytes * 8);
+
+    try
+    {
+        T_type_definitions                      type_definitions;
+
+        bool  result = build_types_and_interpret_bytes (type_definitions,
+                                                        frame_data,
+                                                        is,
+                                                        os_out,
+                                                        os_err);
+        in_out_P_bytes      = frame_data.get_P_bytes();
+        in_out_sizeof_bytes = frame_data.get_remaining_entire_bytes();
+
+        if (result && (frame_data.is_physically_at_beginning_of_byte() != true))
+        {
+            result = false;  // bsew ICIOA must do a fatal
+        }
+
+        return  result;
+    }
+    catch (...)
+    {
+    }
+
+    return  false;
+}
diff --git a/plugins/epan/generic/byte_interpret.h b/plugins/epan/generic/byte_interpret.h
new file mode 100644
index 00000000000..5ea98c0c349
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef BYTE_INTERPRET_H
+#define BYTE_INTERPRET_H
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+using namespace std;
+
+#include "byte_interpret_common.h"
+#include "byte_interpret_build_types.h"
+#include "T_interpret_data.h"
+
+
+//*****************************************************************************
+// interpret_bytes ************************************************************
+//*****************************************************************************
+// type_definitions    : definitions of types (struct, enum, function ...)
+// in_out_P_bytes      : binary data to interpret
+// in_out_sizeof_bytes : size of binary data, out: size of unread data
+// input_stream        : what must be read inside binary data
+// os_out              : normal output stream
+// os_err              : error  output stream
+// interpret_data      : binary data read and interpreted
+// Returns true if ok.
+//*****************************************************************************
+// NB: Returns false if it remains data into inside_frame.
+// NB: This interface accepts only bytes and not bits.
+//*****************************************************************************
+
+bool    interpret_bytes (const T_type_definitions  & type_definitions,
+                         const T_byte             *& in_out_P_bytes,
+                               size_t              & in_out_sizeof_bytes,
+                               istream             & input_stream,
+                               ostream             & os_out,
+                               ostream             & os_err,
+                               T_interpret_data    & in_out_interpret_data);
+
+bool    interpret_bytes (const T_type_definitions  & type_definitions,
+                         const T_byte             *& in_out_P_bytes,
+                               size_t              & in_out_sizeof_bytes,
+                         const string              & in_input_string,
+                               ostream             & os_out,
+                               ostream             & os_err,
+                               T_interpret_data    & in_out_interpret_data);
+
+//*****************************************************************************
+// build_types_and_interpret_bytes ********************************************
+//*****************************************************************************
+// Idem above except that
+//  the definitions of types is directly read inside input_stream
+//*****************************************************************************
+
+bool    build_types_and_interpret_bytes (
+                  const T_byte             *& in_out_P_bytes,
+                        size_t              & in_out_sizeof_bytes,
+                        istream             & input_stream,
+                        ostream             & os_out,
+                        ostream             & os_err);
+
+//*****************************************************************************
+// misc
+//*****************************************************************************
+
+bool    is_a_switch_value (const T_type_definitions  & type_definitions,
+                           const string              & orig_type,
+                                 string              & final_simple_type,
+                                 string              & discriminant);
+
+
+
+
+#endif /* BYTE_INTERPRET_H */
diff --git a/plugins/epan/generic/byte_interpret_build_types.cpp b/plugins/epan/generic/byte_interpret_build_types.cpp
new file mode 100644
index 00000000000..90cd2763bc4
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_build_types.cpp
@@ -0,0 +1,2714 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+// Necessary for windows pre-compiled headers.
+// At the end, does NOT work : missing functions at link time
+// After other includes, does NOT work : does NOT compile (on "ifstream   ifs") 
+#include "precomp.h"
+
+#include <cstdio>
+#include <cerrno>
+#include <cassert>
+#include <iostream>
+#include <string>
+#include <map>
+#include <vector>
+#include <queue>
+#include <fstream>
+#include <sstream>
+using namespace std;
+
+#include "byte_interpret_common.h"
+#include "byte_interpret_compute_expression.h"
+#include "byte_interpret_parse.h"
+#include "F_common_print.h"
+#include "byte_interpret_build_types.h"
+#include "byte_interpret_build_types_context.h"
+#include "byte_interpret_build_types_read_token.h"
+#include "C_setlocale_numeric_C_guard.h"
+
+// plugin needs gmodule/glib
+// Linux 300X must find (cmake) g_module to enable it
+// Undocumented feature, nobody will miss it
+//#define BYTE_INTERPRET_USE_PLUGIN
+#ifdef FRHED
+// FRHED do not find gmodule lib
+#undef  BYTE_INTERPRET_USE_PLUGIN
+#endif
+
+
+//*****************************************************************************
+// byte_interpret_get_include_file_name
+//*****************************************************************************
+
+static string    S_basic_directory;
+
+void      byte_interpret_set_include_directory(const string  & dir_name)
+{
+    S_basic_directory = dir_name;
+}
+
+void      byte_interpret_append_include_directory(const string  & sub_dir_name)
+{
+    S_basic_directory = byte_interpret_get_include_file_name(sub_dir_name);
+}
+
+string    byte_interpret_get_include_directory()
+{
+    return  S_basic_directory;
+}
+
+string    byte_interpret_get_include_file_name(const string  & file_name)
+{
+    if (S_basic_directory == "")
+        return  file_name;
+
+    return  S_basic_directory + "/" + file_name;      // "/" is ok for windows
+}
+
+class C_byte_interpret_append_include_directory
+{
+public:
+    C_byte_interpret_append_include_directory()
+        :include_directory_save(byte_interpret_get_include_directory())
+    {
+    }
+
+    C_byte_interpret_append_include_directory(const string  & sub_dir_name)
+        :include_directory_save(byte_interpret_get_include_directory())
+    {
+        byte_interpret_append_include_directory(sub_dir_name);
+    }
+
+    void    append_include_directory(const string  & sub_dir_name)
+    {
+        byte_interpret_append_include_directory(sub_dir_name);
+    }
+
+    ~C_byte_interpret_append_include_directory()
+    {
+        byte_interpret_set_include_directory(include_directory_save);
+    }
+
+private:
+    string    include_directory_save;
+};
+
+//*****************************************************************************
+// build_alias
+// ----------------------------------------------------------------------------
+// Format :
+// alias  <type_alias_name>  <type_to_use_instead>
+//*****************************************************************************
+void    build_alias (const E_override            must_override,
+                     const string              & key_word,
+                           istream             & is,
+                           T_type_definitions  & type_definitions)
+{
+    M_TRACE_ENTER ("build_alias", "");
+
+    M_ASSERT_EQ (key_word, "alias");
+
+    string    alias_name;
+    M_FATAL_IF_FALSE (read_token_type_simple (is, alias_name));
+
+    build_types_context_type_begin(alias_name);
+
+    string    type;
+    M_FATAL_IF_FALSE (read_token_type_complex (is, type));
+
+    type_definitions.add_alias(alias_name, type, must_override);
+
+    read_token_end_of_statement(is);
+
+    build_types_context_type_end(alias_name);
+}
+
+//*****************************************************************************
+// string_to_numeric **********************************************************
+//*****************************************************************************
+// ICIOA
+C_value    string_to_numeric(const T_type_definitions  & type_definitions,
+                             const string              & str_to_convert_to_numeric,
+                             const string              & field_name,
+                             const char                * attr);
+
+//*****************************************************************************
+// check_field_name ***********************************************************
+//*****************************************************************************
+// Authorized : alphanum and _.
+// I refuse - (accepted by wireshark) because used into expression.
+//*****************************************************************************
+
+void    check_field_name(      T_field_type_name  & field_type_name,
+                         const char                 also_authorized = '\0')
+{
+    // Extract display/filter/extended names
+    string    simple_name;
+    string    str_parameter;
+    while (decompose_type_sep_value_sep (field_type_name.name,
+                                                      '{',
+                                                      '}',
+                                                      simple_name,
+                                                      str_parameter) == E_rc_ok)
+    {
+        field_type_name.name = simple_name;
+        M_TRACE_DEBUG(str_parameter);
+
+        if (strncmp(str_parameter.c_str(), "name=", 5) == 0)         // display name
+        {
+            field_type_name.display_name = str_parameter.substr(5);
+            remove_string_limits(field_type_name.display_name);
+        }
+        else if (strncmp(str_parameter.c_str(), "filter=", 7) == 0)    // filter name
+        {
+            field_type_name.filter_name = str_parameter.substr(7);
+            if ((field_type_name.filter_name[0] == '\"') ||
+                (field_type_name.filter_name[0] == '\''))
+            {
+                M_FATAL_COMMENT("Unexpected blank/space/'/\" inside field filter name (" << field_type_name.filter_name << ").");
+            }
+        }
+        else if (strncmp(str_parameter.c_str(), "desc=", 5) == 0)  // extended name
+        {
+            field_type_name.extended_name = str_parameter.substr(5);
+            remove_string_limits(field_type_name.extended_name);
+        }
+        else
+        {
+            M_FATAL_COMMENT("Unexpected parameter (" << str_parameter << ") inside field name.");
+        }
+    }
+
+    const string &  field_name = field_type_name.name;
+    if (is_a_valid_short_variable_name(field_name, also_authorized) == false)
+    {
+        M_FATAL_COMMENT("Unexpected field name (" << field_name << ") only alphanumeric and _ accepted. Must not start by a number.");
+    }
+}
+
+//*****************************************************************************
+// ----------------------------------------------------------------------------
+// Format :
+// <simple_type>[<str_array_size>]
+// NB: <str_array_size> is :
+//     - an integer > 0 or
+//     - the name of the integer variable which contains the size
+//*****************************************************************************
+
+bool    is_an_array (const string   & orig_type,
+                           string   & simple_type,
+                           string   & str_array_size)
+{
+    E_return_code  rc = decompose_type_sep_value_sep (orig_type,
+                                                      '[',
+                                                      ']',
+                                                      simple_type,
+                                                      str_array_size);
+    if (rc != E_rc_ok)
+    {
+        return  false;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// Find an isolated character into a string
+//*****************************************************************************
+
+string::size_type  find_isolated(const string  & str, char  to_find)
+{
+    string::size_type  idx_sep = str.find (to_find);
+
+    while (idx_sep != string::npos)
+    {
+        if (str[idx_sep+1] != to_find)
+        {
+            break;
+        }
+
+        idx_sep += 2;
+        while (str[idx_sep] == to_find)
+            ++idx_sep;
+
+        idx_sep = str.find (to_find, idx_sep);
+    }
+    return  idx_sep;
+}
+
+//*****************************************************************************
+// post_build_field_base
+// Manage Display, transform and constraints specifications.
+//*****************************************************************************
+
+enum E_field_scope
+{
+    E_field_scope_bitfield,
+    E_field_scope_parameter,
+    E_field_scope_other
+};
+
+void    post_build_field_base (
+                 const T_type_definitions                & type_definitions,
+                       T_field_type_name_base            & field_type_name,
+                       E_field_scope                       field_scope)
+{
+    M_TRACE_ENTER ("post_build_field_base", field_type_name.type << "  " << field_type_name.name);
+
+    if ((field_type_name.type == "padding_bits") ||
+        (field_type_name.type == "msg"))
+    {
+        return;
+    }
+
+    // while true because of (e.g.) : string{decoder=decoder_utf8}(50){d=%32.32s}
+    while (true)
+    {
+        string    simple_type;
+
+        // Display, transform and constraints (integer/float)
+        string    str_display_or_transform;
+        while (decompose_type_sep_value_sep (field_type_name.type,
+                                                          '{',
+                                                          '}',
+                                                          simple_type,
+                                                          str_display_or_transform) == E_rc_ok)
+        {
+            field_type_name.type = type_definitions.get_final_type (simple_type);
+            M_TRACE_DEBUG(str_display_or_transform);
+
+            if ((strncmp(str_display_or_transform.c_str(), "q=", 2) == 0) ||
+                (strncmp(str_display_or_transform.c_str(), "o=", 2) == 0))
+            {
+                if (strncmp(str_display_or_transform.c_str(), "q=", 2) == 0)
+                {
+                    const string::size_type  idx_sep = str_display_or_transform.find(":o=");
+                    type_definitions.set_field_transform_quantum(field_type_name, str_display_or_transform.substr(2, idx_sep-2));
+
+                    if (idx_sep != string::npos)
+                    {
+                        type_definitions.set_field_transform_offset(field_type_name, str_display_or_transform.c_str()+idx_sep+1+2);
+                    }
+                }
+                else
+                {
+                    const string::size_type  idx_sep = str_display_or_transform.find(":q=");
+                    type_definitions.set_field_transform_offset(field_type_name, str_display_or_transform.substr(2, idx_sep));
+
+                    if (idx_sep != string::npos)
+                    {
+                        M_FATAL_COMMENT("Bad transform specification (" << str_display_or_transform << ") : do NOT accept anything after offset");
+//                        M_FATAL_IF_NE(strncmp(str_display_or_transform.c_str()+idx_sep+1, "q=", 2), 0);
+//                        type_definitions.set_field_transform_quantum(field_type_name, str_display_or_transform.c_str()+idx_sep+1+2);
+                    }
+                }
+            }
+            else if ((strncmp(str_display_or_transform.c_str(), "tei=", 4) == 0))
+            {
+                type_definitions.set_field_transform_expression_integer(field_type_name, str_display_or_transform.c_str()+4);
+            }
+            else if ((strncmp(str_display_or_transform.c_str(), "tef=", 4) == 0))
+            {
+                type_definitions.set_field_transform_expression_float(field_type_name, str_display_or_transform.c_str()+4);
+            }
+            else if ((strncmp(str_display_or_transform.c_str(), "min=", 4) == 0) ||
+                     (strncmp(str_display_or_transform.c_str(), "max=", 4) == 0))
+            {
+                const string  & str_constraints = str_display_or_transform;
+                if (strncmp(str_display_or_transform.c_str(), "min=", 4) == 0)
+                {
+                    const string::size_type  idx_sep = str_constraints.find(":max=");
+                    const string             min_param = str_constraints.substr(4, idx_sep-4);
+                    if (idx_sep == string::npos)
+                    {
+                        type_definitions.prepend_field_constraint_min(field_type_name, min_param);
+                    }
+                    else
+                    {
+                        type_definitions.prepend_field_constraint_min_max(field_type_name, min_param, str_constraints.c_str()+idx_sep+1+4);
+                    }
+                }
+                else
+                {
+                    const string::size_type  idx_sep = str_constraints.find(":min=");
+                    const string             max_param = str_constraints.substr(4, idx_sep-4);
+                    if (idx_sep == string::npos)
+                    {
+                        type_definitions.prepend_field_constraint_max(field_type_name, max_param);
+                    }
+                    else
+                    {
+                        type_definitions.prepend_field_constraint_min_max(field_type_name, str_constraints.c_str()+idx_sep+1+4, max_param);
+                    }
+                }
+            }
+            else if (strncmp(str_display_or_transform.c_str(), "d=", 2) == 0)
+            {
+                type_definitions.set_field_display(field_type_name, str_display_or_transform.c_str()+2);
+            }
+            else if (strncmp(str_display_or_transform.c_str(), "de=", 3) == 0)
+            {
+                type_definitions.set_field_display_expression(field_type_name, str_display_or_transform.c_str()+3);
+            }
+            else if (strncmp(str_display_or_transform.c_str(), "ns=", 3) == 0)
+            {
+                type_definitions.set_field_no_statement(field_type_name, str_display_or_transform.c_str()+3);
+            }
+            else if (strncmp(str_display_or_transform.c_str(), "dissector=", 10) == 0)
+            {
+                type_definitions.set_field_subdissector(field_type_name, str_display_or_transform.c_str()+10);
+            }
+            else if (strncmp(str_display_or_transform.c_str(), "decoder=", 8) == 0)
+            {
+                type_definitions.set_field_decoder(field_type_name, str_display_or_transform.c_str()+8);
+            }
+            else if (strncmp(str_display_or_transform.c_str(), "byte_order=", 11) == 0)
+            {
+                type_definitions.set_field_byte_order(field_type_name, str_display_or_transform.c_str()+11);
+            }
+            else if (strncmp(str_display_or_transform.c_str(), "name=", 5) == 0)  // name display
+            {
+                field_type_name.display_name = str_display_or_transform.substr(5);
+                remove_string_limits(field_type_name.display_name);
+            }
+            else if (strncmp(str_display_or_transform.c_str(), "filter=", 7) == 0)  // name filter
+            {
+                field_type_name.filter_name = str_display_or_transform.substr(7);
+                if ((field_type_name.filter_name[0] == '\"') ||
+                    (field_type_name.filter_name[0] == '\''))
+                {
+                    M_FATAL_COMMENT("Unexpected blank/space/'/\" inside field filter name (" << field_type_name.filter_name << ").");
+                }
+            }
+            else if (strncmp(str_display_or_transform.c_str(), "desc=", 5) == 0)  // name extended
+            {
+                field_type_name.extended_name = str_display_or_transform.substr(5);
+                remove_string_limits(field_type_name.extended_name);
+            }
+            else
+            {
+                M_FATAL_COMMENT("Unexpected " << str_display_or_transform);
+            }
+        }
+
+        // string/raw size or switch parameter
+        // Could be :
+        // string(50), string{decoder=decoder_utf8}(50)
+        // string(50){d=%32.32s}, subproto(50){dissector=...}
+        // string{decoder=decoder_utf8}(50){d=%32.32s}
+        {
+            string    str_size_or_parameter;
+            if (decompose_type_sep_value_sep (field_type_name.type,
+                                                          '(',
+                                                          ')',
+                                                          simple_type,
+                                                          str_size_or_parameter) == E_rc_ok)
+            {
+                M_TRACE_DEBUG(str_size_or_parameter);
+                type_definitions.set_field_type(field_type_name, simple_type);
+                type_definitions.set_field_type_size_or_parameter(field_type_name, str_size_or_parameter);
+            }
+            else
+            {
+                // (...) not found at the end, so no more specifications to read/extract
+                break;
+            }
+        }
+    }
+
+    // check the type.
+    if (type_definitions.is_a_type_name(field_type_name.type) == false)
+    {
+        bool    bad_type = true;
+
+        if (field_scope == E_field_scope_parameter)
+        {
+            if ((field_type_name.type == "any") ||
+                (field_type_name.type == "pointer"))
+            {
+                bad_type = false;
+            }
+        }
+        else if (field_scope == E_field_scope_bitfield)
+        {
+            long    bit_size = 0;
+            if ((strncmp(field_type_name.type.c_str(), "uint", 4) == 0) &&
+                (get_number(field_type_name.type.c_str()+4, &bit_size) == true))
+            {
+                bad_type = false;
+            }
+        }
+
+        if (bad_type)
+        {
+            M_FATAL_COMMENT("Unexpected field type " << field_type_name.type << " (" << field_type_name.orig_type << ")");
+        }
+    }
+
+    // Check the str_size_or_parameter
+    if ((field_type_name.type == "raw") ||
+        (field_type_name.type == "subproto") ||
+        (field_type_name.type == "insproto") ||
+        (type_definitions.is_a_switch_value(field_type_name.type)))
+    {
+        if (field_type_name.str_size_or_parameter == "")
+        {
+            M_FATAL_COMMENT("Empty () for " << field_type_name.type);
+        }
+    }
+
+    // Compute basic_type_bit_size.
+#define M_READ_SIMPLE_TYPE(TYPE_NAME,TYPE_NAME_SIZE,TYPE)                   \
+    else if (field_type_name.type == TYPE_NAME)                             \
+    {                                                                       \
+        field_type_name.basic_type_bit_size = TYPE_NAME_SIZE;               \
+    }
+
+    const T_enum_definition_representation  * P_enum = type_definitions.get_P_enum(field_type_name.type);
+
+    if (P_enum != nullptr)
+    {
+        field_type_name.basic_type_bit_size = P_enum->bit_size;
+    }
+    M_READ_SIMPLE_TYPE ( "int8",    8,    signed char)
+    M_READ_SIMPLE_TYPE ("uint8",    8,  unsigned char)
+    M_READ_SIMPLE_TYPE ( "int16",  16,    signed short)
+    M_READ_SIMPLE_TYPE ("uint16",  16,  unsigned short)
+    M_READ_SIMPLE_TYPE ( "int24",  24,    signed int)
+    M_READ_SIMPLE_TYPE ("uint24",  24,  unsigned int)
+    M_READ_SIMPLE_TYPE ( "int32",  32,    signed int)
+    M_READ_SIMPLE_TYPE ("uint32",  32,  unsigned int)
+    M_READ_SIMPLE_TYPE ( "int40",  40,    signed long long)
+    M_READ_SIMPLE_TYPE ("uint40",  40,  unsigned long long)
+    M_READ_SIMPLE_TYPE ( "int48",  48,    signed long long)
+    M_READ_SIMPLE_TYPE ("uint48",  48,  unsigned long long)
+    M_READ_SIMPLE_TYPE ( "int64",  64,    signed long long)
+    M_READ_SIMPLE_TYPE ("uint64",  64,  unsigned long long)
+    M_READ_SIMPLE_TYPE ("float32", 32, float)
+    M_READ_SIMPLE_TYPE ("float64", 64, double)
+    M_READ_SIMPLE_TYPE ("spare",    8, unsigned char)
+    M_READ_SIMPLE_TYPE ( "char",    8,          char)
+    M_READ_SIMPLE_TYPE ("schar",    8,   signed char)
+    M_READ_SIMPLE_TYPE ("uchar",    8, unsigned char)
+    else
+    {
+        /* bitfield, bitstream, bsew uintXX intXX */
+        long    bit_size = 0;
+        if ((strncmp(field_type_name.type.c_str(), "uint", 4) == 0) &&
+            (get_number(field_type_name.type.c_str()+4, &bit_size)))
+        {
+            field_type_name.basic_type_bit_size = bit_size;
+        }
+        else if ((strncmp(field_type_name.type.c_str(), "int", 3) == 0) &&
+                 (get_number(field_type_name.type.c_str()+3, &bit_size)))
+        {
+            field_type_name.basic_type_bit_size = bit_size;
+        }
+    }
+}
+
+//*****************************************************************************
+//*****************************************************************************
+
+const char *  build_struct_fields (
+                   istream                           & is,
+             const T_type_definitions                & type_definitions,
+                   T_struct_fields                   & struct_fields,
+             const char                              * end_flag1,
+             const char                              * end_flag2 = nullptr,
+             const char                              * end_flag3 = nullptr,
+                   E_field_scope                       field_scope = E_field_scope_other,
+             const char                              * return_type = "void");
+
+void    build_struct_base ( istream              & is,
+                      const T_type_definitions   & type_definitions,
+                            T_struct_definition  & struct_definition,
+                      const char                 * return_type = "void");
+
+string    build_struct_unnamed (
+                            istream             & is,
+                            T_type_definitions  & type_definitions);
+
+void    build_bitfield_unnamed (
+                        const string                 & key_word,
+                              istream                & is,
+                        const T_type_definitions     & type_definitions,
+                              T_bitfield_definition  & def_rep);
+
+void    build_switch_unnamed (
+                        const string                 & key_word,
+                              istream                & is,
+                        const T_type_definitions     & type_definitions,
+                              T_switch_definition    & switch_def,
+                        const char                   * return_type);
+
+//*****************************************************************************
+// build_field
+// ----------------------------------------------------------------------------
+// Format :
+// <type_name>  <field_name>
+// while/if     (condition)
+// { ... }
+// else                          optional
+// { ... }
+// ... 
+// Returns the last word read (which is NOT part of the field).
+//*****************************************************************************
+// type_definitions  must be const because
+//  build_field is used into frame_to_main
+//  where I do not want to declare new types.
+// BUT then, I'm unable to call build_struct_unnamed or ...
+//*****************************************************************************
+
+#define  M_FINISH_build_field_check()                                      \
+    if ((must_have_new_expression) &&                                      \
+        (field_type_name.new_expression.is_defined() == false))            \
+    {                                                                      \
+        M_FATAL_COMMENT("var could not be use for a command ...");         \
+    }
+
+#define  M_FINISH_build_field_read_next()                                  \
+    string    last_word_read;                                              \
+    if (read_next_token == true)                                           \
+    {                                                                      \
+        read_token_left_any (is, last_word_read);                          \
+    }                                                                      \
+    return  last_word_read
+
+#define  M_FINISH_build_field()                                            \
+         M_FINISH_build_field_check();                                     \
+        if (field_type_name.display_name  == "")  field_type_name.display_name  = field_type_name.name;  \
+        if (field_type_name.filter_name   == "")  field_type_name.filter_name   = field_type_name.name;  \
+        if (field_type_name.extended_name == "")  field_type_name.extended_name = field_type_name.name;  \
+         read_token_end_of_statement(is);                                  \
+         M_FINISH_build_field_read_next()
+
+
+string    build_field (istream                           & is,
+                 const T_type_definitions                & type_definitions,
+                       string                              first_word,
+                       T_field_type_name                 & field_type_name,
+                       E_field_scope                       field_scope,
+                 const char                              * return_type,
+                       bool                                read_next_token = true)
+{
+    M_TRACE_ENTER ("build_field", first_word);
+
+    M_FATAL_IF_EQ (first_word, "");
+
+    // modifier: forget
+    if (first_word == "forget")
+    {
+        field_type_name.must_forget = true;
+        M_FATAL_IF_FALSE (read_token_left_any (is, first_word));
+    }
+
+    // modifier: hide
+    if (first_word == "hide")
+    {
+        field_type_name.output_directive = T_field_type_name::E_output_directive_hide;
+        M_FATAL_IF_FALSE (read_token_left_any (is, first_word));
+    }
+    else if (first_word == "show")
+    {
+        field_type_name.output_directive = T_field_type_name::E_output_directive_show;
+        M_FATAL_IF_FALSE (read_token_left_any (is, first_word));
+    }
+
+    // modifier: const
+    bool    is_const = false;
+    if (first_word == "const")
+    {
+        is_const = true;
+        first_word = "var";    // treated as var
+    }
+
+    // modifier: var
+    bool    must_have_new_expression = false;
+    if (first_word == "var")
+    {
+        field_type_name.A_is_a_variable = true;
+        must_have_new_expression = true;
+        M_FATAL_IF_FALSE (read_token_left_any (is, first_word));
+    }
+
+    field_type_name.type = type_definitions.get_final_type(first_word);
+
+
+    // command ctrl: break & continue
+    if ((field_type_name.type == "deep_break") ||
+        (field_type_name.type == "deep_continue") ||
+        (field_type_name.type == "break") ||
+        (field_type_name.type == "continue"))
+    {
+        M_FINISH_build_field();
+    }
+
+
+    // command ctrl: return
+    if (field_type_name.type == "return")
+    {
+        if (strcmp(return_type, "void") != 0)
+        {
+            // return value
+            M_FATAL_IF_FALSE (read_token_expression_any (is, field_type_name.name));
+
+            if (field_type_name.name == ";")
+            {
+                M_FATAL_COMMENT("No return value, expecting a " << return_type);
+            }
+
+            field_type_name.return_expression.build_expression(type_definitions, field_type_name.name);
+        }
+
+        M_FINISH_build_field();
+    }
+
+
+    // command: display
+    if ((field_type_name.type == "print") ||
+        (field_type_name.type == "debug_print") ||
+        (field_type_name.type == "chat") ||
+        (field_type_name.type == "note") ||
+        (field_type_name.type == "warning") ||
+        (field_type_name.type == "error") ||
+        (field_type_name.type == "fatal"))
+    {
+        M_FATAL_IF_FALSE (read_token_expression_any (is, field_type_name.name));
+        // ICIOA mettre les parametres dans une/des expressions
+
+        M_FINISH_build_field();
+    }
+
+
+    // command: display ctrl
+    if (field_type_name.type == "output")
+    {
+        read_token_key_word_specified (is, field_type_name.name, "--", "++");
+        M_FINISH_build_field();
+    }
+
+    // command: data ctrl
+    if (field_type_name.type == "byte_order")
+    {
+        read_token_key_word_specified (is, field_type_name.name, "big_endian", "little_endian", "as_host");
+        M_FINISH_build_field();
+    }
+
+    // command: position
+    if ((field_type_name.type == "save_position") ||
+        (field_type_name.type == "goto_position") ||
+        (field_type_name.type == "move_position_bytes") ||
+        (field_type_name.type == "move_position_bits"))
+    {
+        M_FATAL_IF_FALSE (read_token_expression_any (is, field_type_name.name));
+        // nothing to test for now
+        // not sure it is a good idea
+        M_FINISH_build_field();
+    }
+    if (field_type_name.type == "move_position")
+    {
+        M_FATAL_COMMENT("move_position is no more available. Replace it by move_position_bits or move_position_bytes");
+    }
+
+    if ((field_type_name.type == "check_eof_distance_bytes") ||
+        (field_type_name.type == "check_eof_distance_bits"))
+    {
+        M_FATAL_IF_FALSE (read_token_expression_any (is, field_type_name.name));
+        // nothing to test for now
+        // not sure it is a good idea
+        M_FINISH_build_field();
+    }
+    if (field_type_name.type == "check_eof_distance")
+    {
+        M_FATAL_COMMENT("check_eof_distance is no more available. Replace it by check_eof_distance_bytes");
+    }
+
+    // command: chrono
+    if (field_type_name.type == "chrono")
+    {
+        // Read chrono argument.
+        M_FATAL_IF_FALSE (read_token_expression_any(is, field_type_name.name));
+
+        M_FINISH_build_field();
+    }
+
+
+    // command: call function
+    if (field_type_name.type == "call")
+    {
+        // Read function name.
+        M_FATAL_IF_FALSE (read_token_function_name(is, field_type_name.name));
+
+        if (type_definitions.is_a_function(field_type_name.name) == false)
+        {
+            M_FATAL_COMMENT(field_type_name.name << " is not a known function");
+        }
+
+        // ICIOA tout mettre dans une expression ?
+
+        // Read function parameters.
+        vector<string>  fct_parameters_vector;
+        M_FATAL_IF_FALSE(read_token_parameters_vector(is, fct_parameters_vector, E_parser_cfg_parameters));
+
+        for (size_t  idx_parameters = 0; idx_parameters < fct_parameters_vector.size(); ++idx_parameters)
+        {
+            const string  & fct_parameter = fct_parameters_vector[idx_parameters];
+            T_expression    expression;
+            expression.build_expression(type_definitions, fct_parameter);
+
+            field_type_name.fct_parameters.push_back(expression);
+        }
+
+        M_FINISH_build_field();
+    }
+
+
+    // command: set variable
+    if (field_type_name.type == "set")
+    {
+        // Read variable name.
+        M_FATAL_IF_FALSE (read_token_left_any(is, field_type_name.name));
+
+        read_token_key_word_specified(is, "=");
+
+        string    new_expression;
+        M_FATAL_IF_FALSE (read_token_expression_any(is, new_expression));
+        field_type_name.new_expression.build_expression(type_definitions, new_expression);
+
+        M_FINISH_build_field();
+    }
+
+
+    // data: inline struct
+    if (field_type_name.type == "struct")
+    {
+        field_type_name.P_sub_struct.reset(new T_struct_definition);
+        build_struct_base (is, type_definitions, *field_type_name.P_sub_struct, return_type);
+
+        M_FATAL_IF_FALSE (read_token_field_name (is, field_type_name.name));
+        // NB : "" not authorized : non sense and not coded into generic (register)
+        check_field_name(field_type_name);
+
+        M_FINISH_build_field();
+    }
+
+
+    // data: inline bitfield
+    if ((field_type_name.type == "bitfield8") ||
+        (field_type_name.type == "bitfield16") ||
+        (field_type_name.type == "bitfield24") ||
+        (field_type_name.type == "bitfield32") ||
+        (field_type_name.type == "bitstream8") ||
+        (field_type_name.type == "bitstream16") ||
+        (field_type_name.type == "bitstream24") ||
+        (field_type_name.type == "bitstream32"))
+    {
+        field_type_name.P_bitfield_inline.reset(new T_bitfield_definition);
+        build_bitfield_unnamed (field_type_name.type, is, type_definitions, *field_type_name.P_bitfield_inline);
+        field_type_name.type = "bitfield";    // simplification (for register and dissect) 
+
+        M_FATAL_IF_FALSE (read_token_field_name (is, field_type_name.name));
+
+        if (field_type_name.name != "")
+        {
+            check_field_name(field_type_name);
+        }
+
+        M_FINISH_build_field();
+    }
+
+
+    // command: inline switch
+    {
+        bool    is_an_inline_switch = false;
+        bool    is_switch_expr = false;
+        string  inline_switch_parameter;
+        if (field_type_name.type == "switch")
+        {
+            is_an_inline_switch = true;
+
+            M_FATAL_IF_FALSE (read_token_right_any (is, inline_switch_parameter));
+            if ((inline_switch_parameter == "{") ||
+                (inline_switch_parameter[0] != '('))
+            {
+                M_FATAL_COMMENT("expecting (parameter) for inline switch " << field_type_name.type);
+            }
+            if ((inline_switch_parameter.size() < 3) ||
+                (inline_switch_parameter[0] != '(') ||
+                (inline_switch_parameter[inline_switch_parameter.size()-1] != ')'))
+            {
+                M_FATAL_COMMENT("invalid parameter for inline switch " << field_type_name.type);
+            }
+            inline_switch_parameter.erase(inline_switch_parameter.size()-1);
+            inline_switch_parameter.erase(0, 1);
+        }
+        else if (strncmp(field_type_name.type.c_str(), "switch(", 7) == 0)
+        {
+            is_an_inline_switch = true;
+            inline_switch_parameter = field_type_name.type.substr(7);
+            if ((inline_switch_parameter.size() < 2) ||
+                (inline_switch_parameter[inline_switch_parameter.size()-1] != ')'))
+            {
+                M_FATAL_COMMENT("invalid parameter for inline switch " << field_type_name.type);
+            }
+            inline_switch_parameter.erase(inline_switch_parameter.size()-1);
+        }
+        else if (strncmp(field_type_name.type.c_str(), "switch_expr", 7) == 0)
+        {
+            is_an_inline_switch = true;
+            is_switch_expr = true;
+            // no parameter
+        }
+        if (is_an_inline_switch)
+        {
+            field_type_name.str_size_or_parameter = inline_switch_parameter;
+            field_type_name.type = "switch";
+            
+            field_type_name.P_switch_inline.reset(new T_switch_definition);
+            field_type_name.P_switch_inline->is_switch_expr = is_switch_expr;
+            build_switch_unnamed (field_type_name.type, is, type_definitions, *field_type_name.P_switch_inline, return_type);
+
+            // Inline switch is a command control bloc (like if and loops)
+            // -> no name
+            // -> no ; after }
+            M_FINISH_build_field_check();
+            M_FINISH_build_field_read_next();
+        }
+    }
+
+
+    // command: decoder
+    if (field_type_name.type == "decoder")
+    {
+        string  decoder_function_name;
+        M_FATAL_IF_FALSE (read_token_function_name (is, decoder_function_name));
+
+        // Check that the function exist
+        if (decoder_function_name != "")
+        {
+            const T_function_definition  * P_fct_def = type_definitions.get_P_function(decoder_function_name);
+            if (P_fct_def == nullptr)
+            {
+                M_FATAL_COMMENT(decoder_function_name << " is not a function.");
+            }
+            if (P_fct_def->get_function_parameters().size() != 2)
+            {
+                M_FATAL_COMMENT(decoder_function_name << " must have 2 parameters.");
+            }
+            if (P_fct_def->return_type != "void")
+            {
+                M_FATAL_COMMENT(decoder_function_name << " must not return anything.");
+            }
+        }
+
+        field_type_name.name = decoder_function_name;
+
+        M_FINISH_build_field();
+    }
+
+
+    // command ctrl: condition & loop
+    if ((field_type_name.type == "if") ||
+        (field_type_name.type == "while") ||
+        (field_type_name.type == "loop_size_bytes") ||
+        (field_type_name.type == "loop_size_bits") ||
+        (field_type_name.type == "loop_nb_times") ||
+        (field_type_name.type == "do"))
+    {
+        if (field_type_name.type != "do")
+        {
+            M_FATAL_IF_FALSE (read_token_expression_parenthesis (is, field_type_name.name));
+            field_type_name.condition_expression.build_expression(type_definitions, field_type_name.name);
+        }
+
+        read_token_key_word_specified (is, "{");
+
+        field_type_name.P_sub_struct.reset(new T_struct_definition);
+        build_struct_fields (is, type_definitions,
+                             field_type_name.P_sub_struct->fields,
+                             "}",
+                             nullptr,
+                             nullptr,
+                             field_scope,
+                             return_type);
+
+        if (field_type_name.type == "if")
+        {
+            string    word_else;
+            read_token_left_any (is, word_else);
+
+            if (word_else != "else")
+                return  word_else;
+
+            read_token_key_word_specified (is, "{");
+
+            build_struct_fields (is, type_definitions,
+                               field_type_name.sub_struct_2,
+                               "}",
+                               nullptr,
+                               nullptr,
+                               field_scope,
+                               return_type);
+        }
+        else if (field_type_name.type == "do")
+        {
+            read_token_key_word_specified (is, "while");
+
+            field_type_name.type = "do_while";
+
+            M_FATAL_IF_FALSE (read_token_expression_parenthesis (is, field_type_name.name));
+            field_type_name.condition_expression.build_expression(type_definitions, field_type_name.name);
+
+            read_token_end_of_statement(is);
+        }
+    }
+    else if ((field_type_name.type == "loop_size"))
+    {
+        M_FATAL_COMMENT("loop_size is no more available. Replace it by loop_size_bytes");
+    }
+
+    else
+
+    {
+        M_FATAL_IF_FALSE (read_token_field_name (is, field_type_name.name));
+
+        // Incomplete !!!
+        // So a field/variable name could be identic to a type or a keyword.
+        // type : Use is_a_type_name ? Is it interesting to forbid this ?
+        if ((field_type_name.name == "}") ||
+            (field_type_name.name == "{") ||
+            (field_type_name.name == "struct") ||
+            (field_type_name.name == "switch") ||
+            (field_type_name.name == "alias") ||
+            (field_type_name.name == "enum8") ||
+            (field_type_name.name == "enum16") ||
+            (field_type_name.name == "enum24") ||
+            (field_type_name.name == "enum32") ||
+            (field_type_name.name == "include"))
+        {
+            M_FATAL_COMMENT("Bad field name " << field_type_name.name << " for field type " << field_type_name.type);
+        }
+
+        field_type_name.orig_type = field_type_name.type;
+        field_type_name.type = type_definitions.get_final_type(field_type_name.type);
+
+        if (must_have_new_expression)
+        {
+            read_token_key_word_specified (is, "=");
+
+            string    new_expression;
+            M_FATAL_IF_FALSE (read_token_expression_any(is, new_expression));
+            field_type_name.new_expression.build_expression(type_definitions, new_expression);
+        }
+        else if (field_type_name.type == "msg")
+        {
+            M_FATAL_COMMENT("msg must always be var (" << field_type_name.name << ")");
+        }
+
+        read_token_end_of_statement(is);
+
+        string    simple_type;
+
+        // Arrays
+        {
+            string    str_array_size;
+            while (is_an_array (field_type_name.type, simple_type, str_array_size))
+            {
+                if ((str_array_size == "*") || (str_array_size == "+"))
+                {
+                    if (field_type_name.str_arrays.empty() == false)
+                    {
+                        M_FATAL_COMMENT("[*] or [+] are only accepted on the last array level");
+                    }
+                }
+                field_type_name.type = type_definitions.get_final_type(simple_type);
+
+                T_field_type_name::T_array  field_array;
+                if (str_array_size == "*")
+                {
+                    field_array.size_type = T_field_type_name::T_array::E_size_unknow_any;
+                }
+                else if (str_array_size == "+")
+                {
+                    field_array.size_type = T_field_type_name::T_array::E_size_unknow_at_least_1;
+                }
+                else
+                {
+                    field_array.size_type = T_field_type_name::T_array::E_size_normal;
+                    field_array.size_expression.build_expression(type_definitions, str_array_size);
+                }
+
+                field_type_name.str_arrays.insert(field_type_name.str_arrays.begin(), field_array);
+            }
+        }
+
+        // int/float           : Display, transform, constraints and basic_type_bit_size
+        // string/raw/subproto : size
+        // switch              : parameter
+        // decoder, byte_order, nameDisplay, nameFilter, nameExtended ...
+        // Check that type is defined.
+        // Must be called before check_field_name.
+        post_build_field_base(type_definitions, field_type_name, field_scope);
+
+        if (field_type_name.name != "")
+        {
+            if (is_const == true)
+                check_field_name(field_type_name, ':');
+            else
+                check_field_name(field_type_name);
+        }
+    }
+
+
+    M_FINISH_build_field_check();
+    M_FINISH_build_field_read_next();
+}
+
+
+string    build_field (istream                           & is,
+                 const T_type_definitions                & type_definitions,
+                       string                              first_word,
+                       T_field_type_name                 & field_type_name)
+{
+    return  build_field(is, type_definitions, first_word, field_type_name,
+                        E_field_scope_other,
+                        "void");
+}
+
+//*****************************************************************************
+// build_struct_fields
+// ----------------------------------------------------------------------------
+// Format :
+// <type_name>  <field_name>
+//  ...
+// <type_name>  <field_name>
+// <end_flag>
+//*****************************************************************************
+const char *  build_struct_fields (
+                   istream                           & is,
+             const T_type_definitions                & type_definitions,
+                   T_struct_fields                   & struct_fields,
+             const char                              * end_flag1,
+             const char                              * end_flag2,
+             const char                              * end_flag3,
+                   E_field_scope                       field_scope,
+             const char                              * return_type)
+{
+    M_TRACE_ENTER ("build_struct_fields", "");
+
+    if (end_flag2 == nullptr)
+        end_flag2 = end_flag1;
+
+    if (end_flag3 == nullptr)
+        end_flag3 = end_flag1;
+
+    string    last_word_read;
+    M_FATAL_IF_FALSE (read_token_left_any (is, last_word_read));
+
+    while (true)
+    {
+        if (last_word_read == end_flag1)
+            return  end_flag1;
+        if (last_word_read == end_flag2)
+            return  end_flag2;
+        if (last_word_read == end_flag3)
+            return  end_flag3;
+
+        T_field_type_name    field_type_name;
+
+        last_word_read = build_field (is, type_definitions, last_word_read, field_type_name, field_scope, return_type);
+
+        struct_fields.push_back (field_type_name);
+    }
+}
+
+//*****************************************************************************
+// build_struct_base
+// ----------------------------------------------------------------------------
+// Format :
+//    [ print ("...", ..., ...) ]
+// {
+//    <type_name>  <field_name>
+//    ...
+//    <type_name>  <field_name>
+// }
+//*****************************************************************************
+void    build_struct_base ( istream              & is,
+                      const T_type_definitions   & type_definitions,
+                            T_struct_definition  & struct_definition,
+                      const char                 * return_type)
+{
+    M_TRACE_ENTER ("build_struct_base", "");
+
+    string  open_brace_or_print;
+    M_FATAL_IF_FALSE (read_token_key_word (is, open_brace_or_print));
+    if (open_brace_or_print == "print")
+    {
+        M_FATAL_IF_FALSE (read_token_parameters (is, struct_definition.printf_args));
+        // ICIOA mettre les parametres dans une/des expressions
+
+        M_FATAL_IF_FALSE (read_token_key_word (is, open_brace_or_print));
+    }
+    M_ASSERT (open_brace_or_print == "{");
+
+    build_struct_fields (is,
+                       type_definitions,
+                       struct_definition.fields,
+                       "}",
+                       nullptr,
+                       nullptr,
+                       E_field_scope_other,
+                       return_type);
+
+    // Search if it is a field_struct
+    for (T_struct_fields::const_iterator  iter  = struct_definition.fields.begin();
+                                          iter != struct_definition.fields.end();
+                                        ++iter)
+    {
+        const T_field_type_name  & field_type_name = *iter;
+
+        // No control
+        if (field_type_name.name == "field_struct")
+        {
+            struct_definition.field_struct_idx = iter - struct_definition.fields.begin();
+            break;
+        }
+    }
+}
+
+//*****************************************************************************
+// M_CHECK_FORWARD
+// If the next character is ; (ie end of statement),
+//  it is a forward declaration (ie "<type> <type_name> ;").
+//*****************************************************************************
+
+#define M_CHECK_FORWARD(is,KIND,NAME)                                      \
+    skip_blanks_and_comments(is);                                          \
+    if (is.peek() == ';')                                                  \
+    {                                                                      \
+        read_token_end_of_statement(is);                                   \
+        type_definitions.add_forward_declaration(KIND, NAME);              \
+        return;                                                            \
+    }
+
+//*****************************************************************************
+// build_struct
+// ----------------------------------------------------------------------------
+// Format :
+// struct  <struct_name>   [ print ("...", ..., ...) ]
+// {
+//    <type_name>  <field_name>
+//    ...
+//    <type_name>  <field_name>
+// }
+//*****************************************************************************
+void    build_struct (const E_override            must_override,
+                      const string              & key_word,
+                            istream             & is,
+                            T_type_definitions  & type_definitions)
+{
+    M_TRACE_ENTER ("build_struct", "");
+
+    M_ASSERT_EQ (key_word, "struct");
+
+    string  struct_name;
+    M_FATAL_IF_FALSE (read_token_type_simple (is, struct_name));
+
+    M_CHECK_FORWARD(is, type_definitions.E_type_struct, struct_name);
+
+    build_types_context_type_begin(struct_name);
+
+    // Check it is possible to define a new type with this name.
+    // No returned value, FATAL is called if it is not possible.
+    type_definitions.could_define_new_type(struct_name, T_type_definitions::E_type_struct, must_override);
+
+    type_definitions.map_struct_definition[struct_name] = T_struct_definition();    // possible override ok
+
+    build_struct_base (is, type_definitions, type_definitions.map_struct_definition[struct_name]);
+
+    build_types_context_type_end(struct_name);
+}
+
+//*****************************************************************************
+// build_const
+// ----------------------------------------------------------------------------
+// Format :
+// const  <existing_type_name>  <const_name> = <expression>;
+//*****************************************************************************
+void    build_const (const E_override            must_override,
+                     const string              & key_word,
+                           istream             & is,
+                           T_type_definitions  & type_definitions)
+{
+    M_TRACE_ENTER ("build_const", "");
+
+    M_ASSERT_EQ (key_word, "const");
+
+
+    T_field_type_name    field_type_name;
+
+    string  last_word_read = build_field (is, type_definitions,
+                                          key_word,
+                                          field_type_name,
+                                          E_field_scope_other,
+                                          "return_type_do_not_care",
+                                          false  /* read_next_token */);
+
+    build_types_context_type_begin(field_type_name.name);
+
+    M_FATAL_IF_NE(last_word_read, "");
+
+    M_FATAL_IF_NE(field_type_name.is_a_variable(), true);
+    M_FATAL_IF_NE(field_type_name.is_an_array(), false);
+    M_FATAL_IF_NE(field_type_name.has_post_treatment(), false);
+
+    // Check it is possible to define a new const value with this name.
+    // No returned value, FATAL is called if it is not possible.
+    type_definitions.could_define_new_type(field_type_name.name, T_type_definitions::E_type_const, must_override);
+
+    type_definitions.map_const_value[field_type_name.name] = field_type_name.get_var_expression().compute_expression_static(type_definitions);
+
+    build_types_context_type_end(field_type_name.name);
+}
+
+//*****************************************************************************
+// build_bitfield_unnamed_helper
+//*****************************************************************************
+void    build_bitfield_unnamed_helper (
+                        const bool                     is_a_bitstream,
+                        const long                     sizeof_bitfield_total,
+                        const T_type_definitions     & type_definitions,
+                              T_bitfield_definition  & def_rep)
+{
+    M_TRACE_ENTER ("build_bitfield_unnamed_helper", "");
+
+    def_rep.is_a_bitstream = is_a_bitstream;
+
+    def_rep.master_field.name = "last_bitfield_value";            // name used by the following fields
+    def_rep.master_field.type = "uint" + get_string(sizeof_bitfield_total);
+    def_rep.master_field.output_directive = T_field_type_name::E_output_directive_hide;
+    def_rep.master_field.str_display = "hex";
+
+    // Transform each "normal" structure field 
+    //  to a bitfield field.
+    int    bitfield_position = 0;
+    for (T_struct_fields::iterator    iter  = def_rep.fields_definition.begin();
+                                      iter != def_rep.fields_definition.end();
+                                    ++iter)
+    {
+        T_field_type_name  & field_type_name = *iter;
+
+        if (field_type_name.is_a_variable())
+            continue;                            
+        if (field_type_name.type == "set")
+            continue;
+
+        // Could not initialize an array with 1 expression
+        M_FATAL_IF_NE(field_type_name.is_an_array(), false);
+
+        const T_enum_definition_representation  * P_enum = nullptr;
+
+        long    sizeof_bitfield_field = 0;
+        if (strncmp(field_type_name.type.c_str(), "uint", 4) == 0)
+        {
+            M_FATAL_IF_FALSE (get_number (field_type_name.type.c_str() + strlen ("uint"),
+                                          &sizeof_bitfield_field));
+            field_type_name.type = "uint32";
+        }
+        else if ((P_enum = type_definitions.get_P_enum(field_type_name.type)) != nullptr)
+        {
+            sizeof_bitfield_field = P_enum->bit_size;
+        }
+        else
+        {
+            M_FATAL_COMMENT("bitfield accepts only uint, enum, var and set");
+        }
+
+        if (sizeof_bitfield_field < 1)
+        {
+            M_FATAL_COMMENT("bitfield field size is < 1");
+        }
+        if (sizeof_bitfield_field + bitfield_position > sizeof_bitfield_total)
+        {
+            M_FATAL_COMMENT("bitfield total size averflow");
+        }
+
+        const int    mask = (1 << sizeof_bitfield_field) -1;
+        const int    shift = def_rep.is_a_bitstream ? sizeof_bitfield_total-bitfield_position-sizeof_bitfield_field : bitfield_position;
+        string       new_expression = "((last_bitfield_value >> " +
+                                         get_string(shift) + ") & " +
+                                         get_string(mask) +
+                                         ")";
+        field_type_name.new_expression.build_expression(type_definitions, new_expression);
+
+        field_type_name.A_is_a_variable = true;
+
+        bitfield_position += sizeof_bitfield_field;
+    }
+
+//    def_rep.bit_size = sizeof_bitfield;
+//    def_rep.representation_type = "uint" + get_string (def_rep.bit_size);
+}
+
+//*****************************************************************************
+// build_bitfield_unnamed
+// ----------------------------------------------------------------------------
+// Format :
+// bitfieldXX  
+// {
+//    <type_name>  <var_name>
+//    ...
+//    <type_name>  <var_name>
+// }
+// NB: bitfieldXX : XX is the size (in bits) of the bitfield (could be 8, 16, 24 or 32)
+//*****************************************************************************
+void    build_bitfield_unnamed (
+                        const string                 & key_word,
+                              istream                & is,
+                        const T_type_definitions     & type_definitions,
+                              T_bitfield_definition  & def_rep)
+{
+    M_TRACE_ENTER ("build_bitfield_unnamed", "key_word=" << key_word);
+
+    long    sizeof_bitfield_total = 0;
+    if (strncmp(key_word.c_str (), "bitfield", 8) == 0)
+    {
+        def_rep.is_a_bitstream = false;
+        M_FATAL_IF_FALSE (get_number (key_word.c_str () + strlen ("bitfield"),
+                                      &sizeof_bitfield_total));
+    }
+    else
+    {
+        def_rep.is_a_bitstream = true;
+        M_FATAL_IF_FALSE (get_number (key_word.c_str () + strlen ("bitstream"),
+                                      &sizeof_bitfield_total));
+    }
+
+    read_token_key_word_specified (is, "{");
+
+    // lecture struct dans def_rep.fields_definition
+    build_struct_fields (is, type_definitions,
+                         def_rep.fields_definition,
+                         "}",
+                         nullptr,
+                         nullptr,
+                         E_field_scope_bitfield);
+
+    build_bitfield_unnamed_helper(def_rep.is_a_bitstream, sizeof_bitfield_total, type_definitions, def_rep);
+}
+
+//*****************************************************************************
+// build_bitfield
+// ----------------------------------------------------------------------------
+// Format :
+// bitfieldXX  <bitfield_name>
+// {
+//    <type_name>  <var_name>
+//    ...
+//    <type_name>  <var_name>
+// }
+// NB: bitfieldXX : XX is the size (in bits) of the bitfield (could be 8, 16, 24 or 32)
+//*****************************************************************************
+void    build_bitfield (const E_override            must_override,
+                        const string              & key_word,
+                              istream             & is,
+                              T_type_definitions  & type_definitions)
+{
+    M_TRACE_ENTER ("build_bitfield", "key_word=" << key_word);
+
+    string  bitfield_name;
+    M_FATAL_IF_FALSE (read_token_type_simple (is, bitfield_name));
+
+    M_CHECK_FORWARD(is, type_definitions.E_type_bitfield, bitfield_name);
+
+    build_types_context_type_begin(bitfield_name);
+
+    // Check it is possible to define a new bitfield type with this name.
+    // No returned value, FATAL is called if it is not possible.
+    type_definitions.could_define_new_type(bitfield_name, T_type_definitions::E_type_bitfield, must_override);
+
+    T_map_bitfield_definition  & map_bitfield_def = type_definitions.map_bitfield_definition;
+    T_bitfield_definition      & def_rep = map_bitfield_def[bitfield_name];    // possible override ok
+    def_rep = T_bitfield_definition();
+
+    build_bitfield_unnamed (key_word, is, type_definitions, def_rep);
+
+    build_types_context_type_end(bitfield_name);
+}
+
+//*****************************************************************************
+// build_enum
+// ----------------------------------------------------------------------------
+// Format :
+// enumXX  <enum_name>
+// {
+//    <symbolic_name>  <integer_value>
+//    ...
+//    <symbolic_name>  <integer_value>
+// }
+// NB: enumXX : XX is the size (in bits) of the enum (could be 8, 16, 24 or 32)
+// NB: <integer_value> could be -. It means :
+//     - previous <integer_value> + 1
+//     - zero if there is no previous <integer_value>
+//*****************************************************************************
+void    build_enum (const E_override            must_override,
+                    const string              & key_word,
+                          istream             & is,
+                          T_type_definitions  & type_definitions)
+{
+    M_TRACE_ENTER ("build_enum", "key_word=" << key_word);
+
+    T_map_enum_definition_representation  & map_enum_def_rep = type_definitions.map_enum_definition_representation;
+
+    long    sizeof_enum = 0;
+    if (key_word != "enum")
+    {
+        M_FATAL_IF_FALSE (get_number (key_word.c_str () + strlen ("enum"),
+                                      &sizeof_enum));
+    }
+    M_FATAL_IF_LE(sizeof_enum,  0);
+    M_FATAL_IF_GT(sizeof_enum, 32);
+
+    string  enum_name;
+    M_FATAL_IF_FALSE (read_token_type_simple (is, enum_name));
+
+    M_CHECK_FORWARD(is, type_definitions.E_type_enum, enum_name);
+
+    build_types_context_type_begin(enum_name);
+
+    string  open_brace_or_as_or_expand;
+    read_token_key_word_specified (is, open_brace_or_as_or_expand, "{", "as", "expand");
+
+
+    // Check it is possible to define a new enum type with this name.
+    // No returned value, FATAL is called if it is not possible.
+    type_definitions.could_define_new_type(enum_name, T_type_definitions::E_type_enum, must_override);
+
+    T_enum_definition_representation  & def_rep = map_enum_def_rep[enum_name];    // possible override ok
+
+    if ((open_brace_or_as_or_expand == "as") ||
+        (open_brace_or_as_or_expand == "expand"))
+    {
+        string  as_enum_name;
+        M_FATAL_IF_FALSE (read_token_type_simple (is, as_enum_name));
+
+        if (map_enum_def_rep.find (as_enum_name) ==
+            map_enum_def_rep.end ())
+        {
+            M_FATAL_COMMENT ("enum " << as_enum_name << " NOT found.");
+        }
+
+        def_rep = map_enum_def_rep[as_enum_name];
+    }
+    else
+    {
+        def_rep = T_enum_definition_representation ();
+    }
+
+    if (open_brace_or_as_or_expand == "expand")
+    {
+        read_token_key_word_specified (is, "{");
+    }
+
+    if (open_brace_or_as_or_expand == "as")
+    {
+        read_token_end_of_statement(is);
+    }
+    else
+    {
+        long long    last_value = -1;
+        long long    min_value = LONGLONG_MAX;
+        long long    max_value = LONGLONG_MIN;
+
+        while (true)
+        {
+            T_enum_name_val    enum_name_val;
+
+            M_FATAL_IF_FALSE (read_token_enum_symbolic (is, enum_name_val.name));
+
+            if (enum_name_val.name == "}")
+                break;
+
+            string    str_last_value;
+            M_FATAL_IF_FALSE (read_token_enum_value (is, str_last_value));
+
+            if (str_last_value == "-")
+                ++last_value;
+            else
+            {
+                if (get_number (str_last_value.c_str (), last_value) != true)
+                {
+                    M_FATAL_COMMENT(str_last_value << " is NOT a number for enum type " << enum_name);
+                }
+            }
+
+            enum_name_val.value = last_value;
+
+            min_value = min (min_value, last_value);
+            max_value = max (max_value, last_value);
+
+            def_rep.definition.push_back (enum_name_val);
+        }
+
+        def_rep.is_signed = (min_value < 0);
+    }
+
+    def_rep.bit_size = sizeof_enum;
+    def_rep.representation_type =
+                string (def_rep.is_signed ? "" : "u") +
+                "int" +
+                get_string (sizeof_enum);
+
+    build_types_context_type_end(enum_name);
+}
+
+//*****************************************************************************
+// build_switch_unnamed
+// ----------------------------------------------------------------------------
+// Format :
+// switch(parameter)  <case_type_name>
+// {
+// case <a_valid_value_for case_type_name> :  <type_name>  <field_name>
+// ...
+// case <a_valid_value_for case_type_name> :
+//   <type_name>  <field_name>
+//   ...
+//   <type_name>  <field_name>
+// default       :
+//   <type_name>  <field_name>
+// }
+//*****************************************************************************
+void    build_switch_unnamed (
+                      const string               & key_word,
+                            istream              & is,
+                      const T_type_definitions   & type_definitions,
+                            T_switch_definition  & switch_def,
+                      const char                 * return_type)
+{
+    M_TRACE_ENTER ("build_switch_unnamed", "");
+
+    bool const  is_switch_expr = switch_def.is_switch_expr;
+    M_ASSERT_EQ (key_word, "switch");
+
+//    M_FATAL_IF_FALSE (read_token_type_simple (is, switch_def.case_type));
+    M_FATAL_IF_FALSE (read_token_simple_word (is, switch_def.case_type));
+
+    if (switch_def.case_type == "{")
+    {
+        // switch case_type is optional and deprecated.
+        // It is not if you try to specify enum values without ::. You should not.
+        switch_def.case_type = "";
+    }
+    else
+    {
+        read_token_key_word_specified (is, "{");
+    }
+
+    string  end_flag;
+    M_FATAL_IF_FALSE (read_token_key_word (is, end_flag));
+
+    C_value::E_type    previous_case_value_type = C_value::E_type_float;
+
+    while (end_flag != "}")
+    {
+        T_switch_case    switch_case;
+
+        if ((end_flag == "case") && (is_switch_expr == true))
+        {
+            string    str_case_expr;
+            M_FATAL_IF_FALSE (read_token_expression_parenthesis (is, str_case_expr));
+
+            T_expression  & case_expression = switch_case.case_expr;
+            case_expression.build_expression(type_definitions, str_case_expr);
+        }
+        else if (end_flag == "case")
+        {
+            string    str_case_value;
+            M_FATAL_IF_FALSE (read_token_case_value (is, str_case_value));
+
+            // 20090606 new
+            string::size_type  str_size_before = str_case_value.size();
+            remove_string_limits(str_case_value);
+            switch_case.case_value = str_case_value;
+
+            if (str_case_value.size() != str_size_before)
+            {
+                // It is a string
+            }
+            else
+            {
+                // It is not a string (could be int or enum symbolic value)
+                switch_case.case_value.promote();
+
+                if (switch_case.case_value.get_type() == C_value::E_type_integer)
+                {
+                }
+                else if (switch_case.case_value.get_type() == C_value::E_type_string)
+                {
+                    // Search ::, means <enum_type>::<symbolic_name>
+                    if (switch_case.case_value.as_string().find("::") == string::npos)
+                    {
+                        // Must add <enum_type> to be able to retrieve the value.
+                        switch_case.case_value = switch_def.case_type + "::" + switch_case.case_value.as_string();
+                    }
+                    switch_case.case_value =
+                            string_to_numeric(type_definitions, switch_case.case_value.as_string(), "inline switch", "case value");
+                }
+                else
+                {
+                    M_FATAL_COMMENT("case value must be string, int or enum symbolic name");
+                }
+            }
+
+            // Check that all case value have the same type.
+            if ((previous_case_value_type != C_value::E_type_float) &&
+                (switch_case.case_value.get_type() != previous_case_value_type))
+            {
+                M_FATAL_COMMENT("switch case values must have the same type");
+            }
+
+            previous_case_value_type = switch_case.case_value.get_type();
+        }
+        else if (end_flag == "case_")    // ICIOA in progress   does not work
+        {
+            string    str_case_value;
+            M_FATAL_IF_FALSE (read_token_case_value (is, str_case_value));
+
+            T_expression  & case_expression = switch_case.case_expr;
+            case_expression.build_expression(type_definitions, str_case_value);
+
+            switch_case.case_value = case_expression.compute_expression_static(type_definitions);
+
+            // Check that all case value have the same type.
+            if ((previous_case_value_type != C_value::E_type_float) &&
+                (switch_case.case_value.get_type() != previous_case_value_type))
+            {
+                M_FATAL_COMMENT("switch case values must have the same type");
+            }
+
+            previous_case_value_type = switch_case.case_value.get_type();
+        }
+        else if (end_flag == "default")
+        {
+            switch_case.is_default_case = true;
+        }
+        else
+        {
+            M_FATAL_COMMENT ("Expected case, default or } instead of " << end_flag);
+        }
+
+        read_token_key_word_specified (is, ":");
+
+        // lecture struct dans switch_case.definition
+        end_flag = build_struct_fields (is, type_definitions,
+                                      switch_case.fields,
+                                      "case",
+                                      "default",
+                                      "}",
+                                      E_field_scope_other,
+                                      return_type);
+
+        switch_def.switch_cases.push_back (switch_case);
+    }
+}
+
+//*****************************************************************************
+// build_switch
+// ----------------------------------------------------------------------------
+// Format :
+// switch  <switch_name>  <case_type_name>
+// {
+// case <a_valid_value_for case_type_name> :  <type_name>  <field_name>
+// ...
+// case <a_valid_value_for case_type_name> :
+//   <type_name>  <field_name>
+//   ...
+//   <type_name>  <field_name>
+// default       :
+//   <type_name>  <field_name>
+// }
+//*****************************************************************************
+void    build_switch (const E_override            must_override,
+                      const string              & key_word_param,
+                            istream             & is,
+                            T_type_definitions  & type_definitions)
+{
+    M_TRACE_ENTER ("build_switch", "");
+
+//    M_ASSERT_EQ (key_word, "switch");
+    string    key_word = key_word_param;
+
+    string  switch_name;
+    M_FATAL_IF_FALSE (read_token_type_simple (is, switch_name));
+
+    M_CHECK_FORWARD(is, type_definitions.E_type_switch, switch_name);
+
+    build_types_context_type_begin(switch_name);
+
+    T_switch_definition    switch_def;
+    if (key_word == "switch_expr")
+    {
+        switch_def.is_switch_expr = true;
+        key_word = "switch";
+    }
+
+    build_switch_unnamed(key_word, is, type_definitions, switch_def, "void");
+
+    // Check it is possible to define a new type with this name.
+    // No returned value, FATAL is called if it is not possible.
+    type_definitions.could_define_new_type(switch_name, T_type_definitions::E_type_switch, must_override);
+
+    type_definitions.map_switch_definition[switch_name] = switch_def;    // possible override ok
+
+    build_types_context_type_end(switch_name);
+}
+
+//*****************************************************************************
+// build_function_prototype
+// ----------------------------------------------------------------------------
+// Format :
+// function  <type_name>  <function_name> ( <type_name>  <param_name>, ... )
+//*****************************************************************************
+void    build_function_prototype (
+                        const string                           & key_word,
+                              istream                          & is,
+                              T_function_prototype_definition  & function_def,
+                              string                           & function_name,
+                        const T_type_definitions               & type_definitions)
+{
+    M_TRACE_ENTER ("build_function_prototype", "");
+
+    M_ASSERT_EQ (key_word, "function");
+
+    M_FATAL_IF_FALSE (read_token_type_simple (is, function_def.return_type));
+
+    M_FATAL_IF_FALSE (read_token_type_simple (is, function_name));
+
+    build_types_context_type_begin(function_name);
+
+    vector<string>  parameters;
+    M_FATAL_IF_FALSE(read_token_parameters_vector(is, parameters));
+    // ICIOA mettre les parametres dans une/des expressions
+    
+    {
+        // Get type and name.
+        bool    is_parameter_default_value_mandatory = false;
+        for (unsigned int   idx = 0; idx < parameters.size(); ++idx)
+        {
+            vector<string>    parameter_type_name;
+            string_to_words(parameters[idx], parameter_type_name);
+
+            if ((parameter_type_name.size() != 3) &&
+                (parameter_type_name.size() != 5))
+            {
+                M_FATAL_COMMENT("Bad function parameters specification (" << parameters[idx] << ")");
+            }
+            if ((is_parameter_default_value_mandatory == true) &&
+                (parameter_type_name.size() != 5))
+            {
+                M_FATAL_COMMENT("No default value for parameter (" << parameters[idx] << ")");
+            }
+
+            T_function_parameter    function_parameter;
+
+            const string  & parameter_direction = parameter_type_name[0];
+            if (parameter_direction == "in")
+            {
+                function_parameter.direction = E_parameter_in;
+            }
+            else if (parameter_direction == "out")
+            {
+                function_parameter.direction = E_parameter_out;
+            }
+            else if (parameter_direction == "in_out")
+            {
+                function_parameter.direction = E_parameter_in_out;
+            }
+            else
+            {
+                M_FATAL_COMMENT("Bad parameter direction " << parameter_direction);
+            }
+
+            function_parameter.type = type_definitions.get_final_type(parameter_type_name[1]);
+            function_parameter.name = parameter_type_name[2];
+
+            post_build_field_base(type_definitions, function_parameter, E_field_scope_parameter);
+
+            if (parameter_type_name.size() > 3)
+            {
+                // parameter with default value.
+
+                // all following parameters must have a default value.
+                is_parameter_default_value_mandatory = true;
+
+                if (function_parameter.direction != E_parameter_in)
+                {
+                    M_FATAL_COMMENT("Default value is possible only with in parameter (" << parameters[idx] << ")");
+                }
+
+                M_FATAL_IF_NE(parameter_type_name[3], "=");
+
+                const string  & parameter_default_value_expression = parameter_type_name[4];
+                C_value         parameter_default_value = compute_expression_static(type_definitions, parameter_default_value_expression);
+
+                // Check value type.
+                check_function_parameter_value(type_definitions, function_parameter, parameter_default_value);
+
+                function_parameter.set_default_value(parameter_default_value);
+            }
+
+            function_def.add_function_parameter(function_parameter);
+        }
+    }
+
+    build_types_context_type_end(function_name);
+}
+
+//*****************************************************************************
+// build_function_after_prototype
+// ----------------------------------------------------------------------------
+// Format :
+// {
+//   fields
+// }
+//*****************************************************************************
+void    build_function_after_prototype (
+                        const E_override                         must_override,
+                              istream                          & is,
+                              T_function_definition            & function_def,
+                        const string                           & function_name,
+                              T_type_definitions               & type_definitions)
+{
+    M_TRACE_ENTER ("build_function_after_prototype", "");
+
+    build_types_context_type_begin(function_name);
+
+    read_token_key_word_specified (is, "{");
+
+    build_struct_fields(is, type_definitions, function_def.fields,
+                        "}", nullptr, nullptr,
+                        E_field_scope_other,
+                        function_def.return_type.c_str());
+
+    // NB: too difficult to verify that there is a return (for a not void function). 
+
+    // Check it is possible to define a new type with this name.
+    // No returned value, FATAL is called if it is not possible.
+    type_definitions.could_define_new_type(function_name, T_type_definitions::E_type_function, must_override);
+
+    type_definitions.map_function_definition[function_name] = function_def;    // possible override ok
+
+    build_types_context_type_end(function_name);
+}
+
+//*****************************************************************************
+// build_function
+// ----------------------------------------------------------------------------
+// Format :
+// function  <type_name>  <function_name> ( <type_name>  <param_name>, ... )
+// {
+//   fields
+// }
+//*****************************************************************************
+void    build_function (const E_override            must_override,
+                        const string              & key_word,
+                              istream             & is,
+                              T_type_definitions  & type_definitions)
+{
+    M_TRACE_ENTER ("build_function", "");
+
+    T_function_definition    function_def;
+    string                   function_name;
+
+    build_function_prototype (key_word, is, function_def, function_name, type_definitions);
+
+    build_function_after_prototype (must_override, is, function_def, function_name, type_definitions);
+}
+
+//*****************************************************************************
+// build_plugin_output
+// ----------------------------------------------------------------------------
+// Format :
+// plugin{output}{user_data="..."}  <library_name>;
+//*****************************************************************************
+#ifdef BYTE_INTERPRET_USE_PLUGIN
+#include <gmodule.h>
+
+void    build_plugin_output (const E_override            UNUSED(must_override),
+                             const string              & key_word,
+                                   istream             & is,
+                                   T_type_definitions  & type_definitions)
+{
+    M_TRACE_ENTER ("build_plugin_output", "");
+
+    M_ASSERT_EQ (key_word.compare(0, 14, "plugin{output}"), 0);
+
+
+    T_plugin_output_definition  plugin_def;
+
+    M_FATAL_IF_FALSE (read_token_type_simple (is, plugin_def.library_name));
+
+    build_types_context_type_begin(plugin_def.library_name);
+
+    {
+        string    key_word_base = key_word;
+        string    key_word_extend;
+        if (decompose_type_sep_value_sep (key_word_base,
+                                              '{',
+                                              '}',
+                                              key_word_base,
+                                              key_word_extend) == E_rc_ok)
+        {
+            M_TRACE_DEBUG(key_word_extend);
+
+            if (strncmp(key_word_extend.c_str(), "user_data=", 10) == 0)
+            {
+                key_word_extend = key_word_extend.substr(10);
+                remove_string_limits(key_word_extend);
+                plugin_def.user_data = key_word_extend;
+                plugin_def.context.P_user_data = strdup(plugin_def.user_data.c_str());
+            }
+        }
+    }
+
+
+    const string  & filename = plugin_def.library_name;
+
+    GModule   *handle = g_module_open(filename.c_str(), (GModuleFlags)G_MODULE_BIND_LAZY);
+
+    if (handle == nullptr)
+    {
+        const char  * error = g_module_error ();
+        M_FATAL_COMMENT(filename << " not found or not a readable libray : " << error);
+    }
+    M_TRACE_DEBUG(filename << " found");
+
+    gpointer       gp;
+
+    if (g_module_symbol(handle, "byte_interpret_plugin_output_begin", &gp))
+    {
+        plugin_def.byte_interpret_plugin_output_begin_cb = (T_byte_interpret_plugin_output_begin_cb)gp;
+        M_TRACE_DEBUG("byte_interpret_plugin_output_begin found");
+    }
+
+    if (g_module_symbol(handle, "byte_interpret_plugin_output_value_integer", &gp))
+    {
+        plugin_def.byte_interpret_plugin_output_value_integer_cb = (T_byte_interpret_plugin_output_value_integer_cb)gp;
+        M_TRACE_DEBUG("byte_interpret_plugin_output_value_integer found");
+    }
+
+    if (g_module_symbol(handle, "byte_interpret_plugin_output_value_float", &gp))
+    {
+        plugin_def.byte_interpret_plugin_output_value_float_cb = (T_byte_interpret_plugin_output_value_float_cb)gp;
+        M_TRACE_DEBUG("byte_interpret_plugin_output_value_float found");
+    }
+
+    if (g_module_symbol(handle, "byte_interpret_plugin_output_value_string", &gp))
+    {
+        plugin_def.byte_interpret_plugin_output_value_string_cb = (T_byte_interpret_plugin_output_value_string_cb)gp;
+        M_TRACE_DEBUG("byte_interpret_plugin_output_value_string found");
+    }
+
+    if (g_module_symbol(handle, "byte_interpret_plugin_output_raw_data", &gp))
+    {
+        plugin_def.byte_interpret_plugin_output_raw_data_cb = (T_byte_interpret_plugin_output_raw_data_cb)gp;
+        M_TRACE_DEBUG("byte_interpret_plugin_output_raw_data found");
+    }
+
+    if (g_module_symbol(handle, "byte_interpret_plugin_output_group_begin", &gp))
+    {
+        plugin_def.byte_interpret_plugin_output_group_begin_cb = (T_byte_interpret_plugin_output_group_begin_cb)gp;
+        M_TRACE_DEBUG("byte_interpret_plugin_output_group_begin found");
+    }
+
+    if (g_module_symbol(handle, "byte_interpret_plugin_output_group_append_text", &gp))
+    {
+        plugin_def.byte_interpret_plugin_output_group_append_text_cb = (T_byte_interpret_plugin_output_group_append_text_cb)gp;
+        M_TRACE_DEBUG("byte_interpret_plugin_output_group_append_text found");
+    }
+
+    if (g_module_symbol(handle, "byte_interpret_plugin_output_group_end", &gp))
+    {
+        plugin_def.byte_interpret_plugin_output_group_end_cb = (T_byte_interpret_plugin_output_group_end_cb)gp;
+        M_TRACE_DEBUG("byte_interpret_plugin_output_group_end found");
+    }
+
+    if (g_module_symbol(handle, "byte_interpret_plugin_output_error", &gp))
+    {
+        plugin_def.byte_interpret_plugin_output_error_cb = (T_byte_interpret_plugin_output_error_cb)gp;
+        M_TRACE_DEBUG("byte_interpret_plugin_output_error found");
+    }
+
+    if (g_module_symbol(handle, "byte_interpret_plugin_output_missing_data", &gp))
+    {
+        plugin_def.byte_interpret_plugin_output_missing_data_cb = (T_byte_interpret_plugin_output_missing_data_cb)gp;
+        M_TRACE_DEBUG("byte_interpret_plugin_output_missing_data found");
+    }
+
+    if (g_module_symbol(handle, "byte_interpret_plugin_output_cmd_error", &gp))
+    {
+        plugin_def.byte_interpret_plugin_output_cmd_error_cb = (T_byte_interpret_plugin_output_cmd_error_cb)gp;
+        M_TRACE_DEBUG("byte_interpret_plugin_output_cmd_error found");
+    }
+
+    if (g_module_symbol(handle, "byte_interpret_plugin_output_cmd_print", &gp))
+    {
+        plugin_def.byte_interpret_plugin_output_cmd_print_cb = (T_byte_interpret_plugin_output_cmd_print_cb)gp;
+        M_TRACE_DEBUG("byte_interpret_plugin_output_cmd_print found");
+    }
+
+
+
+    type_definitions.vector_plugin_output_definition.push_back(plugin_def);
+
+    build_types_context_type_end(plugin_def.library_name);
+
+    skip_line(is);
+}
+#endif
+
+//*****************************************************************************
+// build_library
+// ----------------------------------------------------------------------------
+// Format :
+// library  "library path;...;library path"    or const string with same format
+// {
+//    <function prototype>
+//    ...
+//    <function prototype>
+// }
+//*****************************************************************************
+#ifdef BYTE_INTERPRET_USE_LIBRARY_DYNCALL
+#include <dynload.h>
+
+void    build_library  (const E_override            must_override,
+                        const string              & key_word,
+                              istream             & is,
+                              T_type_definitions  & type_definitions)
+{
+    M_TRACE_ENTER ("build_library", "");
+
+    M_ASSERT_EQ (key_word, "library");
+
+
+    // Read library filenames list (1 string with ; delimiter)
+    string   library_filenames_str;
+    M_FATAL_IF_FALSE (read_token_right_any(is, library_filenames_str));
+
+    {
+        T_expression  expression;
+        expression.build_expression(type_definitions, library_filenames_str);
+
+        C_value  expression_result = expression.compute_expression_static(type_definitions);
+        library_filenames_str = expression_result.get_str();
+    }
+
+    // Split string read on ;
+    vector<string>  library_filenames;
+    while (true)
+    {
+        string         library_filename;
+        string         str_right;
+        E_return_code  rc = get_before_separator_after (library_filenames_str, ';', library_filename, str_right);
+        if (rc != E_rc_ok)
+        {
+            library_filenames.push_back(library_filenames_str);
+            break;
+        }
+
+        library_filenames.push_back(library_filename);
+        library_filenames_str = str_right;
+    }
+
+
+    // Load library from one of the library_filenames 
+    T_library_definition  * P_library_def = nullptr;
+    string   libraries_not_found;
+    string   libraries_not_loadable;
+
+    for (vector<string>::const_iterator  iter  = library_filenames.begin();
+                                         iter != library_filenames.end();
+                                       ++iter)
+    {
+        const string  & library_filename = *iter;
+
+        T_map_library_definition::iterator  iter_lib =
+            type_definitions.map_library_definition.find(library_filename);
+        if (iter_lib != type_definitions.map_library_definition.end())
+        {
+            // already found
+            P_library_def = & iter_lib->second;
+            break;
+        }
+
+        ifstream              ifs (library_filename.c_str());
+        if (!ifs)
+        {
+            M_TRACE_DEBUG(library_filename << " not found");
+            libraries_not_found += " >";
+            libraries_not_found += library_filename;
+            libraries_not_found += "<";
+            continue;
+        }
+
+        void  * DLLib_handle = dlLoadLibrary (library_filename.c_str());
+        if (DLLib_handle == nullptr)
+        {
+            M_TRACE_DEBUG(library_filename << " not a loadable library");
+            libraries_not_loadable += " >";
+            libraries_not_loadable += library_filename;
+            libraries_not_loadable += "<";
+            continue;
+        }
+
+        // New library
+        P_library_def = & type_definitions.map_library_definition[library_filename];
+        P_library_def->DLLib_handle = DLLib_handle;
+        P_library_def->full_name    = library_filename;
+        break;
+    }
+
+    if (P_library_def == nullptr)
+    {
+        ostringstream  oss;
+        if (libraries_not_loadable != "")
+        {
+            oss << "Libraries" << libraries_not_loadable << " are not loadable." << endl << endl;
+        }
+        if (libraries_not_found != "")
+        {
+            oss << "Libraries" << libraries_not_found << " are not found." << endl << endl;
+        }
+
+        M_FATAL_COMMENT(oss.str());
+    }
+
+    M_TRACE_DEBUG(P_library_def->full_name << " is a loadable library");
+
+    read_token_key_word_specified(is, "{");
+
+    // Read function prototypes and get corresponding pointer into library
+    while (true)
+    {
+        string  key_word;
+        M_FATAL_IF_FALSE (read_token_simple_word_or_string (is, key_word));
+        if (key_word == "}")
+            break;
+
+        T_function_definition            function_def;
+        T_library_function_definition    library_function_def;
+        string                         & function_name = library_function_def.name;
+
+        build_function_prototype (key_word, is, function_def, function_name, type_definitions);
+        read_token_key_word_specified(is, ";");
+
+        library_function_def.funptr = dlFindSymbol((DLLib*)P_library_def->DLLib_handle , library_function_def.name.c_str());
+        if (library_function_def.funptr == nullptr)
+        {
+            M_FATAL_COMMENT(library_function_def.name << " not found into " << P_library_def->full_name << " library");
+        }
+        M_TRACE_DEBUG(library_function_def.name << " found into " << P_library_def->full_name << " library");
+
+        function_def.idx_library_function_def = P_library_def->library_functions.size();
+        function_def.P_library_def = P_library_def;
+
+        istringstream    iss("{ \n"
+                             "  fatal \"Bug in the software, this version is only a prototype\"; \n"
+                             "}");
+        build_function_after_prototype (must_override, iss, function_def, function_name, type_definitions);
+
+        P_library_def->library_functions.push_back(library_function_def);
+    }
+}
+#endif
+
+//*****************************************************************************
+// build_types_no_include
+// - search for alias, struct, enum, switch definitions
+// - add the definition into the associated map
+// - stop when key word is NOT understand and return it
+//   NB: NOT understand = NOT understand at this level (see calling functions)
+//*****************************************************************************
+string    build_types_no_include (istream             & is,
+                                  T_type_definitions  & type_definitions)
+{
+    M_TRACE_ENTER ("build_types_no_include", "");
+
+    string    key_word;
+    while (read_token_left_any (is, key_word))
+    {
+        E_override    must_override = E_override_no;
+        if (key_word == "override")
+        {
+            must_override = E_override_yes;
+
+            M_FATAL_IF_FALSE (read_token_left_any (is, key_word));
+        }
+
+        build_types_context_type_kind_begin(key_word);
+
+        long    sizeof_enum = 0;
+        if (key_word == "alias")
+        {
+            build_alias (must_override, key_word, is, type_definitions);
+        }
+        else if (key_word == "const")
+        {
+            build_const (must_override, key_word, is, type_definitions);
+        }
+        else if (key_word == "struct")
+        {
+            build_struct (must_override, key_word, is, type_definitions);
+        }
+        else if (/* (key_word == "enum") || */
+                 (key_word == "enum8") ||
+                 (key_word == "enum16") ||
+                 (key_word == "enum24") ||
+                 (key_word == "enum32") ||
+                 ((strncmp(key_word.c_str(), "enum", 4) == 0) &&
+                  (get_number (key_word.c_str () + strlen ("enum"), &sizeof_enum))))
+        {
+            build_enum (must_override, key_word, is, type_definitions);
+        }
+        else if ((key_word == "switch") ||
+                 (key_word == "switch_expr"))
+        {
+            build_switch (must_override, key_word, is, type_definitions);
+        }
+        else if (key_word == "function")
+        {
+            build_function (must_override, key_word, is, type_definitions);
+        }
+        else if ((key_word == "bitfield8") ||
+                 (key_word == "bitfield16") ||
+                 (key_word == "bitfield24") ||
+                 (key_word == "bitfield32") ||
+                 (key_word == "bitstream8") ||
+                 (key_word == "bitstream16") ||
+                 (key_word == "bitstream24") ||
+                 (key_word == "bitstream32"))
+        {
+            build_bitfield (must_override, key_word, is, type_definitions);
+        }
+#ifdef BYTE_INTERPRET_USE_PLUGIN
+        else if (strncmp(key_word.c_str(), "plugin{output}", 14) == 0)
+        {
+            build_plugin_output (must_override, key_word, is, type_definitions);
+        }
+#endif
+#ifdef BYTE_INTERPRET_USE_LIBRARY_DYNCALL
+        else if (strncmp(key_word.c_str(), "library", 7) == 0)
+        {
+            build_library (must_override, key_word, is, type_definitions);
+        }
+#endif
+        else
+        {
+            build_types_context_type_kind_end(key_word);
+            break;
+        }
+
+        build_types_context_type_kind_end(key_word);
+    }
+
+    return  key_word;
+}
+
+//*****************************************************************************
+// build_types_no_include_str *************************************************
+//*****************************************************************************
+
+void    build_types_no_include_str (const string              & str,
+                                          T_type_definitions  & type_definitions)
+{
+    istringstream           iss(str.c_str());
+
+    const string    result = build_types_no_include (iss, type_definitions);
+    M_FATAL_IF_NE(result, "");
+}
+
+//*****************************************************************************
+// build_types_begin **********************************************************
+//*****************************************************************************
+C_value  string_count_cpp_to_fdesc(const string::size_type  cpp_count);
+
+void    build_types_begin (T_type_definitions  & type_definitions)
+{
+    if (type_definitions.map_enum_definition_representation.empty() == false)
+    {
+        // Already initialized
+        return;
+    }
+
+    M_TRACE_ENTER ("build_types_begin", "");
+
+    // bool type definitions
+    build_types_no_include_str("enum8     bool8   { false 0  true 1 }", type_definitions);
+    build_types_no_include_str("enum16    bool16  as  bool8 ;", type_definitions);
+    build_types_no_include_str("enum32    bool32  as  bool8 ;", type_definitions);
+    build_types_no_include_str("enum1     bool1   as  bool8 ;", type_definitions);
+
+    // string type definitions
+    type_definitions.map_const_value["string::npos"] = string_count_cpp_to_fdesc(string::npos);
+
+    // system
+#if defined WIN32
+    type_definitions.map_const_value["system::os"]     = "win";
+#else
+    type_definitions.map_const_value["system::os"]     = "linux";
+#endif
+    type_definitions.map_const_value["system::bits"] = sizeof(void*)*8;
+    type_definitions.map_const_value["system::osbits"] =
+    type_definitions.map_const_value["system::os"].as_string() +
+    type_definitions.map_const_value["system::bits"].as_string();
+
+
+#define M_DEFINE_BUILTIN_FUNCTION(PROTOTYPE)                                    \
+    build_types_no_include_str("function " PROTOTYPE " \n"                      \
+        "{ \n"                                                                  \
+        "  fatal \"Bug in the software, this version is only a prototype\"; \n" \
+        "}", type_definitions)
+
+    // Built-in functions
+    M_DEFINE_BUILTIN_FUNCTION("bool8    is_existing_field_or_variable (in string  var_name)");
+    M_DEFINE_BUILTIN_FUNCTION("string   to_string (in any  value)");
+    M_DEFINE_BUILTIN_FUNCTION("any      to_numeric (in string  value)");
+    M_DEFINE_BUILTIN_FUNCTION("float64  to_float (in any  value)");
+    M_DEFINE_BUILTIN_FUNCTION("int64    to_integer (in string  value, in int8  base = 0)");
+    M_DEFINE_BUILTIN_FUNCTION("string   getenv (in string  env_name)");
+
+    M_DEFINE_BUILTIN_FUNCTION("int64    string.length  (in string  str)");
+    M_DEFINE_BUILTIN_FUNCTION("string   string.substr  (in string  str, in int64  idx, in int64  count = string::npos)");
+    M_DEFINE_BUILTIN_FUNCTION("string   string.erase   (in string  str, in int64  idx, in int64  count = string::npos)");
+    M_DEFINE_BUILTIN_FUNCTION("string   string.insert  (in string  str, in int64  idx, in string  str_to_insert)");
+    M_DEFINE_BUILTIN_FUNCTION("string   string.replace (in string  str, in int64  idx, in int64  count, in string str_to_insert)");
+    M_DEFINE_BUILTIN_FUNCTION("string   string.replace_all (in string  str, in string  old, in string new)");
+    M_DEFINE_BUILTIN_FUNCTION("int64    string.find    (in string  str, in string  str_to_find)");
+
+//    M_DEFINE_BUILTIN_FUNCTION("void     date.get_year_from_days          (in uint16{min=1583} ref_year, in uint32 number_of_days   , out uint16 year, out uint16 number_of_days_in_year)");
+//    M_DEFINE_BUILTIN_FUNCTION("void     date.get_year_from_seconds       (in uint16{min=1583} ref_year, in uint40 number_of_seconds, out uint16 year, out uint32 number_of_seconds_in_year)");
+//    M_DEFINE_BUILTIN_FUNCTION("void     date.get_month_from_year_days    (in uint16{min=1583} year, in uint16 number_of_days_in_year   , out uint8 month, out uint8 day)");
+//    M_DEFINE_BUILTIN_FUNCTION("void     date.get_month_from_year_seconds (in uint16{min=1583} year, in uint32 number_of_seconds_in_year, out uint8 month, out uint8 day, out uint32 number_of_seconds_in_day)");
+    M_DEFINE_BUILTIN_FUNCTION("string   date.get_string_from_days    (in uint16{min=1583} ref_year, in uint32 number_of_days)");
+    M_DEFINE_BUILTIN_FUNCTION("string   date.get_string_from_seconds (in uint16{min=1583} ref_year, in uint40 number_of_seconds)");
+
+    // Decoder definitions
+    build_types_no_include_str("alias     frame   int64 ;", type_definitions);
+    M_DEFINE_BUILTIN_FUNCTION("void  frame_append_data (in frame  frame, in any  byte)");
+    M_DEFINE_BUILTIN_FUNCTION("void  frame_append_data_array (in frame  frame, in pointer  data, in int64  data_size)");
+    M_DEFINE_BUILTIN_FUNCTION("void  frame_append_hexa_data (in frame  frame, in string  str_hexa)");
+
+    // Decoder built-in
+    M_DEFINE_BUILTIN_FUNCTION("void  decoder_aes     (in frame  frame, in uint32   nb_of_bits_needed_uint)");
+    M_DEFINE_BUILTIN_FUNCTION("void  decoder_base64  (in frame  frame, in uint32   nb_of_bits_needed_uint)");
+    M_DEFINE_BUILTIN_FUNCTION("void  decoder_utf16be (in frame  frame, in uint32   nb_of_bits_needed_uint)");
+    M_DEFINE_BUILTIN_FUNCTION("void  decoder_utf16le (in frame  frame, in uint32   nb_of_bits_needed_uint)");
+    M_DEFINE_BUILTIN_FUNCTION("void  decoder_utf8    (in frame  frame, in uint32   nb_of_bits_needed_uint)");
+
+    // Library pointer function
+    M_DEFINE_BUILTIN_FUNCTION("int64    get_pointer_len_bytes     (                        in uint32  length_bytes )");
+    M_DEFINE_BUILTIN_FUNCTION("int64    get_pointer_len_bits      (                        in uint32  length_bits )");
+    M_DEFINE_BUILTIN_FUNCTION("int64    get_pointer_pos_len_bytes ( in uint32  pos_bytes , in uint32  length_bytes )");
+    M_DEFINE_BUILTIN_FUNCTION("int64    get_pointer_pos_len_bits  ( in uint32  pos_bits  , in uint32  length_bits  )");
+}
+
+
+
+//*****************************************************************************
+// build_types_finalize struct_fields *****************************************
+//*****************************************************************************
+void    build_types_finalize(T_type_definitions  & type_definitions,
+                             T_field_type_name   & field_type_name);
+
+void    build_types_finalize(T_type_definitions  & type_definitions,
+                             T_struct_fields     & fields)
+{
+    for (T_struct_fields::iterator
+                             iter  = fields.begin();
+                             iter != fields.end();
+                           ++iter)
+    {
+        T_field_type_name   & field = *iter;
+
+        build_types_finalize(type_definitions, field);
+    }
+}
+
+//*****************************************************************************
+// build_types_finalize struct_def ********************************************
+//*****************************************************************************
+
+void    build_types_finalize(T_type_definitions   & type_definitions,
+                             T_struct_definition  & struct_def)
+{
+    build_types_finalize(type_definitions, struct_def.fields);
+}
+
+//*****************************************************************************
+// build_types_finalize bitfield_def ******************************************
+//*****************************************************************************
+
+void    build_types_finalize(T_type_definitions     & type_definitions,
+                             T_bitfield_definition  & bitfield_def)
+{
+    build_types_finalize(type_definitions, bitfield_def.master_field);
+    build_types_finalize(type_definitions, bitfield_def.fields_definition);
+}
+
+//*****************************************************************************
+// build_types_finalize switch_def ********************************************
+//*****************************************************************************
+
+void    build_types_finalize(T_type_definitions   & type_definitions,
+                             T_switch_definition  & switch_def)
+{
+    for (T_switch_cases::iterator
+                             iter  = switch_def.switch_cases.begin();
+                             iter != switch_def.switch_cases.end();
+                           ++iter)
+    {
+        T_switch_case   & case_val = *iter;
+
+        build_types_finalize(type_definitions, case_val.fields);
+    }
+}
+
+//*****************************************************************************
+// build_types_finalize field *************************************************
+//*****************************************************************************
+void    build_types_finalize_itself(T_type_definitions  & type_definitions,
+                                    T_field_type_name   & field_type_name);
+
+void    build_types_finalize(T_type_definitions  & type_definitions,
+                             T_field_type_name   & field_type_name)
+{
+    if (field_type_name.P_sub_struct)
+    {
+        build_types_finalize(type_definitions, *field_type_name.P_sub_struct);
+    }
+
+    build_types_finalize(type_definitions, field_type_name.sub_struct_2);
+
+    if (field_type_name.P_bitfield_inline)
+    {
+        build_types_finalize(type_definitions, *field_type_name.P_bitfield_inline);
+    }
+
+    if (field_type_name.P_switch_inline)
+    {
+        build_types_finalize(type_definitions, *field_type_name.P_switch_inline);
+    }
+
+    build_types_finalize_itself(type_definitions, field_type_name);
+}
+
+
+
+//*****************************************************************************
+// build_types_finalize *******************************************************
+//*****************************************************************************
+
+void    build_types_finalize(T_type_definitions  & type_definitions)
+{
+    M_TRACE_ENTER("build_types_finalize", "");
+
+  {
+    T_map_struct_definition  & map_struct_definition = type_definitions.map_struct_definition;
+    for (T_map_struct_definition::iterator
+                             iter  = map_struct_definition.begin();
+                             iter != map_struct_definition.end();
+                           ++iter)
+    {
+      T_struct_definition  & struct_definition = iter->second;
+
+      build_types_finalize(type_definitions, struct_definition);
+    }
+  }
+
+  {
+    T_map_bitfield_definition  & map_bitfield_definition = type_definitions.map_bitfield_definition;
+    for (T_map_bitfield_definition::iterator
+                             iter  = map_bitfield_definition.begin();
+                             iter != map_bitfield_definition.end();
+                           ++iter)
+    {
+      T_bitfield_definition  & bitfield_definition = iter->second;
+
+      build_types_finalize(type_definitions, bitfield_definition);
+    }
+  }
+#if 0
+  // Nothing to do
+  {
+    T_map_enum_definition_representation  & map_enum_definition_representation = type_definitions.map_enum_definition_representation;
+    for (T_map_enum_definition_representation::iterator
+                             iter  = map_enum_definition_representation.begin();
+                             iter != map_enum_definition_representation.end();
+                           ++iter)
+    {
+      T_enum_definition_representation  & enum_definition = iter->second;
+
+      build_types_finalize(type_definitions, enum_definition);
+    }
+  }
+#endif
+  {
+    T_map_switch_definition  & map_switch_definition = type_definitions.map_switch_definition;
+    for (T_map_switch_definition::iterator
+                             iter  = map_switch_definition.begin();
+                             iter != map_switch_definition.end();
+                           ++iter)
+    {
+      T_switch_definition  & switch_definition = iter->second;
+
+      build_types_finalize(type_definitions, switch_definition);
+    }
+  }
+
+  {
+    T_map_function_definition  & map_function_definition = type_definitions.map_function_definition;
+    for (T_map_function_definition::iterator
+                             iter  = map_function_definition.begin();
+                             iter != map_function_definition.end();
+                           ++iter)
+    {
+      T_function_definition  & function_definition = iter->second;
+
+      build_types_finalize(type_definitions, function_definition.fields);
+    }
+  }
+}
+
+//*****************************************************************************
+// build_types ****************************************************************
+//*****************************************************************************
+// Read type definitions until :
+// - end of stream        : returns ""
+// - NOT understand word  : returns the NOT understand word
+//*****************************************************************************
+
+string    build_types2 (istream             & is,
+                       T_type_definitions  & type_definitions)
+{
+    M_TRACE_ENTER ("build_types", "");
+
+    build_types_begin (type_definitions);
+
+    while (true)
+    {
+        const string    last_extracted_word = build_types_no_include (is,
+                                                           type_definitions);
+
+        // If there is nothing else to read.
+        if (last_extracted_word == "")
+        {
+            M_ASSERT (is.eof ());
+            return  last_extracted_word;
+        }
+
+        if (last_extracted_word == "include")
+        {
+            // include a file.
+            string    file_name;
+            M_FATAL_IF_FALSE (read_token_include_name (is, file_name));
+
+            read_token_end_of_statement(is);
+
+            const string    full_file_name = byte_interpret_get_include_file_name(file_name);
+            ifstream   ifs (full_file_name.c_str ());
+            if (!ifs)
+            {
+                M_FATAL_COMMENT("Impossible to open file " << full_file_name);
+            }
+
+            M_TRACE_INFO ("include " << file_name);
+
+            // Save include_directory (and restore it in destructor).
+            C_byte_interpret_append_include_directory  biaid;
+
+            // Retrieve (sub-)directory from file name.
+            {
+                const string::size_type  idx_last_dir = file_name.find_last_of("/\\");
+                if (idx_last_dir != string::npos)
+                {
+                    biaid.append_include_directory(file_name.substr(0, idx_last_dir));
+                }
+            }
+
+            build_types_context_include_file_open(file_name, ifs);
+
+            const string    result = build_types (ifs, type_definitions);
+            if (result != "")
+            {
+                M_FATAL_COMMENT("Expecting keyword instead of " << result);
+            }
+
+            build_types_context_include_file_close(file_name);
+            continue;
+        }
+
+        // Unknow word, return it.
+        return  last_extracted_word;
+    }
+}
+
+string    build_types (istream             & is,
+                       T_type_definitions  & type_definitions)
+{
+    C_setlocale_numeric_C_guard  locale_guard;
+
+    const string  NOT_understood_word = build_types2 (is, type_definitions);
+
+    build_types_finalize(type_definitions);
+
+
+    return  NOT_understood_word;
+}
+
+//****************************************************************************
+// build_types
+//****************************************************************************
+
+void      build_types (const string              & file_name,
+                             T_type_definitions  & type_definitions)
+{
+    M_TRACE_ENTER ("build_types", file_name);
+
+    // Open the types definitions file.
+    ifstream    ifs(file_name.c_str());
+    if (!ifs)
+    {
+        M_FATAL_COMMENT("Unable to open " << file_name);
+    }
+
+    // ICIOA must manage sub-directory
+
+    // Build the types.
+    const string  NOT_understood_word = build_types (ifs, type_definitions);
+    if (NOT_understood_word != "")
+    {
+        M_FATAL_COMMENT("Not understood word (" << NOT_understood_word << ") into " << file_name);
+    }
+}
+
diff --git a/plugins/epan/generic/byte_interpret_build_types.h b/plugins/epan/generic/byte_interpret_build_types.h
new file mode 100644
index 00000000000..c4004c049e2
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_build_types.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef BYTE_INTERPRET_BUILD_TYPES_H
+#define BYTE_INTERPRET_BUILD_TYPES_H
+
+//****************************************************************************
+// Includes.
+//****************************************************************************
+
+#include "T_type_definitions.h"
+
+#include <string>
+
+using namespace std;
+
+//****************************************************************************
+// byte_interpret_set_include_directory
+// Sets the directory name where are the include files.
+//****************************************************************************
+
+void      byte_interpret_set_include_directory(const string  & dir_name);
+
+//****************************************************************************
+// byte_interpret_get_include_file_name
+// Returns <include dir>/<file_name>.
+//****************************************************************************
+
+string    byte_interpret_get_include_file_name(const string  & file_name);
+
+
+//****************************************************************************
+// build_types
+// Build types specified into <file_name>.
+//****************************************************************************
+
+void      build_types (const string              & file_name,
+                             T_type_definitions  & type_definitions);
+
+
+//****************************************************************************
+// build_types
+// Build types specified into <is>.
+// Returns the last extracted word (which has NOT been treated).
+//****************************************************************************
+
+string    build_types (istream             & is,
+                       T_type_definitions  & type_definitions);
+
+
+//****************************************************************************
+// build_field
+// Build field specified at the beginning of <is> starting with <first_word>.
+// Returns the last extracted word (which has NOT been treated).
+//****************************************************************************
+
+string    build_field (istream                           & is,
+                 const T_type_definitions                & type_definitions,
+                       string                              first_word,
+                       T_field_type_name                 & field_type_name);
+
+
+#endif /* BYTE_INTERPRET_BUILD_TYPES_H */
diff --git a/plugins/epan/generic/byte_interpret_build_types_context.cpp b/plugins/epan/generic/byte_interpret_build_types_context.cpp
new file mode 100644
index 00000000000..adb321af412
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_build_types_context.cpp
@@ -0,0 +1,283 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+// Necessary for windows pre-compiled headers.
+// At the end, does NOT work : missing functions at link time
+// After other includes, does NOT work : does NOT compile (on "ifstream   ifs") 
+#include "precomp.h"
+
+#include <string>
+#include <vector>
+
+using namespace std;
+
+#include "byte_interpret_build_types_context.h"
+#include "byte_interpret_common.h"
+
+
+//*****************************************************************************
+// T_build_types_context_file
+//*****************************************************************************
+
+struct T_build_types_context_file
+{
+    T_build_types_context_file(string    file_name_param)
+        :file_name(file_name_param),
+         P_is(nullptr),
+         file_line(-1)
+    {
+    }
+
+    T_build_types_context_file(const string    & file_name_param,
+                               const istream   & is_param)
+        :file_name(file_name_param),
+         P_is(&is_param),
+         file_line(1)
+    {
+    }
+
+          string     file_name;
+    const istream  * P_is;
+
+    int       file_line;
+
+    string    previous_type;
+    string    type_kind;
+    string    type_name;
+};
+
+vector<T_build_types_context_file>  A_include_files;
+
+T_build_types_context_file  & get_current_context()
+{
+    if (A_include_files.empty())
+    {
+//        M_FATAL_COMMENT("Bug in the software");
+        A_include_files.push_back(T_build_types_context_file("Not known file or not a file"));
+    }
+
+    return  A_include_files.back();
+}
+
+//*****************************************************************************
+// Types
+//*****************************************************************************
+
+void         build_types_context_type_kind_begin(const std::string  & type_kind)
+{
+    T_build_types_context_file  & context = get_current_context();
+
+    if (context.type_kind != "")
+    {
+        M_FATAL_COMMENT("prev kind not ended");
+    }
+    context.type_kind = type_kind;
+}
+void         build_types_context_type_begin(const std::string  & type_name)
+{
+    T_build_types_context_file  & context = get_current_context();
+
+    if (context.type_name != "")
+    {
+        M_FATAL_COMMENT("prev type_name not ended");
+    }
+    context.type_name = type_name;
+}
+void         build_types_context_type_end  (const std::string  & type_name)
+{
+    T_build_types_context_file  & context = get_current_context();
+
+    if (type_name != context.type_name)
+    {
+        M_FATAL_COMMENT("Ended type_name does not match last type_name");
+    }
+    context.previous_type = context.type_kind + " " + context.type_name;
+    context.type_name = "";
+}
+void         build_types_context_type_kind_end(const std::string  & type_kind)
+{
+    T_build_types_context_file  & context = get_current_context();
+
+    if (type_kind != context.type_kind)
+    {
+        M_FATAL_COMMENT("Ended type_kind does not match last type_kind");
+    }
+    context.type_kind = "";
+}
+std::string  build_types_context_type_where()
+{
+    T_build_types_context_file  & context = get_current_context();
+
+    string  result;
+
+    if ((context.type_kind == "") || (context.type_name == ""))
+    {
+        if (context.previous_type == "enum1 bool1")    // automatically created type
+        {
+            result += "At beginning of type definitions.\n";
+        }
+        else if (context.previous_type == "")
+        {
+            result += "At beginning of file.\n";
+        }
+        else
+        {
+            result += "After definition of " + context.previous_type + ".\n";
+        }
+    }
+    if (context.type_kind != "")
+    {
+        if (context.type_name == "")
+        {
+            result += "Starting definition of " + context.type_kind + ".\n";
+        }
+        else
+        {
+            result += "Into definition of " + context.type_kind + " " + context.type_name + ".\n";
+        }
+    }
+
+    return  result;
+}
+
+//*****************************************************************************
+// Include files
+//*****************************************************************************
+
+void    build_types_context_include_file_open(const std::string  & file_name)
+{
+    A_include_files.push_back(T_build_types_context_file(file_name));
+}
+
+void    build_types_context_include_file_open(const std::string  & file_name,
+                                              const istream      & is)
+{
+    A_include_files.push_back(T_build_types_context_file(file_name, is));
+}
+
+void    build_types_context_include_file_close(const std::string  & file_name)
+{
+    if (A_include_files.empty())
+    {
+        M_FATAL_COMMENT("No opened include files specified.");
+    }
+    if (file_name != A_include_files.back().file_name)
+    {
+        M_FATAL_COMMENT("Closed include file does not match last opened include file");
+    }
+
+    A_include_files.pop_back();
+}
+
+void         build_types_context_line_new ()
+{
+    if (A_include_files.empty())
+    {
+        // It is possible
+        return;
+    }
+
+    A_include_files.back().file_line++;
+}
+void         build_types_context_line_new (const istream  & is)
+{
+    if (A_include_files.empty())
+    {
+        // It is possible
+        return;
+    }
+
+    if (A_include_files.back().P_is == &is)
+    {
+        A_include_files.back().file_line++;
+    }
+}
+
+string  build_types_context_include_file_where()
+{
+    string     result;
+
+    if (A_include_files.empty())
+    {
+        return  result;
+    }
+
+    result += "In file ";
+    result += A_include_files.back().file_name;
+
+    for (int   idx = static_cast<int>(A_include_files.size())-2; idx >= 0; --idx)
+    {
+        result += ",\n";
+        result += " included in file ";
+        result += A_include_files[idx].file_name;
+    }
+    result += " :\n";
+
+    if (A_include_files.back().file_line > 0)
+    {
+        result += "\n";
+        result += "At line " + get_string(A_include_files.back().file_line) + ".\n";
+    }
+
+    return  result;
+}
+
+//****************************************************************************
+// 
+//****************************************************************************
+
+void         build_types_context_reset()
+{
+    A_include_files.clear();
+}
+
+string    build_types_context_where()
+{
+    string     result;
+
+    if (A_include_files.empty())
+    {
+        // build_types not already started
+        return  result;
+    }
+
+    result += "In file ";
+    result += A_include_files.back().file_name;
+
+    for (int   idx = static_cast<int>(A_include_files.size())-2; idx >= 0; --idx)
+    {
+        result += ",\n";
+        result += " included in file ";
+        result += A_include_files[idx].file_name;
+    }
+    result += " :\n";
+    result += "\n";
+    result += build_types_context_type_where();
+
+    if (A_include_files.back().file_line > 0)
+    {
+        result += "At line " + get_string(A_include_files.back().file_line) + ".\n";
+    }
+
+    return  result;
+}
+
diff --git a/plugins/epan/generic/byte_interpret_build_types_context.h b/plugins/epan/generic/byte_interpret_build_types_context.h
new file mode 100644
index 00000000000..5fa2579b3d5
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_build_types_context.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef byte_interpret_build_types_context_h
+#define byte_interpret_build_types_context_h
+
+//****************************************************************************
+// Includes.
+//****************************************************************************
+
+#include <string>
+#include <iostream>
+
+
+//****************************************************************************
+// 
+//****************************************************************************
+
+void         build_types_context_reset();
+std::string  build_types_context_where();
+
+//****************************************************************************
+// files
+//****************************************************************************
+
+void         build_types_context_include_file_open (const std::string  & file_name,
+                                                    const istream      & is);
+void         build_types_context_include_file_open (const std::string  & file_name);
+void         build_types_context_include_file_close(const std::string  & file_name);
+
+//****************************************************************************
+// types
+//****************************************************************************
+
+void         build_types_context_type_kind_begin(const std::string  & type_kind);
+void         build_types_context_type_begin     (const std::string  & type_name);
+void         build_types_context_type_end       (const std::string  & type_name);
+void         build_types_context_type_kind_end  (const std::string  & type_kind);
+
+//****************************************************************************
+// lines
+//****************************************************************************
+
+void         build_types_context_line_new (const istream  & is);
+
+
+#endif /* byte_interpret_build_types_context_h */
diff --git a/plugins/epan/generic/byte_interpret_build_types_read_token.cpp b/plugins/epan/generic/byte_interpret_build_types_read_token.cpp
new file mode 100644
index 00000000000..5efbd1dccc0
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_build_types_read_token.cpp
@@ -0,0 +1,337 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+// Necessary for windows pre-compiled headers.
+// At the end, does NOT work : missing functions at link time
+// After other includes, does NOT work : does NOT compile (on "ifstream   ifs") 
+#include "precomp.h"
+
+#include <iostream>
+#include <string>
+using namespace std;
+
+#include "byte_interpret_parse.h"
+#include "byte_interpret_build_types_read_token.h"
+
+
+//*****************************************************************************
+// read_token_simple_word
+// - ignore comments
+// - ignore leading spaces
+// - manage ;
+//*****************************************************************************
+
+bool       read_token_simple_word (
+                            istream       & is,
+                            string        & str_result)
+{
+    str_result = "";
+
+    skip_blanks_and_comments(is);
+    if (is.good () == false)
+        return  false;
+
+    // ifstream unget/putback bug with VC++ 2003/2005/2008 :
+    //  the char is NOT unget (i.e. putback into the stream) and the badbit is set 
+    // The problem is NOT triggered by unget/putback
+    //  but by the previous read operation on 
+    //  a input string "<field_name>;"
+    //  which ends at position 4096 (8192, ...) of the input file.
+    // Microsoft says : conform to C++ standard
+    // NB: this code is better since it is able to manage "<field_name>;<another word>"
+    while (true)
+    {
+        const istream::int_type  peek_char = is.peek();
+        if (peek_char < 0)
+        {
+            break;
+        }
+//        if (isspace(peek_char) || iscntrl(peek_char))
+        if (isgraph(peek_char) == 0)
+        {
+            break;
+        }
+        if (peek_char == ';')
+        {
+            if (str_result.empty())
+            {
+                str_result.push_back(is.get());
+            }
+            break;
+        }
+
+        str_result.push_back(is.get());
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// read_token_key_word_specified
+// - read a key word
+// - fatal if != key_word_expected
+//*****************************************************************************
+
+void       read_token_key_word_specified (
+                            istream       & is,
+                      const string        & key_word_expected)
+{
+    string    str_result;
+
+    if (read_token_simple_word(is, str_result) == false)
+    {
+        M_FATAL_COMMENT("Expecting " << key_word_expected << " and found nothing (end of file)");
+    }
+
+    if (str_result != key_word_expected)
+    {
+        M_FATAL_COMMENT("Expecting " << key_word_expected << " and found " << str_result);
+    }
+}
+
+//*****************************************************************************
+// read_token_key_word_specified
+// - read a key word
+// - fatal if != one of the key_word_expected
+//*****************************************************************************
+
+void       read_token_key_word_specified (
+                            istream       & is,
+                            string        & str_result,
+                      const string        & key_word_expected_1,
+                      const string        & key_word_expected_2)
+{
+    if (read_token_simple_word(is, str_result) == false)
+    {
+        M_FATAL_COMMENT("Expecting " << key_word_expected_1 <<
+            " or " << key_word_expected_2 << " and found nothing (end of file)");
+    }
+
+    if ((str_result != key_word_expected_1) &&
+        (str_result != key_word_expected_2))
+    {
+        M_FATAL_COMMENT("Expecting " << key_word_expected_1 <<
+            " or " << key_word_expected_2 << " and found " << str_result);
+    }
+}
+
+//*****************************************************************************
+// read_token_key_word_specified
+// - read a key word
+// - fatal if != one of the key_word_expected
+//*****************************************************************************
+
+void       read_token_key_word_specified (
+                            istream       & is,
+                            string        & str_result,
+                      const string        & key_word_expected_1,
+                      const string        & key_word_expected_2,
+                      const string        & key_word_expected_3)
+{
+    if (read_token_simple_word(is, str_result) == false)
+    {
+        M_FATAL_COMMENT("Expecting " << key_word_expected_1 <<
+            " or " << key_word_expected_2 <<
+            " or " << key_word_expected_3 << " and found nothing (end of file)");
+    }
+
+    if ((str_result != key_word_expected_1) &&
+        (str_result != key_word_expected_2) &&
+        (str_result != key_word_expected_3))
+    {
+        M_FATAL_COMMENT("Expecting " << key_word_expected_1 <<
+            " or " << key_word_expected_2 <<
+            " or " << key_word_expected_3 << " and found " << str_result);
+    }
+}
+
+//*****************************************************************************
+// read_token_end_of_statement
+//*****************************************************************************
+
+void       read_token_end_of_statement (
+                            istream       & is)
+{
+    read_token_key_word_specified(is, ";");
+}
+
+//*****************************************************************************
+// read_token_simple_word_check_unexpected
+//*****************************************************************************
+
+bool       read_token_simple_word_check_unexpected (
+                            istream       & is,
+                            string        & str_result,
+                      const char          * P_unexpected_char)
+{
+    if (read_token_simple_word(is, str_result) == false)
+        return  false;
+
+    if (P_unexpected_char != nullptr)
+    {
+        if (strpbrk(str_result.c_str(), P_unexpected_char) != nullptr)
+        {
+            M_TRACE_ERROR("read_token_simple_word unexpected character into " << str_result);
+            return  false;
+        }
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// read_token_type_simple
+//*****************************************************************************
+
+bool       read_token_type_simple (
+                            istream       & is,
+                            string        & str_result)
+{
+    return  read_token_simple_word_check_unexpected(is, str_result, "{}()[]<>\"';");
+}
+
+//*****************************************************************************
+// read_token_key_word
+//*****************************************************************************
+
+bool       read_token_key_word (
+                            istream       & is,
+                            string        & str_result)
+{
+    if (read_token_simple_word_check_unexpected(is, str_result, "}()[]<>\"';") == false)
+        return  false;
+
+    if (str_result == "{")
+        return  true;
+
+    if (strchr(str_result.c_str(), '{') != nullptr)
+    {
+        M_TRACE_ERROR("read_token_simple_word unexpected character into " << str_result);
+        return  false;
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// read_token_simple_word_or_string
+//*****************************************************************************
+// a simple word or "..." or '...'
+extern
+bool    is_str_limit (const char   c);
+
+bool       read_token_simple_word_or_string (
+                            istream       & is,
+                            string        & str_result)
+{
+    str_result = "";
+
+    skip_blanks_and_comments(is);
+    if (is.good () == false)
+        return  false;
+
+    if (is_str_limit(is.peek ()))
+    {
+        return  read_token_word_cplx(is, str_result);
+    }
+
+    return  read_token_simple_word(is, str_result);
+}
+
+//*****************************************************************************
+// read_token_function_name
+// Accept "" and nil.
+//*****************************************************************************
+
+bool       read_token_function_name (
+                            istream       & is,
+                            string        & str_result)
+{
+    bool    result = read_token_simple_word(is, str_result);
+    if (result == true)
+    {
+        if (str_result == "\"\"")
+        {
+            str_result = "";
+        }
+        else if (str_result == "nil")
+        {
+            str_result = "";
+        }
+    }
+
+    return  result;
+}
+
+//*****************************************************************************
+// read_token_field_name
+// Accept "".
+//*****************************************************************************
+
+bool       read_token_field_name (
+                            istream       & is,
+                            string        & str_result)
+{
+//    bool    result = read_token_simple_word(is, str_result);   // NOT ok on ID{ext=a c};  or   ID{ext="a c"};
+//    bool    result = read_token_type_complex(is, str_result);  // NOT ok on ID{ext=a c};  or   ID{ext="a c"};
+    bool    result = read_token_left_any(is, str_result);
+    
+    if (result == true)
+    {
+        if (str_result == "\"\"")
+        {
+            str_result = "";
+        }
+    }
+
+    return  result;
+}
+
+//*****************************************************************************
+// read_token_parameters_vector
+//*****************************************************************************
+
+bool   read_token_parameters_vector(istream               & is,
+                                    vector<string>        & fct_parameters_vector,
+                                    const E_parser_cfg      parser_cfg)
+{
+    string    fct_parameters;
+    bool      ret = read_token_parameters(is, fct_parameters, parser_cfg);
+
+    if (ret == true)
+    {
+        if ((fct_parameters[0] != '(') ||
+            (fct_parameters[fct_parameters.size() - 1] != ')'))
+        {
+            M_FATAL_COMMENT("Expecting ( and ) for function parameters " << fct_parameters);
+        }
+
+        // Remove ( and ).
+        fct_parameters.erase(0, 1);
+        fct_parameters.erase(fct_parameters.size() - 1);
+
+        // Split on ,.
+        string_to_words(fct_parameters, fct_parameters_vector, K_parser_cfg_parameters);
+    }
+
+    return ret;
+}
diff --git a/plugins/epan/generic/byte_interpret_build_types_read_token.h b/plugins/epan/generic/byte_interpret_build_types_read_token.h
new file mode 100644
index 00000000000..29cf9ca2dd5
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_build_types_read_token.h
@@ -0,0 +1,187 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef BYTE_INTERPRET_BUILD_TYPES_READ_TOKEN_H
+#define BYTE_INTERPRET_BUILD_TYPES_READ_TOKEN_H
+
+//****************************************************************************
+// Includes.
+//****************************************************************************
+
+#include <string>
+#include <iostream>
+
+using namespace std;
+
+
+//*****************************************************************************
+// read_token_simple_word
+// - ignore comments
+// - ignore leading spaces
+// - manage ;
+//*****************************************************************************
+
+bool       read_token_simple_word (
+                            istream       & is,
+                            string        & str_result);
+
+//*****************************************************************************
+// read_token_end_of_statement
+// - read ;
+//*****************************************************************************
+
+void       read_token_end_of_statement (
+                            istream       & is);
+
+//*****************************************************************************
+// read_token_simple_word_check_unexpected
+// - read a simple word
+// - check non existence of unexpected specified char
+//*****************************************************************************
+
+bool       read_token_simple_word_check_unexpected (
+                            istream       & is,
+                            string        & str_result,
+                      const char          * P_unexpected_char);
+
+//*****************************************************************************
+// read_token_type_simple
+// - read simple type (ie without {}()[] ...)
+//*****************************************************************************
+
+bool       read_token_type_simple (
+                            istream       & is,
+                            string        & str_result);
+
+//*****************************************************************************
+// read_token_xxx
+// simple_word which could be followed by (expression) {expression} [expression] 
+// Ne doit pas commencer par l'un des caracteres speciaux
+//*****************************************************************************
+
+#define read_token_type_complex  read_token_word_cplx
+
+//*****************************************************************************
+// read_token_key_word
+// - read a key word (if, set ...)
+// - reject {}()[] ...   except "{"
+//*****************************************************************************
+
+bool       read_token_key_word (
+                            istream       & is,
+                            string        & str_result);
+
+//*****************************************************************************
+// read_token_key_word_specified
+// - read a key word
+// - fatal if != key_word_expected
+//*****************************************************************************
+
+void       read_token_key_word_specified (
+                            istream       & is,
+                      const string        & key_word_expected);
+
+//*****************************************************************************
+// read_token_key_word_specified
+// - read a key word
+// - fatal if != one of the key_word_expected
+//*****************************************************************************
+
+void       read_token_key_word_specified (
+                            istream       & is,
+                            string        & str_result,
+                      const string        & key_word_expected_1,
+                      const string        & key_word_expected_2);
+void       read_token_key_word_specified (
+                            istream       & is,
+                            string        & str_result,
+                      const string        & key_word_expected_1,
+                      const string        & key_word_expected_2,
+                      const string        & key_word_expected_3);
+
+//*****************************************************************************
+// read_token_simple_word_or_string
+// a simple word or "..." or '...'
+//*****************************************************************************
+
+bool       read_token_simple_word_or_string (
+                            istream       & is,
+                            string        & str_result);
+
+//*****************************************************************************
+// read_token_xxx
+//*****************************************************************************
+
+// ICIOA pas fini, pas clair
+
+
+#define read_token_left_any      read_token_type_complex
+
+// right
+// take care of : (simple word or "..." or '...' or expression)
+// idem read_token_type_complex sauf que ca peut commencer par (
+
+// var_str_array[var_idx+1] + " et quelques ...";
+// ->
+// var_str_array[var_idx+1] + 
+//#define read_token_expression_any(P1,P2)    read_token_word_cplx(P1,P2,K_parser_cfg_expression)
+#define read_token_expression_any(P1,P2)    read_token_word_cplx(P1,P2,E_parser_cfg_parameters)
+
+// (...)
+#define read_token_expression_parenthesis    read_token_word_cplx
+
+// (...)
+#define read_token_parameters    read_token_word_cplx
+
+#define read_token_right_any     read_token_simple_word_or_string
+
+#define read_token_include_name      read_token_simple_word_or_string
+#define read_token_case_value        read_token_simple_word_or_string
+#define read_token_enum_value        read_token_simple_word_or_string
+#define read_token_enum_symbolic     read_token_left_any
+
+//*****************************************************************************
+// read_token_parameters_vector
+// (param1, ..., paramN)
+//*****************************************************************************
+
+bool   read_token_parameters_vector(istream               & is,
+                                    vector<string>        & fct_parameters_vector,
+                                    const E_parser_cfg      parser_cfg = K_parser_cfg_normal);
+
+//*****************************************************************************
+// read_token_function_name
+// Accept "" and nil.
+//*****************************************************************************
+
+bool       read_token_function_name (
+                            istream       & is,
+                            string        & str_result);
+
+//*****************************************************************************
+// read_token_field_name
+// Accept "".
+//*****************************************************************************
+
+bool       read_token_field_name (
+                            istream       & is,
+                            string        & str_result);
+
+
+
+#endif /* BYTE_INTERPRET_BUILD_TYPES_READ_TOKEN_H */
diff --git a/plugins/epan/generic/byte_interpret_builder.cpp b/plugins/epan/generic/byte_interpret_builder.cpp
new file mode 100644
index 00000000000..334b1fed322
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_builder.cpp
@@ -0,0 +1,550 @@
+/*
+ * Copyright 2008-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "byte_interpret_builder.h"
+#include "byte_interpret.h"                 // is_a_raw_field ...
+
+#include "C_byte_interpret_builder.h"
+
+
+
+//*****************************************************************************
+// The builder.
+//*****************************************************************************
+
+static C_byte_interpret_builder  * S_P_builder = nullptr;    // recursive call ok
+
+
+//*****************************************************************************
+// C_interpret_builder_set_temporary
+//*****************************************************************************
+
+C_interpret_builder_set_temporary::C_interpret_builder_set_temporary(C_byte_interpret_builder  * P_builder)
+    :previous_value(S_P_builder),
+     value_modified(false)
+{
+    set(P_builder);
+}
+
+C_interpret_builder_set_temporary::~C_interpret_builder_set_temporary()
+{
+    unset();
+}
+
+void
+C_interpret_builder_set_temporary::set(C_byte_interpret_builder  * P_builder)
+{
+    S_P_builder = P_builder;
+    value_modified = true;
+}
+void
+C_interpret_builder_set_temporary::unset()
+{
+    if (value_modified)
+    {
+        S_P_builder = previous_value;
+        value_modified = false;
+    }
+}
+void
+C_interpret_builder_set_temporary::forget()
+{
+    value_modified = false;
+}
+
+
+//*****************************************************************************
+// M_TRACE_CHECK
+//*****************************************************************************
+
+#if 1
+#define M_TRACE_CHECK()
+#else
+#define M_TRACE_CHECK()                                                     \
+{                                                                           \
+    if (data_simple_name != field_type_name.name)                           \
+    {                                                                       \
+        M_TRACE_INFO("data_simple_name(" << data_simple_name << ") != field_type_name.name(" << field_type_name.name << ")");  \
+    }                                                                       \
+}
+#endif
+
+//*****************************************************************************
+// interpret_builder_begin
+//*****************************************************************************
+
+void    interpret_builder_begin(const T_type_definitions  & type_definitions)
+{
+    if (type_definitions.vector_plugin_output_definition.empty() == false)
+    {
+        // Call all plugin_ouput
+        for (T_vector_plugin_output_definition::const_iterator
+                iter  = type_definitions.vector_plugin_output_definition.begin();
+                iter != type_definitions.vector_plugin_output_definition.end();
+              ++iter)
+        {
+            const T_plugin_output_definition  & plugin = *iter;
+
+            if (plugin.byte_interpret_plugin_output_begin_cb != nullptr)
+            {
+                (*plugin.byte_interpret_plugin_output_begin_cb)(
+                    nullptr);
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+// interpret_builder_value
+//*****************************************************************************
+
+void    interpret_builder_value(    const T_type_definitions  & type_definitions,
+                                    const T_frame_data        & in_out_frame_data,
+                                    const T_field_type_name   & field_type_name,
+                                    const string              & data_name,
+                                    const string              & data_simple_name,
+                                    const T_attribute_value   & attribute_value,
+                                    const string              & data_value,
+                                    const string              & final_type,
+                                    const int                   type_bit_size,
+                                    const bool                  is_little_endian,
+                                    const bool                  error)
+{
+    M_TRACE_CHECK();
+
+    if (S_P_builder != nullptr)
+    {
+        S_P_builder->value (type_definitions, in_out_frame_data,
+                             field_type_name, data_name, data_simple_name,
+                             attribute_value, data_value,
+                             final_type, type_bit_size,
+                             is_little_endian,
+                             error);
+    }
+
+    if (type_definitions.vector_plugin_output_definition.empty() == false)
+    {
+        const char  * P_error = nullptr;
+        if (attribute_value.has_error())
+        {
+            P_error = attribute_value.get_P_error()->c_str();
+        }
+        
+        for (T_vector_plugin_output_definition::const_iterator
+                iter  = type_definitions.vector_plugin_output_definition.begin();
+                iter != type_definitions.vector_plugin_output_definition.end();
+              ++iter)
+        {
+            const T_plugin_output_definition  & plugin = *iter;
+
+            if (attribute_value.get_value().get_type() == C_value::E_type_float)
+            {
+                if (plugin.byte_interpret_plugin_output_value_float_cb != nullptr)
+                {
+                    M_TRACE_ENTER ("byte_interpret_plugin_output_value_float_cb", "");
+                    (*plugin.byte_interpret_plugin_output_value_float_cb)(
+                        nullptr,
+                        nullptr,
+                        field_type_name.type.c_str(),
+                        data_name.c_str(),
+                        field_type_name.name.c_str(),
+                        final_type.c_str(),
+                        attribute_value.get_value().get_flt(),
+                        attribute_value.get_value().as_string().c_str(),
+                        P_error);
+                }
+            }
+            else if (attribute_value.get_value().get_type() == C_value::E_type_integer)
+            {
+                if (plugin.byte_interpret_plugin_output_value_integer_cb != nullptr)
+                {
+                    M_TRACE_ENTER ("byte_interpret_plugin_output_value_integer_cb", "");
+                    (*plugin.byte_interpret_plugin_output_value_integer_cb)(
+                        nullptr,
+                        nullptr,
+                        field_type_name.type.c_str(),
+                        data_name.c_str(),
+                        field_type_name.name.c_str(),
+                        final_type.c_str(),
+                        attribute_value.get_value().get_int(),
+                        attribute_value.get_value().as_string().c_str(),
+                        P_error);
+                }
+            }
+            else if (attribute_value.get_value().get_type() == C_value::E_type_string)
+            {
+                if (plugin.byte_interpret_plugin_output_value_string_cb != nullptr)
+                {
+                    M_TRACE_ENTER ("byte_interpret_plugin_output_value_string_cb", "");
+                    (*plugin.byte_interpret_plugin_output_value_string_cb)(
+                        nullptr,
+                        nullptr,
+                        field_type_name.type.c_str(),
+                        data_name.c_str(),
+                        field_type_name.name.c_str(),
+                        final_type.c_str(),
+                        attribute_value.get_value().get_str().c_str(),
+                        attribute_value.get_value().as_string().c_str(),
+                        P_error);
+                }
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+// interpret_builder_raw_data
+//*****************************************************************************
+
+void    interpret_builder_raw_data( const T_type_definitions  & type_definitions,
+                                    const T_frame_data        & in_out_frame_data,
+                                    const T_interpret_data    & interpret_data,
+                                    const T_field_type_name   & field_type_name,
+                                    const string              & data_name,
+                                    const string              & data_simple_name,
+                                    const int                   type_bit_size,
+                                    const E_raw_data_type       raw_data_type,
+                                    const bool                  is_decoded_data)
+{
+    M_TRACE_CHECK();
+
+    if (S_P_builder != nullptr)
+    {
+        S_P_builder->raw_data (type_definitions, in_out_frame_data, interpret_data,
+                              field_type_name, data_name, data_simple_name,
+                              type_bit_size,
+                              raw_data_type,
+                              is_decoded_data);
+    }
+
+    if (type_definitions.vector_plugin_output_definition.empty() == false)
+    {
+        // Call all plugin_ouput
+        for (T_vector_plugin_output_definition::const_iterator
+                iter  = type_definitions.vector_plugin_output_definition.begin();
+                iter != type_definitions.vector_plugin_output_definition.end();
+              ++iter)
+        {
+            const T_plugin_output_definition  & plugin = *iter;
+
+            if (plugin.byte_interpret_plugin_output_raw_data_cb != nullptr)
+            {
+                (*plugin.byte_interpret_plugin_output_raw_data_cb)(
+                        nullptr,
+                        nullptr,
+                        field_type_name.type.c_str(),
+                        data_name.c_str(),
+                        field_type_name.name.c_str(),
+                        type_bit_size);
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+// interpret_builder_group_begin
+//*****************************************************************************
+
+void    interpret_builder_group_begin(const T_type_definitions  & type_definitions,
+                                      const T_frame_data        & in_out_frame_data,
+                                      const T_field_type_name   & field_type_name,
+                                      const string              & data_name,
+                                      const string              & data_simple_name)
+{
+    M_TRACE_CHECK();
+
+    if (S_P_builder != nullptr)
+    {
+        S_P_builder->group_begin (type_definitions, in_out_frame_data,
+                                  field_type_name, data_name, data_simple_name);
+    }
+
+    if (type_definitions.vector_plugin_output_definition.empty() == false)
+    {
+        // Call all plugin_ouput
+        for (T_vector_plugin_output_definition::const_iterator
+                iter  = type_definitions.vector_plugin_output_definition.begin();
+                iter != type_definitions.vector_plugin_output_definition.end();
+              ++iter)
+        {
+            const T_plugin_output_definition  & plugin = *iter;
+
+            if (plugin.byte_interpret_plugin_output_group_begin_cb != nullptr)
+            {
+                (*plugin.byte_interpret_plugin_output_group_begin_cb)(
+                    nullptr,
+                    nullptr,
+                    field_type_name.type.c_str(),
+                    data_name.c_str(),
+                    field_type_name.name.c_str());
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+// interpret_builder_group_append_text
+//*****************************************************************************
+
+void    interpret_builder_group_append_text(const T_type_definitions  & type_definitions,
+                                            const T_frame_data        & in_out_frame_data,
+                                            const string              & data_name,
+                                            const string              & data_simple_name,
+                                            const string              & text)
+{
+    if (S_P_builder != nullptr)
+    {
+        S_P_builder->group_append_text (type_definitions, in_out_frame_data,
+                                        data_name, data_simple_name, text);
+    }
+
+    if (type_definitions.vector_plugin_output_definition.empty() == false)
+    {
+        // Call all plugin_ouput
+        for (T_vector_plugin_output_definition::const_iterator
+                iter  = type_definitions.vector_plugin_output_definition.begin();
+                iter != type_definitions.vector_plugin_output_definition.end();
+              ++iter)
+        {
+            const T_plugin_output_definition  & plugin = *iter;
+
+            if (plugin.byte_interpret_plugin_output_group_append_text_cb != nullptr)
+            {
+                (*plugin.byte_interpret_plugin_output_group_append_text_cb)(
+                    nullptr,
+                    nullptr,
+                    data_name.c_str(),
+                    data_simple_name.c_str(),
+                    text.c_str());
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+// interpret_builder_group_end
+//*****************************************************************************
+
+void    interpret_builder_group_end(const T_type_definitions  & type_definitions,
+                                       const T_frame_data        & in_out_frame_data,
+                                       const T_field_type_name   & field_type_name,
+                                       const string              & data_name,
+                                       const string              & data_simple_name,
+                                       const int                   type_bit_size)
+{
+    M_TRACE_CHECK();
+
+    if (S_P_builder != nullptr)
+    {
+        S_P_builder->group_end (type_definitions, in_out_frame_data,
+                             field_type_name, data_name, data_simple_name, type_bit_size);
+    }
+
+    if (type_definitions.vector_plugin_output_definition.empty() == false)
+    {
+        // Call all plugin_ouput
+        for (T_vector_plugin_output_definition::const_iterator
+                iter  = type_definitions.vector_plugin_output_definition.begin();
+                iter != type_definitions.vector_plugin_output_definition.end();
+              ++iter)
+        {
+            const T_plugin_output_definition  & plugin = *iter;
+
+            if (plugin.byte_interpret_plugin_output_group_end_cb != nullptr)
+            {
+                (*plugin.byte_interpret_plugin_output_group_end_cb)(
+                    nullptr,
+                    nullptr,
+                    field_type_name.type.c_str(),
+                    data_name.c_str(),
+                    field_type_name.name.c_str());
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+// interpret_builder_error
+//*****************************************************************************
+
+void    interpret_builder_error    (const T_type_definitions  & type_definitions,
+                                    const T_frame_data        & in_out_frame_data,
+                                    const T_field_type_name   & field_type_name,
+                                    const string              & data_name,
+                                    const string              & data_simple_name,
+                                    const string              & error)
+{
+    M_TRACE_CHECK();
+
+    if (S_P_builder != nullptr)
+    {
+        S_P_builder->error (type_definitions, in_out_frame_data,
+                            field_type_name, data_name, data_simple_name,
+                            error);
+    }
+
+    if (type_definitions.vector_plugin_output_definition.empty() == false)
+    {
+        // Call all plugin_ouput
+        for (T_vector_plugin_output_definition::const_iterator
+                iter  = type_definitions.vector_plugin_output_definition.begin();
+                iter != type_definitions.vector_plugin_output_definition.end();
+              ++iter)
+        {
+            const T_plugin_output_definition  & plugin = *iter;
+
+            if (plugin.byte_interpret_plugin_output_error_cb != nullptr)
+            {
+                (*plugin.byte_interpret_plugin_output_error_cb)(
+                    nullptr,
+                    nullptr,
+                    data_name.c_str(),
+                    field_type_name.name.c_str(),
+                    error.c_str());
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+// interpret_builder_missing_data
+//*****************************************************************************
+
+void    interpret_builder_missing_data( const T_type_definitions  & type_definitions,
+                                        const T_frame_data        & in_out_frame_data,
+                                        const T_interpret_data    & interpret_data,
+                                        const T_field_type_name   & field_type_name,
+                                        const string              & data_name,
+                                        const string              & data_simple_name,
+                                        const string              & error)
+{
+    M_TRACE_CHECK();
+
+    if (S_P_builder != nullptr)
+    {
+        S_P_builder->missing_data (type_definitions, in_out_frame_data, interpret_data,
+                            field_type_name, data_name, data_simple_name,
+                            error);
+    }
+
+    if (type_definitions.vector_plugin_output_definition.empty() == false)
+    {
+        // Call all plugin_ouput
+        for (T_vector_plugin_output_definition::const_iterator
+                iter  = type_definitions.vector_plugin_output_definition.begin();
+                iter != type_definitions.vector_plugin_output_definition.end();
+              ++iter)
+        {
+            const T_plugin_output_definition  & plugin = *iter;
+
+            if (plugin.byte_interpret_plugin_output_missing_data_cb != nullptr)
+            {
+                (*plugin.byte_interpret_plugin_output_missing_data_cb)(
+                    nullptr,
+                    nullptr,
+                    field_type_name.type.c_str(),
+                    data_name.c_str(),
+                    field_type_name.name.c_str(),
+                    error.c_str());
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+// interpret_builder_cmd_error
+//*****************************************************************************
+
+void    interpret_builder_cmd_error(const T_type_definitions  & type_definitions,
+                                    const T_frame_data        & in_out_frame_data,
+                                    const T_field_type_name   & field_type_name,
+                                    const string              & data_name,
+                                    const string              & text_to_print)
+{
+    if (S_P_builder != nullptr)
+    {
+        S_P_builder->cmd_error (type_definitions, in_out_frame_data,
+                             field_type_name, data_name, text_to_print);
+    }
+
+    if (type_definitions.vector_plugin_output_definition.empty() == false)
+    {
+        // Call all plugin_ouput
+        for (T_vector_plugin_output_definition::const_iterator
+                iter  = type_definitions.vector_plugin_output_definition.begin();
+                iter != type_definitions.vector_plugin_output_definition.end();
+              ++iter)
+        {
+            const T_plugin_output_definition  & plugin = *iter;
+
+            if (plugin.byte_interpret_plugin_output_cmd_error_cb != nullptr)
+            {
+                (*plugin.byte_interpret_plugin_output_cmd_error_cb)(
+                    nullptr,
+                    nullptr,
+                    data_name.c_str(),
+                    field_type_name.name.c_str(),
+                    text_to_print.c_str());
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+// interpret_builder_cmd_print ************************************************
+//*****************************************************************************
+
+void    interpret_builder_cmd_print(const T_type_definitions  & type_definitions,
+                                    const T_frame_data        & in_out_frame_data,
+                                    const T_field_type_name   & field_type_name,
+                                    const string              & data_name,
+                                    const string              & text_to_print)
+{
+    if (S_P_builder != nullptr)
+    {
+        S_P_builder->cmd_print (type_definitions, in_out_frame_data,
+                                field_type_name, data_name, text_to_print);
+    }
+
+    if (type_definitions.vector_plugin_output_definition.empty() == false)
+    {
+        // Call all plugin_ouput
+        for (T_vector_plugin_output_definition::const_iterator
+                iter  = type_definitions.vector_plugin_output_definition.begin();
+                iter != type_definitions.vector_plugin_output_definition.end();
+              ++iter)
+        {
+            const T_plugin_output_definition  & plugin = *iter;
+
+            if (plugin.byte_interpret_plugin_output_cmd_print_cb != nullptr)
+            {
+                (*plugin.byte_interpret_plugin_output_cmd_print_cb)(
+                    nullptr,
+                    nullptr,
+                    data_name.c_str(),
+                    field_type_name.name.c_str(),
+                    text_to_print.c_str());
+            }
+        }
+    }
+}
diff --git a/plugins/epan/generic/byte_interpret_builder.h b/plugins/epan/generic/byte_interpret_builder.h
new file mode 100644
index 00000000000..c6694f3c8dd
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_builder.h
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2008-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef BYTE_INTERPRET_BUILDER_H
+#define BYTE_INTERPRET_BUILDER_H
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "byte_interpret_common.h"
+#include "byte_interpret_build_types.h"
+#include "T_frame_data.h"
+#include "T_attribute_value.h"
+#include "T_interpret_data.h"
+
+
+class C_byte_interpret_builder;
+
+
+//*****************************************************************************
+// interpret_builder_set_builder **********************************************
+//*****************************************************************************
+
+// void    interpret_builder_set_builder(C_byte_interpret_builder  * P_builder);
+
+//*****************************************************************************
+// Permits recursive call of generic dissector.
+// Mandatory for subdissector and inside dissector.
+//*****************************************************************************
+
+class C_interpret_builder_set_temporary
+{
+public:
+    C_interpret_builder_set_temporary(C_byte_interpret_builder  * P_builder);
+    ~C_interpret_builder_set_temporary();
+
+    void    set(C_byte_interpret_builder  * P_builder);
+    void    unset();
+    void    forget();
+
+private:
+    C_interpret_builder_set_temporary(const C_interpret_builder_set_temporary  &);
+
+    C_byte_interpret_builder  * previous_value;
+    bool                        value_modified;
+};
+
+
+//*****************************************************************************
+// interpret_builder_begin
+//*****************************************************************************
+
+void    interpret_builder_begin(const T_type_definitions  & type_definitions);
+
+//*****************************************************************************
+// interpret_builder_value
+//*****************************************************************************
+
+void    interpret_builder_value(const T_type_definitions  & type_definitions,
+                                const T_frame_data        & in_out_frame_data,
+                                const T_field_type_name   & field_type_name,
+                                const string              & data_name,
+                                const string              & data_simple_name,
+                                const T_attribute_value   & attribute_value,
+                                const string              & data_value,
+                                const string              & final_type,
+                                const int                   type_bit_size,
+                                const bool                  is_little_endian,
+                                const bool                  error);
+
+//*****************************************************************************
+// interpret_builder_raw_data
+//*****************************************************************************
+
+enum E_raw_data_type
+{
+    E_raw_data_any,
+    E_raw_data_sub_proto,
+    E_raw_data_ins_proto
+};
+void    interpret_builder_raw_data(const T_type_definitions  & type_definitions,
+                                   const T_frame_data        & in_out_frame_data,
+                                   const T_interpret_data    & interpret_data,
+                                   const T_field_type_name   & field_type_name,
+                                   const string              & data_name,
+                                   const string              & data_simple_name,
+                                   const int                   type_bit_size,
+                                   const E_raw_data_type       raw_data_type,
+                                   const bool                  is_decoded_data);
+
+//*****************************************************************************
+// interpret_builder_group_begin **********************************************
+//*****************************************************************************
+
+void    interpret_builder_group_begin(const T_type_definitions  & type_definitions,
+                                      const T_frame_data        & in_out_frame_data,
+                                      const T_field_type_name   & field_type_name,
+                                      const string              & data_name,
+                                      const string              & data_simple_name);
+
+//*****************************************************************************
+// interpret_builder_group_append_text ****************************************
+//*****************************************************************************
+
+void    interpret_builder_group_append_text(const T_type_definitions  & type_definitions,
+                                            const T_frame_data        & in_out_frame_data,
+//                                            const T_field_type_name   & field_type_name,
+                                            const string              & data_name,
+                                            const string              & data_simple_name,
+                                            const string              & text);
+
+//*****************************************************************************
+// interpret_builder_group_end ************************************************
+//*****************************************************************************
+
+void    interpret_builder_group_end(const T_type_definitions  & type_definitions,
+                                    const T_frame_data        & in_out_frame_data,
+                                    const T_field_type_name   & field_type_name,
+                                    const string              & data_name,
+                                    const string              & data_simple_name,
+                                    const int                   type_bit_size);
+
+//*****************************************************************************
+// interpret_builder_error ****************************************************
+//*****************************************************************************
+
+void    interpret_builder_error    (const T_type_definitions  & type_definitions,
+                                    const T_frame_data        & in_out_frame_data,
+                                    const T_field_type_name   & field_type_name,
+                                    const string              & data_name,
+                                    const string              & data_simple_name,
+                                    const string              & error);
+
+#define interpret_builder_fatal    interpret_builder_error
+
+//*****************************************************************************
+// interpret_builder_missing_data *********************************************
+//*****************************************************************************
+
+void    interpret_builder_missing_data
+                                   (const T_type_definitions  & type_definitions,
+                                    const T_frame_data        & in_out_frame_data,
+                                    const T_interpret_data    & interpret_data,
+                                    const T_field_type_name   & field_type_name,
+                                    const string              & data_name,
+                                    const string              & data_simple_name,
+                                    const string              & error);
+
+//*****************************************************************************
+// interpret_builder_cmd_error ************************************************
+//*****************************************************************************
+
+void    interpret_builder_cmd_error(const T_type_definitions  & type_definitions,
+                                    const T_frame_data        & in_out_frame_data,
+                                    const T_field_type_name   & field_type_name,
+                                    const string              & data_name,
+                                    const string              & text_to_print);
+
+//*****************************************************************************
+// interpret_builder_cmd_fatal
+//*****************************************************************************
+
+#define interpret_builder_cmd_fatal    interpret_builder_cmd_error
+
+//*****************************************************************************
+// interpret_builder_cmd_print ************************************************
+//*****************************************************************************
+
+void    interpret_builder_cmd_print(const T_type_definitions  & type_definitions,
+                                    const T_frame_data        & in_out_frame_data,
+                                    const T_field_type_name   & field_type_name,
+                                    const string              & data_name,
+                                    const string              & text_to_print);
+
+//*****************************************************************************
+// T_interpret_builder_cmd_print_cb *******************************************
+//*****************************************************************************
+
+typedef void  (* T_interpret_builder_cmd_print_cb)(
+                                    const T_type_definitions  & type_definitions,
+                                    const T_frame_data        & in_out_frame_data,
+                                    const T_field_type_name   & field_type_name,
+                                    const string              & data_name,
+                                    const string              & text_to_print);
+
+
+#endif /* BYTE_INTERPRET_BUILDER_H */
diff --git a/plugins/epan/generic/byte_interpret_common.cpp b/plugins/epan/generic/byte_interpret_common.cpp
new file mode 100644
index 00000000000..da810ce2c1f
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_common.cpp
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+// ****************************************************************************
+// Includes.
+// ****************************************************************************
+
+#include "precomp.h"
+#include "byte_interpret_common.h"
diff --git a/plugins/epan/generic/byte_interpret_common.h b/plugins/epan/generic/byte_interpret_common.h
new file mode 100644
index 00000000000..801af9aa48d
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_common.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#pragma once
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+
+#include "byte_interpret_common_base.h"
+#include "byte_interpret_common_exception.h"
+#include "byte_interpret_common_fatal.h"
+#include "byte_interpret_common_trace.h"
+
diff --git a/plugins/epan/generic/byte_interpret_common_base.cpp b/plugins/epan/generic/byte_interpret_common_base.cpp
new file mode 100644
index 00000000000..e3451625c6b
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_common_base.cpp
@@ -0,0 +1,136 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+// ****************************************************************************
+// Includes.
+// ****************************************************************************
+
+#include "precomp.h"
+#include "byte_interpret_common.h"
+
+#include <iostream>
+#include <vector>
+#include <cstdio>
+
+
+//****************************************************************************
+// ostream << nullptr
+//****************************************************************************
+std::ostream& operator << (std::ostream& os, std::nullptr_t)
+{
+    return os << "nullptr";
+}
+
+//*****************************************************************************
+// get_files_in_dir ***********************************************************
+//*****************************************************************************
+#ifdef WIN32
+#include <windows.h>
+#else
+#include <dirent.h>
+#endif
+
+int   get_files_in_dir (const string          & dir_name,
+                        const string          & begin_file_name,
+                        const string          & end_file_name,
+                              vector<string>  & file_names,
+                        const bool              full_name_required)
+{
+    M_TRACE_ENTER("get_files_in_dir",
+        "dir_name=" << dir_name <<
+        "  begin_file_name=" << begin_file_name <<
+        "  end_file_name=" << end_file_name);
+
+#ifdef WIN32
+
+    const string     filter = dir_name + "\\" + begin_file_name + "*" + end_file_name;
+
+    WIN32_FIND_DATAA FindData;
+    HANDLE           hFindFile = FindFirstFileA(filter.c_str(), &FindData);
+    if (hFindFile == INVALID_HANDLE_VALUE)
+    {
+        M_TRACE_ERROR("filter " << filter << " not found");
+        return  -1;
+    }
+
+    BOOL hOK = (hFindFile != INVALID_HANDLE_VALUE);
+    while (hOK)
+    {
+        if ((full_name_required) && (dir_name != ""))
+            file_names.push_back(dir_name + "\\" + FindData.cFileName);
+        else
+            file_names.push_back(FindData.cFileName);
+
+        //-------------------------------------------------------
+        // Recherche du fichier suivant
+        //-------------------------------------------------------
+        hOK = FindNextFileA(hFindFile, &FindData);
+    }
+
+    FindClose(hFindFile);
+
+#else
+
+    const size_t  begin_file_name_length = begin_file_name.size();
+    const size_t    end_file_name_length = end_file_name.size();
+
+    DIR  * dir = opendir(dir_name.c_str());
+
+    if (dir == nullptr)
+    {
+        M_TRACE_ERROR("dir " << dir_name << " not found");
+        return  -1;
+    }
+
+    for (struct dirent * dp  = readdir(dir);
+                         dp != nullptr;
+                         dp  = readdir(dir))
+    {
+#ifdef __linux__
+        const size_t    d_namlen = strlen(dp->d_name);
+#else
+        const size_t    d_namlen = dp->d_namlen;
+#endif
+
+        if (d_namlen <= (begin_file_name_length + end_file_name_length))
+            continue;
+
+        if (strncmp(dp->d_name,
+            begin_file_name.c_str(),
+            begin_file_name_length) != 0)
+            continue;
+
+        if (strncmp(dp->d_name + d_namlen - end_file_name_length,
+            end_file_name.c_str(),
+            end_file_name_length) != 0)
+            continue;
+
+        const string    file_name(dp->d_name, 0, d_namlen);
+
+        if ((full_name_required) && (dir_name != ""))
+            file_names.push_back(dir_name + "/" + file_name);
+        else
+            file_names.push_back(file_name);
+    }
+
+    closedir(dir);
+
+#endif
+
+    return  0;
+}
diff --git a/plugins/epan/generic/byte_interpret_common_base.h b/plugins/epan/generic/byte_interpret_common_base.h
new file mode 100644
index 00000000000..894ce5e8a97
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_common_base.h
@@ -0,0 +1,176 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#pragma once
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+
+#include <cstring>
+#include <climits>
+#include <string>
+#include <vector>
+#include <sstream>
+using namespace std;
+
+#ifdef WIN32
+#else
+#include <sys/times.h>
+#endif
+
+#include "CT_debug_object_counter.h"
+
+
+//****************************************************************************
+// Unused parameter
+// http://stackoverflow.com/questions/7090998/portable-unused-parameter-macro-used-on-function-signature-for-c-and-c
+//****************************************************************************
+
+#ifdef UNUSED
+#elif defined(__GNUC__)
+# define UNUSED(x) UNUSED_ ## x __attribute__((unused))
+#elif defined(__LCLINT__)
+# define UNUSED(x) /*@unused@*/ x
+#elif defined(__cplusplus)
+# define UNUSED(x)
+#else
+# define UNUSED(x) x
+#endif
+
+//****************************************************************************
+//
+//****************************************************************************
+
+#ifndef LONGLONG_MAX
+#define LONGLONG_MAX        ((long long)(~0ULL>>1))
+#define LONGLONG_MIN        (-LONGLONG_MAX - 1)
+#endif
+
+#ifdef __lynx__
+typedef unsigned int      uint;
+#endif
+#ifdef WIN32
+typedef unsigned int      uint;
+typedef unsigned int      ulong;
+#else
+#include <sys/types.h>
+#endif
+
+typedef          long long     longlong;
+typedef unsigned long long    ulonglong;
+
+typedef unsigned char   T_byte;
+
+#ifdef FRHED
+#define endl "\r\n"
+#endif
+
+#define M_WHERE  __FILE__, __LINE__
+
+//****************************************************************************
+// Misc
+//****************************************************************************
+
+enum E_return_code
+{
+    E_rc_ok,                       // everything is ok
+    E_rc_not_integer,              // format ok BUT integer value NOK
+    E_rc_not_found,                // format expected NOT found
+    E_rc_multiple_value,           // is a mulitple value
+    E_rc_not_ok                    // NOT ok
+};
+
+#define K_COMMENT_START  '#'
+
+// NB: from foundation/csc_common
+#define M_SIZE_TAB(array) (sizeof(array)/sizeof(array[0]))
+
+
+//****************************************************************************
+// ostream << nullptr
+//****************************************************************************
+std::ostream& operator << (std::ostream& os, std::nullptr_t);
+
+//****************************************************************************
+// get_string
+//****************************************************************************
+template <class TYPE>
+//inline
+string    get_string (const TYPE&   rhs)
+{
+  ostringstream    oss;
+ 
+  oss << rhs;
+
+  return  oss.str();
+}
+#if 1
+#include <cstdio>
+// moins performant sur le tableau ?
+template <>
+inline
+string    get_string (const long long&   rhs)
+{
+  char    str_tmp[99+1];
+#ifdef WIN32
+  sprintf(str_tmp, "%I64d", rhs);
+#else
+  sprintf(str_tmp, "%lld", rhs);
+#endif
+  return  str_tmp;
+}
+#endif
+//****************************************************************************
+// rfind : reverse find
+//****************************************************************************
+template <class T_iter,
+          class T_value>
+inline
+T_iter    rfind (const T_iter     begin,
+                 const T_iter     end,
+                 const T_value  & value)
+{
+    if (begin == end)
+        return  end;
+
+    T_iter  current = end;
+
+    do
+    {
+        --current;
+
+        if (*current == value)
+            return  current;
+
+    } while (current != begin);
+
+    return  end;
+}
+
+//*****************************************************************************
+// get_files_in_dir ***********************************************************
+//*****************************************************************************
+
+int   get_files_in_dir( const string          & dir_name,
+                        const string          & begin_file_name,
+                        const string          & end_file_name,
+                              vector<string>  & file_names,
+                        const bool              full_name_required);
diff --git a/plugins/epan/generic/byte_interpret_common_exception.cpp b/plugins/epan/generic/byte_interpret_common_exception.cpp
new file mode 100644
index 00000000000..5dedadc8ebe
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_common_exception.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+// ****************************************************************************
+// Includes.
+// ****************************************************************************
+
+#include "precomp.h"
+#include "byte_interpret_common_base.h"
+#include "byte_interpret_common_exception.h"
+
+//****************************************************************************
+// C_byte_interpret_exception
+//****************************************************************************
+
+C_byte_interpret_exception::C_byte_interpret_exception(
+                      const char                        * file_name,
+                            int                           file_line,
+                            E_byte_interpret_exception    bie,
+                      const std::string                 & str)
+    :std::exception(),
+    A_file_name(file_name),
+    A_file_line(file_line),
+    A_bie(bie),
+    A_str(str)
+{
+    A_explanation = get_explanation();
+}
+
+const char*
+C_byte_interpret_exception::what() const throw()
+{
+    return  A_explanation.c_str();
+}
+
+const std::string 
+C_byte_interpret_exception::get_explanation() const
+{
+    string  debug_str;
+    if (A_file_name != "")
+    {
+        debug_str += " at " + A_file_name + " line=" + get_string(A_file_line);
+    }
+    return  A_str + debug_str;
+}
+
diff --git a/plugins/epan/generic/byte_interpret_common_exception.h b/plugins/epan/generic/byte_interpret_common_exception.h
new file mode 100644
index 00000000000..1d61ac70f85
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_common_exception.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#pragma once
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "byte_interpret_common_exception.h"
+
+
+//****************************************************************************
+// Exceptions
+//****************************************************************************
+
+enum E_byte_interpret_exception
+{
+    E_byte_interpret_exception_missing_data,
+    E_byte_interpret_exception_loop_deep_break,
+    E_byte_interpret_exception_loop_deep_continue,
+    E_byte_interpret_exception_loop_break,
+    E_byte_interpret_exception_loop_continue,
+    E_byte_interpret_exception_return,
+    E_byte_interpret_exception_fatal
+};
+
+class C_byte_interpret_exception : public std::exception
+{
+public:
+    C_byte_interpret_exception(
+                         const char                        * file_name,
+                               int                           file_line,
+                               E_byte_interpret_exception    bie,
+                         const std::string                 & str);
+    ~C_byte_interpret_exception() throw() { }
+
+    // override
+    virtual const char* what() const throw();
+    
+    E_byte_interpret_exception    get_cause() const          { return  A_bie; }
+    const std::string             get_explanation() const;
+
+private:
+    std::string                   A_file_name;
+    int                           A_file_line;
+    E_byte_interpret_exception    A_bie;
+    std::string                   A_str;
+    std::string                   A_explanation;
+};
+
diff --git a/plugins/epan/generic/byte_interpret_common_fatal.cpp b/plugins/epan/generic/byte_interpret_common_fatal.cpp
new file mode 100644
index 00000000000..a1afdfd1ff2
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_common_fatal.cpp
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+// ****************************************************************************
+// Includes.
+// ****************************************************************************
+
+#include "precomp.h"
+#include "byte_interpret_common_fatal.h"
+#include "byte_interpret_common_trace.h"
+#include "byte_interpret_common_exception.h"
+
+#include <iostream>
+#include <vector>
+#include <cstdio>
+
+
+//*****************************************************************************
+// fatal_pb
+//*****************************************************************************
+
+void    fatal_pb (const string  & lhs,
+                  const string  & comp,
+                  const string  & rhs,
+                  const char    * file_name,
+                  const size_t    file_line)
+{
+    ostringstream  oss;
+    oss << lhs << " "
+        << comp << " "
+        << rhs << " "
+        << "at " << file_name << "[" << file_line << "]";
+    const string  oss_str = oss.str ();
+
+    M_TRACE_FATAL(oss_str);
+    throw  C_byte_interpret_exception(M_WHERE, E_byte_interpret_exception_fatal, oss_str);
+}
diff --git a/plugins/epan/generic/byte_interpret_common_fatal.h b/plugins/epan/generic/byte_interpret_common_fatal.h
new file mode 100644
index 00000000000..4160ac63082
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_common_fatal.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#pragma once
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "byte_interpret_common_base.h"
+
+
+//****************************************************************************
+// M_FATAL_IF_ ...
+//****************************************************************************
+
+void    fatal_pb (const string  & lhs,
+                  const string  & comp,
+                  const string  & rhs,
+                  const char    * file_name,
+                  const size_t    file_line);
+
+#define M_FATAL_IF_FALSE(assertion)                                           \
+    if ((assertion) == false)                                                 \
+    {                                                                         \
+        fatal_pb (#assertion, "is", "false",                                  \
+                  __FILE__, __LINE__);                                        \
+    }
+
+#define M_FATAL_IF_NE(lhs,rhs)                                                \
+    if ((lhs) != rhs)                                                         \
+    {                                                                         \
+        fatal_pb (#lhs " (" + get_string (lhs) + ") ",                        \
+                  "!=",                                                       \
+                  #rhs " (" + get_string (rhs) + ") ",                        \
+                  __FILE__, __LINE__);                                        \
+    }
+
+#define M_FATAL_IF_EQ(lhs,rhs)                                                \
+    if ((lhs) == rhs)                                                         \
+    {                                                                         \
+        fatal_pb (#lhs " (" + get_string (lhs) + ") ",                        \
+                  "==",                                                       \
+                  #rhs " (" + get_string (rhs) + ") ",                        \
+                  __FILE__, __LINE__);                                        \
+    }
+
+#define M_FATAL_IF_LT(lhs,rhs)                                                \
+    if ((lhs) <  rhs)                                                         \
+    {                                                                         \
+        fatal_pb (#lhs " (" + get_string (lhs) + ") ",                        \
+                  "<",                                                        \
+                  #rhs " (" + get_string (rhs) + ") ",                        \
+                  __FILE__, __LINE__);                                        \
+    }
+
+#define M_FATAL_IF_LE(lhs,rhs)                                                \
+    if ((lhs) <= rhs)                                                         \
+    {                                                                         \
+        fatal_pb (#lhs " (" + get_string (lhs) + ") ",                        \
+                  "<=",                                                       \
+                  #rhs " (" + get_string (rhs) + ") ",                        \
+                  __FILE__, __LINE__);                                        \
+    }
+
+#define M_FATAL_IF_GT(lhs,rhs)                                                \
+    if ((lhs) >  rhs)                                                         \
+    {                                                                         \
+        fatal_pb (#lhs " (" + get_string (lhs) + ") ",                        \
+                  ">",                                                        \
+                  #rhs " (" + get_string (rhs) + ") ",                        \
+                  __FILE__, __LINE__);                                        \
+    }
+
+#define M_FATAL_IF_GE(lhs,rhs)                                                \
+    if ((lhs) >= rhs)                                                         \
+    {                                                                         \
+        fatal_pb (#lhs " (" + get_string (lhs) + ") ",                        \
+                  ">=",                                                       \
+                  #rhs " (" + get_string (rhs) + ") ",                        \
+                  __FILE__, __LINE__);                                        \
+    }
+
+#define M_FATAL_IF_NULL(lhs)   M_FATAL_IF_EQ(lhs, nullptr)
+
+#define M_FATAL_COMMENT(comment)                                              \
+    {                                                                         \
+        std::ostringstream  M_FATAL_COMMENT_oss;                              \
+        M_FATAL_COMMENT_oss << comment;                                       \
+        fatal_pb ("FATAL :", "", M_FATAL_COMMENT_oss.str (),                  \
+                  __FILE__, __LINE__);                                        \
+    }
+
+#define M_ASSERT(assertion)     M_FATAL_IF_FALSE(assertion)
+#define M_ASSERT_EQ(lhs,rhs)    M_FATAL_IF_NE(lhs,rhs)
+#define M_ASSERT_NE(lhs,rhs)    M_FATAL_IF_EQ(lhs,rhs)
+
diff --git a/plugins/epan/generic/byte_interpret_common_trace.cpp b/plugins/epan/generic/byte_interpret_common_trace.cpp
new file mode 100644
index 00000000000..152f472c611
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_common_trace.cpp
@@ -0,0 +1,173 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+// ****************************************************************************
+// Includes.
+// ****************************************************************************
+
+#include "precomp.h"
+#include "byte_interpret_common_trace.h"
+
+#include <iostream>
+#include <vector>
+#include <cstdio>
+
+// ****************************************************************************
+// M_state_... trace output stream.
+// ****************************************************************************
+
+static ostream  * S_P_state_ostream = &cout;
+
+ostream  & get_state_ostream()
+{
+    return  * S_P_state_ostream;
+}
+
+ostream  & set_state_ostream(ostream  & new_state_ostream)
+{
+    ostream  & old_state_ostream = * S_P_state_ostream;
+
+    S_P_state_ostream = & new_state_ostream;
+
+    return  old_state_ostream;
+}
+
+// ****************************************************************************
+// M_state_... trace flag.
+// ****************************************************************************
+void    set_debug(E_debug_status    debug)
+{
+    C_trace::A_debug_status = debug;
+}
+
+E_debug_status  get_debug()
+{
+    return  C_trace::A_debug_status;
+}
+
+
+C_debug_set_temporary::C_debug_set_temporary(E_debug_status  debug)
+    :previous_value(get_debug()),
+     value_modified(false)
+{
+    set(debug);
+}
+
+C_debug_set_temporary::C_debug_set_temporary()
+    :previous_value(get_debug()),
+     value_modified(false)
+{
+}
+
+C_debug_set_temporary::~C_debug_set_temporary()
+{
+    unset();
+}
+
+void
+C_debug_set_temporary::set(E_debug_status  debug)
+{
+    set_debug(debug);
+    value_modified = true;
+}
+void
+C_debug_set_temporary::unset()
+{
+    if (value_modified)
+    {
+        set_debug(previous_value);
+        value_modified = false;
+    }
+}
+void
+C_debug_set_temporary::forget()
+{
+    value_modified = false;
+}
+
+// ****************************************************************************
+// M_state_... trace class.
+// ****************************************************************************
+E_debug_status  C_trace::A_debug_status = E_debug_status_OFF;
+
+C_trace::C_trace(const char  * function_name)
+    :A_function_name(function_name),
+     A_must_do_leave_trace(true)
+{
+}
+
+C_trace::~C_trace()
+{
+    if (A_must_do_leave_trace)
+    {
+        M_TRACE_base(" ", "Leave", A_function_name);
+    }
+}
+
+//#ifdef WIN32
+#include "T_perf_time.h"
+
+bool         perf_time_val_last_trace_initialized = false;
+T_perf_time  perf_time_val_last_trace;
+//#endif
+
+void
+C_trace::print_beginning_of_trace(      ostream  & os,
+                                  const char     * prefix1,
+                                  const char     * prefix2)
+{
+    os << prefix1 << " ";
+
+    if (A_debug_status == E_debug_status_ON)
+    {
+        T_perf_time  timeb_val;
+
+        os << timeb_val << " ";
+
+        if ((perf_time_val_last_trace_initialized) &&
+            (timeb_val != perf_time_val_last_trace))
+        {
+            long    diff_time_ms = perf_time_diff_ms(timeb_val, perf_time_val_last_trace);
+            if (diff_time_ms > 1)
+            {
+                char  time_str[99+1];
+                sprintf(time_str, "%4ld ", diff_time_ms);
+                os << time_str;
+            }
+            else
+            {
+                os << "     ";
+            }
+        }
+        else
+        {
+            os << "     ";
+        }
+        perf_time_val_last_trace = timeb_val;
+        perf_time_val_last_trace_initialized = true;
+    }
+
+    os << prefix2 << " "; 
+}
+
+void
+C_trace::leave_trace_done()
+{
+    A_must_do_leave_trace = false;
+}
+
diff --git a/plugins/epan/generic/byte_interpret_common_trace.h b/plugins/epan/generic/byte_interpret_common_trace.h
new file mode 100644
index 00000000000..57833bc2dfd
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_common_trace.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#pragma once
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+#include "byte_interpret_common_base.h"
+
+
+//****************************************************************************
+// Traces
+//****************************************************************************
+
+#define M_TRACE_ENTER(function_name,OSTREAM_OUTPUT_EXPR)                      \
+    C_trace    M_trace(function_name);                                        \
+    M_TRACE_base (" ", "Enter", function_name << " " << OSTREAM_OUTPUT_EXPR)
+
+#define M_TRACE_ENTER_NO_LEAVE(function_name,OSTREAM_OUTPUT_EXPR)             \
+    M_TRACE_ENTER(function_name,OSTREAM_OUTPUT_EXPR);                         \
+    M_trace.leave_trace_done()
+
+#define M_TRACE_LEAVE(OSTREAM_OUTPUT_EXPR)                      \
+    M_TRACE_base (" ", "Leave", M_trace.A_function_name << " " << OSTREAM_OUTPUT_EXPR);  \
+    M_trace.leave_trace_done()
+
+
+#define M_TRACE_DEBUG(OSTREAM_OUTPUT_EXPR)                                    \
+    M_TRACE_base (" ", "     ", OSTREAM_OUTPUT_EXPR)
+#define M_TRACE_INFO(OSTREAM_OUTPUT_EXPR)                                     \
+    M_TRACE_base ("i", "     ", OSTREAM_OUTPUT_EXPR)
+#define M_TRACE_WARNING(OSTREAM_OUTPUT_EXPR)                                  \
+    M_TRACE_print ("W", "     ", OSTREAM_OUTPUT_EXPR)
+#define M_TRACE_ERROR(OSTREAM_OUTPUT_EXPR)                                    \
+    M_TRACE_print ("E", "     ", OSTREAM_OUTPUT_EXPR)
+#define M_TRACE_FATAL(OSTREAM_OUTPUT_EXPR)                                    \
+    M_TRACE_print ("F", "     ", OSTREAM_OUTPUT_EXPR)
+#define M_TRACE_ASSERT(OSTREAM_OUTPUT_EXPR)                                   \
+    M_TRACE_print ("A", "     ", OSTREAM_OUTPUT_EXPR)
+
+#define M_TRACE_base(PREFIX1,PREFIX2,OSTREAM_OUTPUT_EXPR)                     \
+    if (C_trace::A_debug_status != E_debug_status_OFF)                        \
+    {                                                                         \
+        M_TRACE_print (PREFIX1, PREFIX2, OSTREAM_OUTPUT_EXPR);                \
+    }
+
+#define M_TRACE_print(PREFIX1,PREFIX2,OSTREAM_OUTPUT_EXPR)                    \
+    C_trace::print_beginning_of_trace(get_state_ostream(), PREFIX1, PREFIX2); \
+    get_state_ostream() << OSTREAM_OUTPUT_EXPR << endl << flush
+
+
+
+enum E_debug_status
+{
+    E_debug_status_OFF,
+    E_debug_status_ON,
+    E_debug_status_ON_NO_TIME,
+};
+
+void            set_debug(E_debug_status    debug);
+E_debug_status  get_debug();
+
+class C_debug_set_temporary
+{
+public:
+    C_debug_set_temporary(E_debug_status  debug);
+    C_debug_set_temporary();
+    ~C_debug_set_temporary();
+
+    void    set(E_debug_status  debug);
+    void    unset();
+    void    forget();
+
+private:
+    C_debug_set_temporary(const C_debug_set_temporary  &);
+
+    E_debug_status    previous_value;
+    bool              value_modified;
+};
+
+
+
+ostream  & get_state_ostream();
+ostream  & set_state_ostream(ostream  & new_state_ostream);
+
+
+//#define M_TRACE_print(OSTREAM_OUTPUT_EXPR)
+
+struct C_trace
+{
+    C_trace(const char  * function_name);
+    ~C_trace();
+
+    static
+    void    print_beginning_of_trace(      ostream  & os,
+                                     const char     * prefix1,
+                                     const char     * prefix2);
+
+    // Specifiy the leave trace has been done
+    void    leave_trace_done();
+
+    const char  * A_function_name;
+    bool          A_must_do_leave_trace;
+
+
+    static E_debug_status   A_debug_status;
+};
+
diff --git a/plugins/epan/generic/byte_interpret_common_utils.h b/plugins/epan/generic/byte_interpret_common_utils.h
new file mode 100644
index 00000000000..96963be35ef
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_common_utils.h
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#pragma once
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+
+#include <string>
+#include <iostream>
+#include <vector>
+
+using namespace std;
+
+
+//****************************************************************************
+// comparison
+//****************************************************************************
+
+inline
+bool ends_with(const std::string& str, const std::string& suffix)
+{
+    return str.size() >= suffix.size() && 0 == str.compare(str.size() - suffix.size(), suffix.size(), suffix);
+}
+
+inline
+bool ends_with_case_insensitive(const std::string& str, const std::string& suffix)
+{
+    if (suffix.size() > str.size())
+    {
+        return false;
+    }
+    return std::equal(suffix.rbegin(), suffix.rend(), str.rbegin(),
+        [](const char a, const char b)
+    {
+        return tolower(a) == tolower(b);
+    }
+    );
+}
+
+inline
+bool starts_with(const std::string& str, const std::string& prefix)
+{
+    return str.size() >= prefix.size() && 0 == str.compare(0, prefix.size(), prefix);
+}
+
+
+//****************************************************************************
+// trim
+//****************************************************************************
+
+// trim from end of string (right)
+inline
+std::string& rtrim(std::string& s, const char* t = " \t\n\r\f\v")
+{
+    s.erase(s.find_last_not_of(t) + 1);
+    return s;
+}
+inline
+std::string  get_rtrim(std::string  s, const char* t = " \t\n\r\f\v")
+{
+    s.erase(s.find_last_not_of(t) + 1);
+    return s;
+}
+
+// trim from beginning of string (left)
+inline
+std::string& ltrim(std::string& s, const char* t = " \t\n\r\f\v")
+{
+    s.erase(0, s.find_first_not_of(t));
+    return s;
+}
+
+// trim from both ends of string (right then left)
+inline
+std::string& trim(std::string& s, const char* t = " \t\n\r\f\v")
+{
+    return ltrim(rtrim(s, t), t);
+}
+inline
+std::string get_trim(std::string s, const char* t = " \t\n\r\f\v")
+{
+    return ltrim(rtrim(s, t), t);
+}
+
+
+//****************************************************************************
+// split
+//****************************************************************************
+inline
+vector<string> split(string s, string delimiter)
+{
+    size_t pos_start = 0, pos_end, delim_len = delimiter.length();
+    string token;
+    vector<string> res;
+
+    while ((pos_end = s.find(delimiter, pos_start)) != string::npos)
+    {
+        token = s.substr(pos_start, pos_end - pos_start);
+        pos_start = pos_end + delim_len;
+        res.push_back(token);
+    }
+
+    res.push_back(s.substr(pos_start));
+    return res;
+}
diff --git a/plugins/epan/generic/byte_interpret_compute_expression.cpp b/plugins/epan/generic/byte_interpret_compute_expression.cpp
new file mode 100644
index 00000000000..adeb7c1fd87
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_compute_expression.cpp
@@ -0,0 +1,228 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <vector>
+#include <algorithm>
+
+using namespace std;
+
+#include "precomp.h"
+#include "C_value.h"
+#include "byte_interpret_compute_expression.h"
+#include "byte_interpret_parse.h"
+
+
+//*****************************************************************************
+// ----------------------------------------------------------------------------
+// Format :
+// <value>
+// <value> could be :
+//   <int_value>
+//   <float_value>
+//   <enum_value> or <const_value>
+//   <variable_value>
+//   *   --> return E_rc_multiple_value
+//   "string value"
+//*****************************************************************************
+
+E_return_code    get_complex_value (const T_type_definitions  & type_definitions,
+                                    const T_interpret_data    & interpret_data,
+                                    const string              & value_str,
+                                          C_value             & value)
+{
+    long long    value_int = 0;
+    double       value_flt = 0.0;
+
+    if (get_number (value_str.c_str (), value_int))
+    {
+        value = value_int;
+    }
+    else if (get_number (value_str.c_str (), value_flt))
+    {
+        value = value_flt;
+    }
+    else if (type_definitions.get_type_value(value_str, value))
+    {
+    }
+    // very bad perfomance
+    else if (interpret_data.get_value_of_read_variable (value_str, value))
+    {
+    }
+    else
+    {
+        string  real_value_str = value_str;
+        remove_string_limits (real_value_str);
+
+        if (real_value_str == value_str)
+        {
+            if (strchr(value_str.c_str(), '*') != nullptr)
+            {
+                return  E_rc_multiple_value;
+            }
+
+            return  E_rc_not_ok;
+        }
+
+        value = real_value_str;
+    }
+
+    return  E_rc_ok;
+}
+
+//*****************************************************************************
+// words_to_string
+//*****************************************************************************
+
+string    words_to_string(const vector<string>::const_iterator      & iter_begin,
+                          const vector<string>::const_iterator      & iter_end)
+{
+    string  str;
+    for (vector<string>::const_iterator  iter  = iter_begin;
+                                         iter != iter_end;
+                                       ++iter)
+    {
+        str += *iter;
+        str += " ";
+    }
+
+    return  str;
+}
+
+string    words_to_string(const vector<string>      & words)
+{
+    string  str;
+    for (vector<string>::const_iterator  iter  = words.begin();
+                                         iter != words.end();
+                                       ++iter)
+    {
+        str += *iter;
+        str += " ";
+    }
+
+    return  str;
+}
+
+//*****************************************************************************
+// compute_expression
+//*****************************************************************************
+#include "T_expression.h"
+C_value    compute_expression (
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const string                  & in_str,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err)
+{
+    M_TRACE_ENTER("compute_expression", in_str);
+
+    T_expression    expression;
+    expression.build_expression(type_definitions, in_str);
+
+    return  expression.compute_expression(
+                                type_definitions,
+                                interpret_data,
+                                in_out_frame_data,
+                                data_name,
+                                data_simple_name,
+                                os_out,
+                                os_err);
+}
+
+//*****************************************************************************
+// compute_expression_no_io
+//*****************************************************************************
+
+C_value    compute_expression_no_io (
+                         const T_type_definitions  & type_definitions,
+                               T_interpret_data    & interpret_data,
+                         const std::string         & str)
+{
+    M_TRACE_ENTER("compute_expression_no_io", str);
+
+    T_expression    expression;
+    expression.build_expression(type_definitions, str);
+
+    return  expression.compute_expression_no_io(type_definitions, interpret_data);
+}
+
+//*****************************************************************************
+// compute_expression_static
+//*****************************************************************************
+
+C_value    compute_expression_static (const T_type_definitions  & type_definitions,
+                                      const std::string         & str)
+{
+    M_TRACE_ENTER("compute_expression_static", str);
+
+    T_expression    expression;
+    expression.build_expression(type_definitions, str);
+
+    return  expression.compute_expression_static(type_definitions);
+}
+
+//*****************************************************************************
+// compute_expression_array
+// ----------------------------------------------------------------------------
+// Format :
+// 
+//*****************************************************************************
+
+string    compute_expressions_in_array (
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const string                  & in_str,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err)
+{
+    M_TRACE_ENTER("compute_expressions_in_array", in_str);
+
+    // Compute the value of each array index.
+    string    simple_type = in_str;
+    string    str_array_index;
+    string    str_arrays_result;
+    while (decompose_type_sep_value_sep (simple_type,
+                                                      '[',
+                                                      ']',
+                                                      simple_type,
+                                                      str_array_index) == E_rc_ok)
+    {
+        // Compute the value of the extracted index.
+        C_value  value_index = compute_expression (type_definitions, interpret_data, in_out_frame_data, str_array_index, data_name, data_simple_name, os_out, os_err);
+        M_FATAL_IF_NE(value_index.get_type(), C_value::E_type_integer);
+
+        // Add the computed index to the result array.
+        const string  str_array_index_result = "[" + value_index.as_string() + "]";
+        str_arrays_result.insert(0, str_array_index_result);
+    }
+
+    const string  result = simple_type + str_arrays_result;
+
+    M_TRACE_DEBUG("result=" << result);
+    return  result;
+}
+
diff --git a/plugins/epan/generic/byte_interpret_compute_expression.h b/plugins/epan/generic/byte_interpret_compute_expression.h
new file mode 100644
index 00000000000..08ccbfec811
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_compute_expression.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef BYTE_INTERPRET_compute_expression_H
+#define BYTE_INTERPRET_compute_expression_H
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <string>
+
+#include "byte_interpret_common.h"
+#include "C_value.h"
+#include "T_type_definitions.h"
+#include "T_interpret_data.h"
+#include "T_frame_data.h"
+
+
+//*****************************************************************************
+// get_complex_value **********************************************************
+//*****************************************************************************
+
+E_return_code    get_complex_value (const T_type_definitions  & type_definitions,
+                                    const T_interpret_data    & interpret_data,
+                                    const std::string         & value_str,
+                                          C_value             & value);
+
+//*****************************************************************************
+// compute_expressions_in_array ***********************************************
+//*****************************************************************************
+// Eg : "an_array[val+1][val+2]" -> "an_array[11][12]" (if val=10)
+//*****************************************************************************
+
+string    compute_expressions_in_array (
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const string                  & in_str,
+                         const string                  & data_name,
+                         const string                  & data_simple_name,
+                               ostream                 & os_out,
+                               ostream                 & os_err);
+
+//*****************************************************************************
+// compute_expression *********************************************************
+//*****************************************************************************
+
+C_value    compute_expression (
+                         const T_type_definitions      & type_definitions,
+                               T_interpret_data        & interpret_data,
+                               T_frame_data            & in_out_frame_data,
+                         const std::string             & str,
+                         const std::string             & data_name,
+                         const std::string             & data_simple_name,
+                               std::ostream            & os_out,
+                               std::ostream            & os_err);
+
+//*****************************************************************************
+// compute_expression_no_io ***************************************************
+//*****************************************************************************
+// Read no field (do not have in_out_frame_data parameter).
+// Variables must be hidden (do not have data_name, os_out, ...).
+//*****************************************************************************
+
+C_value    compute_expression_no_io (
+                         const T_type_definitions  & type_definitions,
+                               T_interpret_data    & interpret_data,
+                         const std::string         & str);
+
+//*****************************************************************************
+// compute_expression_static **************************************************
+//*****************************************************************************
+// Static expression (without any attribute/variable)
+//*****************************************************************************
+
+C_value    compute_expression_static (const T_type_definitions  & type_definitions,
+                                      const std::string         & str);
+
+
+
+#endif /* BYTE_INTERPRET_compute_expression_H */
diff --git a/plugins/epan/generic/byte_interpret_main.cpp b/plugins/epan/generic/byte_interpret_main.cpp
new file mode 100644
index 00000000000..dac5e746755
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_main.cpp
@@ -0,0 +1,479 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <cstdio>
+#include <cerrno>
+#include <cassert>
+#include <iostream>
+#include <string>
+#include <map>
+#include <vector>
+#include <queue>
+#include <fstream>
+#include <sstream>
+using namespace std;
+
+#include "byte_interpret_common.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+
+//*****************************************************************************
+// output_time_spent **********************************************************
+//*****************************************************************************
+bool  S_must_output_time = false;
+void  output_time_spent (const char  * comment)
+{
+#ifndef WIN32
+    struct tms       tms_var;
+    static time_t    S_begin_time = times (&tms_var);
+    static time_t    S_last_time = S_begin_time;
+
+    time_t    new_time = times (&tms_var);
+
+    if (S_must_output_time)
+    {
+        cout << "time spent (" << comment
+             << ") = " << new_time - S_last_time << " cs / "
+             << new_time - S_begin_time << " cs."
+             << endl;
+    }
+
+    S_last_time = new_time;
+#endif
+}
+
+//*****************************************************************************
+// is_string_ended_by *********************************************************
+//*****************************************************************************
+
+bool    is_string_ended_by (const char  * file_name,
+                            const char  * suffix)
+{
+    const size_t    suffix_length = strlen (suffix);
+    const size_t    file_name_length = strlen (file_name);
+
+    if (file_name_length < suffix_length)
+        return  false;
+
+    const char  * file_name_suffix = file_name + file_name_length - suffix_length;
+
+    return  strcmp (file_name_suffix, suffix) == 0;
+}
+
+//*****************************************************************************
+// is_frame_desc_file_name ****************************************************
+//*****************************************************************************
+
+bool    is_frame_desc_file_name (const char  * file_name)
+{
+    return  is_string_ended_by (file_name, ".fdesc");
+}
+
+bool    is_frame_desc_file_name (const string  & file_name)
+{
+    return  is_frame_desc_file_name (file_name.c_str ());
+}
+
+//*****************************************************************************
+// is_frame_bin_file_name *****************************************************
+//*****************************************************************************
+
+bool    is_frame_bin_file_name (const char  * file_name)
+{
+    return  is_string_ended_by (file_name, ".fbin");
+}
+
+bool    is_frame_bin_file_name (const string  & file_name)
+{
+    return  is_frame_bin_file_name (file_name.c_str ());
+}
+
+//*****************************************************************************
+// is_frame_hexa_file_name ****************************************************
+//*****************************************************************************
+
+bool    is_frame_hexa_file_name (const char  * file_name)
+{
+    return  is_string_ended_by (file_name, ".fhex") ||
+            is_string_ended_by (file_name, ".frame");
+}
+
+bool    is_frame_hexa_file_name (const string  & file_name)
+{
+    return  is_frame_hexa_file_name (file_name.c_str ());
+}
+
+//*****************************************************************************
+// is_frame_hexa_dump_file_name ***********************************************
+//*****************************************************************************
+
+bool    is_frame_hexa_dump_file_name (const char  * file_name)
+{
+    return  strstr (file_name, ".fhexd") != nullptr;
+}
+
+bool    is_frame_hexa_dump_file_name (const string  & file_name)
+{
+    return  is_frame_hexa_dump_file_name (file_name.c_str ());
+}
+
+//*****************************************************************************
+// wait_for_any_operator_input ************************************************
+//*****************************************************************************
+
+void    wait_for_any_operator_input ()
+{
+    cout << "Enter to exit" << endl;
+    char    do_not_care;
+    cin.get (do_not_care);
+}
+
+//*****************************************************************************
+// help_role ******************************************************************
+//*****************************************************************************
+
+void    help_role (const char  * UNUSED(prog_name))
+{
+    cerr << "Interpret binary data." << endl;
+}
+
+//*****************************************************************************
+// usage **********************************************************************
+//*****************************************************************************
+
+void  usage (const char  * prog_name)
+{
+    ostream  & os = cerr;
+
+    os << "usage: " << prog_name << 
+" [ options ] <type description> <what must be read> <binary data to interpret>\n"
+"\n";
+    help_role (prog_name);
+
+    os <<
+"\n*** "
+"Options are : \n"
+"-help  : print this.\n"
+"-trace : output traces.\n"
+"-perf  : display execution times.\n"
+"\n";
+
+    os <<
+"\n*** "
+"<type description> <what must be read> could be specified :\n"
+"- directly into the command line\n"
+"- from stdin  if you specify -fdesc -\n"
+"- from a file if you specify -fdesc <file_name> or <file_name>.fdesc\n"
+"\n";
+    os <<
+"Look at http://wsgd.free.fr/fdesc_format.html for the type description syntax.\n"
+"Or " << prog_name << "  -help_syntax\n" 
+"\n";
+    os <<
+"\n*** "
+"<binary data to interpret> could be specified :\n"
+"- directly into the command line if you specify --\n"
+"- from stdin                     if you specify -\n"
+"- from a file                    if you specify :\n"
+"  -frame_bin     <file_name> or <file_name>.fbin\n"
+"  -frame_hex     <file_name> or <file_name>.fhex\n"
+"  -frame_hexd... <file_name> or <file_name>.fhexd...\n"
+"\n";
+
+    os <<
+"Format command line, stdin or file -frame_hex :  02E3 B7 C24F112c b2 7C ...\n"
+"\n"
+"Format file -frame_hexd1 :\n"
+"<word1>  02E3 B7 C2 435D6F112c b2 7C\n"
+"<word1>  435D6F112 02E3 B7 C2 412c b2 7C\n"
+"\n"
+"Format file -frame_hexd2- :\n"
+"<word1> <word2>  02E3 B7 C2 435D6F112c b2 7C     - to ignore\n"
+"<word1> <word2>  435D6F112 02E3 B7 C2 412c b2 7C - to ignore\n"
+"\n"
+"Format file -frame_hexd<num><end_of_hexa> :\n"
+"<word1> ... <word<num>> 02E3 B7 C2 43512c b2 7C     <end_of_hexa> to ignore\n"
+"<word1> ... <word<num>> 435D6F112 02E3 B7 C2 412c   <end_of_hexa> to ignore\n"
+"\n";
+
+    os <<
+"\n*** "
+"Very simple examples :\n"
+"\n"
+"> byte_interpret.exe  my_file.fdesc  -frame_bin  file_which_contains_binary_data\n"
+"...\n"
+"\n"
+"> byte_interpret.exe  int32  toto ;  -- 00 01 02 03\n"
+"toto = 50462976\n"
+"\n"
+"> byte_interpret.exe byte_order big_endian ; int32  toto ;  -- 00 01 02 03\n"
+"toto = 66051\n"
+"\n"
+"> byte_interpret.exe byte_order big_endian ; float32 toto ;  -- 00 01 02 03\n"
+"toto = 9.25572e-041\n"
+#ifndef WIN32
+"\n"
+"NB: for Linux/Unix systems, ; must be changed to \\; or \";\" or \"int32  toto ;\"\n"
+#endif
+       << endl;
+
+#ifdef WIN32
+    // To avoid window closing.
+    wait_for_any_operator_input ();
+#endif
+}
+
+//*****************************************************************************
+// main ***********************************************************************
+//*****************************************************************************
+
+int   main (int  argc, const char * const  argv[])
+{
+    output_time_spent ("begin");
+
+    int   arg_idx = 1;
+
+    if (arg_idx >= argc)
+    {
+        usage (argv[0]);
+        return  2;
+    }
+
+    if (strcmp (argv[arg_idx], "-help_role") == 0)
+    {
+        help_role (argv[0]);
+        return  0;
+    }
+
+    if (strcmp (argv[arg_idx], "-help") == 0)
+    {
+        usage (argv[0]);
+        return  0;
+    }
+
+    if (strcmp (argv[arg_idx], "-trace") == 0)
+    {
+        set_debug (E_debug_status_ON);
+        ++arg_idx;
+    }
+
+    if (strcmp (argv[arg_idx], "-perf") == 0)
+    {
+        S_must_output_time = true;
+        ++arg_idx;
+    }
+
+    output_time_spent ("apres alias");
+
+    if (arg_idx >= argc)
+    {
+        usage (argv[0]);
+        return  2;
+    }
+
+    // Lecture des types.
+    istream  * P_istream = nullptr;
+    string     types_and_commands;
+
+    if (strcmp (argv[arg_idx], "-help_syntax") == 0)
+    {
+        ++arg_idx;
+        P_istream = new istringstream ("print syntax ;");
+    }
+    else if ((strcmp (argv[arg_idx], "-fdesc") == 0) ||
+        (is_frame_desc_file_name (argv[arg_idx])))
+    {
+        if (strcmp (argv[arg_idx], "-fdesc") == 0)
+            ++arg_idx;
+
+        const string    file_name (argv[arg_idx]);
+        ++arg_idx;
+
+        if ((file_name == "-") || (file_name == "stdin"))
+            P_istream = &cin;
+        else
+        {
+            P_istream = new ifstream (file_name.c_str ());
+
+            const string::size_type  last_separator = file_name.find_last_of("/\\");
+            if (last_separator != string::npos)
+            {
+                const string    directory = file_name.substr(0, last_separator);
+                byte_interpret_set_include_directory(directory);
+            }
+        }
+    }
+    else
+    {
+        while (arg_idx < argc)
+        {
+            if (strcmp (argv[arg_idx], "--") == 0)
+            {
+                break;
+            }
+            if (strcmp (argv[arg_idx], "-") == 0)
+            {
+                break;
+            }
+            if ((strcmp (argv[arg_idx], "-frame_bin") == 0) ||
+                (is_frame_bin_file_name (argv[arg_idx])))
+            {
+                break;
+            }
+            if ((strcmp (argv[arg_idx], "-frame") == 0) ||
+                (strcmp (argv[arg_idx], "-frame_hex") == 0) ||
+                (is_frame_hexa_file_name (argv[arg_idx])))
+            {
+                break;
+            }
+            if ((strncmp (argv[arg_idx], "-frame_hexd", 11) == 0) ||
+                (is_frame_hexa_dump_file_name (argv[arg_idx])))
+            {
+                break;
+            }
+
+            types_and_commands += argv[arg_idx];
+            types_and_commands += " ";
+
+            ++arg_idx;
+        }
+
+        P_istream = new istringstream (types_and_commands.c_str ());
+    }
+
+    output_time_spent ("avant frame");
+
+    T_byte_vector    byte_vector;
+
+    if (arg_idx == argc)
+    {
+        cerr << "No data is specified." << endl;
+    }
+    else if (strcmp (argv[arg_idx], "-") == 0)
+    {
+        ++arg_idx;
+        istream_hexa_to_frame (cin, byte_vector);
+    }
+    else if ((strcmp (argv[arg_idx], "-frame_bin") == 0) ||
+             (is_frame_bin_file_name (argv[arg_idx])))
+    {
+        if (strcmp (argv[arg_idx], "-frame_bin") == 0)
+            ++arg_idx;
+
+        bin_file_to_frame (argv[arg_idx], byte_vector);
+        ++arg_idx;
+    }
+    else if ((strcmp (argv[arg_idx], "-frame") == 0) ||
+             (strcmp (argv[arg_idx], "-frame_hex") == 0) ||
+             (is_frame_hexa_file_name (argv[arg_idx])))
+    {
+        if ((strcmp (argv[arg_idx], "-frame") == 0) ||
+            (strcmp (argv[arg_idx], "-frame_hex") == 0))
+            ++arg_idx;
+
+        ifstream   ifs (argv[arg_idx]);
+        istream_hexa_to_frame (ifs, byte_vector);
+        ++arg_idx;
+    }
+    else if ((strncmp (argv[arg_idx], "-frame_hexd", 11) == 0) ||
+             (is_frame_hexa_dump_file_name (argv[arg_idx])))
+    {
+        const char  * dump_arg_nb = argv[arg_idx] + 11;
+        if (strncmp (argv[arg_idx], "-frame_hexd", 11) == 0)
+            ++arg_idx;
+        else
+        {
+            dump_arg_nb = strstr (argv[arg_idx], ".fhexd") + 6;
+        }
+
+        if (*dump_arg_nb == '\0')
+        {
+            usage (argv[0]);
+            return  3;
+        }
+        if (isdigit (*dump_arg_nb) == 0)
+        {
+            usage (argv[0]);
+            return  3;
+        }
+        const int  nb_of_first_words_to_ignore = *dump_arg_nb - '0';
+
+        const char  * dump_arg_str = dump_arg_nb + 1;
+
+        ifstream   ifs (argv[arg_idx]);
+        istream_hexa_dump_to_frame (ifs,
+                                    nb_of_first_words_to_ignore,
+                                    dump_arg_str,
+                                    byte_vector);
+        ++arg_idx;
+    }
+    else
+    {
+        if (strcmp (argv[arg_idx], "--") == 0)
+        {
+            ++arg_idx;
+        }
+
+        while (arg_idx < argc)
+        {
+            // Convert to int value.
+            string_hexa_to_frame (argv[arg_idx], byte_vector);
+            ++arg_idx;
+        }
+    }
+
+    output_time_spent ("apres frame");
+
+    if (arg_idx != argc)
+    {
+        usage (argv[0]);
+        return  4;
+    }
+
+    // Do not use cerr to avoid order problems between cout and cerr.
+    ostream  & os_err = cout;
+
+    const T_byte  * P_bytes = byte_vector.size () ? &byte_vector[0] : nullptr;
+    size_t          sizeof_bytes = byte_vector.size ();
+
+    bool    result = build_types_and_interpret_bytes (P_bytes, sizeof_bytes,
+                                                      *P_istream,
+                                                      cout,
+                                                      os_err);
+
+    output_time_spent ("end");
+
+    if (sizeof_bytes != 0)
+    {
+        os_err << sizeof_bytes << " bytes have NOT been read." << endl;
+        return  6;
+    }
+    else if (result == false)
+    {
+        os_err << "Error during build_types_and_interpret_bytes." << endl;
+        return  5;
+    }
+
+    return  0;
+}
+
diff --git a/plugins/epan/generic/byte_interpret_parse.cpp b/plugins/epan/generic/byte_interpret_parse.cpp
new file mode 100644
index 00000000000..aa58abfac5c
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_parse.cpp
@@ -0,0 +1,1039 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "precomp.h"
+
+#ifndef __lynx__
+#include <sys/stat.h>
+#endif
+
+#include <cstdio>
+#include <cstdlib>
+#include <cerrno>
+#include <cassert>
+#include <iostream>
+#include <string>
+#include <map>
+#include <vector>
+#include <queue>
+#include <fstream>
+#include <sstream>
+using namespace std;
+
+#include "byte_interpret_common.h"
+#include "byte_interpret_parse.h"
+
+
+// must be called for each new line seen
+void    build_types_context_line_new (const istream  & is);
+
+
+//*****************************************************************************
+// skip_blanks  including new lines
+//*****************************************************************************
+
+void    skip_blanks (istream  & is)
+{
+    // While istream is ok ...
+    while (is.good())
+    {
+        // NB: do NOT use unget or putback (bug on VC++ 2003/2005/2008)
+        const istream::int_type  next_char = is.peek();
+
+        if (isspace(next_char) == 0)
+        {
+            // This is not a space (blank, tab, \r, \n ...)
+            break;
+        }
+
+        if (next_char == '\n')
+        {
+            // new line notification
+            build_types_context_line_new(is);
+        }
+
+        is.get();
+    }
+}
+
+//*****************************************************************************
+// skip_blanks_and_comments
+//*****************************************************************************
+
+void    skip_blanks_and_comments (istream  & is)
+{
+    // While istream is ok ...
+    while (is.good())
+    {
+        // skip blanks including new lines
+        skip_blanks(is);
+
+        // NB: do NOT use unget or putback (bug on VC++ 2003/2005/2008)
+        const istream::int_type  next_char = is.peek();
+
+        if (next_char != K_COMMENT_START)
+        {
+            // This is not a comment (and not a space).
+            break;
+        }
+
+        // This is a comment.
+        // Skip the end of the line.
+        string  tmp;
+        getline (is, tmp);
+
+        // new line notification
+        build_types_context_line_new(is);
+    }
+}
+
+//*****************************************************************************
+// skip_line
+//*****************************************************************************
+
+void    skip_line (istream  & is)
+{
+    // If istream is ok ...
+    if (is.good())
+    {
+        // Skip the end of the line.
+        string  tmp;
+        getline (is, tmp);
+
+        // new line notification
+        build_types_context_line_new(is);
+    }
+}
+
+//*****************************************************************************
+// is_istream_empty
+//*****************************************************************************
+bool    is_istream_empty (istream &         is)
+{
+    skip_blanks_and_comments (is);
+    return  is.eof () || is.fail ();
+}
+
+// ****************************************************************************
+//    Name      : mod_replace_all
+//!@n Role      : modify the string : all occurences of <replace_old>
+//!@n              are replaced by <replace_new>
+//!@n Important : Avoid possible infinite loop
+// ****************************************************************************
+
+void       mod_replace_all (string  & value_mod,
+                      const string  & replace_old,
+                      const string  & replace_new)
+{
+    string::size_type  pos_found;
+    string::size_type  pos_search = 0;
+    while ((pos_found = value_mod.find (replace_old,
+                                        pos_search)) != string::npos)
+    {
+        value_mod.replace (pos_found, replace_old.size (), replace_new);
+        pos_search = pos_found + replace_new.size ();
+    }
+}
+
+string     get_replace_all (      string    str_copy,
+                            const string  & replace_old,
+                            const string  & replace_new)
+{
+    mod_replace_all (str_copy, replace_old, replace_new);
+    return  str_copy;
+}
+
+//*****************************************************************************
+// remove_word_limits      if both limits are found
+//*****************************************************************************
+
+void    remove_word_limits (string  & str,
+                      const char      limit_left,
+                      const char      limit_right)
+{
+    if ((str[0] == limit_left) &&
+        (str.size () >= 2) &&
+        (str[str.size () - 1] == limit_right))
+    {
+        str.erase (str.size () - 1);
+        str.erase (0,1);
+    }
+}
+
+//*****************************************************************************
+// remove_string_limits      if both limits are found
+// Limits are " or '
+//*****************************************************************************
+
+void    remove_string_limits (string  & str)
+{
+    const string::size_type  original_size = str.size ();
+
+    remove_word_limits (str, '"', '"');
+    if (str.size () != original_size)
+        return;
+
+    remove_word_limits (str, '\'', '\'');
+}
+
+//*****************************************************************************
+// is_separator
+//*****************************************************************************
+// A separator is anything which could not be used into an identifier or an
+//  integer/float value.
+// Anything else : letters numbers _ : .
+//*****************************************************************************
+bool    is_separator (const char   c)
+{
+    return  (isalnum (c) == 0) && (c != '_') && (c != ':') && (c != '.');
+}
+bool    is_open (const char   c)
+{
+    return  (c == '(') || (c == '[') || (c == '{');
+}
+bool    is_str_limit (const char   c)
+{
+    return  (c == '"') || (c == '\'');
+}
+
+//*****************************************************************************
+// end_of_str :
+// - '\0' means : space, tab, new_line, eof         and ;
+// - any caracter
+// returns true if ok (i.e. end_of_str found)
+//
+// ATTENTION: do NOT use unget or putback (bug on VC++ 2003/2005/2008)
+//*****************************************************************************
+bool    append_to_string_until (istream       & is,
+                                string        & result,
+                          const char            end_of_str,
+                          const E_parser_cfg    parser_cfg);
+
+#define M_GET_FROM_ISTREAM(THE_IS)                   \
+    if (c_read == '\n')                              \
+    {                                                \
+        build_types_context_line_new(THE_IS);        \
+    }                                                \
+    THE_IS.get()
+
+bool    append_to_string_until_base (istream       & is,
+                                string        & result,
+                          const char            end_of_str,
+                          const E_parser_cfg    parser_cfg)
+{
+    M_TRACE_ENTER ("append_to_string_until",
+                   "result=" << result <<
+                   " end_of_str=" << int(end_of_str));
+
+    while (true)
+    {
+        const istream::int_type    c_read_int = is.peek();
+        if (c_read_int < 0)
+        {
+            // Fin du istream.
+            if (result.empty ())
+                return  false;
+
+            return  (end_of_str == '\0');
+        }
+
+        char    c_read = c_read_int;
+
+        if (end_of_str == '\0')
+        {
+            if (isspace (c_read))
+            {
+                if (result.empty ())
+                {
+                    // Token not already found.
+                    // Do NOT add the blank.
+                    M_GET_FROM_ISTREAM(is);
+                    continue;
+                }
+
+                if (parser_cfg & K_parser_cfg_manage_blanks)
+                {
+                    // End of the token.
+                    // Not appended to the result string.
+                    M_GET_FROM_ISTREAM(is);
+                    return  true;
+                }
+            }
+
+            if ((parser_cfg & K_parser_cfg_manage_dot_comma) &&
+                (c_read == ';'))       // 2009/01/18
+            {
+                if (result.empty () == false)
+                {
+                    // End of the token.
+                    // Not appended to the result string.
+                    return  true;
+                }
+                else
+                {
+                    // This is the token.
+                    result = c_read;
+                    M_GET_FROM_ISTREAM(is);
+                    return  true;
+                }
+            }
+
+            if (parser_cfg & K_parser_cfg_manage_comma)
+            {
+                if (c_read == ',')
+                {
+                    // End of parameter.
+                    // , is removed.
+                    M_GET_FROM_ISTREAM(is);
+                    return  true;
+                }
+            }
+
+            if ((parser_cfg == K_parser_cfg_C) &&
+                (result.empty () == false))
+            {
+                if (c_read != '[')  // 2010/07/15 to avoid split of an_array[idx]
+                {
+                    if (is_open (c_read))
+                    {
+                        // Supposed to be if( or while( ...
+                        return  true;
+                    }
+                    if ((is_separator (c_read) != is_separator (result[0])) ||
+                        (result[0] == '('))
+                    {
+                        return  true;
+                    }
+                }
+            }
+
+            if ((parser_cfg & K_parser_cfg_ignore_comments_sharp) &&
+                (c_read == K_COMMENT_START) &&
+                (result.empty ()))                  // comment must have a space before
+            {
+                // This is a comment.
+                // Ignore it.
+                string  end_of_line;
+                getline (is, end_of_line);
+                build_types_context_line_new(is);
+                continue;
+            }
+
+            if ((parser_cfg != K_parser_cfg_parameters) &&    // 20090521 manage "..."+"..."
+                (is_str_limit (c_read)) &&
+                (result.empty () == false))
+            {
+                // A string begins (and so previous token is terminated).
+                return  true;
+            }
+        }
+
+        // Transform any space into blank.
+        if (isspace (c_read))
+            c_read = ' ';
+
+        result += c_read;
+        M_GET_FROM_ISTREAM(is);
+
+        if (c_read == end_of_str)
+        {
+            return  true;
+        }
+
+#define M_BEGIN_END(open_char,close_char)                                     \
+        else if (c_read == open_char)                                         \
+        {                                                                     \
+            if (append_to_string_until (is, result, close_char,               \
+                                        parser_cfg) == false)                 \
+                return  false;                                                \
+        }
+
+// 2009/02/21 : some time before, I had removed the 2 last lines
+// without -> bug on "1"+"2" which gives "1"+ and "2" intead of "1" + and "2"
+// with    -> bug on fatal ("Unknow msg identifier (%d)", Type);
+// Seems ok with supplementary test on K_parser_cfg_manage_comma
+#define M_BEGIN_END_STR(open_close_char)                                      \
+        else if (c_read == open_close_char)                                   \
+        {                                                                     \
+            if (append_to_string_until (is, result, open_close_char,          \
+                                        parser_cfg) == false)                 \
+                return  false;                                                \
+            if ((end_of_str == '\0') && ((parser_cfg & K_parser_cfg_manage_comma) == 0))      \
+                return  true;                                                 \
+        }
+//        }
+
+        if (is_str_limit (end_of_str)) { }
+        M_BEGIN_END ('(', ')')
+        M_BEGIN_END ('[', ']')
+        M_BEGIN_END_STR ('"')
+        M_BEGIN_END_STR ('\'')
+//         M_BEGIN_END ('{', '}')
+        else if ((c_read == '{') &&
+                 ((end_of_str != '\0') || (result.size () > 1)))
+        {
+            append_to_string_until (is, result, '}', parser_cfg);
+        }
+    }
+}
+
+//*****************************************************************************
+// end_of_str :
+// - '\0' means : space, tab, new_line, eof         and ;
+// - any caracter
+// returns true if ok (i.e. end_of_str found)
+//*****************************************************************************
+bool    append_to_string_until (istream       & is,
+                                string        & result,
+                          const char            end_of_str,
+                          const E_parser_cfg    parser_cfg)
+{
+    const bool  ok = append_to_string_until_base(is, result, end_of_str, parser_cfg);
+
+    if (ok && (result != ""))
+    {
+        // Remove all blanks at the end.
+        for (long long  idx = result.size() - 1; idx >= 0; --idx)
+        {
+            if (isspace(result[idx]) == 0)
+            {
+                ++idx;
+                if (static_cast<size_t>(idx) < result.size())
+                {
+                    result.erase(idx);
+                }
+                break;
+            }
+        }
+    }
+
+    return  ok;
+}
+
+//*****************************************************************************
+//*****************************************************************************
+bool       read_token_word_cplx (istream       & is,
+                                 string        & str_result,
+                           const E_parser_cfg    parser_cfg)
+{
+    str_result = "";
+    skip_blanks_and_comments(is);
+    if (is.good () == false)
+        return  false;
+
+    return  append_to_string_until (is, str_result, '\0', parser_cfg);
+}
+
+//*****************************************************************************
+//*****************************************************************************
+void    istream_to_words (istream         & is,
+                          vector<string>  & words,
+                    const E_parser_cfg      parser_cfg)
+{
+    string    word;
+    while (read_token_word_cplx (is, word, parser_cfg))
+    {
+        words.push_back (word);
+    }
+    if (is.eof () == false)
+    {
+        M_FATAL_COMMENT ("NOT eof !");
+    }
+}
+
+//*****************************************************************************
+//*****************************************************************************
+void    string_to_words (const string          & str,
+                               vector<string>  & words,
+                         const E_parser_cfg      parser_cfg)
+{
+    istringstream    is (str.c_str ());
+    istream_to_words (is, words, parser_cfg);
+}
+
+//*****************************************************************************
+// istream_hexa_space_to_frame ************************************************
+// ----------------------------------------------------------------------------
+// Format :
+// <byte in hexa>  <byte in hexa>  <byte in hexa>  ...
+//*****************************************************************************
+void    istream_hexa_space_to_frame (istream        & is,
+                                     T_byte_vector  & frame)
+{
+    while (is_istream_empty (is) == false)
+    {
+        // Get the hexa word.
+        string    str_value_hexa;
+        is >> str_value_hexa;
+
+        // Convert to int value.
+        int    value_hexa;
+        sscanf (str_value_hexa.c_str (), "%x", &value_hexa);
+
+        frame.push_back (value_hexa);
+    }
+}
+
+//*****************************************************************************
+// string_hexa_to_frame *******************************************************
+// ----------------------------------------------------------------------------
+// Format :
+// <byte in hexa><byte in hexa><byte in hexa><byte in hexa>...
+//*****************************************************************************
+void    string_hexa_to_frame (const string         & str_value_hexa,
+                                    T_byte_vector  & frame)
+{
+    M_ASSERT_EQ (str_value_hexa.size () % 2, 0);
+
+    const char  * p_str_value_hexa_end = str_value_hexa.c_str () +
+                                         str_value_hexa.size ();
+
+    for (const char  * p_str_value_hexa  = str_value_hexa.c_str ();
+                       p_str_value_hexa != p_str_value_hexa_end;
+                       p_str_value_hexa += 2)
+    {
+        // Convert to int value.
+        int    value_hexa;
+        sscanf (p_str_value_hexa, "%02x", &value_hexa);
+
+        frame.push_back (value_hexa);
+    }
+}
+
+//*****************************************************************************
+// istream_hexa_to_frame ******************************************************
+// ----------------------------------------------------------------------------
+// Format :
+// <byte in hexa><byte in hexa>  <byte in hexa>  <byte in hexa>  ...
+//*****************************************************************************
+void    istream_hexa_to_frame (istream        & is,
+                               T_byte_vector  & frame)
+{
+    while (is_istream_empty (is) == false)
+    {
+        // Get the hexa word.
+        string    str_value_hexa;
+        is >> str_value_hexa;
+
+        // Parse the hexa word.
+        string_hexa_to_frame (str_value_hexa, frame);
+    }
+}
+
+//*****************************************************************************
+// istream_hexa_dump_to_frame *************************************************
+// ----------------------------------------------------------------------------
+// Format :
+// [<??> <??>] <byte in hexa><byte in hexa>  <byte in hexa>  <end_of_hexa>  ...
+//*****************************************************************************
+void    istream_hexa_dump_to_frame (
+                                 istream        & is,
+                           const int              nb_of_first_words_to_ignore,
+                           const string         & end_of_hexa,
+                                 T_byte_vector  & frame)
+{
+    while (is_istream_empty (is) == false)
+    {
+        // Get the line.
+        string    str_line;
+        getline (is, str_line);
+
+        istringstream    is_line (str_line.c_str ());
+
+        // Ignore the first words.
+        for (int   idx = 0; idx < nb_of_first_words_to_ignore; ++idx)
+        {
+            string    to_ignore;
+            is_line >> to_ignore;
+        }
+
+        while (true)
+        {
+            // Get the hexa word.
+            string    str_value_hexa;
+            is_line >> str_value_hexa;
+
+            if (str_value_hexa == end_of_hexa)
+                break;
+
+            // Parse the hexa word.
+            string_hexa_to_frame (str_value_hexa, frame);
+        }
+    }
+}
+
+//*****************************************************************************
+// istream_to_frame ***********************************************************
+//*****************************************************************************
+// void    istream_to_frame (istream        & is,
+//                           T_byte_vector  & frame)
+// {
+//     istream_hexa_space_to_frame (is, frame);
+// }
+
+//*****************************************************************************
+// bin_file_to_frame **********************************************************
+//*****************************************************************************
+void    bin_file_to_frame (const string         & file_name,
+                                 T_byte_vector  & frame)
+{
+    M_TRACE_ENTER ("bin_file_to_frame", file_name);
+
+    // Compute size of the file.
+    size_t       size_file = 0;
+    {
+        struct stat  stat_data;
+        int    return_code_stat = stat (file_name.c_str(),
+                                        &stat_data);
+        M_ASSERT_EQ (return_code_stat, 0);
+        size_file = stat_data.st_size;
+    }
+
+    //
+    frame.resize (size_file);
+
+    // 
+    FILE  * file = fopen (file_name.c_str(), "rb");
+    M_ASSERT_NE (file, nullptr);
+
+    const size_t  nb_read = fread (&frame[0], size_file, 1, file);
+    M_ASSERT_EQ (nb_read, 1);
+
+    fclose (file);
+}
+
+//*****************************************************************************
+// get_number *****************************************************************
+//*****************************************************************************
+// Currently accept leading spaces BUT there is no warranty. 
+// string to integer accepts decimal, octal and hexa.
+//*****************************************************************************
+
+bool    get_number (const char*   word,
+                          long*   P_number)
+{
+    if (P_number != nullptr)
+        *P_number = 0;
+
+    if (strcmp(word, "") == 0)
+        return  false;
+
+    long    number = 0;
+    char*   endptr = nullptr;
+
+    errno = 0;
+    number = strtol(word, &endptr, 0);
+
+    if ((errno != 0) ||
+        (endptr == nullptr) ||
+        (*endptr != '\0'))
+        return  false;
+
+    if (P_number != nullptr)
+        *P_number = number;
+
+    return  true;
+}
+
+bool    get_number (const char*        word,
+                          long long  & number)
+{
+    return  get_number(word, 0, number);
+}
+
+bool    get_number (const char*        word,
+                          int          base,
+                          long long  & number)
+{
+    number = 0;
+
+    if (strcmp(word, "") == 0)
+        return  false;
+
+    char*   endptr = nullptr;
+
+    errno = 0;
+#if defined WIN32
+    number = _strtoi64(word, &endptr, base);
+#else
+    number = strtoll(word, &endptr, base);
+#endif
+
+    if ((errno != 0) ||
+        (endptr == nullptr) ||
+        (*endptr != '\0'))
+        return  false;
+
+    return  true;
+}
+
+bool    get_number (const char*        word,
+                          double     & out_number)
+{
+    out_number = 0.0;
+
+    if (strcmp (word,"") == 0)
+        return  false;
+
+    char*   endptr = nullptr;
+
+    errno = 0;
+    out_number = strtod (word, &endptr);
+
+    if ((errno != 0) ||
+        (endptr == nullptr) ||
+        (*endptr != '\0'))
+        return  false;
+
+    // Zero leading is simply ignored by strtod -> wrong result value.
+    {
+        const char  * first_digit = word;
+        while (isdigit(*first_digit) == 0)
+        {
+            ++first_digit;
+            if (*first_digit == '\0')
+                break;
+        }
+        if (*first_digit == '0')
+        {
+            ++first_digit;
+            if (isdigit(*first_digit))
+            {
+                // Zero followed by a digit -> octal number, not a float number.
+                return  false;
+            }
+        }
+    }
+
+    return  true;
+}
+
+//*****************************************************************************
+// ----------------------------------------------------------------------------
+// Format :
+// <str_left without separator><separator><str_right which could be anything>]
+//*****************************************************************************
+E_return_code  get_before_separator_after (const string  & str,
+                                           const char      separator,
+                                                 string  & str_left,
+                                                 string  & str_right)
+{
+    // Searching for separator.
+    const string::size_type  idx = str.find (separator);
+
+    if (idx == string::npos)
+        return  E_rc_not_found;
+
+    str_left  = str.substr (0, idx - 0);
+    str_right = str.substr (idx + 1);
+
+    return  E_rc_ok;
+}
+
+//*****************************************************************************
+// ----------------------------------------------------------------------------
+// Format :
+// <str_left without separator><separator><str_right which could be anything>]
+//*****************************************************************************
+E_return_code  get_before_separator_after (const string  & str,
+                                           const string  & separator,
+                                                 string  & str_left,
+                                                 string  & str_right)
+{
+    // Searching for separator.
+    const string::size_type  idx = str.find (separator);
+
+    if (idx == string::npos)
+        return  E_rc_not_found;
+
+    str_left  = str.substr (0, idx - 0);
+    str_right = str.substr (idx + separator.size());
+
+    return  E_rc_ok;
+}
+
+//*****************************************************************************
+// ----------------------------------------------------------------------------
+// Format :
+// <left_part><separator_left><value_str><separator_right>
+// e.g with ( ) :
+// really_anything_including(...)(...(...)...(...)...)
+// <--- left_part --------------> <--- value_str --->
+//*****************************************************************************
+E_return_code    decompose_type_sep_value_sep (
+                        const string     orig_type,
+                        const char       separator_left,
+                        const char       separator_right,
+                              string   & left_part,
+                              string   & value_str)
+{
+    // Searching for separator_right which must be at the end.
+    const string::size_type  idx_right = orig_type.rfind (separator_right);
+
+    if (idx_right == string::npos)
+        return  E_rc_not_found;
+
+    if (idx_right != orig_type.size () - 1)
+        return  E_rc_not_found;
+
+    // Searching for separator_left.
+    int                number_of_separator_left_to_find = 1;
+    string::size_type  idx_left = idx_right-1;
+
+    while (idx_left > 0)                         // do NOT accept empty left_part
+    {
+        if (orig_type[idx_left] == separator_left)
+        {
+            --number_of_separator_left_to_find;
+            if (number_of_separator_left_to_find <= 0)
+                break;
+        }
+        else if ((separator_left != separator_right) &&
+                 (orig_type[idx_left] == separator_right))
+        {
+            ++number_of_separator_left_to_find;
+        }
+
+        --idx_left;
+    }
+
+    if ((idx_left <= 0) || (number_of_separator_left_to_find != 0))
+        return  E_rc_not_found;
+
+    // Extract data part.
+    // NB: orig_type is a copy and not a reference
+    //      to avoid pb if left_part or value_str are the same reference
+    left_part = orig_type.substr (0, idx_left - 0);
+    value_str = orig_type.substr (idx_left+1, idx_right - (idx_left+1));
+
+    return  E_rc_ok;
+}
+
+//*****************************************************************************
+// ----------------------------------------------------------------------------
+// Format :
+// <left_part><separator_left><middle_part><separator_right><right_part>
+// e.g with ( ) :
+// really_anything_but_not(...)(...(...)...(...)...)really_anything_including(...)
+// <--- left_part ------------> <--- middle_part -> <--- right_part ------------->
+//*****************************************************************************
+E_return_code    decompose_left_sep_middle_sep_right (
+                        const string     orig_type,
+                        const char       separator_left,
+                        const char       separator_right,
+                              string   & left_part,
+                              string   & middle_part,
+                              string   & right_part)
+{
+    // Searching for separator_left.
+    const string::size_type  idx_left = orig_type.find (separator_left);
+
+    if (idx_left == string::npos)
+        return  E_rc_not_found;
+
+    // Searching for separator_right.
+    int                number_of_separator_right_to_find = 1;
+    string::size_type  idx_right = idx_left+1;
+
+    while (idx_right < orig_type.size())
+    {
+        if (orig_type[idx_right] == separator_right)
+        {
+            --number_of_separator_right_to_find;
+            if (number_of_separator_right_to_find <= 0)
+                break;
+        }
+        else if ((separator_left != separator_right) &&
+                 (orig_type[idx_right] == separator_left))
+        {
+            ++number_of_separator_right_to_find;
+        }
+
+        ++idx_right;
+    }
+
+    if ((idx_right >= orig_type.size()) || (number_of_separator_right_to_find != 0))
+        return  E_rc_not_found;
+
+    // Extract data part.
+    // NB: orig_type is a copy and not a reference
+    //      to avoid pb if left_part or middle_part or right_part are the same reference
+    left_part   = orig_type.substr (0, idx_left - 0);
+    middle_part = orig_type.substr (idx_left+1, idx_right - (idx_left+1));
+    right_part  = orig_type.substr (idx_right+1);
+
+    return  E_rc_ok;
+}
+
+//*****************************************************************************
+// I definitively do not try :
+// - to solve all the cases
+// - to detect all the errors
+//*****************************************************************************
+
+void    promote_printf_string_to_64bits(string   & printf_string)
+{
+    const string::size_type  size_before = printf_string.size();
+
+    string::size_type  idx_any = 0;
+    while ((idx_any = printf_string.find ('%', idx_any)) != string::npos)
+    {
+        ++idx_any;
+        if (idx_any >= printf_string.size())
+        {
+            M_FATAL_COMMENT("bad printf format " << printf_string << " with last character % (should be %% to print % ?)");
+            return;
+        }
+
+        if (printf_string[idx_any] == '%')
+        {
+            // %% is not a printf format directive.
+            ++idx_any;
+            continue;
+        }
+
+        while (isalpha(printf_string[idx_any]) == 0)
+        {
+            ++idx_any;
+            if (idx_any >= printf_string.size())
+            {
+                M_FATAL_COMMENT("bad printf format string gives >" << printf_string << "< %... must end with a letter");
+                return;
+            }
+        }
+
+        if ((printf_string[idx_any] == 'h') ||   // for short integer        wsgd integers are always 64 bits
+            (printf_string[idx_any] == 'l') ||   // for long  integer        wsgd integers are always 64 bits
+            (printf_string[idx_any] == 'L'))     // for long double          not managed
+        {
+            M_FATAL_COMMENT("bad printf format string gives >" << printf_string << "< %... must not contains h, l or L");
+            return;
+        }
+
+        if (printf_string[idx_any] != 's')
+        {
+            if ((printf_string[idx_any] == 'd') ||
+                (printf_string[idx_any] == 'i') ||
+                (printf_string[idx_any] == 'o') ||
+                (printf_string[idx_any] == 'u') ||
+                (printf_string[idx_any] == 'x') ||
+                (printf_string[idx_any] == 'X'))
+            {
+                // wsgd integers are always 64 bits
+#ifdef WIN32
+                printf_string.insert(idx_any, "I64");
+                idx_any += 4;
+#else
+                printf_string.insert(idx_any, "ll");
+                idx_any += 3;
+#endif
+            }
+        }
+    }
+
+    if (printf_string.size() != size_before)
+    {
+        M_TRACE_DEBUG("promote_printf_string_to_64bits gives >" << printf_string << "<");
+    }
+}
+
+//*****************************************************************************
+// Dump hexa.
+//*****************************************************************************
+static const long  K_NB_BYTES_PER_LINE = 16;
+ 
+void    dump_buffer (      ostream &  os,
+                     const void *     A_buffer,
+                     const long       P_user_length)
+{
+    const unsigned char *   PA_buffer = static_cast<const unsigned char *>(A_buffer);
+    long     P_length = P_user_length;
+    long     I_offset = 0;
+
+    while (P_length > 0)
+    {
+        const long  I_limite_boucle = (P_length >= K_NB_BYTES_PER_LINE) ? K_NB_BYTES_PER_LINE : P_length;
+
+        // affichage offset
+        char     line[256];
+        char     line_part[256];
+        sprintf(line, "%08lx : ", I_offset);
+
+        // dump hexa
+        long     I_count;
+        for (I_count = 0; I_count < I_limite_boucle; I_count++)
+        {
+            sprintf(line_part, "%02x ", PA_buffer[I_count]);
+            strcat(line, line_part);
+        }
+
+        // ecriture fin ligne dump hexa en blanc
+        // si nb < K_NB_BYTES_PER_LINE
+        while (I_count < K_NB_BYTES_PER_LINE)
+        {
+            sprintf(line_part, "   ");
+            strcat(line, line_part);
+            I_count++;
+        }
+
+
+        // separation entre hexa et ascii
+        sprintf(line_part, " - ");
+        strcat(line, line_part);
+
+
+        // dump ascii
+        for (I_count = 0; I_count < I_limite_boucle; I_count++)
+        {
+            if (isprint(PA_buffer[I_count]))
+            {
+                sprintf(line_part, "%c", PA_buffer[I_count]);
+            }
+            else
+            {
+                sprintf(line_part, ".");
+            }
+            strcat(line, line_part);
+        }
+
+        assert(strlen(line) < 256);
+
+        // ecriture fin ligne dump ascii en blanc
+        // si nb < K_NB_BYTES_PER_LINE
+        while (I_count < K_NB_BYTES_PER_LINE)
+        {
+            sprintf(line_part, " ");
+            strcat(line, line_part);
+            I_count++;
+        }
+
+
+        // print line in output file      
+        assert(strlen(line) < 256);
+        os << line << endl;
+
+        PA_buffer += K_NB_BYTES_PER_LINE;
+        P_length -= K_NB_BYTES_PER_LINE;
+        I_offset += K_NB_BYTES_PER_LINE;
+    }
+}
+
diff --git a/plugins/epan/generic/byte_interpret_parse.h b/plugins/epan/generic/byte_interpret_parse.h
new file mode 100644
index 00000000000..0037d7dd397
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_parse.h
@@ -0,0 +1,171 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef BYTE_INTERPRET_PARSE_H
+#define BYTE_INTERPRET_PARSE_H
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <string>
+#include <sstream>
+#include <vector>
+using namespace std;
+
+#include "byte_interpret_common.h"
+
+
+//*****************************************************************************
+// 
+//*****************************************************************************
+
+void    skip_blanks_and_comments (istream  & is);
+void    skip_line (istream  & is);
+bool    is_istream_empty (istream &         is);
+
+//*****************************************************************************
+// 
+//*****************************************************************************
+
+void       mod_replace_all (      string  & str_to_modify,
+                            const string  & replace_old,
+                            const string  & replace_new);
+
+string     get_replace_all (      string    str_copy,
+                            const string  & replace_old,
+                            const string  & replace_new);
+
+void    remove_word_limits (string  & str,
+                      const char      limit_left,
+                      const char      limit_right);
+void    remove_string_limits (string  & str);
+bool    is_separator (const char   c);
+
+//*****************************************************************************
+// parser
+//*****************************************************************************
+
+#define K_parser_cfg_manage_blanks                1    /* blank = separator */
+#define K_parser_cfg_ignore_comments_sharp        2
+//#define K_parser_cfg_ignore_comments_C            4
+//#define K_parser_cfg_ignore_comments_CPP          8
+#define K_parser_cfg_keep_strings                16    /* manage "..." */
+#define K_parser_cfg_manage_blocks_open_close    32    /* sauf { isole */
+#define K_parser_cfg_manage_separator_C          64    /*  */
+#define K_parser_cfg_manage_comma               128    /* , = separator */
+#define K_parser_cfg_manage_dot_comma           256    /* ; = separator */
+
+#define K_parser_cfg_common  K_parser_cfg_ignore_comments_sharp | K_parser_cfg_keep_strings | K_parser_cfg_manage_blocks_open_close | K_parser_cfg_manage_dot_comma
+
+enum E_parser_cfg
+{
+    E_parser_cfg_normal      = K_parser_cfg_common | K_parser_cfg_manage_blanks,
+    E_parser_cfg_C           = K_parser_cfg_common | K_parser_cfg_manage_blanks | K_parser_cfg_manage_separator_C,
+    E_parser_cfg_parameters  = K_parser_cfg_common | K_parser_cfg_manage_comma,
+    E_parser_cfg_expression  = K_parser_cfg_common  // a tester
+};
+
+#define K_parser_cfg_normal        E_parser_cfg_normal
+#define K_parser_cfg_C             E_parser_cfg_C
+#define K_parser_cfg_parameters    E_parser_cfg_parameters
+#define K_parser_cfg_expression    E_parser_cfg_expression
+
+bool       read_token_word_cplx (
+                            istream       & is,
+                            string        & str_result,
+                      const E_parser_cfg    parser_cfg = K_parser_cfg_normal);
+void    istream_to_words (istream         & is,
+                          vector<string>  & words,
+                    const E_parser_cfg      parser_cfg = K_parser_cfg_normal);
+void    string_to_words (
+                    const string          & str,
+                          vector<string>  & words,
+                    const E_parser_cfg      parser_cfg = K_parser_cfg_normal);
+
+//*****************************************************************************
+// binary to frame
+//*****************************************************************************
+
+typedef vector<T_byte>  T_byte_vector;
+
+
+void    string_hexa_to_frame (const string         & str_value_hexa,
+                                    T_byte_vector  & frame);
+void    istream_hexa_to_frame (istream        & is,
+                               T_byte_vector  & frame);
+void    istream_hexa_dump_to_frame (
+                                 istream        & is,
+                           const int              nb_of_first_words_to_ignore,
+                           const string         & end_of_hexa,
+                                 T_byte_vector  & frame);
+void    bin_file_to_frame (const string  & file_name,
+                                 T_byte_vector  & frame);
+
+//*****************************************************************************
+// get_number
+//*****************************************************************************
+
+bool    get_number (const char*   word,
+                          long*   P_number);
+bool    get_number (const char*        word,
+                          long long  & P_number);
+bool    get_number (const char*        word,
+                          int          base,
+                          long long  & number);
+bool    get_number (const char*        word,
+                          double     & P_number);
+
+//*****************************************************************************
+// parse a string
+//*****************************************************************************
+
+E_return_code  get_before_separator_after (const string  & str,
+                                           const char      separator,
+                                                 string  & str_left,
+                                                 string  & str_right);
+E_return_code  get_before_separator_after (const string  & str,
+                                           const string  & separator,
+                                                 string  & str_left,
+                                                 string  & str_right);
+E_return_code    decompose_type_sep_value_sep (
+                        const string     orig_type,
+                        const char       separator_left,
+                        const char       separator_right,
+                              string   & left_part,
+                              string   & value_str);
+
+E_return_code    decompose_left_sep_middle_sep_right (
+                        const string     orig_type,
+                        const char       separator_left,
+                        const char       separator_right,
+                              string   & left_part,
+                              string   & middle_part,
+                              string   & right_part);
+
+void    promote_printf_string_to_64bits(string   & printf_string);
+
+//*****************************************************************************
+// dump hexa
+//*****************************************************************************
+
+void    dump_buffer (      ostream &  os,
+                     const void *     A_buffer,
+                     const long       P_user_length);
+
+#endif /* BYTE_INTERPRET_PARSE_H */
diff --git a/plugins/epan/generic/byte_interpret_plugin.h b/plugins/epan/generic/byte_interpret_plugin.h
new file mode 100644
index 00000000000..682a683ecf4
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_plugin.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2012-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef BYTE_INTERPRET_PLUGIN_H
+#define BYTE_INTERPRET_PLUGIN_H
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+
+#ifndef EXTERN_C
+#ifdef __cplusplus
+#define EXTERN_C    extern "C"
+#else
+#define EXTERN_C    
+#endif
+#endif
+
+#ifndef LIBRARY_EXPORT
+#ifdef WIN32
+#define LIBRARY_EXPORT  __declspec(dllexport)
+#else
+#define LIBRARY_EXPORT
+#endif
+#endif
+
+//*****************************************************************************
+// T_byte_interpret_plugin_output
+//*****************************************************************************
+#if 0
+struct T_byte_interpret_plugin_output
+{
+    const char  * P_user_data;
+};
+#endif
+
+
+#endif /* BYTE_INTERPRET_PLUGIN_H */
diff --git a/plugins/epan/generic/byte_interpret_plugin_output.h b/plugins/epan/generic/byte_interpret_plugin_output.h
new file mode 100644
index 00000000000..12307c11d5f
--- /dev/null
+++ b/plugins/epan/generic/byte_interpret_plugin_output.h
@@ -0,0 +1,308 @@
+/*
+ * Copyright 2012-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef BYTE_INTERPRET_PLUGIN_OUTPUT_H
+#define BYTE_INTERPRET_PLUGIN_OUTPUT_H
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include "byte_interpret_plugin.h"
+
+
+//*****************************************************************************
+// T_byte_interpret_plugin_output_context
+//*****************************************************************************
+
+struct T_byte_interpret_plugin_output_context
+{
+    const void  * P_null1;
+    const void  * P_null2;
+    const void  * P_library_name;
+    const char  * P_user_data;
+
+#ifdef __cplusplus
+    T_byte_interpret_plugin_output_context()
+        :P_null1(nullptr),
+         P_null2(nullptr),
+         P_library_name(nullptr),
+         P_user_data(nullptr)
+    {
+    }
+#endif
+};
+
+//*****************************************************************************
+// byte_interpret_plugin_output_begin *****************************************
+//*****************************************************************************
+// Called when a new capture is started.
+// Called when a new capture file is loaded.
+// ...
+//*****************************************************************************
+EXTERN_C 
+LIBRARY_EXPORT
+void    byte_interpret_plugin_output_begin(
+                const T_byte_interpret_plugin_output_context   * P_context);
+
+typedef void  (* T_byte_interpret_plugin_output_begin_cb)(
+                const T_byte_interpret_plugin_output_context   * P_context);
+
+//*****************************************************************************
+// byte_interpret_plugin_output_value_integer *********************************
+//*****************************************************************************
+EXTERN_C 
+LIBRARY_EXPORT
+void    byte_interpret_plugin_output_value_integer(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     type_name,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     final_type,
+                const long long                                  data_value,
+                const char *                                     data_value_str,
+                const char *                                     error);
+
+typedef void  (* T_byte_interpret_plugin_output_value_integer_cb)(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     type_name,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     final_type,
+                const long long                                  data_value,
+                const char *                                     data_value_str,
+                const char *                                     error);
+
+//*****************************************************************************
+// byte_interpret_plugin_output_value_float ***********************************
+//*****************************************************************************
+EXTERN_C 
+LIBRARY_EXPORT
+void    byte_interpret_plugin_output_value_float(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     type_name,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     final_type,
+                const double                                     data_value,
+                const char *                                     data_value_str,
+                const char *                                     error);
+
+typedef void  (* T_byte_interpret_plugin_output_value_float_cb)(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     type_name,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     final_type,
+                const double                                     data_value,
+                const char *                                     data_value_str,
+                const char *                                     error);
+
+//*****************************************************************************
+// byte_interpret_plugin_output_value_string **********************************
+//*****************************************************************************
+EXTERN_C 
+LIBRARY_EXPORT
+void    byte_interpret_plugin_output_value_string(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     type_name,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     final_type,
+                const char *                                     data_value,
+                const char *                                     data_value_str,
+                const char *                                     error);
+
+typedef void  (* T_byte_interpret_plugin_output_value_string_cb)(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     type_name,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     final_type,
+                const char *                                     data_value,
+                const char *                                     data_value_str,
+                const char *                                     error);
+
+//*****************************************************************************
+// byte_interpret_plugin_output_raw_data **************************************
+//*****************************************************************************
+EXTERN_C 
+LIBRARY_EXPORT
+void    byte_interpret_plugin_output_raw_data(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     type_name,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const int                                        type_bit_size/*,
+                const E_raw_data_type                            raw_data_type*/);
+
+typedef void  (* T_byte_interpret_plugin_output_raw_data_cb)(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     type_name,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const int                                        type_bit_size/*,
+                const E_raw_data_type                            raw_data_type*/);
+
+//*****************************************************************************
+// byte_interpret_plugin_output_group_begin ***********************************
+//*****************************************************************************
+EXTERN_C 
+LIBRARY_EXPORT
+void    byte_interpret_plugin_output_group_begin(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     type_name,
+                const char *                                     data_name,
+                const char *                                     data_simple_name);
+
+typedef void  (* T_byte_interpret_plugin_output_group_begin_cb)(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     type_name,
+                const char *                                     data_name,
+                const char *                                     data_simple_name);
+
+//*****************************************************************************
+// byte_interpret_plugin_output_group_append_text *****************************
+//*****************************************************************************
+EXTERN_C 
+LIBRARY_EXPORT
+void    byte_interpret_plugin_output_group_append_text(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     text);
+
+typedef void  (* T_byte_interpret_plugin_output_group_append_text_cb)(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     text);
+
+//*****************************************************************************
+// byte_interpret_plugin_output_group_end *************************************
+//*****************************************************************************
+EXTERN_C 
+LIBRARY_EXPORT
+void    byte_interpret_plugin_output_group_end(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     type_name,
+                const char *                                     data_name,
+                const char *                                     data_simple_name);
+
+typedef void  (* T_byte_interpret_plugin_output_group_end_cb)(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     type_name,
+                const char *                                     data_name,
+                const char *                                     data_simple_name);
+
+//*****************************************************************************
+// byte_interpret_plugin_output_error *****************************************
+//*****************************************************************************
+EXTERN_C 
+LIBRARY_EXPORT
+void    byte_interpret_plugin_output_error(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     error);
+
+typedef void  (* T_byte_interpret_plugin_output_error_cb)(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     error);
+
+//*****************************************************************************
+// byte_interpret_plugin_output_missing_data **********************************
+//*****************************************************************************
+EXTERN_C 
+LIBRARY_EXPORT
+void    byte_interpret_plugin_output_missing_data(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     type_name,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     error);
+
+typedef void  (* T_byte_interpret_plugin_output_missing_data_cb)(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     type_name,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     error);
+
+//*****************************************************************************
+// byte_interpret_plugin_output_cmd_error *************************************
+//*****************************************************************************
+EXTERN_C 
+LIBRARY_EXPORT
+void    byte_interpret_plugin_output_cmd_error(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     error);
+
+typedef void  (* T_byte_interpret_plugin_output_cmd_error_cb)(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     error);
+
+
+
+//*****************************************************************************
+// byte_interpret_plugin_output_cmd_print *************************************
+//*****************************************************************************
+EXTERN_C 
+LIBRARY_EXPORT
+void    byte_interpret_plugin_output_cmd_print(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     text);
+
+typedef void  (* T_byte_interpret_plugin_output_cmd_print_cb)(
+                const T_byte_interpret_plugin_output_context   * P_context,
+                const void                                     * P_null,
+                const char *                                     data_name,
+                const char *                                     data_simple_name,
+                const char *                                     text);
+
+
+#endif /* BYTE_INTERPRET_PLUGIN_OUTPUT_H */
diff --git a/plugins/epan/generic/cmake_wireshark_version_number.cmake b/plugins/epan/generic/cmake_wireshark_version_number.cmake
new file mode 100644
index 00000000000..15bae5f48d2
--- /dev/null
+++ b/plugins/epan/generic/cmake_wireshark_version_number.cmake
@@ -0,0 +1,4 @@
+
+# WIRESHARK_VERSION_NUMBER=<major><minor_on_2_digits><micro_on_2_digits>
+# Example for Wireshark 2.4.0
+add_definitions(-DWIRESHARK_VERSION_NUMBER=40100)
diff --git a/plugins/epan/generic/generic.cpp b/plugins/epan/generic/generic.cpp
new file mode 100644
index 00000000000..750074961c0
--- /dev/null
+++ b/plugins/epan/generic/generic.cpp
@@ -0,0 +1,2748 @@
+/* generic.c
+ * Copyright 2008-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * $Id: 
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes
+//*****************************************************************************
+
+#include "generic.h"
+#include "T_generic_protocol_data.h"
+
+#include <limits.h>
+#include <stdlib.h>
+
+#include "byte_interpret_common.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret_build_types.h"
+#include "byte_interpret_build_types_context.h"
+#include "byte_interpret.h"
+#include "byte_interpret_compute_expression.h"
+#include "T_interpret_data.h"
+#include "byte_interpret_builder.h"
+#include "C_byte_interpret_wsgd_builder.h"
+#include "C_byte_interpret_wsgd_builder_base.h"
+#include "C_setlocale_numeric_C_guard.h"
+#include <fstream>
+
+#ifdef WIN32
+#include <process.h>
+#define getpid  _getpid
+#define strdup  _strdup
+#else
+#include <unistd.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <epan/tvbuff.h>
+#include <wsutil/filesystem.h>
+#include <wsutil/report_message.h>
+#include <epan/conversation.h>
+#include <epan/tap.h>
+#include <epan/stats_tree.h>
+#include <epan/stats_tree_priv.h>  // to retrieve the protocol_data
+#include <epan/prefs.h>
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#ifndef WIRESHARK_VERSION_NUMBER
+#error you must define WIRESHARK_VERSION_NUMBER as <major><minor_on_2_digits><micro_on_2_digits>
+#endif
+
+//*****************************************************************************
+// register_enum_values
+//*****************************************************************************
+
+void    register_enum_values(T_generic_protocol_data  & protocol_data)
+{
+    M_TRACE_ENTER ("register_enum_values", "proto_idx=" << protocol_data.proto_idx);
+
+    T_type_definitions  & type_definitions = protocol_data.type_definitions;
+    T_map_enum_definition_representation  & map_enum_definition_representation = type_definitions.map_enum_definition_representation;
+
+    M_TRACE_DEBUG ("max_nb_of_enums=" << map_enum_definition_representation.size());
+
+    int   enum_idx = 0;
+    for (T_map_enum_definition_representation::iterator
+                             iter  = map_enum_definition_representation.begin();
+                             iter != map_enum_definition_representation.end();
+                           ++iter)
+    {
+        const string                      & enum_type_name = iter->first;
+        T_enum_definition_representation  & definition_representation = iter->second;
+        definition_representation.wsgd_enum_values_idx = enum_idx;
+
+        const T_enum_definition                 & definition = definition_representation.definition;
+
+        M_TRACE_DEBUG ("add enum  enum_idx=" << enum_idx <<
+                       "  name=" << enum_type_name <<
+                       "  nb_values=" << definition.size());
+
+        T_generic_protocol_enum_value  enum_value;
+
+        int     enum_value_idx = 0;
+        for (T_enum_definition::const_iterator
+                             iter_value  = definition.begin();
+                             iter_value != definition.end();
+                           ++iter_value)
+        {
+            const T_enum_name_val  & enum_name_val = *iter_value;
+
+            M_TRACE_DEBUG ("add enum value  enum_idx=" << enum_idx << "  enum_value_idx="  << enum_value_idx <<
+                            "  (" << enum_name_val.value << ", " << enum_name_val.name << ")");
+
+            value_string    vs;
+            vs.value  = static_cast<const int>(enum_name_val.value);
+            vs.strptr = strdup (enum_name_val.name.c_str());
+
+            enum_value.value_strings.push_back(vs);
+
+            ++enum_value_idx;
+        }
+
+        // Must add a last value_string with nullptr ptr.
+        {
+            value_string    vs;
+            vs.value  = 0;
+            vs.strptr = nullptr;
+
+            enum_value.value_strings.push_back(vs);
+        }
+
+        protocol_data.ws_data.enum_values_data.enum_values.push_back(enum_value);
+
+        ++enum_idx;
+    }
+}
+
+//*****************************************************************************
+// register_fields_add_field_...
+//*****************************************************************************
+
+void    register_fields_add_field_none(
+                                         T_generic_protocol_data      & protocol_data,
+                                   const int                            field_idx,
+                                   const char                         * field_name,
+                                   const char                         * field_filter_name_param,
+                                   const char                         * field_extended_name)
+{
+    T_generic_protocol_ws_data      * P_protocol_ws_data = &protocol_data.ws_data;
+
+    M_FATAL_IF_NE(field_idx, (int)P_protocol_ws_data->fields_data.hf.size());
+
+    const string                   filter_field_name = protocol_data.PROTOABBREV + "." + field_filter_name_param;
+    hf_register_info               hf = 
+        { nullptr,    // initialized later
+          { strdup(field_name),
+            strdup(filter_field_name.c_str()), FT_NONE, BASE_NONE, nullptr, 0x0,
+            strdup(field_extended_name), HFILL }};
+
+    P_protocol_ws_data->fields_data.hf.push_back(hf);
+}
+
+void    register_fields_add_field_none(
+                                         T_generic_protocol_data      & protocol_data,
+                                   const int                            field_idx,
+                                   const T_field_type_name            & field_name)
+{
+    T_generic_protocol_ws_data      * P_protocol_ws_data = &protocol_data.ws_data;
+
+    M_FATAL_IF_NE(field_idx, (int)P_protocol_ws_data->fields_data.hf.size());
+
+    const string                   filter_field_name = protocol_data.PROTOABBREV + "." + field_name.get_filter_name();
+    hf_register_info               hf = 
+        { nullptr,    // initialized later
+          { strdup(field_name.get_display_name().c_str()),
+            strdup(filter_field_name.c_str()), FT_NONE, BASE_NONE, nullptr, 0x0,
+            strdup(field_name.get_extended_name().c_str()), HFILL }};
+
+    P_protocol_ws_data->fields_data.hf.push_back(hf);
+}
+
+void    register_fields_add_field_bytes(
+                                         T_generic_protocol_data      & protocol_data,
+                                   const int                            field_idx,
+                                   const T_field_type_name            & field_name)
+{
+    T_generic_protocol_ws_data      * P_protocol_ws_data = &protocol_data.ws_data;
+
+    M_FATAL_IF_NE(field_idx, (int)P_protocol_ws_data->fields_data.hf.size());
+
+    const string                   filter_field_name = protocol_data.PROTOABBREV + "." + field_name.get_filter_name();
+    hf_register_info               hf = 
+        { nullptr,    // initialized later
+          { strdup(field_name.get_display_name().c_str()),
+            strdup(filter_field_name.c_str()), FT_BYTES, BASE_NONE, nullptr, 0x0,
+            strdup(field_name.get_extended_name().c_str()), HFILL }};
+
+    P_protocol_ws_data->fields_data.hf.push_back(hf);
+}
+
+void    register_fields_add_field_string(
+                                         T_generic_protocol_data      & protocol_data,
+                                   const int                            field_idx,
+                                   const T_field_type_name            & field_name)
+{
+    T_generic_protocol_ws_data      * P_protocol_ws_data = &protocol_data.ws_data;
+
+    M_FATAL_IF_NE(field_idx, (int)P_protocol_ws_data->fields_data.hf.size());
+
+    const string                   filter_field_name = protocol_data.PROTOABBREV + "." + field_name.get_filter_name();
+    hf_register_info               hf = 
+        { nullptr,    // initialized later
+          { strdup(field_name.get_display_name().c_str()),
+            strdup(filter_field_name.c_str()), FT_STRING, BASE_NONE, nullptr, 0x0,
+            strdup(field_name.get_extended_name().c_str()), HFILL }};
+
+    P_protocol_ws_data->fields_data.hf.push_back(hf);
+}
+
+void    register_fields_add_field_float(
+                                         T_generic_protocol_data      & protocol_data,
+                                   const int                            field_idx,
+                                   const T_field_type_name            & field_name,
+                                   const int                            field_bit_size)
+{
+    T_generic_protocol_ws_data      * P_protocol_ws_data = &protocol_data.ws_data;
+
+    M_FATAL_IF_NE(field_idx, (int)P_protocol_ws_data->fields_data.hf.size());
+
+    const string                   filter_field_name = protocol_data.PROTOABBREV + "." + field_name.get_filter_name();
+    ftenum                         ws_size = field_bit_size<=32 ? FT_FLOAT : FT_DOUBLE;
+    hf_register_info               hf = 
+        { nullptr,    // initialized later
+          { strdup(field_name.get_display_name().c_str()),
+            strdup(filter_field_name.c_str()), ws_size, BASE_NONE, nullptr, 0x0,
+            strdup(field_name.get_extended_name().c_str()), HFILL }};
+
+    P_protocol_ws_data->fields_data.hf.push_back(hf);
+}
+
+void    register_fields_add_field_int(
+                                         T_generic_protocol_data      & protocol_data,
+                                   const int                            field_idx,
+                                   const T_field_type_name            & field_name,
+                                   const int                            field_bit_size,
+                                   const bool                           is_signed,
+                                   const int                            enum_idx)
+{
+    T_generic_protocol_ws_data      * P_protocol_ws_data = &protocol_data.ws_data;
+
+    M_FATAL_IF_NE(field_idx, (int)P_protocol_ws_data->fields_data.hf.size());
+
+    const string                   filter_field_name = protocol_data.PROTOABBREV + "." + field_name.get_filter_name();
+
+    const ftenum    ws_size_unsign[] = { FT_UINT8, FT_UINT16, FT_UINT24, FT_UINT32, FT_NONE, FT_NONE, FT_NONE, FT_UINT64 };
+    const ftenum    ws_size_signed[] = {  FT_INT8,  FT_INT16,  FT_INT24,  FT_INT32, FT_NONE, FT_NONE, FT_NONE,  FT_INT64 };
+
+    int           field_byte_size = field_bit_size / 8;
+
+    M_FATAL_IF_LT(field_byte_size, 1);
+    M_FATAL_IF_GT(field_byte_size, (int)(sizeof(ws_size_unsign)/sizeof(ws_size_unsign[0])));
+
+    // wireshark (proto.c) forbids enum with size > 4 bytes
+    // NB: could have enum with size = 8 only
+    //      with must_force_manage_as_biggest_int and so
+    //      in case of var (i.e. not a field read inside the packet)
+    if (enum_idx >= 0)
+        field_byte_size = 4;
+
+    ftenum                         ws_size;
+    if (is_signed)
+    {
+        ws_size = ws_size_signed[field_byte_size - 1];
+    }
+    else
+    {
+        ws_size = ws_size_unsign[field_byte_size - 1];
+    }
+    M_FATAL_IF_EQ(ws_size, FT_NONE);
+
+    hf_register_info               hf = 
+        { nullptr,    // initialized later
+          { strdup(field_name.get_display_name().c_str()),
+            strdup(filter_field_name.c_str()), ws_size, BASE_DEC, nullptr, 0x0,
+            strdup(field_name.get_extended_name().c_str()), HFILL }};
+
+    if (enum_idx >= 0)
+    {
+        hf.hfinfo.strings = VALS(&P_protocol_ws_data->enum_values_data.enum_values[enum_idx].value_strings[0]);
+    }
+
+    P_protocol_ws_data->fields_data.hf.push_back(hf);
+}
+
+//*****************************************************************************
+// register_fields_field_type_name
+// Must be coherent with frame_to_any.
+//*****************************************************************************
+bool    S_ICIOA_in_bitfield = false;
+
+void    register_fields_struct_fields(T_generic_protocol_data  & protocol_data,
+                                      int                      & field_idx,
+                                      T_struct_fields          & struct_fields);
+
+void    register_fields_struct_definition(T_generic_protocol_data      & protocol_data,
+                                          int                          & field_idx,
+                                          T_struct_definition          & struct_definition);
+
+void    register_fields_bitfield_definition(T_generic_protocol_data      & protocol_data,
+                                            int                          & field_idx,
+                                            T_bitfield_definition        & bitfield_definition);
+
+void    register_fields_switch_definition(T_generic_protocol_data      & protocol_data,
+                                          int                          & field_idx,
+                                          T_switch_definition          & switch_definition);
+
+void    register_fields_field_type_name(T_generic_protocol_data          & protocol_data,
+                                        int                              & field_idx,
+                                        T_field_type_name                & field_type_name,
+                                  const string                           & data_type)
+{
+    M_TRACE_ENTER ("register_fields_field_type_name",
+                    "proto_idx=" << protocol_data.proto_idx << "  " <<
+                    "field_idx=" << field_idx << "  " <<
+                    "field_type_name.type=" << field_type_name.type << "  " <<
+                    "field_type_name.name=" << field_type_name.name << "  " <<
+                    "data_type=" << data_type << "  ");
+
+    T_type_definitions       & type_definitions = protocol_data.type_definitions;
+
+    string    final_type = data_type;
+    M_FATAL_IF_NE(data_type, field_type_name.type);
+
+    // Ignore commands (not a field).
+    if ((final_type == "debug_print") || (final_type == "print"))  return;
+    if (final_type == "chat")                                      return;
+    if (final_type == "note")                                      return;
+    if (final_type == "warning")                                   return;
+    if (final_type == "error")                                     return;
+    if (final_type == "fatal")                                     return;
+    if (final_type == "output")                                    return;
+    if (final_type == "byte_order")                                return;
+    if (final_type == "decoder")                                   return;
+    if (final_type == "save_position")                             return;
+    if (final_type == "goto_position")                             return;
+    if (final_type == "move_position_bytes")                       return;
+    if (final_type == "move_position_bits")                        return;
+    if (final_type == "check_eof_distance_bytes")                  return;
+    if (final_type == "check_eof_distance_bits")                   return;
+    if (final_type == "chrono")                                    return;
+    if (final_type == "set")                                       return;
+    if (final_type == "call")                                      return;
+    if (final_type == "deep_break")                                return;
+    if (final_type == "deep_continue")                             return;
+    if (final_type == "break")                                     return;
+    if (final_type == "continue")                                  return;
+    if (final_type == "return")                                    return;
+
+    // array ? Not specifically managed.
+
+    // switch ?
+    if ((final_type == "switch") ||
+        (type_definitions.is_a_switch(final_type)))
+    {
+        // name NOT specified means :
+        // - user do NOT want to see it
+        // - wireshark will reject it 
+        if (field_type_name.name != "")
+        {
+            // ajout champ none (size inconnue)
+            field_type_name.wsgd_field_idx = field_idx;
+            M_TRACE_DEBUG ("add_field_none("
+                << protocol_data.proto_idx << ", "
+                << field_idx << ", "
+                << field_type_name.name << ") switch");
+
+            register_fields_add_field_none(protocol_data,
+                                                field_idx,
+                                                field_type_name);
+            ++field_idx;
+        }
+        if (final_type == "switch")
+        {
+            // must manage inline switch
+            M_FATAL_IF_EQ (field_type_name.P_switch_inline.get(), nullptr);
+            register_fields_switch_definition(protocol_data, field_idx, *field_type_name.P_switch_inline);
+        }
+        return;
+    }
+
+    // struct ?
+    {
+        T_struct_definition  * P_struct = nullptr;
+
+        if (final_type == "struct")
+        {
+            P_struct = field_type_name.P_sub_struct.get();
+            M_FATAL_IF_EQ (P_struct, nullptr);
+        }
+        else
+        {
+            P_struct = type_definitions.get_P_struct(final_type);
+        }
+
+        if (P_struct != nullptr)
+        {
+            // name NOT specified means :
+            // - user do NOT want to see it
+            // - wireshark will reject it 
+            if (field_type_name.name != "")
+            {
+                // ajout champ none (size inconnue)
+                field_type_name.wsgd_field_idx = field_idx;
+                M_TRACE_DEBUG ("add_field_none("
+                    << protocol_data.proto_idx << ", "
+                    << field_idx << ", "
+                    << field_type_name.name << ") struct");
+
+                register_fields_add_field_none(protocol_data,
+                                                field_idx,
+                                                field_type_name);
+                ++field_idx;
+
+                if (P_struct->is_a_field_struct())
+                {
+                    T_field_type_name  fs_field_type_name = P_struct->fields[P_struct->field_struct_idx];
+                    fs_field_type_name.name = field_type_name.name + "." + fs_field_type_name.name;
+                    register_fields_field_type_name(protocol_data, field_idx, fs_field_type_name, fs_field_type_name.type);
+                }
+            }
+            if (final_type == "struct")
+            {
+                // must manage inline struct
+                M_FATAL_IF_EQ (field_type_name.P_sub_struct.get(), nullptr);
+                register_fields_struct_definition(protocol_data, field_idx, *field_type_name.P_sub_struct);
+            }
+            return;
+        }
+    }
+
+    // bitfield ?
+    {
+        if ((final_type == "bitfield") ||
+            (type_definitions.is_a_bitfield(final_type)))
+        {
+            // name NOT specified means :
+            // - user do NOT want to see it
+            // - wireshark will reject it 
+            if (field_type_name.name != "")
+            {
+                // ajout champ none (size inconnue)
+                field_type_name.wsgd_field_idx = field_idx;
+                M_TRACE_DEBUG ("add_field_none("
+                    << protocol_data.proto_idx << ", "
+                    << field_idx << ", "
+                    << field_type_name.name << ") bitfield");
+
+                register_fields_add_field_none(protocol_data,
+                                                    field_idx,
+                                                    field_type_name);
+                ++field_idx;
+            }
+            if (final_type == "bitfield")
+            {
+                // must manage inline bitfield
+                M_FATAL_IF_EQ (field_type_name.P_bitfield_inline.get(), nullptr);
+                register_fields_bitfield_definition(protocol_data, field_idx, *field_type_name.P_bitfield_inline);
+            }
+            return;
+        }
+    }
+
+    // enum ?
+    int     wsgd_enum_values_idx = -1;
+    bool    is_enum = false;
+    bool    is_enum_signed = false;
+    {
+        const T_enum_definition_representation  * P_enum = type_definitions.get_P_enum(final_type);
+        if (P_enum != nullptr)
+        {
+            is_enum = true;
+            is_enum_signed = P_enum->is_signed;
+
+            final_type = P_enum->representation_type;
+
+            wsgd_enum_values_idx = P_enum->wsgd_enum_values_idx;
+        }
+    }
+
+    // simple fields and subproto, insproto
+
+#define M_CHECK_FIELD_NAME()                                                                        \
+    if (field_type_name.name == "")                                                                 \
+    {                                                                                               \
+        M_FATAL_COMMENT("\"\" field name is only accepted for struct, switch or bitfield types.");  \
+    }
+
+#define M_READ_SIMPLE_TYPE_BASE(TYPE_NAME,TYPE_NAME_BIT_SIZE,TYPE_IMPL,TYPE_IMPL_BIT_SIZE,TYPE_IMPL_STR,CHANGE_basic_type_bit_size)    \
+    else if (final_type == TYPE_NAME)                                         \
+    {                                                                         \
+        M_CHECK_FIELD_NAME();                                                 \
+                                                                              \
+        M_FATAL_IF_GT (TYPE_NAME_BIT_SIZE, TYPE_IMPL_BIT_SIZE);               \
+                                                                              \
+        field_type_name.wsgd_field_idx = field_idx;                           \
+    if (CHANGE_basic_type_bit_size)    field_type_name.basic_type_bit_size = TYPE_IMPL_BIT_SIZE; /* ce champ est deja calcule dans post_build_field_base MAIS pas suffisant pb sur les bitfield ? a priori corrige 20091102 ??? */ \
+                                                                              \
+        if (field_type_name.must_force_manage_as_biggest_float())             \
+        {                                                                     \
+            M_TRACE_DEBUG ("PROMOTION add_field_float("                       \
+               << protocol_data.proto_idx << ", "                             \
+               << field_idx << ", "                                           \
+               << field_type_name.name << ", "                                \
+               << TYPE_IMPL_BIT_SIZE << ")");                                 \
+            register_fields_add_field_float(                                  \
+                                               protocol_data,                 \
+                                               field_idx,                     \
+                                               field_type_name,               \
+                                               64);                           \
+        }                                                                     \
+        else if (strncmp(TYPE_NAME, "float", 5) == 0)                         \
+        {                                                                     \
+            M_TRACE_DEBUG ("add_field_float("                                 \
+               << protocol_data.proto_idx << ", "                             \
+               << field_idx << ", "                                           \
+               << field_type_name.name << ", "                                \
+               << TYPE_IMPL_BIT_SIZE << ")");                                 \
+            register_fields_add_field_float(                                  \
+                                               protocol_data,                 \
+                                               field_idx,                     \
+                                               field_type_name,               \
+                                               TYPE_IMPL_BIT_SIZE);           \
+        }                                                                     \
+        else if (field_type_name.must_force_manage_as_biggest_int())          \
+        {                                                                     \
+            bool  is_signed = (is_enum == true) ? is_enum_signed : true;      \
+            M_TRACE_DEBUG ("PROMOTION add_field_int("                         \
+               << protocol_data.proto_idx << ", "                             \
+               << field_idx << ", "                                           \
+               << field_type_name.name << ", "                                \
+               << TYPE_IMPL_BIT_SIZE << ", "                                  \
+               << is_signed << ")");                                          \
+            register_fields_add_field_int(                                    \
+                                       protocol_data,                         \
+                                       field_idx,                             \
+                                       field_type_name,                       \
+                                       64,                                    \
+                                       is_signed,                             \
+                                       wsgd_enum_values_idx);                 \
+        }                                                                     \
+        else                                                                  \
+        {                                                                     \
+            M_TRACE_DEBUG ("add_field_int("                                   \
+               << protocol_data.proto_idx << ", "                             \
+               << field_idx << ", "                                           \
+               << field_type_name.name << ", "                                \
+               << TYPE_IMPL_BIT_SIZE << ")");                                 \
+            register_fields_add_field_int(                                    \
+                                       protocol_data,                         \
+                                       field_idx,                             \
+                                       field_type_name,                       \
+                                       TYPE_IMPL_BIT_SIZE,                    \
+                                       final_type[0] != 'u',                  \
+                                       wsgd_enum_values_idx);                 \
+        }                                                                     \
+    }
+
+#define M_READ_SIMPLE_TYPE(TYPE_NAME,TYPE_NAME_SIZE,TYPE_IMPL)                \
+        M_READ_SIMPLE_TYPE_BASE(TYPE_NAME, TYPE_NAME_SIZE, TYPE_IMPL, sizeof(TYPE_IMPL)*8, #TYPE_IMPL, true)
+
+    string    str_string_size;
+
+    if (false) ;
+    M_READ_SIMPLE_TYPE ( "int8",    8,    signed char)
+    M_READ_SIMPLE_TYPE ("uint8",    8,  unsigned char)
+    M_READ_SIMPLE_TYPE ( "int16",  16,    signed short)
+    M_READ_SIMPLE_TYPE ("uint16",  16,  unsigned short)
+    M_READ_SIMPLE_TYPE ( "int24",  24,    signed int)
+    M_READ_SIMPLE_TYPE ("uint24",  24,  unsigned int)
+    M_READ_SIMPLE_TYPE ( "int32",  32,    signed int)
+    M_READ_SIMPLE_TYPE ("uint32",  32,  unsigned int)
+    M_READ_SIMPLE_TYPE ( "int40",  40,    signed long long)
+    M_READ_SIMPLE_TYPE ("uint40",  40,  unsigned long long)
+    M_READ_SIMPLE_TYPE ( "int48",  48,    signed long long)
+    M_READ_SIMPLE_TYPE ("uint48",  48,  unsigned long long)
+    M_READ_SIMPLE_TYPE ( "int64",  64,    signed long long)
+    M_READ_SIMPLE_TYPE ("uint64",  64,  unsigned long long)
+    M_READ_SIMPLE_TYPE ("float32", 32, float)
+    M_READ_SIMPLE_TYPE ("float64", 64, double)
+// alias    M_READ_SIMPLE_TYPE ("bool",      sizeof(bool)*8,  bool)
+// enum     M_READ_SIMPLE_TYPE ("bool8",    8, unsigned char)
+// enum     M_READ_SIMPLE_TYPE ("bool16",  16, unsigned short)
+// enum     M_READ_SIMPLE_TYPE ("bool32",  32, unsigned int)
+    M_READ_SIMPLE_TYPE ("spare",    8, unsigned char)
+    M_READ_SIMPLE_TYPE ( "char",    8,          char)
+    M_READ_SIMPLE_TYPE ("schar",    8,   signed char)
+    M_READ_SIMPLE_TYPE ("uchar",    8, unsigned char)
+    else if ((final_type == "string") ||
+             (final_type == "string_nl"))
+    {
+        M_CHECK_FIELD_NAME();
+
+        // ajout champ str
+        field_type_name.wsgd_field_idx = field_idx;
+        M_TRACE_DEBUG ("add_field_string("
+           << protocol_data.proto_idx << ", "
+           << field_idx << ", "
+           << field_type_name.name << ")");
+        register_fields_add_field_string(protocol_data,
+                                               field_idx,
+                                               field_type_name);
+    }
+    else if (final_type == "raw")
+    {
+        M_CHECK_FIELD_NAME();
+
+        // ajout champ none (size inconnue)
+        field_type_name.wsgd_field_idx = field_idx;
+        M_TRACE_DEBUG ("add_field_none("
+           << protocol_data.proto_idx << ", "
+           << field_idx << ", "
+           << field_type_name.name << ") " << final_type);
+        register_fields_add_field_bytes(protocol_data,
+                                           field_idx,
+                                           field_type_name);
+    }
+    else if ((final_type == "subproto") ||
+             (final_type == "insproto"))
+    {
+        // I think I can accept for subproto and insproto, but there is no interest.
+        M_CHECK_FIELD_NAME();
+
+        // subdissector : nothing to do, wireshark will manage it as Data
+        return;
+    }
+    else if ((final_type == "padding_bits") ||
+             (final_type == "msg"))
+    {
+        M_CHECK_FIELD_NAME();
+        return;    // nothing to do
+    }
+    else
+    {
+        long    bit_size = 0;
+        if (((strncmp(final_type.c_str(), "uint", 4) == 0) &&
+             (get_number(final_type.c_str()+4, &bit_size) == true) &&
+             (bit_size >   0) &&
+             (bit_size <= 32)) ||
+            ((strncmp(final_type.c_str(), "int", 3) == 0) &&
+             (get_number(final_type.c_str()+3, &bit_size) == true) &&
+             (bit_size >   1) &&
+             (bit_size <  32)))
+        {
+            M_CHECK_FIELD_NAME();
+
+            if (S_ICIOA_in_bitfield == false)
+            {
+            // Ceci ne fonctionne pas a cause des bitfield !!!
+            // voir proto_test
+            if (false) { }
+            M_READ_SIMPLE_TYPE_BASE(final_type.c_str(),bit_size,signed int,32,"signed int", false);
+//            M_READ_SIMPLE_TYPE_BASE(final_type.c_str(),bit_size,signed int,32,"signed int", S_ICIOA_in_bitfield);
+//            field_type_name.basic_type_bit_size = TYPE_BIT_SIZE;  // ce champ est deja calcule dans post_build_field_base MAIS pas suffisant pb sur les bitfield
+            }
+            else
+            {
+            /* bsew uintXX intXX */
+            field_type_name.wsgd_field_idx = field_idx;
+            M_TRACE_DEBUG ("BIT add_field_int("
+               << protocol_data.proto_idx << ", "
+               << field_idx << ", "
+               << field_type_name.name << ", "
+               << bit_size << ")");
+            register_fields_add_field_int(     protocol_data,
+                                               field_idx,
+                                               field_type_name,
+                                               32,
+                                               final_type[0] != 'u',
+                                               wsgd_enum_values_idx);
+            }
+        }
+        else
+        {
+            // Oups ...
+            M_FATAL_COMMENT ("Type " << final_type << " unknown.");
+            return;
+        }
+    }
+
+    ++field_idx;
+}
+
+//*****************************************************************************
+// register_fields_struct_definition
+// Must be coherent with frame_to_field.
+//*****************************************************************************
+
+void    register_fields_struct_fields(T_generic_protocol_data  & protocol_data,
+                                      int                      & field_idx,
+                                      T_struct_fields          & struct_fields)
+{
+    for (T_struct_fields::iterator
+                             iter_field  = struct_fields.begin();
+                             iter_field != struct_fields.end();
+                           ++iter_field)
+    {
+        T_field_type_name  & field_type_name = *iter_field;
+
+        if ((field_type_name.type != "if") &&
+            (field_type_name.type != "while") &&
+            (field_type_name.type != "do_while") &&
+            (field_type_name.type != "loop_size_bytes") &&
+            (field_type_name.type != "loop_size_bits") &&
+            (field_type_name.type != "loop_nb_times"))
+        {
+            register_fields_field_type_name(protocol_data, field_idx, field_type_name, field_type_name.type);
+            continue;
+        }
+
+        // if or any loop
+        if (field_type_name.P_sub_struct)
+            register_fields_struct_definition(protocol_data, field_idx, *field_type_name.P_sub_struct);
+        register_fields_struct_fields(protocol_data, field_idx, field_type_name.sub_struct_2);
+    }
+}
+
+//*****************************************************************************
+// register_fields_struct_definition
+// Must be coherent with frame_to_field.
+//*****************************************************************************
+
+void    register_fields_struct_definition(T_generic_protocol_data      & protocol_data,
+                                          int                          & field_idx,
+                                          T_struct_definition          & struct_definition)
+{
+    register_fields_struct_fields(protocol_data, field_idx, struct_definition.fields);
+}
+
+//*****************************************************************************
+// register_fields_bitfield_definition
+//*****************************************************************************
+
+void    register_fields_bitfield_definition(T_generic_protocol_data      & protocol_data,
+                                          int                          & field_idx,
+                                          T_bitfield_definition          & bitfield_definition)
+{
+    register_fields_field_type_name(protocol_data, field_idx, bitfield_definition.master_field, bitfield_definition.master_field.type);
+    S_ICIOA_in_bitfield = true;
+    register_fields_struct_fields(protocol_data, field_idx, bitfield_definition.fields_definition);
+    S_ICIOA_in_bitfield = false;
+}
+
+//*****************************************************************************
+// register_fields_switch_definition
+//*****************************************************************************
+
+void    register_fields_switch_definition(T_generic_protocol_data      & protocol_data,
+                                          int                          & field_idx,
+                                          T_switch_definition          & switch_definition)
+{
+    T_switch_cases       & switch_cases = switch_definition.switch_cases;
+
+    for (T_switch_cases::iterator
+                            sw_iter  = switch_cases.begin();
+                            sw_iter != switch_cases.end();
+                          ++sw_iter)
+    {
+        T_struct_fields  & struct_fields = sw_iter->fields;
+
+        register_fields_struct_fields(protocol_data, field_idx, struct_fields);
+    }
+}
+
+//*****************************************************************************
+// register_fields
+//*****************************************************************************
+
+void    register_fields(T_generic_protocol_data  & protocol_data)
+{
+    M_TRACE_ENTER ("register_fields", "proto_idx=" << protocol_data.proto_idx);
+
+    T_type_definitions       & type_definitions = protocol_data.type_definitions;
+
+    int   field_idx = 0;
+
+    // whole or any data
+    M_FATAL_IF_NE(field_idx, K_WHOLE_WSGD_FIELD_IDX);
+    M_FATAL_IF_NE(field_idx, K_ANY_WSGD_FIELD_IDX);
+    register_fields_add_field_none(protocol_data, field_idx, "data", "data", "data");
+    ++field_idx;
+
+    // pseudo field to do a coloring rule or a display filter on it
+    // I do not know how to code a coloring rule.
+    // -> must do it manually at this time.
+    if (K_ERROR_WSGD_FIELD_IDX != K_ANY_WSGD_FIELD_IDX)
+    {
+        M_FATAL_IF_NE(field_idx, K_ERROR_WSGD_FIELD_IDX);
+        register_fields_add_field_none(protocol_data, field_idx, "error_in_packet", "error_in_packet", "error_in_packet");
+        ++field_idx;
+    }
+
+    {
+        T_map_struct_definition  & map_struct_definition = type_definitions.map_struct_definition;
+        for (T_map_struct_definition::iterator
+                                    iter  = map_struct_definition.begin();
+                                    iter != map_struct_definition.end();
+                                  ++iter)
+        {
+            T_struct_definition  & struct_definition = iter->second;
+
+            register_fields_struct_definition(protocol_data, field_idx, struct_definition);
+        }
+    }
+
+    {
+        T_map_bitfield_definition  & map_bitfield_definition = type_definitions.map_bitfield_definition;
+        for (T_map_bitfield_definition::iterator
+                                    iter  = map_bitfield_definition.begin();
+                                    iter != map_bitfield_definition.end();
+                                  ++iter)
+        {
+            T_bitfield_definition  & bitfield_definition = iter->second;
+
+            register_fields_bitfield_definition(protocol_data, field_idx, bitfield_definition);
+        }
+    }
+
+    {
+        T_map_switch_definition  & map_switch_definition = type_definitions.map_switch_definition;
+        for (T_map_switch_definition::iterator
+                                    iter  = map_switch_definition.begin();
+                                    iter != map_switch_definition.end();
+                                  ++iter)
+        {
+            T_switch_definition  & switch_definition = iter->second;
+
+            register_fields_switch_definition(protocol_data, field_idx, switch_definition);
+        }
+    }
+
+    {
+        T_map_function_definition  & map_function_definition = type_definitions.map_function_definition;
+        for (T_map_function_definition::iterator
+                                    iter  = map_function_definition.begin();
+                                    iter != map_function_definition.end();
+                                  ++iter)
+        {
+            T_function_definition  & function_definition = iter->second;
+
+            register_fields_struct_fields(protocol_data, field_idx, function_definition.fields);
+        }
+    }
+
+    T_generic_protocol_ws_data         * P_protocol_ws_data = &protocol_data.ws_data;
+    T_generic_protocol_fields_data     & fields_data = P_protocol_ws_data->fields_data;
+
+    fields_data.hf_id.resize(fields_data.hf.size());
+    fields_data.ett.resize(fields_data.hf.size());
+    fields_data.ett_id.resize(fields_data.ett.size());
+
+    // WARNING_ADDRESSES
+    // Must NOT be done before,
+    //  because the addresses of hf_id[idx] and ett_id[idx] could change
+    //  when the size of the vector change
+    for (uint  idx = 0; idx < fields_data.hf.size(); ++idx)
+    {
+        fields_data.hf_id[idx]    = -1;
+        fields_data.hf[idx].p_id  = &fields_data.hf_id[idx];
+        fields_data.ett_id[idx] = -1;
+        fields_data.ett[idx]    = &fields_data.ett_id[idx];
+
+//      M_TRACE_DEBUG("hf[" << idx << "].p_id  = " << &fields_data.hf_id[idx]);
+//      M_TRACE_DEBUG("ett[" << idx << "].p_id  = " << &fields_data.ett_id[idx]);
+    }
+}
+
+//*****************************************************************************
+// get_wsgd_files_in_dir
+//*****************************************************************************
+
+int   get_wsgd_files_in_dir (const string          & dir_name,
+                                   vector<string>  & file_names)
+{
+    // true to have the full name (including directory name).
+    return  get_files_in_dir(dir_name, "", ".wsgd", file_names, true);
+}
+
+//*****************************************************************************
+// compute_wsgd_file_names
+//*****************************************************************************
+
+void    compute_wsgd_file_names(vector<string>  & wsgd_file_names)
+{
+
+#define M_SEARCH_IN_DIR_SUBDIR(DIR,SUBDIR)                                  \
+{                                                                           \
+    const char  * p_dir_name = DIR;                                         \
+    if (p_dir_name != nullptr)                                              \
+    {                                                                       \
+        std::string  dir_name = p_dir_name;                                 \
+        dir_name += SUBDIR;                                                 \
+        get_wsgd_files_in_dir(dir_name, wsgd_file_names);                   \
+        if (wsgd_file_names.empty() == false)                               \
+        {                                                                   \
+            byte_interpret_set_include_directory(dir_name);                 \
+            return;                                                         \
+        }                                                                   \
+    }                                                                       \
+}
+
+#define M_SEARCH_IN_DIR(DIR)               M_SEARCH_IN_DIR_SUBDIR(DIR, "")
+#define M_SEARCH_IN_DIR_EPAN(DIR)          M_SEARCH_IN_DIR_SUBDIR(DIR, "/epan")
+
+    M_SEARCH_IN_DIR(getenv("WIRESHARK_GENERIC_DISSECTOR_DIR"));
+    M_SEARCH_IN_DIR(get_profiles_dir());
+    M_SEARCH_IN_DIR(get_persdatafile_dir());
+    M_SEARCH_IN_DIR(get_datafile_dir());
+    M_SEARCH_IN_DIR_EPAN(get_plugins_dir_with_version());
+    M_SEARCH_IN_DIR_EPAN(get_plugins_pers_dir_with_version());
+    M_SEARCH_IN_DIR(get_progfile_dir());
+    M_SEARCH_IN_DIR(".");
+}
+
+//*****************************************************************************
+// prefs_apply_cb
+//*****************************************************************************
+#if 0
+void    prefs_apply_cb(void)
+{
+}
+#endif
+
+//*****************************************************************************
+// cpp_proto_register_generic
+//*****************************************************************************
+
+void    cpp_proto_register_generic(const string   & wsgd_file_name,
+                                   const int        proto_idx)
+{
+    M_TRACE_ENTER ("cpp_proto_register_generic", "wsgd_file_name=" << wsgd_file_name);
+
+    T_generic_protocol_data  & protocol_data = new_protocol_data(proto_idx);
+
+    protocol_data.wsgd_file_name = wsgd_file_name;
+
+    read_file_wsgd (wsgd_file_name, protocol_data);
+
+    C_debug_set_temporary  debug_register_proto_main(protocol_data.DEBUG);
+
+    // Check that PROTOABBREV does NOT already exist to avoid wireshark crash.
+    // No function available into proto.h to test PROTONAME & PROTOSHORTNAME.
+    if (proto_get_id_by_filter_name(protocol_data.PROTOABBREV.c_str()) >= 0)
+    {
+        M_FATAL_COMMENT("Protocol " << protocol_data.PROTOABBREV << " already exist");
+    }
+
+    M_TRACE_DEBUG("proto_register_protocol " <<
+                  protocol_data.PROTONAME << " " <<
+                  protocol_data.PROTOSHORTNAME << " " <<
+                  protocol_data.PROTOABBREV);
+    protocol_data.ws_data.proto_generic =
+                        proto_register_protocol (protocol_data.PROTONAME.c_str(),
+                                                 protocol_data.PROTOSHORTNAME.c_str(),
+                                                 protocol_data.PROTOABBREV.c_str());
+
+    register_enum_values(protocol_data);
+    register_fields(protocol_data);
+
+
+    T_generic_protocol_ws_data      * P_protocol_ws_data = &protocol_data.ws_data;
+
+    M_TRACE_DEBUG("proto_register_field_array " <<
+                  P_protocol_ws_data->proto_generic << " " <<
+                  &P_protocol_ws_data->fields_data.hf[0] << " " <<
+                  P_protocol_ws_data->fields_data.hf.size());
+    proto_register_field_array (P_protocol_ws_data->proto_generic,
+                                &P_protocol_ws_data->fields_data.hf[0],
+                                P_protocol_ws_data->fields_data.hf.size());
+#if 0
+    {
+        for (int idx = 0; idx < P_protocol_ws_data->fields_data.hf.size(); ++idx)
+        {
+            M_TRACE_DEBUG("hf[" << idx << "].p_id=" << P_protocol_ws_data->fields_data.hf[idx].p_id <<
+                          "  &hf_id[" << idx << "]=" << &P_protocol_ws_data->fields_data.hf_id[idx] <<
+                          "   hf_id[" << idx << "]=" <<  P_protocol_ws_data->fields_data.hf_id[idx]);
+        }
+    }
+#endif
+
+    M_TRACE_DEBUG("proto_register_subtree_array " <<
+                  &P_protocol_ws_data->fields_data.ett[0] << " " <<
+                  P_protocol_ws_data->fields_data.ett.size());
+    proto_register_subtree_array (&P_protocol_ws_data->fields_data.ett[0],
+                                  P_protocol_ws_data->fields_data.ett.size());
+
+    {
+        ei_register_info   eri = 
+            { &P_protocol_ws_data->expert_data.ei_malformed_comment,
+              { strdup(string(protocol_data.PROTOABBREV + ".malformed").c_str()),
+                PI_MALFORMED, PI_COMMENT, "comment", EXPFILL }};
+
+        P_protocol_ws_data->expert_data.ei.push_back(eri);
+    }
+    {
+        ei_register_info   eri = 
+            { &P_protocol_ws_data->expert_data.ei_malformed_chat,
+              { strdup(string(protocol_data.PROTOABBREV + ".malformed").c_str()),
+                PI_MALFORMED, PI_CHAT, "chat", EXPFILL }};
+
+        P_protocol_ws_data->expert_data.ei.push_back(eri);
+    }
+    {
+        ei_register_info   eri = 
+            { &P_protocol_ws_data->expert_data.ei_malformed_note,
+              { strdup(string(protocol_data.PROTOABBREV + ".malformed").c_str()),
+                PI_MALFORMED, PI_NOTE, "note", EXPFILL }};
+
+        P_protocol_ws_data->expert_data.ei.push_back(eri);
+    }
+    {
+        ei_register_info   eri = 
+            { &P_protocol_ws_data->expert_data.ei_malformed_warn,
+              { strdup(string(protocol_data.PROTOABBREV + ".malformed").c_str()),
+                PI_MALFORMED, PI_WARN, "warn", EXPFILL }};
+
+        P_protocol_ws_data->expert_data.ei.push_back(eri);
+    }
+    {
+        ei_register_info   eri = 
+            { &P_protocol_ws_data->expert_data.ei_malformed_error,
+              { strdup(string(protocol_data.PROTOABBREV + ".malformed").c_str()),
+                PI_MALFORMED, PI_ERROR, "error", EXPFILL }};
+
+        P_protocol_ws_data->expert_data.ei.push_back(eri);
+    }
+
+    M_TRACE_DEBUG("expert_register_field_array " <<
+                  &P_protocol_ws_data->expert_data.ei[0] << " " <<
+                  P_protocol_ws_data->expert_data.ei.size());
+
+    expert_module_t* expert_proto = expert_register_protocol(P_protocol_ws_data->proto_generic);
+    expert_register_field_array(expert_proto,
+                                &P_protocol_ws_data->expert_data.ei[0],
+                                 P_protocol_ws_data->expert_data.ei.size());
+
+
+    /* subdissector code */
+    if (protocol_data.SUBPROTO_SUBFIELD != "")
+    {
+        protocol_data.SUBPROTO_SUBFIELD_PARAM    = protocol_data.PROTOABBREV    + "." + protocol_data.SUBPROTO_SUBFIELD;
+        protocol_data.SUBPROTO_SUBFIELD_PARAM_UI = protocol_data.PROTOSHORTNAME + " " + protocol_data.SUBPROTO_SUBFIELD;
+
+        M_TRACE_DEBUG ("register_dissector_table " <<
+                        protocol_data.SUBPROTO_SUBFIELD_PARAM.c_str() << " " <<
+                        protocol_data.SUBPROTO_SUBFIELD_PARAM_UI.c_str());
+
+        protocol_data.ws_data.subdissector_data.dissector_table =
+        register_dissector_table(protocol_data.SUBPROTO_SUBFIELD_PARAM.c_str(),
+                                 protocol_data.SUBPROTO_SUBFIELD_PARAM_UI.c_str(),
+                                 protocol_data.ws_data.proto_generic,
+                                 protocol_data.SUBPROTO_SUBFIELD_TYPE_WS,
+                                 BASE_DEC);
+
+        M_FATAL_IF_EQ(protocol_data.ws_data.subdissector_data.dissector_table, nullptr);
+
+        protocol_data.ws_data.subdissector_data.heur_dissector_list = register_heur_dissector_list(protocol_data.PROTOABBREV.c_str(),
+                                                                                                   protocol_data.ws_data.proto_generic);
+    }
+
+    /* Register configuration preferences */
+//    module_t  * module = prefs_register_protocol(protocol_data.ws_data.proto_generic, prefs_apply_cb);
+    module_t  * module = prefs_register_protocol(protocol_data.ws_data.proto_generic, nullptr);
+    prefs_register_bool_preference(module, "try_heuristic_first",
+        "Try heuristic sub-dissectors first",
+        "Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to a specific port",
+        &protocol_data.ws_data.subdissector_data.try_heuristic_first);
+
+    M_TRACE_DEBUG("new_register_dissector " <<
+                  protocol_data.PROTOABBREV << " " <<
+                  P_protocol_ws_data->P_dissect_fct << " " <<
+                  P_protocol_ws_data->proto_generic);
+    register_dissector(protocol_data.PROTOABBREV.c_str(), P_protocol_ws_data->P_dissect_fct, P_protocol_ws_data->proto_generic);
+
+    // Must use PROTOABBREV because generic_stats_tree_... rely on it
+    protocol_data.ws_data.tap_data.proto_tap = register_tap(protocol_data.PROTOABBREV.c_str());
+    M_TRACE_DEBUG("proto_tap=" << protocol_data.ws_data.tap_data.proto_tap);
+}
+
+//*****************************************************************************
+// wsgd_report_failure
+//*****************************************************************************
+
+void    wsgd_report_failure(string    str)
+{
+    str += "\n";
+    str += "\n";
+    str += "More information could be available at http://wsgd.free.fr/";
+    report_failure(str.c_str(), "silly arg to avoid compiler warning, so must not appear");
+}
+
+//*****************************************************************************
+// trace_version_infos
+//*****************************************************************************
+
+void    trace_version_infos()
+{
+    M_TRACE_DEBUG ("wireshark version                 = " << epan_get_version());
+    M_TRACE_DEBUG ("wsgd generation data :");
+    M_TRACE_DEBUG ("- wireshark compilation version   = " << VERSION);
+    M_TRACE_DEBUG ("- WIRESHARK_VERSION_NUMBER        = " << WIRESHARK_VERSION_NUMBER);
+    M_TRACE_DEBUG ("- compilation date                = " << __DATE__);
+#ifdef MSC_VER_REQUIRED
+    M_TRACE_DEBUG ("- compiler                        = " << "Visual C++ " << MSC_VER_REQUIRED);
+#elif defined(__GNUC__)
+    M_TRACE_DEBUG ("- compiler                        = " << "gcc " << __GNUC__);
+#endif
+}
+
+//*****************************************************************************
+// trace_dirs
+//*****************************************************************************
+
+void    trace_dirs()
+{
+    M_TRACE_DEBUG ("get_progfile_dir                  = " << get_progfile_dir());
+    M_TRACE_DEBUG ("get_plugins_dir_with_version      = " << get_plugins_dir_with_version());
+    M_TRACE_DEBUG ("get_plugins_pers_dir_with_version = " << get_plugins_pers_dir_with_version());
+    M_TRACE_DEBUG ("get_datafile_dir                  = " << get_datafile_dir());
+    M_TRACE_DEBUG ("get_systemfile_dir                = " << get_systemfile_dir());
+    M_TRACE_DEBUG ("get_profiles_dir                  = " << get_profiles_dir());
+    M_TRACE_DEBUG ("get_persdatafile_dir              = " << get_persdatafile_dir());
+}
+
+//*****************************************************************************
+// trace_locales
+//*****************************************************************************
+
+#include <locale.h>
+
+void    trace_locales()
+{
+    M_TRACE_DEBUG ("locale LC_ALL         = " << setlocale(LC_ALL, nullptr));
+    M_TRACE_DEBUG ("locale LC_COLLATE     = " << setlocale(LC_COLLATE, nullptr));
+    M_TRACE_DEBUG ("locale LC_CTYPE       = " << setlocale(LC_CTYPE, nullptr));
+    M_TRACE_DEBUG ("locale LC_MONETARY    = " << setlocale(LC_MONETARY, nullptr));
+    M_TRACE_DEBUG ("locale LC_NUMERIC     = " << setlocale(LC_NUMERIC, nullptr));
+    M_TRACE_DEBUG ("locale LC_TIME        = " << setlocale(LC_TIME, nullptr));
+#if 0
+LC_ALL          The entire locale.
+LC_COLLATE      Affects the behavior of strcoll and strxfrm.
+LC_CTYPE        Affects character handling functions (all functions of <cctype>, except isdigit and isxdigit), and the multibyte and wide character functions
+LC_MONETARY     Affects monetary formatting information returned by localeconv.
+LC_NUMERIC      Affects the decimal-point character in formatted input/output operations and string formatting functions, as well as non-monetary information returned by localeconv.
+LC_TIME         Affects the behavior of strftime.
+#endif
+}
+
+//*****************************************************************************
+// cpp_proto__register_generic2
+// double _ needed to avoid wireshark build add proto_register_generic2
+//  into plugin_register
+//*****************************************************************************
+
+void    cpp_proto__register_generic2(void)
+{
+    vector<string>    wsgd_file_names;
+    compute_wsgd_file_names(wsgd_file_names);
+
+    set_max_nb_of_protocol_data(wsgd_file_names.size());
+
+    int   proto_idx = 0;
+    for (vector<string>::const_iterator  iter  = wsgd_file_names.begin();
+                                         iter != wsgd_file_names.end();
+                                        ++iter)
+    {
+        const string   & wsgd_file_name = *iter;
+
+        build_types_context_reset();
+
+        try
+        {
+#if 0
+            string    wsgd_file_name_short = wsgd_file_name;
+            {
+                const string::size_type  idx_last_dir = wsgd_file_name_short.find_last_of("/\\");
+                if (idx_last_dir != string::npos)
+                {
+                    wsgd_file_name_short.erase(0, idx_last_dir+1);
+                }
+            }
+
+            build_types_context_include_file_open (wsgd_file_name_short);
+#endif
+            cpp_proto_register_generic(wsgd_file_name, proto_idx);
+//            build_types_context_include_file_close(wsgd_file_name_short);
+        }
+        catch(C_byte_interpret_exception  & error_str)
+        {
+            get_protocol_data(proto_idx).proto_is_NOT_usable();
+            wsgd_report_failure(
+                        "Generic dissector did NOT succeed to read/interpret/register :\n" +
+                        wsgd_file_name + " \n"
+                        "\n"
+                        "The given protocol is NOT available.\n"
+                        "\n" +
+                        build_types_context_where() +
+                        "\n" +
+                        error_str.get_explanation());
+        }
+        catch(...)
+        {
+            get_protocol_data(proto_idx).proto_is_NOT_usable();
+            wsgd_report_failure(
+                        "Generic dissector did NOT succeed to read/interpret/register :\n" +
+                        wsgd_file_name + " \n"
+                        "\n"
+                        "The given protocol is NOT available.\n" +
+                        "\n" +
+                        build_types_context_where());
+        }
+
+        ++proto_idx;
+    }
+}
+
+//*****************************************************************************
+// get_traces_file_name
+//*****************************************************************************
+string    get_traces_file_name()
+{
+    string  traces_file_name = "";
+
+    const char *  file = getenv("WIRESHARK_GENERIC_DISSECTOR_TRACES_FILE");
+    if (file != nullptr)
+    {
+        traces_file_name += file;
+    }
+    else
+    {
+        traces_file_name += "wireshark_generic_dissector_traces.txt";
+    }
+
+
+    mod_replace_all(traces_file_name, "{pid}", get_string(getpid()));
+
+    return  traces_file_name;
+}
+
+//*****************************************************************************
+// get_traces_file_full_name
+//*****************************************************************************
+string    get_traces_file_full_name()
+{
+    const std::string  traces_file_name = get_traces_file_name();
+    string  traces_file_full_name = "";
+    
+    const char *  dir = getenv("WIRESHARK_GENERIC_DISSECTOR_TRACES_DIR");
+    if (dir != nullptr)
+    {
+        traces_file_full_name = dir;
+        traces_file_full_name += G_DIR_SEPARATOR_S;
+        traces_file_full_name += traces_file_name;
+    }
+    else
+    {
+        // Let's try the local directory
+        traces_file_full_name = traces_file_name;
+        ofstream    ofs(traces_file_full_name.c_str());
+        if (!ofs.is_open())
+        {
+            // File can NOT be created in local directory
+            // Should be a permission problem
+            // So take a personal directory
+            traces_file_full_name = get_persdatafile_dir();
+            traces_file_full_name += G_DIR_SEPARATOR_S;
+            traces_file_full_name += traces_file_name;
+        }
+    }
+
+    mod_replace_all(traces_file_full_name, "{pid}", get_string(getpid()));
+
+    return  traces_file_full_name;
+}
+
+//*****************************************************************************
+// create_traces_file
+//*****************************************************************************
+void    create_traces_file()
+{
+    const std::string  traces_file_full_name = get_traces_file_full_name();
+
+    static ofstream    ofs(traces_file_full_name.c_str());
+    set_state_ostream(ofs);
+}
+
+//*****************************************************************************
+// cpp_proto_register_generic
+//*****************************************************************************
+extern "C"
+void    cpp_proto_register_generic(void)
+{
+    create_traces_file();
+
+    C_debug_set_temporary    debug_register_main(E_debug_status_ON_NO_TIME);
+
+    trace_version_infos();
+    trace_dirs();
+    trace_locales();
+
+    M_TRACE_ENTER ("cpp_proto_register_generic", "");
+
+    C_setlocale_numeric_C_guard  locale_guard;
+
+    try
+    {
+        cpp_proto__register_generic2();
+    }
+    catch(...)
+    {
+    }
+}
+
+//*****************************************************************************
+// stats
+//*****************************************************************************
+
+static void    generic_stats_tree_init(stats_tree  * st)
+{
+    // st->cfg->abbr is not the proto_abbrev
+    // tapname is identic to proto_abbrev
+    T_generic_protocol_data      & protocol_data = get_protocol_data_from_proto_abbrev((const char*)st->cfg->tapname);
+    C_debug_set_temporary          debug_stats(protocol_data.DEBUG);
+    M_TRACE_ENTER ("generic_stats_tree_init", st->cfg->name);
+
+    T_generic_protocol_tap_data  & tap_data = protocol_data.ws_data.tap_data;
+    tap_data.tap_is_needed = true;
+
+    T_stats_sub_group  & sub_group = tap_data.stats.get_sub_group_by_full_name(st->cfg->name);
+
+    sub_group.node_id = stats_tree_create_node(st, sub_group.node_name.c_str(), 0,
+#if WIRESHARK_VERSION_NUMBER >= 30000
+                                                   STAT_DT_INT,
+#endif
+                                                   TRUE);
+
+    for (auto iter = sub_group.topics.begin(); iter != sub_group.topics.end(); ++iter)
+    {
+        T_stats_topic  & topic = *iter;
+
+        topic.pivot_id = stats_tree_create_pivot(st, topic.topic_name.c_str(), sub_group.node_id);
+    }
+}
+
+#if WIRESHARK_VERSION_NUMBER >= 30000
+#define stat_tree_packet_return_type     tap_packet_status
+#define stat_tree_packet_return_value    TAP_PACKET_REDRAW
+#else
+#define stat_tree_packet_return_type     int
+#define stat_tree_packet_return_value    1
+#endif
+static
+#if WIRESHARK_VERSION_NUMBER >= 40000
+stat_tree_packet_return_type
+              generic_stats_tree_packet(stats_tree      * st,
+                                        packet_info     * pinfo,
+                                        epan_dissect_t  * edt,
+                                  const void            * p,
+                                        tap_flags_t       UNUSED(flags))
+#else
+stat_tree_packet_return_type
+              generic_stats_tree_packet(stats_tree      * st,
+                                        packet_info     * pinfo,
+                                        epan_dissect_t  * edt,
+                                  const void            * p)
+#endif
+{
+    T_generic_protocol_data  & protocol_data = *(T_generic_protocol_data*)p;
+    C_debug_set_temporary      debug_stats(protocol_data.DEBUG);
+    M_TRACE_ENTER ("generic_stats_tree_packet", st->cfg->name <<
+                   "  pinfo=" << pinfo <<
+                   "  edt=" << edt <<
+                   "  p=" << p);
+
+    T_generic_protocol_tap_data  & tap_data = protocol_data.ws_data.tap_data;
+    T_stats_sub_group            & sub_group = tap_data.stats.get_sub_group_by_full_name(st->cfg->name);
+
+    M_FATAL_IF_EQ(tap_data.RCP_last_msg_interpret_data.get(), nullptr);
+    T_interpret_data& last_msg_interpret_data = *tap_data.RCP_last_msg_interpret_data;
+
+    tick_stat_node(st, sub_group.node_name.c_str(), 0, FALSE);
+
+    for (auto iter = sub_group.topics.begin(); iter != sub_group.topics.end(); ++iter)
+    {
+        T_stats_topic  & topic = *iter;
+
+        if (last_msg_interpret_data.is_read_variable(topic.variable_name))
+        {
+            const string  value = last_msg_interpret_data.get_full_str_value_of_read_variable(topic.variable_name);
+            stats_tree_tick_pivot(st, topic.pivot_id, value.c_str());
+        }
+    }
+
+    // Msg is ended, some data are no more necessary
+    last_msg_interpret_data.msg_is_ended();
+
+    return  stat_tree_packet_return_value;
+}
+
+static void    generic_stats_tree_cleanup(stats_tree  * st)
+{
+    // st->cfg->abbr is not the proto_abbrev
+    // tapname is identic to proto_abbrev
+    T_generic_protocol_data  & protocol_data = get_protocol_data_from_proto_abbrev((const char*)st->cfg->tapname);
+    C_debug_set_temporary      debug_stats(protocol_data.DEBUG);
+    M_TRACE_ENTER ("generic_stats_tree_cleanup", st->cfg->name);
+
+    T_generic_protocol_tap_data& tap_data = protocol_data.ws_data.tap_data;
+    tap_data.tap_is_needed = false;
+}
+
+static void    register_generic_stats_trees(T_generic_protocol_data  & protocol_data)
+{
+    M_TRACE_ENTER ("register_generic_stats_trees", "");
+
+    auto& stats_groups = protocol_data.ws_data.tap_data.stats.groups;
+    for (auto iter = stats_groups.begin(); iter != stats_groups.end(); ++iter)
+    {
+        const T_stats_group& group = *iter;
+
+        for (auto iter = group.sub_groups.begin(); iter != group.sub_groups.end(); ++iter)
+        {
+            const T_stats_sub_group& sub_group = *iter;
+
+            const std::string & full_name = sub_group.full_name;
+
+            stats_tree_register_plugin(protocol_data.PROTOABBREV.c_str(),
+                                       full_name.c_str(),              // must be unique
+                                       full_name.c_str(),
+                                       0,
+                                       generic_stats_tree_packet,
+                                       generic_stats_tree_init,
+                                       generic_stats_tree_cleanup);
+        }
+    }
+}
+
+//*****************************************************************************
+// is_an_heuristic_dissector
+//*****************************************************************************
+bool  is_an_heuristic_dissector(const string &  parent_name)
+{
+    const bool  result = has_heur_dissector_list(parent_name.c_str());
+    return  result;
+}
+
+//*****************************************************************************
+// cpp_proto_reg_handoff_generic_proto
+//*****************************************************************************
+
+void    cpp_proto_reg_handoff_generic_proto(T_generic_protocol_data  & protocol_data)
+{
+    C_debug_set_temporary    debug_handoff_main(protocol_data.DEBUG);
+
+    M_TRACE_ENTER ("cpp_proto_reg_handoff_generic", protocol_data.proto_idx);
+
+    T_generic_protocol_ws_data      * P_protocol_ws_data = &protocol_data.ws_data;
+
+    // Create the dissector handle.
+    P_protocol_ws_data->dissector_handle = create_dissector_handle(P_protocol_ws_data->P_dissect_fct,
+                                                                   P_protocol_ws_data->proto_generic);
+    M_FATAL_IF_EQ(P_protocol_ws_data->dissector_handle, nullptr);
+
+
+    // Declare parent dissectors
+    for (vector<T_generic_protocol_data::T_parent>::const_iterator
+                                parent_iter  = protocol_data.PARENTS.begin();
+                                parent_iter != protocol_data.PARENTS.end();
+                              ++parent_iter)
+    {
+        const T_generic_protocol_data::T_parent  & parent = * parent_iter;
+
+        // Add dissector for each PARENT_SUBFIELD_VALUES.
+        M_TRACE_DEBUG ("PARENT_SUBFIELD = " << parent.PARENT_SUBFIELD.c_str());
+
+        // Check that PARENT_SUBFIELD exist.
+        if (find_dissector_table(parent.PARENT_SUBFIELD.c_str()) == nullptr)
+        {
+            wsgd_report_failure(
+                        "Generic dissector did NOT succeed to attach " + protocol_data.PROTONAME +
+                        " to its PARENT_SUBFIELD " + parent.PARENT_SUBFIELD +
+                        " (because it does NOT exist).\n" 
+                        "\n"
+                        "The given protocol will NOT be called (at least automatically).\n");
+            continue;
+        }
+
+        for (uint  idx = 0; idx < parent.PARENT_SUBFIELD_VALUES_int.size(); ++idx)
+        {
+            M_TRACE_DEBUG ("PARENT_SUBFIELD_VALUE = " << parent.PARENT_SUBFIELD_VALUES_int[idx]);
+
+            dissector_add_uint(parent.PARENT_SUBFIELD.c_str(),
+                               parent.PARENT_SUBFIELD_VALUES_int[idx],
+                               P_protocol_ws_data->dissector_handle);
+        }
+        for (uint  idx = 0; idx < parent.PARENT_SUBFIELD_RANGES_int.size(); ++idx)
+        {
+            int    value_low  = parent.PARENT_SUBFIELD_RANGES_int[idx].first;
+            int    value_high = parent.PARENT_SUBFIELD_RANGES_int[idx].second;
+
+            M_TRACE_DEBUG ("PARENT_SUBFIELD_RANGE = " << value_low << " - " << value_high);
+
+            for (int  value = value_low; value <= value_high; ++value)
+            {
+                dissector_add_uint(parent.PARENT_SUBFIELD.c_str(),
+                                   value,
+                                   P_protocol_ws_data->dissector_handle);
+            }
+        }
+        for (uint  idx = 0; idx < parent.PARENT_SUBFIELD_VALUES_str.size(); ++idx)
+        {
+            M_TRACE_DEBUG ("PARENT_SUBFIELD_VALUE = " << parent.PARENT_SUBFIELD_VALUES_str[idx]);
+
+            dissector_add_string(parent.PARENT_SUBFIELD.c_str(),
+                                 parent.PARENT_SUBFIELD_VALUES_str[idx].c_str(),
+                                 P_protocol_ws_data->dissector_handle);
+        }
+    }
+
+    // Declare heuristic dissectors
+    for (vector<string>::const_iterator
+                                parent_iter  = protocol_data.PARENTS_HEURISTIC.begin();
+                                parent_iter != protocol_data.PARENTS_HEURISTIC.end();
+                              ++parent_iter)
+    {
+        const string  & parent_name = *parent_iter;
+
+        if (is_an_heuristic_dissector(parent_name) != true)
+        {
+            if (find_dissector_table(parent_name.c_str()) == nullptr)
+            {
+                wsgd_report_failure(
+                            "Generic dissector did NOT succeed to find parent heuristic dissector " + parent_name +
+                            " (because it does NOT exist).\n");
+            }
+            else
+            {
+                wsgd_report_failure(
+                            "Generic dissector did NOT succeed to find parent heuristic dissector " + parent_name +
+                            " (because it is NOT an heuristic dissector).\n");
+            }
+        
+            continue;
+        }
+      
+#if WIRESHARK_VERSION_NUMBER >= 30400
+        heur_dissector_add(parent_name.c_str(),
+                            P_protocol_ws_data->P_heuristic_fct,
+                            protocol_data.PROTONAME.c_str(),
+                            protocol_data.PROTOABBREV.c_str(),
+                            P_protocol_ws_data->proto_generic,
+                            HEURISTIC_ENABLE);
+#else
+        heur_dissector_add(parent_name.c_str(),
+                            P_protocol_ws_data->P_heuristic_fct,
+                            protocol_data.PROTONAME.c_str(),
+                            protocol_data.PROTOSHORTNAME.c_str(),
+                            P_protocol_ws_data->proto_generic,
+                            HEURISTIC_ENABLE);
+#endif
+    }
+
+    // Declare decode as dissectors
+    for (vector<string>::const_iterator
+            decode_as_iter  = protocol_data.ADD_FOR_DECODE_AS_TABLES.begin();
+            decode_as_iter != protocol_data.ADD_FOR_DECODE_AS_TABLES.end();
+          ++decode_as_iter)
+    {
+        const string  & decode_as_table_name = *decode_as_iter;
+
+        dissector_add_for_decode_as(decode_as_table_name.c_str(), P_protocol_ws_data->dissector_handle);
+    }
+
+    // Check subdissector name
+    vector<string>  & vector_subdissector_name = protocol_data.type_definitions.vector_subdissector_name;
+    for (vector<string>::const_iterator
+                                subdissector_iter  = vector_subdissector_name.begin();
+                                subdissector_iter != vector_subdissector_name.end();
+                              ++subdissector_iter)
+    {
+        const string  & subdissector_name = *subdissector_iter;
+
+        dissector_handle_t  dissector_handle = find_dissector(subdissector_name.c_str());
+        if (dissector_handle == nullptr)
+        {
+            wsgd_report_failure(
+                        "Generic dissector did NOT succeed to find subdissector " + subdissector_name +
+                        " (because it does NOT exist).\n" 
+                        "\n"
+                        "Explicit calls to this subdissector will NOT work.\n");
+        }
+        if (false)  // comment savoir qu'il est dsactiv ?
+        {
+            wsgd_report_failure(
+                        "Generic dissector will NOT succeed to call subdissector " + subdissector_name +
+                        " because it has been deactivated.\n" 
+                        "\n"
+                        "Explicit calls to this subdissector will NOT work.\n");
+        }
+    }
+
+    // Statistics
+    register_generic_stats_trees(protocol_data);
+
+    M_TRACE_DEBUG ("Leave cpp_proto_reg_handoff_generic " << protocol_data.proto_idx);
+}
+
+//*****************************************************************************
+// get_interpret_ostream
+//*****************************************************************************
+
+ostream &  get_interpret_ostream()
+{
+    if (get_debug())
+    {
+        return  get_state_ostream();
+    }
+    else
+    {
+        static ostringstream    oss;
+        return  oss;
+    }
+}
+
+//*****************************************************************************
+// proto_init_routine
+// Called when :
+// - a new capture is started ?
+// - a new capture file is loaded
+// - end of wireshark
+// NOT called when :
+// - a new display filter is applied or cancelled
+// - colorization is applied or cancelled
+// !!!!!!!!!!!!!!! a verifier !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+// voir pinfo->fd->num == 1
+// voir reset callback of register_tap_listener
+//*****************************************************************************
+
+void    proto_init_routine(T_generic_protocol_data  & protocol_data)
+{
+    C_debug_set_temporary      debug_dissect_main(protocol_data.DEBUG);
+    M_TRACE_ENTER ("proto_init_routine", protocol_data.PROTOABBREV);
+
+
+    // Begin/load a new capture/file or ...
+    interpret_builder_begin(protocol_data.type_definitions);
+
+
+    // remove all global.*
+    if (protocol_data.GLOBAL_DATA_TYPE != "")
+    {
+        // reset global data
+        protocol_data.ws_data.global_data = T_generic_protocol_global_data();
+
+        // init global data
+        C_interpret_builder_set_temporary  interpret_builder_set_temporary(nullptr);
+        T_interpret_data   & interpret_data = * protocol_data.ws_data.global_data.RCP_initialized_data;
+        const T_byte       * in_out_P_bytes = nullptr;
+        size_t               in_out_sizeof_bytes = 0;
+        const string         str_interpret = "var " + protocol_data.GLOBAL_DATA_TYPE + " global = zero;";
+        istringstream        iss(str_interpret.c_str());
+        ostream            & os = get_interpret_ostream();
+        bool    result = interpret_bytes (protocol_data.type_definitions,
+                                                            in_out_P_bytes,
+                                                            in_out_sizeof_bytes,
+                                                            iss,
+                                                            os,
+                                                            os,
+                                                            interpret_data);
+        if (result == false)
+        {
+            // must report
+            string    str_report = protocol_data.PROTOABBREV + " : Generic dissector is not able to interpret the global data";
+            M_TRACE_FATAL (str_report);
+            wsgd_report_failure(str_report.c_str());
+        }
+    }
+}
+
+//*****************************************************************************
+// proto_init_routine
+//*****************************************************************************
+
+// ICIOA
+extern vector<T_generic_protocol_data>  S_protocol_data;
+
+void    proto_init_routine()
+{
+    for (uint   proto_idx = 0; proto_idx < S_protocol_data.size(); ++proto_idx)
+    {
+        T_generic_protocol_data  & protocol_data = S_protocol_data[proto_idx];
+        if (protocol_data.is_proto_usable())
+        {
+            proto_init_routine(protocol_data);
+        }
+    }
+}
+
+//*****************************************************************************
+// cpp_proto_reg_handoff_generic
+//*****************************************************************************
+extern "C"
+void    cpp_proto_reg_handoff_generic()
+{
+    uint   proto_idx = 0;
+    for (proto_idx = 0; proto_idx < S_protocol_data.size(); ++proto_idx)
+    {
+        if (S_protocol_data[proto_idx].is_proto_usable())
+        {
+            cpp_proto_reg_handoff_generic_proto(S_protocol_data[proto_idx]);
+        }
+    }
+
+    T_generic_protocol_subdissector_data::data_handle = find_dissector("data");
+    register_init_routine(proto_init_routine);
+}
+
+//*****************************************************************************
+// dissect
+//*****************************************************************************
+
+/******************************************************************************
+ * cpp_dissect_generic_add_tree
+ *****************************************************************************/
+
+proto_tree  * cpp_dissect_generic_add_tree(const int           proto_idx,
+                                                 proto_item  * item)
+{
+    T_generic_protocol_data     & protocol_data = get_protocol_data(proto_idx);
+    T_generic_protocol_ws_data  * P_protocol_ws_data = &protocol_data.ws_data;
+
+    return  proto_item_add_subtree(item, P_protocol_ws_data->fields_data.ett_id[K_ANY_WSGD_FIELD_IDX]);
+}
+
+/******************************************************************************
+ * cpp_dissect_generic_set_packet_id_str
+ *****************************************************************************/
+
+void    cpp_dissect_generic_set_packet_id_str(T_generic_protocol_data  & UNUSED(protocol_data),
+                                                    tvbuff_t     * UNUSED(tvb),
+                                                    packet_info  * pinfo,
+                                                    proto_tree   * UNUSED(tree),
+                                              const string       & packet_id_str)
+{
+    M_TRACE_ENTER("cpp_dissect_generic_set_packet_id_str", packet_id_str);
+
+    // ICIOA : do not print the port's names as tcp dissector does
+    // must use get_tcp_port (or ...) from epan/addr_resolv.h
+    // I choose to NOT do it (for now) :
+    // - perhaps I'm not on tcp (how to know it ?)
+    // - always use generic dissector with NOT public protocol on NOT public ports
+    // - is it normal to display the parent proto ports ?
+    // - what will happen with a sub proto ?
+#if 0
+    col_add_fstr(pinfo->cinfo, COL_INFO,
+                 "%d > %d %s",
+                 pinfo->srcport, pinfo->destport, packet_id_str.c_str());
+#else
+    col_append_fstr(pinfo->cinfo, COL_INFO, " %s", packet_id_str.c_str());
+#endif
+}
+
+/******************************************************************************
+ * cpp_dissect_generic_set_packet_summary_str
+ *****************************************************************************/
+
+proto_item  * cpp_dissect_generic_set_packet_summary_str(T_generic_protocol_data  & protocol_data,
+                                                               tvbuff_t     * tvb,
+                                                               packet_info  * UNUSED(pinfo),
+                                                               proto_tree   * tree,
+                                                         const string  & packet_summary_str)
+{
+    T_generic_protocol_ws_data   * P_protocol_ws_data = &protocol_data.ws_data;
+
+    proto_item  * generic_item = proto_tree_add_protocol_format(tree, P_protocol_ws_data->proto_generic, tvb, 0, -1,
+            "%s, %s",
+            protocol_data.PROTONAME.c_str(), packet_summary_str.c_str());
+    return  generic_item;
+}
+
+
+//*****************************************************************************
+// pinfo_address_to_string
+//*****************************************************************************
+#if 0
+typedef enum {
+  AT_NONE,		/* no link-layer address */
+  AT_ETHER,		/* MAC (Ethernet, 802.x, FDDI) address */
+  AT_IPv4,		/* IPv4 */
+  AT_IPv6,		/* IPv6 */
+  AT_IPX,		/* IPX */
+  AT_SNA,		/* SNA */
+  AT_ATALK,		/* Appletalk DDP */
+  AT_VINES,		/* Banyan Vines */
+  AT_OSI,		/* OSI NSAP */
+  AT_ARCNET,	/* ARCNET */
+  AT_FC,		/* Fibre Channel */
+  AT_SS7PC,		/* SS7 Point Code */
+  AT_STRINGZ,	/* null-terminated string */
+  AT_EUI64,		/* IEEE EUI-64 */
+  AT_URI,		/* URI/URL/URN */
+  AT_TIPC,		/* TIPC Address Zone,Subnetwork,Processor */
+  AT_USB		/* USB Device address 
+             * (0xffffffff represents the host) */
+} address_type;
+#endif
+
+string    pinfo_address_to_string(const address  & addr)
+{
+    string  str_address = "type=" + get_string(addr.type);
+    str_address += "  ";
+    for (int  idx_addr = 0; idx_addr < addr.len; ++idx_addr)
+    {
+        if (addr.type == AT_ETHER)
+        {
+            if (idx_addr > 0)
+                str_address += ":";
+            char    tmp[99+1];
+            sprintf(tmp, "%02x", (unsigned int)((const unsigned char*)addr.data)[idx_addr]);
+            str_address += tmp;
+        }
+        else
+        {
+            if (idx_addr > 0)
+                str_address += ".";
+            str_address += get_string((unsigned int)((const unsigned char*)addr.data)[idx_addr]);
+        }
+    }
+
+    return  str_address;
+}
+
+//*****************************************************************************
+// pinfo_nstime_to_string
+//*****************************************************************************
+
+string    pinfo_nstime_to_string(const nstime_t  & nstime)
+{
+    char    tmp[99+1];
+    // long cast : permits to handle platforms where time_t is a long
+  //  rather than an int (e.g., OS X)
+    sprintf (tmp, "%ld.%09d", (long)nstime.secs, nstime.nsecs);
+    return  tmp;
+}
+
+//*****************************************************************************
+// add_pinfo
+// pinfo is wireshark internal data.
+// pinfo definition could change depending on wireshark version.
+//*****************************************************************************
+
+void    add_pinfo(const T_generic_protocol_data  & UNUSED(protocol_data),
+                  const packet_info              * pinfo,
+                        T_interpret_data         & interpret_data)
+{
+    interpret_data.pinfo_variable_group_begin();
+
+#define M_ADD_PINFO(NAME)                                             \
+    interpret_data.add_read_variable(#NAME, pinfo->NAME)
+
+#define M_ADD_PINFO_STR(NAME)                                             \
+    interpret_data.add_read_variable(#NAME, pinfo->NAME ? pinfo->NAME : "")
+
+#define M_ADD_PINFO_ADDRESS(NAME)                                             \
+    interpret_data.add_read_variable(#NAME, pinfo_address_to_string(pinfo->NAME).c_str())
+
+#define M_ADD_PINFO_ADDRESS(NAME)                                             \
+    interpret_data.add_read_variable(#NAME, pinfo_address_to_string(pinfo->NAME).c_str())
+
+#define M_ADD_PINFO_FD(NAME)                                             \
+    interpret_data.add_read_variable(#NAME, pinfo->fd->NAME)
+
+#define M_ADD_PINFO_FD_NSTIME(NAME)                                             \
+    interpret_data.add_read_variable(#NAME, pinfo_nstime_to_string(pinfo->fd->NAME));  \
+    interpret_data.add_read_variable(#NAME ".secs", pinfo->fd->NAME.secs);  \
+    interpret_data.add_read_variable(#NAME ".nsecs", pinfo->fd->NAME.nsecs)
+
+    M_ADD_PINFO(current_proto);
+//  M_ADD_PINFO();  // column_info *cinfo;		/* Column formatting information */
+    if (pinfo->fd != nullptr)  // frame_data*
+    {
+        interpret_data.read_variable_group_begin("fd");
+        M_ADD_PINFO_FD(num);         /* Frame number */
+        M_ADD_PINFO_FD(pkt_len);     /* Packet length */
+        M_ADD_PINFO_FD(cap_len);     /* Amount actually captured */
+        M_ADD_PINFO_FD(cum_bytes);   /* Cumulative bytes into the capture */
+        M_ADD_PINFO_FD_NSTIME(abs_ts);      /* Absolute timestamp */
+        M_ADD_PINFO_FD(file_off);    /* File offset */
+        interpret_data.read_variable_group_end();
+    }
+//  M_ADD_PINFO();  // union wtap_pseudo_header *pseudo_header;
+//  M_ADD_PINFO();  // GSList *data_src;		/* Frame data sources */
+    M_ADD_PINFO_ADDRESS(dl_src);		/* link-layer source address */
+    M_ADD_PINFO_ADDRESS(dl_dst);		/* link-layer destination address */
+    M_ADD_PINFO_ADDRESS(net_src);		/* network-layer source address */
+    M_ADD_PINFO_ADDRESS(net_dst);		/* network-layer destination address */
+    M_ADD_PINFO_ADDRESS(src);			/* source address (net if present, DL otherwise )*/
+    M_ADD_PINFO_ADDRESS(dst);			/* destination address (net if present, DL otherwise )*/
+
+    // In wireshark 1.1.z, there is a new field here.
+    // So, all following fields are not at the same place.
+
+    // wireshark version is "x.y.z<anything>"
+    const char  * version_compil = VERSION;
+    const char  * version_exec   = epan_get_version();
+    if (strncmp(version_compil, version_exec, 4) == 0)
+    {
+        M_ADD_PINFO_STR(noreassembly_reason);  /* reason why reassembly wasn't done, if any */
+        M_ADD_PINFO(fragmented);          /* TRUE if the protocol is only a fragment */
+        M_ADD_PINFO(ptype);               /* type of the following two port numbers */
+        M_ADD_PINFO(srcport);
+        M_ADD_PINFO(destport);
+        M_ADD_PINFO_STR(match_string);
+
+        M_ADD_PINFO(can_desegment);
+        M_ADD_PINFO(saved_can_desegment);
+        M_ADD_PINFO(desegment_offset);
+        M_ADD_PINFO(desegment_len);
+        M_ADD_PINFO(want_pdu_tracking);
+        M_ADD_PINFO(bytes_until_next_pdu);
+        M_ADD_PINFO(p2p_dir);
+    // layers
+//	if (pinfo->layers != nullptr)
+//	{
+//		//interpret_data.read_variable_group_begin("layers");
+//		wmem_list_frame_t * layer_current = wmem_list_head(pinfo->layers);
+//		int layer_current_idx = 0;
+//		while (layer_current != nullptr)
+//		{
+//			const void * layer_data = wmem_list_frame_data(layer_current);
+//			if (layer_data != nullptr)
+//			{
+//				const int   proto_id = GPOINTER_TO_UINT(layer_data);
+//				const char* proto_name = proto_get_protocol_filter_name(proto_id);
+//#if 0
+//				// Good display format but NOT possible to use it
+//				const std::string  variable_name = "layers[" + get_string(layer_current_idx) + "]";
+//#else
+//				// Possible to use (but only with hard-coded value !!!)
+//				const std::string  variable_name = "layers" + get_string(layer_current_idx) + "";
+//				interpret_data.read_variable_group_begin(variable_name);
+//#endif
+//				interpret_data.add_read_variable(variable_name, "id", get_string(proto_id));
+//				interpret_data.add_read_variable(variable_name, "name", ((proto_name != nullptr) ? proto_name : "?"));
+//				interpret_data.read_variable_group_end();
+//			}
+//			layer_current = wmem_list_frame_next(layer_current);
+//			++layer_current_idx;
+//		}
+//		//interpret_data.read_variable_group_end();
+//	}
+        M_ADD_PINFO(curr_layer_num);
+        M_ADD_PINFO(link_number);
+        M_ADD_PINFO(clnp_srcref);
+        M_ADD_PINFO(clnp_dstref);
+        M_ADD_PINFO(link_dir);
+        //{
+        //	interpret_data.read_variable_group_begin("proto_data");
+        //	GSList*  next = pinfo->proto_data;
+        //	while (next != nullptr)
+        //	{
+        //		gpointer data = next->data;
+        //		if (data != nullptr)
+        //		{
+        //		}
+        //		next = next->next;
+        //	}
+        //	interpret_data.read_variable_group_end();
+        //}
+    }
+
+    interpret_data.pinfo_variable_group_end();
+}
+
+//*****************************************************************************
+// update_pinfo_ports
+//*****************************************************************************
+
+void    update_pinfo_ports(const T_generic_protocol_data  & protocol_data,
+                                 packet_info              * pinfo,
+                                 T_interpret_data         & interpret_data)
+{
+    if ((protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_2 == "") ||
+        (protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_1 == ""))
+        return;
+
+    for (vector<T_generic_protocol_data::T_parent>::const_iterator
+                                    parent_iter  = protocol_data.PARENTS.begin();
+                                    parent_iter != protocol_data.PARENTS.end();
+                                  ++parent_iter)
+    {
+        const T_generic_protocol_data::T_parent  & parent = * parent_iter;
+
+        /* TCP/UDP */
+        if (parent.PARENT_SUBFIELD == "ip.proto")
+        {
+            if (parent.PARENT_SUBFIELD_VALUES_int[0] == 0x6)
+            {
+                pinfo->ptype    = PT_TCP;
+            }
+            else if (parent.PARENT_SUBFIELD_VALUES_int[0] == 0x11)
+            {
+                pinfo->ptype    = PT_UDP;
+            }
+            else
+            {
+                continue;
+            }
+
+            longlong    srcport;
+            interpret_data.get_int_value_of_read_variable(
+                                        protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_1,
+                                        srcport);
+            pinfo->srcport  = static_cast<guint32>(srcport);
+
+            longlong    destport;
+            interpret_data.get_int_value_of_read_variable(
+                                        protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_2,
+                                        destport);
+            pinfo->destport = static_cast<guint32>(destport);
+
+            return;
+        }
+    }
+}
+
+//*****************************************************************************
+// cpp_dissect_generic
+//*****************************************************************************
+
+gint    cpp_dissect_generic(      T_generic_protocol_data  & protocol_data,
+                                  tvbuff_t                 * tvb,
+                            const void                     * ptr_raw_data,
+                            const int                        length_raw_data,
+                                  packet_info              * pinfo,
+                                  proto_tree               * msg_root_tree,
+                            const long                       msg_number_inside_packet)
+{
+    M_TRACE_ENTER ("cpp_dissect_generic", protocol_data.PROTOABBREV << " ("
+        << pinfo->fd->num << "/"
+        << msg_number_inside_packet << ", "
+        << tvb << ", "
+        << ptr_raw_data << ", "
+        << length_raw_data << ", "
+        << pinfo << ", "
+        << msg_root_tree << ")");
+
+    proto_tree   * tree = msg_root_tree;
+
+    const int                  proto_idx = protocol_data.proto_idx;
+    M_TRACE_DEBUG ("proto_idx = " << proto_idx);
+    ostream                  & os = get_interpret_ostream();
+
+    // It could be mandatory to interpret the entire msg (even if msg_root_tree is nullptr)
+    bool      mandatory_to_interpret_the_entire_msg = (tree != nullptr);
+    if (protocol_data.GLOBAL_DATA_TYPE != "")
+    {
+        mandatory_to_interpret_the_entire_msg = true;
+    }
+    else if (protocol_data.ws_data.tap_data.tap_is_needed)
+    {
+        mandatory_to_interpret_the_entire_msg = true;
+    }
+
+    // interpret data.
+    // ATTENTION, we must NOT create a new interpret_data if it already exist into global data.
+    //  because it could be referenced by its memory address into other global data.
+    // This is the current implementation of msg type. Not a good idea, but ...
+    T_RCP_interpret_data              RCP_interpret_data;
+
+    // Global data.
+    T_generic_protocol_saved_interpreted_data  * P_where_to_save_interpret_data = nullptr;
+    T_RCP_interpret_data                         RCP_prev_global_interpret_data = nullptr;
+    if (protocol_data.GLOBAL_DATA_TYPE != "")
+    {
+        // Search for previous msg
+        T_RCP_interpret_data    RCP_prev_saved_interpret_data = nullptr;
+
+        // Compute P_prev_saved_interpret_data
+        // Compute P_where_to_save_interpret_data
+        const long                packet_number = pinfo->fd->num;
+        for (vector<T_generic_protocol_saved_interpreted_data>::reverse_iterator
+                rev_iter  = protocol_data.ws_data.global_data.saved_interpreted_datas.rbegin();
+                rev_iter != protocol_data.ws_data.global_data.saved_interpreted_datas.rend();
+              ++rev_iter)
+        {
+            T_generic_protocol_saved_interpreted_data  & saved_interpreted_data = *rev_iter;
+
+            if ((saved_interpreted_data.packet_number == packet_number) &&
+                (saved_interpreted_data.msg_number_inside_packet == msg_number_inside_packet))
+            {
+                // Found
+                P_where_to_save_interpret_data = & saved_interpreted_data;
+
+                ++rev_iter;
+                if (rev_iter != protocol_data.ws_data.global_data.saved_interpreted_datas.rend())
+                {
+                    RCP_prev_saved_interpret_data = rev_iter->RCP_interpret_data;
+                }
+
+                break;
+            }
+            else if (saved_interpreted_data.packet_number < packet_number)
+            {
+                // Not found
+                RCP_prev_saved_interpret_data = rev_iter->RCP_interpret_data;
+                break;
+            }
+            else if ((saved_interpreted_data.packet_number == packet_number) &&
+                    (saved_interpreted_data.msg_number_inside_packet < msg_number_inside_packet))
+            {
+                // Not found
+                RCP_prev_saved_interpret_data = rev_iter->RCP_interpret_data;
+                break;
+            }
+        }
+
+        if (P_where_to_save_interpret_data != nullptr)
+        {
+            RCP_interpret_data = P_where_to_save_interpret_data->RCP_interpret_data;
+            RCP_interpret_data->reset();
+        }
+        else
+        {
+            RCP_interpret_data = new T_interpret_data;
+            M_TRACE_DEBUG ("GLOBAL_DATA new T_interpret_data=" << RCP_interpret_data.get());
+        }
+        // Save global data pointer
+        RCP_prev_global_interpret_data = RCP_prev_saved_interpret_data;
+        if (RCP_prev_global_interpret_data.get() == nullptr)
+        {
+            RCP_prev_global_interpret_data = protocol_data.ws_data.global_data.RCP_initialized_data;
+        }
+        RCP_interpret_data->copy_global_values(*RCP_prev_global_interpret_data);
+    }
+
+    // interpret data.
+    if (! RCP_interpret_data)
+    {
+        RCP_interpret_data = new T_interpret_data;
+        M_TRACE_DEBUG ("new T_interpret_data=" << RCP_interpret_data.get());
+    }
+    T_interpret_data                & interpret_data = * RCP_interpret_data;
+
+    // pinfo is wireshark internal data.
+    if (protocol_data.MANAGE_WIRESHARK_PINFO == true)
+    {
+        add_pinfo(protocol_data, pinfo, interpret_data);
+    }
+
+    // create this_msg variable
+    if (protocol_data.GLOBAL_DATA_TYPE != "")
+    {
+        interpret_data.add_this_msg();
+    }
+
+    // No wireshark output.
+    C_interpret_builder_set_temporary  interpret_builder_set_temporary(nullptr);
+
+    string    summary;
+    string    MSG_ID_FIELD_NAME;
+
+    // Read MSG_HEADER_TYPE.
+    // Retrieve the MSG_ID value
+    // -> set the packet_id_str
+    // -> init summary
+    {
+        // Read MSG_HEADER_TYPE.
+        const T_byte       * in_out_P_bytes = static_cast<const T_byte *>(ptr_raw_data);
+        size_t               in_out_sizeof_bytes = length_raw_data;
+
+        // NB: do not set a name to the variable
+        //      because the name will be mandatory everywhere in the code and/or wsgd file
+        //      for MSG_ID_FIELD_NAME, MSG_SUMMARY_SUBSIDIARY_FIELD_NAMES and MSG_MAIN_TYPE
+        const string         str_interpret = protocol_data.MSG_HEADER_TYPE + " " + "\"\" ;";
+        istringstream        iss(str_interpret.c_str());
+
+        C_byte_interpret_wsgd_builder_base  wsgd_builder(proto_idx, tvb, pinfo, tree, tree);
+        C_interpret_builder_set_temporary   interpret_builder_set_temporary2(&wsgd_builder);
+
+        if (protocol_data.PACKET_CONTAINS_ONLY_COMPLETE_MSG)
+        {
+        // All the input data is present.
+        wsgd_builder.set_is_input_data_complete(true);
+        }
+
+        // returns false if NOT enough bytes -> DESEGMENT managed by wsgd_builder.
+        // NB: returns true even if MSG_HEADER_TYPE is unknown !
+        bool    result = interpret_bytes (protocol_data.type_definitions,
+                                                        in_out_P_bytes,
+                                                        in_out_sizeof_bytes,
+                                                        iss,
+                                                        os,
+                                                        os,
+                                                        interpret_data);
+        if (result == false)
+        {
+            M_TRACE_WARNING ("Error during interpret_bytes for the header, could be not enough data");
+            return  0;
+        }
+
+        const T_attribute_value *  P_attr_MSG_ID_FIELD_NAME = interpret_data.get_P_attribute_value_of_read_variable (protocol_data.MSG_ID_FIELD_NAME);
+
+        if (P_attr_MSG_ID_FIELD_NAME == nullptr)
+        {
+            // The header has been entirely read, but the MSG_ID_FIELD_NAME has NOT been found !!!
+            // ICIOA user NOT warned !!!
+            M_TRACE_FATAL ("Did NOT find " << protocol_data.MSG_ID_FIELD_NAME << " (MSG_ID_FIELD_NAME)");
+            return  0;
+        }
+
+        // Retrieve the MSG_ID value
+        MSG_ID_FIELD_NAME = interpret_data.get_full_str_value_of_read_variable(protocol_data.MSG_ID_FIELD_NAME);
+        M_TRACE_DEBUG ("MSG_ID_FIELD_NAME = " << MSG_ID_FIELD_NAME);
+
+        string    msg_id;
+        if (protocol_data.MSG_TITLE != "")
+        {
+            string    MSG_TITLE = interpret_data.get_full_str_value_of_read_variable(protocol_data.MSG_TITLE);
+            M_TRACE_DEBUG ("MSG_TITLE = " << MSG_TITLE);
+            msg_id = "[" + MSG_TITLE + "]";
+        }
+        else
+        {
+            msg_id = "[" + MSG_ID_FIELD_NAME + "]";
+        }
+
+        // -> set the packet_id_str
+        cpp_dissect_generic_set_packet_id_str(protocol_data, tvb, pinfo, tree, msg_id);
+
+        /* Update the pinfo ports */
+        update_pinfo_ports(protocol_data, pinfo, interpret_data);
+
+
+        if ((tree == nullptr) && (mandatory_to_interpret_the_entire_msg != true))
+        {
+            if (protocol_data.PACKET_CONTAINS_ONLY_COMPLETE_MSG &&
+                protocol_data.PACKET_CONTAINS_ONLY_1_MSG)
+                return length_raw_data;
+
+            if (protocol_data.MSG_TOTAL_LENGTH != "")
+            {
+                C_value  msg_total_length = compute_expression_no_io(protocol_data.type_definitions, interpret_data, protocol_data.MSG_TOTAL_LENGTH);
+                if (length_raw_data < msg_total_length.get_int())
+                {
+                    // Not an error, wait for the next segment.
+                    pinfo->desegment_offset = 0;             /* Start at beginning next time */
+                    pinfo->desegment_len = static_cast<guint32>(msg_total_length.get_int() - length_raw_data);
+                    return  0;
+                }
+                else
+                {
+                    pinfo->desegment_len = 0;           // 2011/05/15
+                    return  msg_total_length.get_int_int();
+                }
+            }
+
+            // I do not know the size of the message.
+            // I must interpret it completely to know where it ends
+            //  (and so where start the next message) !
+            mandatory_to_interpret_the_entire_msg = true;
+        }
+
+        // -> init summary
+        summary += protocol_data.MSG_ID_FIELD_NAME;
+        summary += ": ";
+        summary += MSG_ID_FIELD_NAME;
+        summary += "  ";
+    }
+
+    if (mandatory_to_interpret_the_entire_msg)
+    {
+        // Retrieve all the MSG_SUMMARY_SUBSIDIARY values and complete summary.
+        for (vector<string>::const_iterator  iter  = protocol_data.MSG_SUMMARY_SUBSIDIARY_FIELD_NAMES.begin();
+                                             iter != protocol_data.MSG_SUMMARY_SUBSIDIARY_FIELD_NAMES.end();
+                                           ++iter)
+        {
+            const string    MSG_SUMMARY_SUBSIDIARY_FIELD_NAME = interpret_data.get_full_str_value_of_read_variable(*iter);
+            M_TRACE_DEBUG ("MSG_SUMMARY_SUBSIDIARY_FIELD_NAME = " << MSG_SUMMARY_SUBSIDIARY_FIELD_NAME);
+
+            summary += *iter;
+            summary += ": ";
+            summary += MSG_SUMMARY_SUBSIDIARY_FIELD_NAME;
+            summary += "  ";
+        }
+
+        // Set first item.
+        proto_item  * proto_item = cpp_dissect_generic_set_packet_summary_str(protocol_data, tvb, pinfo, tree, summary);
+        tree = cpp_dissect_generic_add_tree(proto_idx, proto_item);
+
+        // Read MSG_MAIN_TYPE.
+        const T_byte       * in_out_P_bytes = static_cast<const T_byte *>(ptr_raw_data);
+        size_t               in_out_sizeof_bytes = length_raw_data;
+
+        C_byte_interpret_wsgd_builder      wsgd_builder(proto_idx, tvb, pinfo, tree, msg_root_tree);
+        C_interpret_builder_set_temporary  interpret_builder_set_temporary2(&wsgd_builder);
+
+        // Check that the packet identifier has been found.
+        if (MSG_ID_FIELD_NAME == "")
+        {
+            // Could happen if :
+            // - bad MSG_HEADER_TYPE specified (checked at initialization)
+            // - bad MSG_ID_FIELD_NAME specified
+            // - too small packet (checked before IF MSG_HEADER_LENGTH has been set)
+            M_TRACE_FATAL (protocol_data.MSG_ID_FIELD_NAME << " (MSG_ID_FIELD_NAME) NOT found");
+            const string         str_interpret = "fatal  \"value of " + protocol_data.MSG_ID_FIELD_NAME + " (MSG_ID_FIELD_NAME) NOT found into " + protocol_data.MSG_HEADER_TYPE + " (MSG_HEADER_TYPE)\" ;";
+
+            interpret_bytes (               protocol_data.type_definitions,
+                                            in_out_P_bytes,
+                                            in_out_sizeof_bytes,
+                                            str_interpret,
+                                            os,
+                                            os,
+                                            interpret_data);
+//          return  0;
+        }
+
+        // Manage MSG_TOTAL_LENGTH
+        // More or less tested.
+        size_t    sizeof_bytes_NOT_given_to_interpretor = 0;
+        if (protocol_data.MSG_TOTAL_LENGTH != "")
+        {
+            C_value  msg_total_length = compute_expression_no_io(protocol_data.type_definitions, interpret_data, protocol_data.MSG_TOTAL_LENGTH);
+            if (length_raw_data < msg_total_length.get_int())
+            {
+                // Not an error, wait for the next segment.
+                pinfo->desegment_offset = 0;             /* Start at beginning next time */
+                pinfo->desegment_len = static_cast<guint32>(msg_total_length.get_int() - length_raw_data);
+                return  0;
+            }
+
+            // Reduce the interpretor accessible data.
+            in_out_sizeof_bytes = msg_total_length.get_int_size_t();
+            sizeof_bytes_NOT_given_to_interpretor = length_raw_data - msg_total_length.get_int_size_t();
+
+            // All the input data is present.
+            wsgd_builder.set_is_input_data_complete(true);
+        }
+
+        if ((sizeof_bytes_NOT_given_to_interpretor > 0) && (protocol_data.PACKET_CONTAINS_ONLY_1_MSG))
+        {
+            // The packet seems to contains more than 1 msg or
+            //  MSG_TOTAL_LENGTH is not good or
+            //  message is not good.
+        }
+
+        if (protocol_data.PACKET_CONTAINS_ONLY_COMPLETE_MSG)
+        {
+            // All the input data is present.
+            wsgd_builder.set_is_input_data_complete(true);
+        }
+
+        if (RCP_prev_global_interpret_data.get() != nullptr)
+        {
+            // global data could have been modified by header
+            // Since we read again the header, must start with the original values
+            interpret_data.copy_global_values(*RCP_prev_global_interpret_data);
+        }
+
+        // Intrepretation of the main type.
+        string         str_interpret_main;
+        if (protocol_data.MSG_MAIN_TYPE != "")
+        {
+            str_interpret_main = protocol_data.MSG_MAIN_TYPE;
+        }
+        else
+        {
+            // Must choose the main type depending on the source port and the dest port.
+            // 2009/03/14 : these tests work only above a protocol which fills srcport and destport.
+            // Will NOT work above my own proto.
+            for (vector<T_generic_protocol_data::T_parent>::const_iterator
+                                      parent_iter  = protocol_data.PARENTS.begin();
+                                      parent_iter != protocol_data.PARENTS.end();
+                                    ++parent_iter)
+            {
+                const T_generic_protocol_data::T_parent  & parent = * parent_iter;
+
+                for (size_t   idx = 0; idx < parent.PARENT_SUBFIELD_VALUES_int.size(); ++idx)
+                {
+                    if (pinfo->srcport == parent.PARENT_SUBFIELD_VALUES_int[idx])
+                    {
+                        str_interpret_main = protocol_data.MSG_FROM_MAIN_TYPE;
+                        break;
+                    }
+                    else if (pinfo->destport == parent.PARENT_SUBFIELD_VALUES_int[idx])
+                    {
+                        str_interpret_main = protocol_data.MSG_TO_MAIN_TYPE;
+                        break;
+                    }
+                }
+                if (str_interpret_main != "")
+                    break;
+            }
+            if (str_interpret_main == "")
+            {
+                // Port NOT found, choose FROM by default.
+                str_interpret_main = protocol_data.MSG_FROM_MAIN_TYPE;
+                // This could happen if user use Decode as.
+                // How to warn the user about the problem ?
+                // ATTENTION, this will warn the user for each dissection !!!
+                // -> static value to avoid another call (or too much call) ?
+                // -> How to know if it is the same capture or Decode as operation ?
+                wsgd_report_failure("Generic dissector is NOT able to choose between MSG_FROM_MAIN_TYPE and MSG_TO_MAIN_TYPE.\n"
+                        "This could happen if you have choose Decode as for a packet with source and dest ports not into PARENT_SUBFIELD_VALUES.\n"
+                        "\n"
+                        "MSG_FROM_MAIN_TYPE has been taken.\n");
+            }
+        }
+        str_interpret_main += " \"\" ;";
+        istringstream        iss_main(str_interpret_main.c_str());
+
+        bool    result = interpret_bytes (   protocol_data.type_definitions,
+                                            in_out_P_bytes,
+                                            in_out_sizeof_bytes,
+                                            iss_main,
+                                            os,
+                                            os,
+                                            interpret_data);
+
+        const int   proto_item_len = length_raw_data - in_out_sizeof_bytes - sizeof_bytes_NOT_given_to_interpretor;
+        proto_item_set_len(proto_item, proto_item_len);
+
+        // Global data and Tap.
+        if (result == true)
+        {
+            if ((P_where_to_save_interpret_data == nullptr) &&
+                (protocol_data.GLOBAL_DATA_TYPE != ""))
+            {
+                M_TRACE_DEBUG ("GLOBAL_DATA saved_interpreted_datas.push_back");
+
+                protocol_data.ws_data.global_data.saved_interpreted_datas.push_back(T_generic_protocol_saved_interpreted_data());
+                T_generic_protocol_saved_interpreted_data  & saved_interpreted_data = protocol_data.ws_data.global_data.saved_interpreted_datas.back();
+                saved_interpreted_data.packet_number = pinfo->fd->num;
+                saved_interpreted_data.msg_number_inside_packet = msg_number_inside_packet;
+
+                P_where_to_save_interpret_data = & saved_interpreted_data;
+            }
+
+            if (P_where_to_save_interpret_data != nullptr)
+            {
+                P_where_to_save_interpret_data->RCP_interpret_data = RCP_interpret_data;
+            }
+
+            protocol_data.ws_data.tap_data.RCP_last_msg_interpret_data = RCP_interpret_data;
+
+            tap_queue_packet(protocol_data.ws_data.tap_data.proto_tap, pinfo, &protocol_data);
+        }
+
+        // Verify that the entire message has been dissect.
+        // Only if interpretation result is ok.
+        // If not, I suppose that an error is already displayed. 
+        if ((result == true) && (in_out_sizeof_bytes > 0))
+        {
+            if ((protocol_data.PACKET_CONTAINS_ONLY_1_MSG) || (protocol_data.MSG_TOTAL_LENGTH != ""))
+            {
+                const string         str_interpret = "error  \"" + get_string(in_out_sizeof_bytes) + " bytes NOT read into message\" ;";
+                istringstream        iss(str_interpret.c_str());
+
+                interpret_bytes (                   protocol_data.type_definitions,
+                                                    in_out_P_bytes,
+                                                    in_out_sizeof_bytes,
+                                                    iss,
+                                                    os,
+                                                    os,
+                                                    interpret_data);
+            }
+        }
+
+        // Verify that the entire packet has been dissect.
+        // Only if interpretation result is ok.
+        // If not, I suppose that an error is already displayed. 
+        if ((result == true) && (sizeof_bytes_NOT_given_to_interpretor > 0))
+        {
+            if (protocol_data.PACKET_CONTAINS_ONLY_1_MSG)
+            {
+            const string         str_interpret = "error  \"" + get_string(sizeof_bytes_NOT_given_to_interpretor) + " bytes NOT read into packet\" ;";
+            istringstream        iss(str_interpret.c_str());
+
+            interpret_bytes (                   protocol_data.type_definitions,
+                                                in_out_P_bytes,
+                                                in_out_sizeof_bytes,
+                                                iss,
+                                                os,
+                                                os,
+                                                interpret_data);
+            }
+            // ICIOA ne fonctionne pas
+            // Y a-t-il un moyen pour que wireshark re-appelle le dissector ???
+            // je ne crois pas, il faut se rappeler soi-mme
+
+            // 2009/03/03 en testant MSG_TOTAL_LENGTH, il semble bien que le dissector est appel plusieurs fois.
+            // appele 1 fois de plus MAIS pas plus ???
+            // -> voir offset de tvbbuf ???
+            // tvb_reported_length & tvb_reported_length_remaining ???
+            pinfo->desegment_offset = length_raw_data - sizeof_bytes_NOT_given_to_interpretor;
+            pinfo->desegment_len = 0;           // 2011/05/15 
+//          pinfo->desegment_len = 10;         // ICIOA essai avec une taille de msg en dur -> dissector non rappele
+//          pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;    // ICIOA -> dissector non rappele
+        }
+
+        if (result == true)
+        {
+            // Msg is ended, some data are no more necessary
+            if (protocol_data.ws_data.tap_data.tap_is_needed == false)
+            {
+                interpret_data.msg_is_ended();
+            }
+            // else generic_stats_tree_packet will do it
+        }
+
+        return  proto_item_len;
+    }
+
+    M_FATAL_COMMENT("Bug in the software");
+    return  0;  // avoid compiler warning
+}
+
+//*****************************************************************************
+// get_generic_pdu_len
+//*****************************************************************************
+#if 0
+static guint
+get_generic_pdu_len(packet_info  * pinfo _U_, tvbuff_t  * tvb, int  offset)  // ICIOA absolument pas termine
+{
+    guint    length = tvb_get_ntohs(tvb, offset+2);
+//    guint    length = tvb_get_guint8(tvb, offset+2);
+    length = 32;
+    return length;
+}
+#endif
+
+//*****************************************************************************
+// dissect_generic_proto
+//*****************************************************************************
+
+gint    dissect_generic_proto(    T_generic_protocol_data  & protocol_data,
+                                  tvbuff_t                 * tvb,
+                            const void                     * ptr_raw_data,
+                            const int                        length_raw_data,
+                                  packet_info              * pinfo,
+                                  proto_tree               * tree,
+                            const long                       msg_number_inside_packet)
+{
+    M_TRACE_ENTER ("dissect_generic_proto", protocol_data.PROTOABBREV << " ("
+                    << pinfo->fd->num << "/"
+                    << msg_number_inside_packet << ", "
+                    << tvb << ", "
+                    << pinfo << ", "
+                    << tree << ")");
+
+    if ((protocol_data.MSG_HEADER_LENGTH > 0) &&
+        (length_raw_data < protocol_data.MSG_HEADER_LENGTH))
+    {
+        // Not an error, wait for the next segment.
+        M_TRACE_DEBUG("Not enougth data (" << length_raw_data << ") to read the header. Wait for the next segment.");
+        pinfo->desegment_offset = 0;             /* Start at beginning next time */
+        pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;
+        return  0;
+    }
+
+    gint  result = 0;
+
+    M_TRACE_DEBUG ("wsgd_debug dissect+ " << protocol_data.PROTOABBREV << " ("
+                    << pinfo->fd->num << "/"
+                    << msg_number_inside_packet << ") "
+                    << C_debug_object_counter::get_debug_string());
+
+    try
+    {
+        result = cpp_dissect_generic(protocol_data,
+                                    tvb,
+                                    ptr_raw_data,
+                                    length_raw_data,
+                                    pinfo,
+                                    tree,
+                                    msg_number_inside_packet);
+    }
+    catch(std::exception& e)
+    {
+        M_TRACE_FATAL("Unexpected exception " << e.what());
+        result = 0;
+    }
+    catch(...)
+    {
+        M_TRACE_FATAL("Unexpected unknow exception.");
+        result = 0;
+    }
+
+    M_TRACE_DEBUG ("wsgd_debug dissect- " << protocol_data.PROTOABBREV << " ("
+                    << pinfo->fd->num << "/"
+                    << msg_number_inside_packet << ") "
+                    << C_debug_object_counter::get_debug_string());
+    return  result;
+}
+
+//*****************************************************************************
+// dissect_generic_proto
+//*****************************************************************************
+gint
+dissect_generic_proto(const int    proto_idx, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
+{
+    T_generic_protocol_data  & protocol_data = get_protocol_data(proto_idx);
+    C_debug_set_temporary      debug_dissect_main(protocol_data.DEBUG);
+
+    M_TRACE_ENTER ("dissect_generic_proto", protocol_data.PROTOABBREV << " ("
+                    << proto_idx << ", "
+                    << tvb << ", "
+                    << pinfo << ", "
+                    << tree << ")");
+
+    col_set_str(pinfo->cinfo, COL_PROTOCOL, protocol_data.PROTOSHORTNAME.c_str());
+    col_add_fstr(pinfo->cinfo, COL_INFO,
+                "%d > %d",
+                pinfo->srcport, pinfo->destport);
+
+
+    gint    offset_where_dissection_stops = 0;
+    long    msg_number_inside_packet = 0;
+    do
+    {
+        // compute new tvb 
+        tvbuff_t  * sub_tvb = tvb_new_subset_length_caplen(tvb, offset_where_dissection_stops, -1, -1);
+
+        gint    sub_offset_where_dissection_stops = 
+                                        dissect_generic_proto(protocol_data,
+                                                            sub_tvb,
+                                                            tvb_get_ptr(sub_tvb, 0, -1),
+                                                            tvb_reported_length_remaining(sub_tvb, 0),
+                                                            pinfo,
+                                                            tree,
+                                                            msg_number_inside_packet);
+        if (pinfo->desegment_len != 0)
+        {
+            M_TRACE_DEBUG("Not enougth data to read the message. Wait for the next segment.");
+
+            pinfo->desegment_offset += offset_where_dissection_stops;
+        }
+        else
+        {
+            M_TRACE_DEBUG("Message entirely read (no desegmentation required)");
+        }
+
+        offset_where_dissection_stops += sub_offset_where_dissection_stops;
+        ++msg_number_inside_packet;
+
+        // Stop the loop if 
+        if ((pinfo->desegment_len != 0) ||                                               // Message not entirely read
+            (offset_where_dissection_stops >= tvb_reported_length_remaining(tvb, 0)) ||  // No more data to read
+            (protocol_data.PACKET_CONTAINS_ONLY_1_MSG) ||                                // Only 1 msg per packet
+            (sub_offset_where_dissection_stops <= 0))                                    // Nothing has been read
+        {
+            break;
+        }
+    } while (true);
+
+
+
+    if ((pinfo->desegment_len != 0) && (offset_where_dissection_stops == 0))
+    {
+        // to avoid tshark 1.12.0 rc2 crash (rejects return 0 when desegment asked)
+//      return tvb_length(tvb);
+        return  1;
+    }
+    return  offset_where_dissection_stops;
+}
+
+//*****************************************************************************
+// heuristic_generic_proto
+//*****************************************************************************
+
+gboolean    heuristic_generic_proto(const int      proto_idx,
+                                    tvbuff_t     * tvb,
+                                    packet_info  * pinfo,
+                                    proto_tree   * tree)
+{
+    T_generic_protocol_data  & protocol_data = get_protocol_data(proto_idx);
+    C_debug_set_temporary      debug_dissect_main(protocol_data.DEBUG);
+
+    M_TRACE_ENTER ("heuristic_generic_proto", protocol_data.PROTOABBREV << " ("
+                    << proto_idx << ", "
+                    << tvb << ", "
+                    << pinfo << ", "
+                    << tree << ")");
+
+    if (protocol_data.HEURISTIC_FUNCTION != "")
+    {
+        // Check of tvb data to know if it is our protocol
+        try
+        {
+            const void           * ptr_raw_data = tvb_get_ptr(tvb, 0, -1);
+            const int              length_raw_data = tvb_reported_length_remaining(tvb, 0);
+            if ((ptr_raw_data == nullptr) || (length_raw_data <= 0))
+            {
+                return  false;
+            }
+            T_frame_data           frame_data(ptr_raw_data, 0, length_raw_data * 8);
+
+            const string           expression_str = protocol_data.HEURISTIC_FUNCTION + " ()";
+            T_interpret_data       interpret_data;
+            T_decode_stream_frame                             decode_stream_frame;
+            C_decode_stream_frame_set_temporary_if_necessary  dsfstin(interpret_data, decode_stream_frame);
+//          interpret_data.set_decode_stream_frame(&decode_stream_frame);
+            const string           data_name;
+            const string         & data_simple_name = data_name;
+            ostringstream          os_out;
+            ostringstream        & os_err = os_out;
+
+            const C_value          HEURISTIC_FUNCTION_result = compute_expression(protocol_data.type_definitions, interpret_data, frame_data,
+                                                                            expression_str,
+                                                                            data_name, data_simple_name, os_out, os_err);
+
+            if (HEURISTIC_FUNCTION_result.get_bool() != true)
+            {
+                return  false;
+            }
+        }
+        catch(std::exception& e)
+        {
+            M_TRACE_FATAL("Unexpected exception " << e.what());
+            return  false;
+        }
+        catch(...)
+        {
+            M_TRACE_FATAL("Unexpected unknow exception.");
+            return  false;
+        }
+    }
+
+    // Do not care of return value ?
+    dissect_generic_proto(proto_idx, tvb, pinfo, tree);
+
+    return  true;
+}
diff --git a/plugins/epan/generic/generic.h b/plugins/epan/generic/generic.h
new file mode 100644
index 00000000000..07b98fefec8
--- /dev/null
+++ b/plugins/epan/generic/generic.h
@@ -0,0 +1,59 @@
+
+#ifndef __GENERIC_H__
+#define __GENERIC_H__
+
+#include "config.h"
+
+#include <stdio.h>
+#include <glib.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <epan/packet.h>
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+
+#ifndef EXTERN_C
+#ifdef __cplusplus
+#define EXTERN_C    extern "C"
+#else
+#define EXTERN_C    
+#endif
+#endif
+
+
+#ifdef __cplusplus
+/******************************************************************************
+ * dissect
+ *****************************************************************************/
+
+proto_tree  * cpp_dissect_generic_add_tree(const int        proto_idx,
+                                           proto_item     * proto_item_void);
+
+
+#define K_WHOLE_WSGD_FIELD_IDX    0
+#define K_ANY_WSGD_FIELD_IDX      0
+#define K_ERROR_WSGD_FIELD_IDX    1
+
+#endif
+
+/******************************************************************************
+ * register
+ *****************************************************************************/
+EXTERN_C
+void    cpp_proto_register_generic(void);
+
+//*****************************************************************************
+// handoff
+//*****************************************************************************
+EXTERN_C
+void    cpp_proto_reg_handoff_generic(void);
+
+
+#endif
diff --git a/plugins/epan/generic/packet-generic.c b/plugins/epan/generic/packet-generic.c
new file mode 100644
index 00000000000..2de479daf85
--- /dev/null
+++ b/plugins/epan/generic/packet-generic.c
@@ -0,0 +1,42 @@
+/* packet-generic.c
+ * Copyright 2008-2013 Olivier Aveline <wsgd@free.fr>
+ *
+ * $Id: 
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/******************************************************************************
+ * Includes
+ *****************************************************************************/
+
+#include "generic.h"
+
+
+
+void proto_register_generic (void)
+{
+  cpp_proto_register_generic();
+}
+
+void proto_reg_handoff_generic(void)
+{
+  cpp_proto_reg_handoff_generic();
+}
+
diff --git a/plugins/epan/generic/packet-generic.h b/plugins/epan/generic/packet-generic.h
new file mode 100644
index 00000000000..61e74154773
--- /dev/null
+++ b/plugins/epan/generic/packet-generic.h
@@ -0,0 +1,12 @@
+
+#ifndef __PACKET_GENERIC_H__
+#define __PACKET_GENERIC_H__
+
+#ifdef __cplusplus__
+#define EXTERN_C    extern "C"
+#endif
+
+
+
+
+#endif
diff --git a/plugins/epan/generic/peglib.h b/plugins/epan/generic/peglib.h
new file mode 100644
index 00000000000..f8f4c901689
--- /dev/null
+++ b/plugins/epan/generic/peglib.h
@@ -0,0 +1,4021 @@
+// https://github.com/yhirose/cpp-peglib/releases/tag/v0.1.14
+// b92da07beddd286cc16ef3620793e297a5f17a6c
+//
+//  peglib.h
+//
+//  Copyright (c) 2020 Yuji Hirose. All rights reserved.
+//  MIT License
+//
+
+#ifndef CPPPEGLIB_PEGLIB_H
+#define CPPPEGLIB_PEGLIB_H
+
+#ifndef PEGLIB_USE_STD_ANY
+#ifdef _MSVC_LANG
+#define PEGLIB_USE_STD_ANY _MSVC_LANG >= 201703L
+#elif defined(__cplusplus)
+#define PEGLIB_USE_STD_ANY __cplusplus >= 201703L
+#endif
+#endif // PEGLIB_USE_STD_ANY
+
+#include <algorithm>
+#include <cassert>
+#include <cctype>
+#include <cstring>
+#include <functional>
+#include <initializer_list>
+#include <iostream>
+#include <limits>
+#include <list>
+#include <map>
+#include <memory>
+#include <mutex>
+#include <set>
+#include <sstream>
+#include <string>
+#include <unordered_map>
+#include <vector>
+#if PEGLIB_USE_STD_ANY
+#include <any>
+#endif
+
+// guard for older versions of VC++
+#ifdef _MSC_VER
+#if defined(_MSC_VER) && _MSC_VER < 1900 // Less than Visual Studio 2015
+#error "Requires complete C+11 support"
+#endif
+#endif
+
+namespace peg {
+
+/*-----------------------------------------------------------------------------
+ *  any
+ *---------------------------------------------------------------------------*/
+
+#if PEGLIB_USE_STD_ANY
+using any = std::any;
+
+// Define a function alias to std::any_cast using perfect forwarding
+template <typename T, typename... Args>
+auto any_cast(Args &&... args)
+    -> decltype(std::any_cast<T>(std::forward<Args>(args)...)) {
+  return std::any_cast<T>(std::forward<Args>(args)...);
+}
+#else
+class any {
+public:
+  any() = default;
+
+  any(const any &rhs) : content_(rhs.clone()) {}
+
+  any(any &&rhs) : content_(rhs.content_) { rhs.content_ = nullptr; }
+
+  template <typename T> any(const T &value) : content_(new holder<T>(value)) {}
+
+  any &operator=(const any &rhs) {
+    if (this != &rhs) {
+      if (content_) { delete content_; }
+      content_ = rhs.clone();
+    }
+    return *this;
+  }
+
+  any &operator=(any &&rhs) {
+    if (this != &rhs) {
+      if (content_) { delete content_; }
+      content_ = rhs.content_;
+      rhs.content_ = nullptr;
+    }
+    return *this;
+  }
+
+  ~any() { delete content_; }
+
+  bool has_value() const { return content_ != nullptr; }
+
+  template <typename T> friend T &any_cast(any &val);
+
+  template <typename T> friend const T &any_cast(const any &val);
+
+private:
+  struct placeholder {
+    virtual ~placeholder() {}
+    virtual placeholder *clone() const = 0;
+  };
+
+  template <typename T> struct holder : placeholder {
+    holder(const T &value) : value_(value) {}
+    placeholder *clone() const override { return new holder(value_); }
+    T value_;
+  };
+
+  placeholder *clone() const { return content_ ? content_->clone() : nullptr; }
+
+  placeholder *content_ = nullptr;
+};
+
+template <typename T> T &any_cast(any &val) {
+  if (!val.content_) { throw std::bad_cast(); }
+  auto p = dynamic_cast<any::holder<T> *>(val.content_);
+  assert(p);
+  if (!p) { throw std::bad_cast(); }
+  return p->value_;
+}
+
+template <> inline any &any_cast<any>(any &val) { return val; }
+
+template <typename T> const T &any_cast(const any &val) {
+  assert(val.content_);
+  auto p = dynamic_cast<any::holder<T> *>(val.content_);
+  assert(p);
+  if (!p) { throw std::bad_cast(); }
+  return p->value_;
+}
+
+template <> inline const any &any_cast<any>(const any &val) { return val; }
+#endif
+
+/*-----------------------------------------------------------------------------
+ *  scope_exit
+ *---------------------------------------------------------------------------*/
+
+// This is based on
+// "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4189".
+
+template <typename EF> struct scope_exit {
+  explicit scope_exit(EF &&f)
+      : exit_function(std::move(f)), execute_on_destruction{true} {}
+
+  scope_exit(scope_exit &&rhs)
+      : exit_function(std::move(rhs.exit_function)),
+        execute_on_destruction{rhs.execute_on_destruction} {
+    rhs.release();
+  }
+
+  ~scope_exit() {
+    if (execute_on_destruction) { this->exit_function(); }
+  }
+
+  void release() { this->execute_on_destruction = false; }
+
+private:
+  scope_exit(const scope_exit &) = delete;
+  void operator=(const scope_exit &) = delete;
+  scope_exit &operator=(scope_exit &&) = delete;
+
+  EF exit_function;
+  bool execute_on_destruction;
+};
+
+template <typename EF>
+auto make_scope_exit(EF &&exit_function) -> scope_exit<EF> {
+  return scope_exit<typename std::remove_reference<EF>::type>(
+      std::forward<EF>(exit_function));
+}
+
+/*-----------------------------------------------------------------------------
+ *  UTF8 functions
+ *---------------------------------------------------------------------------*/
+
+inline size_t codepoint_length(const char *s8, size_t l) {
+  if (l) {
+    auto b = static_cast<uint8_t>(s8[0]);
+    if ((b & 0x80) == 0) {
+      return 1;
+    } else if ((b & 0xE0) == 0xC0 && l >= 2) {
+      return 2;
+    } else if ((b & 0xF0) == 0xE0 && l >= 3) {
+      return 3;
+    } else if ((b & 0xF8) == 0xF0 && l >= 4) {
+      return 4;
+    }
+  }
+  return 0;
+}
+
+inline size_t encode_codepoint(char32_t cp, char *buff) {
+  if (cp < 0x0080) {
+    buff[0] = static_cast<char>(cp & 0x7F);
+    return 1;
+  } else if (cp < 0x0800) {
+    buff[0] = static_cast<char>(0xC0 | ((cp >> 6) & 0x1F));
+    buff[1] = static_cast<char>(0x80 | (cp & 0x3F));
+    return 2;
+  } else if (cp < 0xD800) {
+    buff[0] = static_cast<char>(0xE0 | ((cp >> 12) & 0xF));
+    buff[1] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));
+    buff[2] = static_cast<char>(0x80 | (cp & 0x3F));
+    return 3;
+  } else if (cp < 0xE000) {
+    // D800 - DFFF is invalid...
+    return 0;
+  } else if (cp < 0x10000) {
+    buff[0] = static_cast<char>(0xE0 | ((cp >> 12) & 0xF));
+    buff[1] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));
+    buff[2] = static_cast<char>(0x80 | (cp & 0x3F));
+    return 3;
+  } else if (cp < 0x110000) {
+    buff[0] = static_cast<char>(0xF0 | ((cp >> 18) & 0x7));
+    buff[1] = static_cast<char>(0x80 | ((cp >> 12) & 0x3F));
+    buff[2] = static_cast<char>(0x80 | ((cp >> 6) & 0x3F));
+    buff[3] = static_cast<char>(0x80 | (cp & 0x3F));
+    return 4;
+  }
+  return 0;
+}
+
+inline std::string encode_codepoint(char32_t cp) {
+  char buff[4];
+  auto l = encode_codepoint(cp, buff);
+  return std::string(buff, l);
+}
+
+inline bool decode_codepoint(const char *s8, size_t l, size_t &bytes,
+                             char32_t &cp) {
+  if (l) {
+    auto b = static_cast<uint8_t>(s8[0]);
+    if ((b & 0x80) == 0) {
+      bytes = 1;
+      cp = b;
+      return true;
+    } else if ((b & 0xE0) == 0xC0) {
+      if (l >= 2) {
+        bytes = 2;
+        cp = ((static_cast<char32_t>(s8[0] & 0x1F)) << 6) |
+             (static_cast<char32_t>(s8[1] & 0x3F));
+        return true;
+      }
+    } else if ((b & 0xF0) == 0xE0) {
+      if (l >= 3) {
+        bytes = 3;
+        cp = ((static_cast<char32_t>(s8[0] & 0x0F)) << 12) |
+             ((static_cast<char32_t>(s8[1] & 0x3F)) << 6) |
+             (static_cast<char32_t>(s8[2] & 0x3F));
+        return true;
+      }
+    } else if ((b & 0xF8) == 0xF0) {
+      if (l >= 4) {
+        bytes = 4;
+        cp = ((static_cast<char32_t>(s8[0] & 0x07)) << 18) |
+             ((static_cast<char32_t>(s8[1] & 0x3F)) << 12) |
+             ((static_cast<char32_t>(s8[2] & 0x3F)) << 6) |
+             (static_cast<char32_t>(s8[3] & 0x3F));
+        return true;
+      }
+    }
+  }
+  return false;
+}
+
+inline size_t decode_codepoint(const char *s8, size_t l, char32_t &out) {
+  size_t bytes;
+  if (decode_codepoint(s8, l, bytes, out)) { return bytes; }
+  return 0;
+}
+
+inline char32_t decode_codepoint(const char *s8, size_t l) {
+  char32_t out = 0;
+  decode_codepoint(s8, l, out);
+  return out;
+}
+
+inline std::u32string decode(const char *s8, size_t l) {
+  std::u32string out;
+  size_t i = 0;
+  while (i < l) {
+    auto beg = i++;
+    while (i < l && (s8[i] & 0xc0) == 0x80) {
+      i++;
+    }
+    out += decode_codepoint(&s8[beg], (i - beg));
+  }
+  return out;
+}
+
+/*-----------------------------------------------------------------------------
+ *  resolve_escape_sequence
+ *---------------------------------------------------------------------------*/
+
+inline bool is_hex(char c, int &v) {
+  if ('0' <= c && c <= '9') {
+    v = c - '0';
+    return true;
+  } else if ('a' <= c && c <= 'f') {
+    v = c - 'a' + 10;
+    return true;
+  } else if ('A' <= c && c <= 'F') {
+    v = c - 'A' + 10;
+    return true;
+  }
+  return false;
+}
+
+inline bool is_digit(char c, int &v) {
+  if ('0' <= c && c <= '9') {
+    v = c - '0';
+    return true;
+  }
+  return false;
+}
+
+inline std::pair<int, size_t> parse_hex_number(const char *s, size_t n,
+                                               size_t i) {
+  int ret = 0;
+  int val;
+  while (i < n && is_hex(s[i], val)) {
+    ret = static_cast<int>(ret * 16 + val);
+    i++;
+  }
+  return std::make_pair(ret, i);
+}
+
+inline std::pair<int, size_t> parse_octal_number(const char *s, size_t n,
+                                                 size_t i) {
+  int ret = 0;
+  int val;
+  while (i < n && is_digit(s[i], val)) {
+    ret = static_cast<int>(ret * 8 + val);
+    i++;
+  }
+  return std::make_pair(ret, i);
+}
+
+inline std::string resolve_escape_sequence(const char *s, size_t n) {
+  std::string r;
+  r.reserve(n);
+
+  size_t i = 0;
+  while (i < n) {
+    auto ch = s[i];
+    if (ch == '\\') {
+      i++;
+      if (i == n) { throw std::runtime_error("Invalid escape sequence..."); }
+      switch (s[i]) {
+      case 'n':
+        r += '\n';
+        i++;
+        break;
+      case 'r':
+        r += '\r';
+        i++;
+        break;
+      case 't':
+        r += '\t';
+        i++;
+        break;
+      case '\'':
+        r += '\'';
+        i++;
+        break;
+      case '"':
+        r += '"';
+        i++;
+        break;
+      case '[':
+        r += '[';
+        i++;
+        break;
+      case ']':
+        r += ']';
+        i++;
+        break;
+      case '\\':
+        r += '\\';
+        i++;
+        break;
+      case 'x':
+      case 'u': {
+        char32_t cp;
+        std::tie(cp, i) = parse_hex_number(s, n, i + 1);
+        r += encode_codepoint(cp);
+        break;
+      }
+      default: {
+        char32_t cp;
+        std::tie(cp, i) = parse_octal_number(s, n, i);
+        r += encode_codepoint(cp);
+        break;
+      }
+      }
+    } else {
+      r += ch;
+      i++;
+    }
+  }
+  return r;
+}
+
+/*-----------------------------------------------------------------------------
+ *  Trie
+ *---------------------------------------------------------------------------*/
+
+class Trie {
+public:
+  Trie() = default;
+  Trie(const Trie &) = default;
+
+  Trie(const std::vector<std::string> &items) {
+    for (const auto &item : items) {
+      for (size_t len = 1; len <= item.size(); len++) {
+        auto last = len == item.size();
+        std::string s(item.c_str(), len);
+        auto it = dic_.find(s);
+        if (it == dic_.end()) {
+          dic_.emplace(s, Info{last, last});
+        } else if (last) {
+          it->second.match = true;
+        } else {
+          it->second.done = false;
+        }
+      }
+    }
+  }
+
+  size_t match(const char *text, size_t text_len) const {
+    size_t match_len = 0;
+    {
+      auto done = false;
+      size_t len = 1;
+      while (!done && len <= text_len) {
+        std::string s(text, len);
+        auto it = dic_.find(s);
+        if (it == dic_.end()) {
+          done = true;
+        } else {
+          if (it->second.match) { match_len = len; }
+          if (it->second.done) { done = true; }
+        }
+        len += 1;
+      }
+    }
+    return match_len;
+  }
+
+private:
+  struct Info {
+    bool done;
+    bool match;
+  };
+  std::unordered_map<std::string, Info> dic_;
+};
+
+/*-----------------------------------------------------------------------------
+ *  PEG
+ *---------------------------------------------------------------------------*/
+
+/*
+ * Line information utility function
+ */
+inline std::pair<size_t, size_t> line_info(const char *start, const char *cur) {
+  auto p = start;
+  auto col_ptr = p;
+  auto no = 1;
+
+  while (p < cur) {
+    if (*p == '\n') {
+      no++;
+      col_ptr = p + 1;
+    }
+    p++;
+  }
+
+  auto col = p - col_ptr + 1;
+
+  return std::make_pair(no, col);
+}
+
+/*
+ * String tag
+ */
+inline constexpr unsigned int str2tag(const char *str, unsigned int h = 0) {
+  return (*str == '\0')
+             ? h
+             : str2tag(str + 1, (h * 33) ^ static_cast<unsigned char>(*str));
+}
+
+namespace udl {
+
+inline constexpr unsigned int operator"" _(const char *s, size_t) {
+  return str2tag(s);
+}
+
+} // namespace udl
+
+/*
+ * Semantic values
+ */
+struct SemanticValues : protected std::vector<any> {
+  // Input text
+  const char *path = nullptr;
+  const char *ss = nullptr;
+  const std::vector<size_t> *source_line_index = nullptr;
+
+  // Matched string
+  const char *c_str() const { return s_; }
+  size_t length() const { return n_; }
+
+  std::string str() const { return std::string(s_, n_); }
+
+  // Definition name
+  const std::string &name() const { return name_; }
+
+  std::vector<unsigned int> tags;
+
+  // Line number and column at which the matched string is
+  std::pair<size_t, size_t> line_info() const {
+    const auto &idx = *source_line_index;
+
+    auto cur = static_cast<size_t>(std::distance(ss, s_));
+    auto it = std::lower_bound(
+        idx.begin(), idx.end(), cur,
+        [](size_t element, size_t value) { return element < value; });
+
+    auto id = static_cast<size_t>(std::distance(idx.begin(), it));
+    auto off = cur - (id == 0 ? 0 : idx[id - 1] + 1);
+    return std::make_pair(id + 1, off + 1);
+  }
+
+  // Choice count
+  size_t choice_count() const { return choice_count_; }
+
+  // Choice number (0 based index)
+  size_t choice() const { return choice_; }
+
+  // Tokens
+  std::vector<std::pair<const char *, size_t>> tokens;
+
+  std::string token(size_t id = 0) const {
+    if (!tokens.empty()) {
+      assert(id < tokens.size());
+      const auto &tok = tokens[id];
+      return std::string(tok.first, tok.second);
+    }
+    return std::string(s_, n_);
+  }
+
+  // Transform the semantic value vector to another vector
+  template <typename T>
+  std::vector<T> transform(size_t beg = 0,
+                           size_t end = static_cast<size_t>(-1)) const {
+    std::vector<T> r;
+    end = (std::min)(end, size());
+    for (size_t i = beg; i < end; i++) {
+      r.emplace_back(any_cast<T>((*this)[i]));
+    }
+    return r;
+  }
+
+  using std::vector<any>::iterator;
+  using std::vector<any>::const_iterator;
+  using std::vector<any>::size;
+  using std::vector<any>::empty;
+  using std::vector<any>::assign;
+  using std::vector<any>::begin;
+  using std::vector<any>::end;
+  using std::vector<any>::rbegin;
+  using std::vector<any>::rend;
+  using std::vector<any>::operator[];
+  using std::vector<any>::at;
+  using std::vector<any>::resize;
+  using std::vector<any>::front;
+  using std::vector<any>::back;
+  using std::vector<any>::push_back;
+  using std::vector<any>::pop_back;
+  using std::vector<any>::insert;
+  using std::vector<any>::erase;
+  using std::vector<any>::clear;
+  using std::vector<any>::swap;
+  using std::vector<any>::emplace;
+  using std::vector<any>::emplace_back;
+
+private:
+  friend class Context;
+  friend class Sequence;
+  friend class PrioritizedChoice;
+  friend class Holder;
+  friend class PrecedenceClimbing;
+
+  const char *s_ = nullptr;
+  size_t n_ = 0;
+  size_t choice_count_ = 0;
+  size_t choice_ = 0;
+  std::string name_;
+};
+
+/*
+ * Semantic action
+ */
+template <typename R, typename F,
+          typename std::enable_if<std::is_void<R>::value,
+                                  std::nullptr_t>::type = nullptr,
+          typename... Args>
+any call(F fn, Args &&... args) {
+  fn(std::forward<Args>(args)...);
+  return any();
+}
+
+template <typename R, typename F,
+          typename std::enable_if<
+              std::is_same<typename std::remove_cv<R>::type, any>::value,
+              std::nullptr_t>::type = nullptr,
+          typename... Args>
+any call(F fn, Args &&... args) {
+  return fn(std::forward<Args>(args)...);
+}
+
+template <typename R, typename F,
+          typename std::enable_if<
+              !std::is_void<R>::value &&
+                  !std::is_same<typename std::remove_cv<R>::type, any>::value,
+              std::nullptr_t>::type = nullptr,
+          typename... Args>
+any call(F fn, Args &&... args) {
+  return any(fn(std::forward<Args>(args)...));
+}
+
+class Action {
+public:
+  Action() = default;
+  Action(const Action &rhs) = default;
+
+  template <typename F,
+            typename std::enable_if<!std::is_pointer<F>::value &&
+                                        !std::is_same<F, std::nullptr_t>::value,
+                                    std::nullptr_t>::type = nullptr>
+  Action(F fn) : fn_(make_adaptor(fn, &F::operator())) {}
+
+  template <typename F, typename std::enable_if<std::is_pointer<F>::value,
+                                                std::nullptr_t>::type = nullptr>
+  Action(F fn) : fn_(make_adaptor(fn, fn)) {}
+
+  template <typename F,
+            typename std::enable_if<std::is_same<F, std::nullptr_t>::value,
+                                    std::nullptr_t>::type = nullptr>
+  Action(F /*fn*/) {}
+
+  template <typename F,
+            typename std::enable_if<!std::is_pointer<F>::value &&
+                                        !std::is_same<F, std::nullptr_t>::value,
+                                    std::nullptr_t>::type = nullptr>
+  void operator=(F fn) {
+    fn_ = make_adaptor(fn, &F::operator());
+  }
+
+  template <typename F, typename std::enable_if<std::is_pointer<F>::value,
+                                                std::nullptr_t>::type = nullptr>
+  void operator=(F fn) {
+    fn_ = make_adaptor(fn, fn);
+  }
+
+  template <typename F,
+            typename std::enable_if<std::is_same<F, std::nullptr_t>::value,
+                                    std::nullptr_t>::type = nullptr>
+  void operator=(F /*fn*/) {}
+
+  Action &operator=(const Action &rhs) = default;
+
+  operator bool() const { return bool(fn_); }
+
+  any operator()(SemanticValues &sv, any &dt) const { return fn_(sv, dt); }
+
+private:
+  template <typename R> struct TypeAdaptor_sv {
+    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}
+    any operator()(SemanticValues &sv, any & /*dt*/) {
+      return call<R>(fn_, sv);
+    }
+    std::function<R(SemanticValues &sv)> fn_;
+  };
+
+  template <typename R> struct TypeAdaptor_csv {
+    TypeAdaptor_csv(std::function<R(const SemanticValues &sv)> fn) : fn_(fn) {}
+    any operator()(SemanticValues &sv, any & /*dt*/) {
+      return call<R>(fn_, sv);
+    }
+    std::function<R(const SemanticValues &sv)> fn_;
+  };
+
+  template <typename R> struct TypeAdaptor_sv_dt {
+    TypeAdaptor_sv_dt(std::function<R(SemanticValues &sv, any &dt)> fn)
+        : fn_(fn) {}
+    any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }
+    std::function<R(SemanticValues &sv, any &dt)> fn_;
+  };
+
+  template <typename R> struct TypeAdaptor_csv_dt {
+    TypeAdaptor_csv_dt(std::function<R(const SemanticValues &sv, any &dt)> fn)
+        : fn_(fn) {}
+    any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }
+    std::function<R(const SemanticValues &sv, any &dt)> fn_;
+  };
+
+  typedef std::function<any(SemanticValues &sv, any &dt)> Fty;
+
+  template <typename F, typename R>
+  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv) const) {
+    return TypeAdaptor_sv<R>(fn);
+  }
+
+  template <typename F, typename R>
+  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv) const) {
+    return TypeAdaptor_csv<R>(fn);
+  }
+
+  template <typename F, typename R>
+  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv)) {
+    return TypeAdaptor_sv<R>(fn);
+  }
+
+  template <typename F, typename R>
+  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv)) {
+    return TypeAdaptor_csv<R>(fn);
+  }
+
+  template <typename F, typename R>
+  Fty make_adaptor(F fn, R (*)(SemanticValues &sv)) {
+    return TypeAdaptor_sv<R>(fn);
+  }
+
+  template <typename F, typename R>
+  Fty make_adaptor(F fn, R (*)(const SemanticValues &sv)) {
+    return TypeAdaptor_csv<R>(fn);
+  }
+
+  template <typename F, typename R>
+  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv, any &dt) const) {
+    return TypeAdaptor_sv_dt<R>(fn);
+  }
+
+  template <typename F, typename R>
+  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv, any &dt) const) {
+    return TypeAdaptor_csv_dt<R>(fn);
+  }
+
+  template <typename F, typename R>
+  Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv, any &dt)) {
+    return TypeAdaptor_sv_dt<R>(fn);
+  }
+
+  template <typename F, typename R>
+  Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv, any &dt)) {
+    return TypeAdaptor_csv_dt<R>(fn);
+  }
+
+  template <typename F, typename R>
+  Fty make_adaptor(F fn, R (*)(SemanticValues &sv, any &dt)) {
+    return TypeAdaptor_sv_dt<R>(fn);
+  }
+
+  template <typename F, typename R>
+  Fty make_adaptor(F fn, R (*)(const SemanticValues &sv, any &dt)) {
+    return TypeAdaptor_csv_dt<R>(fn);
+  }
+
+  Fty fn_;
+};
+
+/*
+ * Semantic predicate
+ */
+// Note: 'parse_error' exception class should be be used in sematic action
+// handlers to reject the rule.
+struct parse_error {
+  parse_error() = default;
+  parse_error(const char *s) : s_(s) {}
+  const char *what() const { return s_.empty() ? nullptr : s_.c_str(); }
+
+private:
+  std::string s_;
+};
+
+/*
+ * Result
+ */
+inline bool success(size_t len) { return len != static_cast<size_t>(-1); }
+
+inline bool fail(size_t len) { return len == static_cast<size_t>(-1); }
+
+/*
+ * Context
+ */
+class Context;
+class Ope;
+class Definition;
+
+typedef std::function<void(const char *name, const char *s, size_t n,
+                           const SemanticValues &sv, const Context &c,
+                           const any &dt)>
+    TracerEnter;
+
+typedef std::function<void(const char *name, const char *s, size_t n,
+                           const SemanticValues &sv, const Context &c,
+                           const any &dt, size_t)>
+    TracerLeave;
+
+class Context {
+public:
+  const char *path;
+  const char *s;
+  const size_t l;
+  std::vector<size_t> source_line_index;
+
+  const char *error_pos = nullptr;
+  const char *message_pos = nullptr;
+  std::string message; // TODO: should be `int`.
+
+  std::vector<std::shared_ptr<SemanticValues>> value_stack;
+  size_t value_stack_size = 0;
+
+  std::vector<Definition *> rule_stack;
+  std::vector<std::vector<std::shared_ptr<Ope>>> args_stack;
+
+  size_t in_token_boundary_count = 0;
+
+  std::shared_ptr<Ope> whitespaceOpe;
+  bool in_whitespace = false;
+
+  std::shared_ptr<Ope> wordOpe;
+
+  std::vector<std::map<std::string, std::string>> capture_scope_stack;
+  size_t capture_scope_stack_size = 0;
+
+  const size_t def_count;
+  const bool enablePackratParsing;
+  std::vector<bool> cache_registered;
+  std::vector<bool> cache_success;
+
+  std::map<std::pair<size_t, size_t>, std::tuple<size_t, any>> cache_values;
+
+  TracerEnter tracer_enter;
+  TracerLeave tracer_leave;
+
+  Context(const char *a_path, const char *a_s, size_t a_l, size_t a_def_count,
+          std::shared_ptr<Ope> a_whitespaceOpe, std::shared_ptr<Ope> a_wordOpe,
+          bool a_enablePackratParsing, TracerEnter a_tracer_enter,
+          TracerLeave a_tracer_leave)
+      : path(a_path), s(a_s), l(a_l), whitespaceOpe(a_whitespaceOpe),
+        wordOpe(a_wordOpe), def_count(a_def_count),
+        enablePackratParsing(a_enablePackratParsing),
+        cache_registered(enablePackratParsing ? def_count * (l + 1) : 0),
+        cache_success(enablePackratParsing ? def_count * (l + 1) : 0),
+        tracer_enter(a_tracer_enter), tracer_leave(a_tracer_leave) {
+
+    for (size_t pos = 0; pos < l; pos++) {
+      if (s[pos] == '\n') { source_line_index.push_back(pos); }
+    }
+    source_line_index.push_back(l);
+
+    args_stack.resize(1);
+
+    push_capture_scope();
+  }
+
+  ~Context() { assert(!value_stack_size); }
+
+  Context(const Context &) = delete;
+  Context(Context &&) = delete;
+  Context operator=(const Context &) = delete;
+
+  template <typename T>
+  void packrat(const char *a_s, size_t def_id, size_t &len, any &val, T fn) {
+    if (!enablePackratParsing) {
+      fn(val);
+      return;
+    }
+
+    auto col = a_s - s;
+    auto idx = def_count * static_cast<size_t>(col) + def_id;
+
+    if (cache_registered[idx]) {
+      if (cache_success[idx]) {
+        auto key = std::make_pair(col, def_id);
+        std::tie(len, val) = cache_values[key];
+        return;
+      } else {
+        len = static_cast<size_t>(-1);
+        return;
+      }
+    } else {
+      fn(val);
+      cache_registered[idx] = true;
+      cache_success[idx] = success(len);
+      if (success(len)) {
+        auto key = std::make_pair(col, def_id);
+        cache_values[key] = std::make_pair(len, val);
+      }
+      return;
+    }
+  }
+
+  SemanticValues &push() {
+    assert(value_stack_size <= value_stack.size());
+    if (value_stack_size == value_stack.size()) {
+      value_stack.emplace_back(std::make_shared<SemanticValues>());
+    } else {
+      auto &sv = *value_stack[value_stack_size];
+      if (!sv.empty()) {
+        sv.clear();
+        if (!sv.tags.empty()) { sv.tags.clear(); }
+      }
+      sv.s_ = nullptr;
+      sv.n_ = 0;
+      sv.choice_count_ = 0;
+      sv.choice_ = 0;
+      if (!sv.tokens.empty()) { sv.tokens.clear(); }
+    }
+
+    auto &sv = *value_stack[value_stack_size++];
+    sv.path = path;
+    sv.ss = s;
+    sv.source_line_index = &source_line_index;
+    return sv;
+  }
+
+  void pop() { value_stack_size--; }
+
+  void push_args(std::vector<std::shared_ptr<Ope>> &&args) {
+    args_stack.emplace_back(args);
+  }
+
+  void pop_args() { args_stack.pop_back(); }
+
+  const std::vector<std::shared_ptr<Ope>> &top_args() const {
+    return args_stack[args_stack.size() - 1];
+  }
+
+  void push_capture_scope() {
+    assert(capture_scope_stack_size <= capture_scope_stack.size());
+    if (capture_scope_stack_size == capture_scope_stack.size()) {
+      capture_scope_stack.emplace_back(std::map<std::string, std::string>());
+    } else {
+      auto &cs = capture_scope_stack[capture_scope_stack_size];
+      if (!cs.empty()) { cs.clear(); }
+    }
+    capture_scope_stack_size++;
+  }
+
+  void pop_capture_scope() { capture_scope_stack_size--; }
+
+  void shift_capture_values() {
+    assert(capture_scope_stack.size() >= 2);
+    auto curr = &capture_scope_stack[capture_scope_stack_size - 1];
+    auto prev = curr - 1;
+    for (const auto &kv : *curr) {
+      (*prev)[kv.first] = kv.second;
+    }
+  }
+
+  void set_error_pos(const char *a_s) {
+    if (error_pos < a_s) error_pos = a_s;
+  }
+
+  void trace_enter(const char *name, const char *a_s, size_t n,
+                   SemanticValues &sv, any &dt) const;
+  void trace_leave(const char *name, const char *a_s, size_t n,
+                   SemanticValues &sv, any &dt, size_t len) const;
+  bool is_traceable(const Ope &ope) const;
+
+  mutable size_t next_trace_id = 0;
+  mutable std::list<size_t> trace_ids;
+};
+
+/*
+ * Parser operators
+ */
+class Ope {
+public:
+  struct Visitor;
+
+  virtual ~Ope() {}
+  size_t parse(const char *s, size_t n, SemanticValues &sv, Context &c,
+               any &dt) const;
+  virtual size_t parse_core(const char *s, size_t n, SemanticValues &sv,
+                            Context &c, any &dt) const = 0;
+  virtual void accept(Visitor &v) = 0;
+};
+
+class Sequence : public Ope {
+public:
+  template <typename... Args>
+  Sequence(const Args &... args)
+      : opes_{static_cast<std::shared_ptr<Ope>>(args)...} {}
+  Sequence(const std::vector<std::shared_ptr<Ope>> &opes) : opes_(opes) {}
+  Sequence(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
+                    any &dt) const override {
+    auto &chldsv = c.push();
+    auto pop_se = make_scope_exit([&]() { c.pop(); });
+    size_t i = 0;
+    for (const auto &ope : opes_) {
+      const auto &rule = *ope;
+      auto len = rule.parse(s + i, n - i, chldsv, c, dt);
+      if (fail(len)) { return static_cast<size_t>(-1); }
+      i += len;
+    }
+    if (!chldsv.empty()) {
+      for (size_t j = 0; j < chldsv.size(); j++) {
+        sv.emplace_back(std::move(chldsv[j]));
+      }
+    }
+    if (!chldsv.tags.empty()) {
+      for (size_t j = 0; j < chldsv.tags.size(); j++) {
+        sv.tags.emplace_back(std::move(chldsv.tags[j]));
+      }
+    }
+    sv.s_ = chldsv.c_str();
+    sv.n_ = chldsv.length();
+    if (!chldsv.tokens.empty()) {
+      for (size_t j = 0; j < chldsv.tokens.size(); j++) {
+        sv.tokens.emplace_back(std::move(chldsv.tokens[j]));
+      }
+    }
+    return i;
+  }
+
+  void accept(Visitor &v) override;
+
+  std::vector<std::shared_ptr<Ope>> opes_;
+};
+
+class PrioritizedChoice : public Ope {
+public:
+  template <typename... Args>
+  PrioritizedChoice(const Args &... args)
+      : opes_{static_cast<std::shared_ptr<Ope>>(args)...} {}
+  PrioritizedChoice(const std::vector<std::shared_ptr<Ope>> &opes)
+      : opes_(opes) {}
+  PrioritizedChoice(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
+                    any &dt) const override {
+    size_t id = 0;
+    for (const auto &ope : opes_) {
+      auto &chldsv = c.push();
+      c.push_capture_scope();
+      auto se = make_scope_exit([&]() {
+        c.pop();
+        c.pop_capture_scope();
+      });
+      auto len = ope->parse(s, n, chldsv, c, dt);
+      if (success(len)) {
+        if (!chldsv.empty()) {
+          for (size_t i = 0; i < chldsv.size(); i++) {
+            sv.emplace_back(std::move(chldsv[i]));
+          }
+        }
+        if (!chldsv.tags.empty()) {
+          for (size_t i = 0; i < chldsv.tags.size(); i++) {
+            sv.tags.emplace_back(std::move(chldsv.tags[i]));
+          }
+        }
+        sv.s_ = chldsv.c_str();
+        sv.n_ = chldsv.length();
+        sv.choice_count_ = opes_.size();
+        sv.choice_ = id;
+        if (!chldsv.tokens.empty()) {
+          for (size_t i = 0; i < chldsv.tokens.size(); i++) {
+            sv.tokens.emplace_back(std::move(chldsv.tokens[i]));
+          }
+        }
+
+        c.shift_capture_values();
+        return len;
+      }
+      id++;
+    }
+    return static_cast<size_t>(-1);
+  }
+
+  void accept(Visitor &v) override;
+
+  size_t size() const { return opes_.size(); }
+
+  std::vector<std::shared_ptr<Ope>> opes_;
+};
+
+class Repetition : public Ope {
+public:
+  Repetition(const std::shared_ptr<Ope> &ope, size_t min, size_t max)
+      : ope_(ope), min_(min), max_(max) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
+                    any &dt) const override {
+    size_t count = 0;
+    size_t i = 0;
+    while (count < min_) {
+      c.push_capture_scope();
+      auto se = make_scope_exit([&]() { c.pop_capture_scope(); });
+      const auto &rule = *ope_;
+      auto len = rule.parse(s + i, n - i, sv, c, dt);
+      if (success(len)) {
+        c.shift_capture_values();
+      } else {
+        return static_cast<size_t>(-1);
+      }
+      i += len;
+      count++;
+    }
+
+    auto save_error_pos = c.error_pos;
+    while (n - i > 0 && count < max_) {
+      c.push_capture_scope();
+      auto se = make_scope_exit([&]() { c.pop_capture_scope(); });
+      auto save_sv_size = sv.size();
+      auto save_tok_size = sv.tokens.size();
+      const auto &rule = *ope_;
+      auto len = rule.parse(s + i, n - i, sv, c, dt);
+      if (success(len)) {
+        c.shift_capture_values();
+      } else {
+        if (sv.size() != save_sv_size) {
+          sv.erase(sv.begin() + static_cast<std::ptrdiff_t>(save_sv_size));
+          sv.tags.erase(sv.tags.begin() +
+                        static_cast<std::ptrdiff_t>(save_sv_size));
+        }
+        if (sv.tokens.size() != save_tok_size) {
+          sv.tokens.erase(sv.tokens.begin() +
+                          static_cast<std::ptrdiff_t>(save_tok_size));
+        }
+        c.error_pos = save_error_pos;
+        break;
+      }
+      i += len;
+      count++;
+    }
+    return i;
+  }
+
+  void accept(Visitor &v) override;
+
+  bool is_zom() const {
+    return min_ == 0 && max_ == std::numeric_limits<size_t>::max();
+  }
+
+  static std::shared_ptr<Repetition> zom(const std::shared_ptr<Ope> &ope) {
+    return std::make_shared<Repetition>(ope, 0,
+                                        std::numeric_limits<size_t>::max());
+  }
+
+  static std::shared_ptr<Repetition> oom(const std::shared_ptr<Ope> &ope) {
+    return std::make_shared<Repetition>(ope, 1,
+                                        std::numeric_limits<size_t>::max());
+  }
+
+  static std::shared_ptr<Repetition> opt(const std::shared_ptr<Ope> &ope) {
+    return std::make_shared<Repetition>(ope, 0, 1);
+  }
+
+  std::shared_ptr<Ope> ope_;
+  size_t min_;
+  size_t max_;
+};
+
+class AndPredicate : public Ope {
+public:
+  AndPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,
+                    Context &c, any &dt) const override {
+    auto &chldsv = c.push();
+    c.push_capture_scope();
+    auto se = make_scope_exit([&]() {
+      c.pop();
+      c.pop_capture_scope();
+    });
+    const auto &rule = *ope_;
+    auto len = rule.parse(s, n, chldsv, c, dt);
+    if (success(len)) {
+      return 0;
+    } else {
+      return static_cast<size_t>(-1);
+    }
+  }
+
+  void accept(Visitor &v) override;
+
+  std::shared_ptr<Ope> ope_;
+};
+
+class NotPredicate : public Ope {
+public:
+  NotPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,
+                    Context &c, any &dt) const override {
+    auto save_error_pos = c.error_pos;
+    auto &chldsv = c.push();
+    c.push_capture_scope();
+    auto se = make_scope_exit([&]() {
+      c.pop();
+      c.pop_capture_scope();
+    });
+    auto len = ope_->parse(s, n, chldsv, c, dt);
+    if (success(len)) {
+      c.set_error_pos(s);
+      return static_cast<size_t>(-1);
+    } else {
+      c.error_pos = save_error_pos;
+      return 0;
+    }
+  }
+
+  void accept(Visitor &v) override;
+
+  std::shared_ptr<Ope> ope_;
+};
+
+class Dictionary : public Ope, public std::enable_shared_from_this<Dictionary> {
+public:
+  Dictionary(const std::vector<std::string> &v) : trie_(v) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
+                    any &dt) const override;
+
+  void accept(Visitor &v) override;
+
+  Trie trie_;
+};
+
+class LiteralString : public Ope,
+                      public std::enable_shared_from_this<LiteralString> {
+public:
+  LiteralString(std::string &&s, bool ignore_case)
+      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}
+
+  LiteralString(const std::string &s, bool ignore_case)
+      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
+                    any &dt) const override;
+
+  void accept(Visitor &v) override;
+
+  std::string lit_;
+  bool ignore_case_;
+  mutable std::once_flag init_is_word_;
+  mutable bool is_word_;
+};
+
+class CharacterClass : public Ope,
+                       public std::enable_shared_from_this<CharacterClass> {
+public:
+  CharacterClass(const std::string &s, bool negated) : negated_(negated) {
+    auto chars = decode(s.c_str(), s.length());
+    auto i = 0u;
+    while (i < chars.size()) {
+      if (i + 2 < chars.size() && chars[i + 1] == '-') {
+        auto cp1 = chars[i];
+        auto cp2 = chars[i + 2];
+        ranges_.emplace_back(std::make_pair(cp1, cp2));
+        i += 3;
+      } else {
+        auto cp = chars[i];
+        ranges_.emplace_back(std::make_pair(cp, cp));
+        i += 1;
+      }
+    }
+    assert(!ranges_.empty());
+  }
+
+  CharacterClass(const std::vector<std::pair<char32_t, char32_t>> &ranges,
+                 bool negated)
+      : ranges_(ranges), negated_(negated) {
+    assert(!ranges_.empty());
+  }
+
+  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,
+                    Context &c, any & /*dt*/) const override {
+    if (n < 1) {
+      c.set_error_pos(s);
+      return static_cast<size_t>(-1);
+    }
+
+    char32_t cp = 0;
+    auto len = decode_codepoint(s, n, cp);
+
+    for (const auto &range : ranges_) {
+      if (range.first <= cp && cp <= range.second) {
+        if (negated_) {
+          c.set_error_pos(s);
+          return static_cast<size_t>(-1);
+        } else {
+          return len;
+        }
+      }
+    }
+
+    if (negated_) {
+      return len;
+    } else {
+      c.set_error_pos(s);
+      return static_cast<size_t>(-1);
+    }
+  }
+
+  void accept(Visitor &v) override;
+
+  std::vector<std::pair<char32_t, char32_t>> ranges_;
+  bool negated_;
+};
+
+class Character : public Ope, public std::enable_shared_from_this<Character> {
+public:
+  Character(char ch) : ch_(ch) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,
+                    Context &c, any & /*dt*/) const override {
+    if (n < 1 || s[0] != ch_) {
+      c.set_error_pos(s);
+      return static_cast<size_t>(-1);
+    }
+    return 1;
+  }
+
+  void accept(Visitor &v) override;
+
+  char ch_;
+};
+
+class AnyCharacter : public Ope,
+                     public std::enable_shared_from_this<AnyCharacter> {
+public:
+  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,
+                    Context &c, any & /*dt*/) const override {
+    auto len = codepoint_length(s, n);
+    if (len < 1) {
+      c.set_error_pos(s);
+      return static_cast<size_t>(-1);
+    }
+    return len;
+  }
+
+  void accept(Visitor &v) override;
+};
+
+class CaptureScope : public Ope {
+public:
+  CaptureScope(const std::shared_ptr<Ope> &ope) : ope_(ope) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
+                    any &dt) const override {
+    c.push_capture_scope();
+    auto se = make_scope_exit([&]() { c.pop_capture_scope(); });
+    const auto &rule = *ope_;
+    auto len = rule.parse(s, n, sv, c, dt);
+    return len;
+  }
+
+  void accept(Visitor &v) override;
+
+  std::shared_ptr<Ope> ope_;
+};
+
+class Capture : public Ope {
+public:
+  typedef std::function<void(const char *s, size_t n, Context &c)> MatchAction;
+
+  Capture(const std::shared_ptr<Ope> &ope, MatchAction ma)
+      : ope_(ope), match_action_(ma) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
+                    any &dt) const override {
+    const auto &rule = *ope_;
+    auto len = rule.parse(s, n, sv, c, dt);
+    if (success(len) && match_action_) { match_action_(s, len, c); }
+    return len;
+  }
+
+  void accept(Visitor &v) override;
+
+  std::shared_ptr<Ope> ope_;
+  MatchAction match_action_;
+};
+
+class TokenBoundary : public Ope {
+public:
+  TokenBoundary(const std::shared_ptr<Ope> &ope) : ope_(ope) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
+                    any &dt) const override;
+
+  void accept(Visitor &v) override;
+
+  std::shared_ptr<Ope> ope_;
+};
+
+class Ignore : public Ope {
+public:
+  Ignore(const std::shared_ptr<Ope> &ope) : ope_(ope) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,
+                    Context &c, any &dt) const override {
+    const auto &rule = *ope_;
+    auto &chldsv = c.push();
+    auto se = make_scope_exit([&]() { c.pop(); });
+    return rule.parse(s, n, chldsv, c, dt);
+  }
+
+  void accept(Visitor &v) override;
+
+  std::shared_ptr<Ope> ope_;
+};
+
+typedef std::function<size_t(const char *s, size_t n, SemanticValues &sv,
+                             any &dt)>
+    Parser;
+
+class User : public Ope {
+public:
+  User(Parser fn) : fn_(fn) {}
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv,
+                    Context & /*c*/, any &dt) const override {
+    assert(fn_);
+    return fn_(s, n, sv, dt);
+  }
+  void accept(Visitor &v) override;
+  std::function<size_t(const char *s, size_t n, SemanticValues &sv, any &dt)>
+      fn_;
+};
+
+class WeakHolder : public Ope {
+public:
+  WeakHolder(const std::shared_ptr<Ope> &ope) : weak_(ope) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
+                    any &dt) const override {
+    auto ope = weak_.lock();
+    assert(ope);
+    const auto &rule = *ope;
+    return rule.parse(s, n, sv, c, dt);
+  }
+
+  void accept(Visitor &v) override;
+
+  std::weak_ptr<Ope> weak_;
+};
+
+class Holder : public Ope {
+public:
+  Holder(Definition *outer) : outer_(outer) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
+                    any &dt) const override;
+
+  void accept(Visitor &v) override;
+
+  any reduce(SemanticValues &sv, any &dt) const;
+
+  const char *trace_name() const;
+
+  std::shared_ptr<Ope> ope_;
+  Definition *outer_;
+  mutable std::string trace_name_;
+
+  friend class Definition;
+};
+
+typedef std::unordered_map<std::string, Definition> Grammar;
+
+class Reference : public Ope, public std::enable_shared_from_this<Reference> {
+public:
+  Reference(const Grammar &grammar, const std::string &name, const char *s,
+            bool is_macro, const std::vector<std::shared_ptr<Ope>> &args)
+      : grammar_(grammar), name_(name), s_(s), is_macro_(is_macro), args_(args),
+        rule_(nullptr), iarg_(0) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
+                    any &dt) const override;
+
+  void accept(Visitor &v) override;
+
+  std::shared_ptr<Ope> get_core_operator() const;
+
+  const Grammar &grammar_;
+  const std::string name_;
+  const char *s_;
+
+  const bool is_macro_;
+  const std::vector<std::shared_ptr<Ope>> args_;
+
+  Definition *rule_;
+  size_t iarg_;
+};
+
+class Whitespace : public Ope {
+public:
+  Whitespace(const std::shared_ptr<Ope> &ope) : ope_(ope) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
+                    any &dt) const override {
+    if (c.in_whitespace) { return 0; }
+    c.in_whitespace = true;
+    auto se = make_scope_exit([&]() { c.in_whitespace = false; });
+    const auto &rule = *ope_;
+    return rule.parse(s, n, sv, c, dt);
+  }
+
+  void accept(Visitor &v) override;
+
+  std::shared_ptr<Ope> ope_;
+};
+
+class BackReference : public Ope {
+public:
+  BackReference(const std::string &name) : name_(name) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
+                    any &dt) const override;
+
+  void accept(Visitor &v) override;
+
+  std::string name_;
+};
+
+class PrecedenceClimbing : public Ope {
+public:
+  using BinOpeInfo = std::map<std::string, std::pair<size_t, char>>;
+
+  PrecedenceClimbing(const std::shared_ptr<Ope> &atom,
+                     const std::shared_ptr<Ope> &binop, const BinOpeInfo &info,
+                     const Definition &rule)
+      : atom_(atom), binop_(binop), info_(info), rule_(rule) {}
+
+  size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,
+                    any &dt) const override {
+    return parse_expression(s, n, sv, c, dt, 0);
+  }
+
+  void accept(Visitor &v) override;
+
+  std::shared_ptr<Ope> atom_;
+  std::shared_ptr<Ope> binop_;
+  BinOpeInfo info_;
+  const Definition &rule_;
+
+private:
+  size_t parse_expression(const char *s, size_t n, SemanticValues &sv,
+                          Context &c, any &dt, size_t min_prec) const;
+
+  Definition &get_reference_for_binop(Context &c) const;
+};
+
+/*
+ * Factories
+ */
+template <typename... Args> std::shared_ptr<Ope> seq(Args &&... args) {
+  return std::make_shared<Sequence>(static_cast<std::shared_ptr<Ope>>(args)...);
+}
+
+template <typename... Args> std::shared_ptr<Ope> cho(Args &&... args) {
+  return std::make_shared<PrioritizedChoice>(
+      static_cast<std::shared_ptr<Ope>>(args)...);
+}
+
+inline std::shared_ptr<Ope> zom(const std::shared_ptr<Ope> &ope) {
+  return Repetition::zom(ope);
+}
+
+inline std::shared_ptr<Ope> oom(const std::shared_ptr<Ope> &ope) {
+  return Repetition::oom(ope);
+}
+
+inline std::shared_ptr<Ope> opt(const std::shared_ptr<Ope> &ope) {
+  return Repetition::opt(ope);
+}
+
+inline std::shared_ptr<Ope> rep(const std::shared_ptr<Ope> &ope, size_t min,
+                                size_t max) {
+  return std::make_shared<Repetition>(ope, min, max);
+}
+
+inline std::shared_ptr<Ope> apd(const std::shared_ptr<Ope> &ope) {
+  return std::make_shared<AndPredicate>(ope);
+}
+
+inline std::shared_ptr<Ope> npd(const std::shared_ptr<Ope> &ope) {
+  return std::make_shared<NotPredicate>(ope);
+}
+
+inline std::shared_ptr<Ope> dic(const std::vector<std::string> &v) {
+  return std::make_shared<Dictionary>(v);
+}
+
+inline std::shared_ptr<Ope> lit(std::string &&s) {
+  return std::make_shared<LiteralString>(s, false);
+}
+
+inline std::shared_ptr<Ope> liti(std::string &&s) {
+  return std::make_shared<LiteralString>(s, true);
+}
+
+inline std::shared_ptr<Ope> cls(const std::string &s) {
+  return std::make_shared<CharacterClass>(s, false);
+}
+
+inline std::shared_ptr<Ope>
+cls(const std::vector<std::pair<char32_t, char32_t>> &ranges) {
+  return std::make_shared<CharacterClass>(ranges, false);
+}
+
+inline std::shared_ptr<Ope> ncls(const std::string &s) {
+  return std::make_shared<CharacterClass>(s, true);
+}
+
+inline std::shared_ptr<Ope>
+ncls(const std::vector<std::pair<char32_t, char32_t>> &ranges) {
+  return std::make_shared<CharacterClass>(ranges, true);
+}
+
+inline std::shared_ptr<Ope> chr(char dt) {
+  return std::make_shared<Character>(dt);
+}
+
+inline std::shared_ptr<Ope> dot() { return std::make_shared<AnyCharacter>(); }
+
+inline std::shared_ptr<Ope> csc(const std::shared_ptr<Ope> &ope) {
+  return std::make_shared<CaptureScope>(ope);
+}
+
+inline std::shared_ptr<Ope> cap(const std::shared_ptr<Ope> &ope,
+                                Capture::MatchAction ma) {
+  return std::make_shared<Capture>(ope, ma);
+}
+
+inline std::shared_ptr<Ope> tok(const std::shared_ptr<Ope> &ope) {
+  return std::make_shared<TokenBoundary>(ope);
+}
+
+inline std::shared_ptr<Ope> ign(const std::shared_ptr<Ope> &ope) {
+  return std::make_shared<Ignore>(ope);
+}
+
+inline std::shared_ptr<Ope>
+usr(std::function<size_t(const char *s, size_t n, SemanticValues &sv, any &dt)>
+        fn) {
+  return std::make_shared<User>(fn);
+}
+
+inline std::shared_ptr<Ope> ref(const Grammar &grammar, const std::string &name,
+                                const char *s, bool is_macro,
+                                const std::vector<std::shared_ptr<Ope>> &args) {
+  return std::make_shared<Reference>(grammar, name, s, is_macro, args);
+}
+
+inline std::shared_ptr<Ope> wsp(const std::shared_ptr<Ope> &ope) {
+  return std::make_shared<Whitespace>(std::make_shared<Ignore>(ope));
+}
+
+inline std::shared_ptr<Ope> bkr(const std::string &name) {
+  return std::make_shared<BackReference>(name);
+}
+
+inline std::shared_ptr<Ope> pre(const std::shared_ptr<Ope> &atom,
+                                const std::shared_ptr<Ope> &binop,
+                                const PrecedenceClimbing::BinOpeInfo &info,
+                                const Definition &rule) {
+  return std::make_shared<PrecedenceClimbing>(atom, binop, info, rule);
+}
+
+/*
+ * Visitor
+ */
+struct Ope::Visitor {
+  virtual ~Visitor() {}
+  virtual void visit(Sequence & /*ope*/) {}
+  virtual void visit(PrioritizedChoice & /*ope*/) {}
+  virtual void visit(Repetition & /*ope*/) {}
+  virtual void visit(AndPredicate & /*ope*/) {}
+  virtual void visit(NotPredicate & /*ope*/) {}
+  virtual void visit(Dictionary & /*ope*/) {}
+  virtual void visit(LiteralString & /*ope*/) {}
+  virtual void visit(CharacterClass & /*ope*/) {}
+  virtual void visit(Character & /*ope*/) {}
+  virtual void visit(AnyCharacter & /*ope*/) {}
+  virtual void visit(CaptureScope & /*ope*/) {}
+  virtual void visit(Capture & /*ope*/) {}
+  virtual void visit(TokenBoundary & /*ope*/) {}
+  virtual void visit(Ignore & /*ope*/) {}
+  virtual void visit(User & /*ope*/) {}
+  virtual void visit(WeakHolder & /*ope*/) {}
+  virtual void visit(Holder & /*ope*/) {}
+  virtual void visit(Reference & /*ope*/) {}
+  virtual void visit(Whitespace & /*ope*/) {}
+  virtual void visit(BackReference & /*ope*/) {}
+  virtual void visit(PrecedenceClimbing & /*ope*/) {}
+};
+
+struct IsReference : public Ope::Visitor {
+  using Ope::Visitor::visit;
+  void visit(Reference & /*ope*/) override { is_reference = true; }
+  bool is_reference = false;
+};
+
+struct TraceOpeName : public Ope::Visitor {
+  void visit(Sequence & /*ope*/) override { name = "Sequence"; }
+  void visit(PrioritizedChoice & /*ope*/) override {
+    name = "PrioritizedChoice";
+  }
+  void visit(Repetition & /*ope*/) override { name = "Repetition"; }
+  void visit(AndPredicate & /*ope*/) override { name = "AndPredicate"; }
+  void visit(NotPredicate & /*ope*/) override { name = "NotPredicate"; }
+  void visit(Dictionary & /*ope*/) override { name = "Dictionary"; }
+  void visit(LiteralString & /*ope*/) override { name = "LiteralString"; }
+  void visit(CharacterClass & /*ope*/) override { name = "CharacterClass"; }
+  void visit(Character & /*ope*/) override { name = "Character"; }
+  void visit(AnyCharacter & /*ope*/) override { name = "AnyCharacter"; }
+  void visit(CaptureScope & /*ope*/) override { name = "CaptureScope"; }
+  void visit(Capture & /*ope*/) override { name = "Capture"; }
+  void visit(TokenBoundary & /*ope*/) override { name = "TokenBoundary"; }
+  void visit(Ignore & /*ope*/) override { name = "Ignore"; }
+  void visit(User & /*ope*/) override { name = "User"; }
+  void visit(WeakHolder & /*ope*/) override { name = "WeakHolder"; }
+  void visit(Holder &ope) override { name = ope.trace_name(); }
+  void visit(Reference & /*ope*/) override { name = "Reference"; }
+  void visit(Whitespace & /*ope*/) override { name = "Whitespace"; }
+  void visit(BackReference & /*ope*/) override { name = "BackReference"; }
+  void visit(PrecedenceClimbing & /*ope*/) override {
+    name = "PrecedenceClimbing";
+  }
+
+  const char *name = nullptr;
+};
+
+struct AssignIDToDefinition : public Ope::Visitor {
+  using Ope::Visitor::visit;
+
+  void visit(Sequence &ope) override {
+    for (auto op : ope.opes_) {
+      op->accept(*this);
+    }
+  }
+  void visit(PrioritizedChoice &ope) override {
+    for (auto op : ope.opes_) {
+      op->accept(*this);
+    }
+  }
+  void visit(Repetition &ope) override { ope.ope_->accept(*this); }
+  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }
+  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }
+  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }
+  void visit(Capture &ope) override { ope.ope_->accept(*this); }
+  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }
+  void visit(Ignore &ope) override { ope.ope_->accept(*this); }
+  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }
+  void visit(Holder &ope) override;
+  void visit(Reference &ope) override;
+  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }
+  void visit(PrecedenceClimbing &ope) override;
+
+  std::unordered_map<void *, size_t> ids;
+};
+
+struct IsLiteralToken : public Ope::Visitor {
+  using Ope::Visitor::visit;
+
+  void visit(PrioritizedChoice &ope) override {
+    for (auto op : ope.opes_) {
+      if (!IsLiteralToken::check(*op)) { return; }
+    }
+    result_ = true;
+  }
+
+  void visit(Dictionary & /*ope*/) override { result_ = true; }
+  void visit(LiteralString & /*ope*/) override { result_ = true; }
+
+  static bool check(Ope &ope) {
+    IsLiteralToken vis;
+    ope.accept(vis);
+    return vis.result_;
+  }
+
+private:
+  bool result_ = false;
+};
+
+struct TokenChecker : public Ope::Visitor {
+  using Ope::Visitor::visit;
+
+  void visit(Sequence &ope) override {
+    for (auto op : ope.opes_) {
+      op->accept(*this);
+    }
+  }
+  void visit(PrioritizedChoice &ope) override {
+    for (auto op : ope.opes_) {
+      op->accept(*this);
+    }
+  }
+  void visit(Repetition &ope) override { ope.ope_->accept(*this); }
+  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }
+  void visit(Capture &ope) override { ope.ope_->accept(*this); }
+  void visit(TokenBoundary & /*ope*/) override { has_token_boundary_ = true; }
+  void visit(Ignore &ope) override { ope.ope_->accept(*this); }
+  void visit(WeakHolder &ope) override;
+  void visit(Reference &ope) override;
+  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }
+  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }
+
+  static bool is_token(Ope &ope) {
+    if (IsLiteralToken::check(ope)) { return true; }
+
+    TokenChecker vis;
+    ope.accept(vis);
+    return vis.has_token_boundary_ || !vis.has_rule_;
+  }
+
+private:
+  bool has_token_boundary_ = false;
+  bool has_rule_ = false;
+};
+
+struct DetectLeftRecursion : public Ope::Visitor {
+  DetectLeftRecursion(const std::string &name) : name_(name) {}
+
+  void visit(Sequence &ope) override {
+    for (auto op : ope.opes_) {
+      op->accept(*this);
+      if (done_) {
+        break;
+      } else if (error_s) {
+        done_ = true;
+        break;
+      }
+    }
+  }
+  void visit(PrioritizedChoice &ope) override {
+    for (auto op : ope.opes_) {
+      op->accept(*this);
+      if (error_s) {
+        done_ = true;
+        break;
+      }
+    }
+  }
+  void visit(Repetition &ope) override {
+    ope.ope_->accept(*this);
+    done_ = ope.min_ > 0;
+  }
+  void visit(AndPredicate &ope) override {
+    ope.ope_->accept(*this);
+    done_ = false;
+  }
+  void visit(NotPredicate &ope) override {
+    ope.ope_->accept(*this);
+    done_ = false;
+  }
+  void visit(Dictionary & /*ope*/) override { done_ = true; }
+  void visit(LiteralString &ope) override { done_ = !ope.lit_.empty(); }
+  void visit(CharacterClass & /*ope*/) override { done_ = true; }
+  void visit(Character & /*ope*/) override { done_ = true; }
+  void visit(AnyCharacter & /*ope*/) override { done_ = true; }
+  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }
+  void visit(Capture &ope) override { ope.ope_->accept(*this); }
+  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }
+  void visit(Ignore &ope) override { ope.ope_->accept(*this); }
+  void visit(User & /*ope*/) override { done_ = true; }
+  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }
+  void visit(Holder &ope) override { ope.ope_->accept(*this); }
+  void visit(Reference &ope) override;
+  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }
+  void visit(BackReference & /*ope*/) override { done_ = true; }
+  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }
+
+  const char *error_s = nullptr;
+
+private:
+  std::string name_;
+  std::set<std::string> refs_;
+  bool done_ = false;
+};
+
+struct HasEmptyElement : public Ope::Visitor {
+  using Ope::Visitor::visit;
+
+  HasEmptyElement(std::list<std::pair<const char *, std::string>> &refs)
+      : refs_(refs) {}
+
+  void visit(Sequence &ope) override {
+    bool save_is_empty = false;
+    const char *save_error_s = nullptr;
+    std::string save_error_name;
+    for (auto op : ope.opes_) {
+      op->accept(*this);
+      if (!is_empty) { return; }
+      save_is_empty = is_empty;
+      save_error_s = error_s;
+      save_error_name = error_name;
+      is_empty = false;
+      error_name.clear();
+    }
+    is_empty = save_is_empty;
+    error_s = save_error_s;
+    error_name = save_error_name;
+  }
+  void visit(PrioritizedChoice &ope) override {
+    for (auto op : ope.opes_) {
+      op->accept(*this);
+      if (is_empty) { return; }
+    }
+  }
+  void visit(Repetition &ope) override {
+    if (ope.min_ == 0) {
+      set_error();
+    } else {
+      ope.ope_->accept(*this);
+    }
+  }
+  void visit(AndPredicate & /*ope*/) override { set_error(); }
+  void visit(NotPredicate & /*ope*/) override { set_error(); }
+  void visit(LiteralString &ope) override {
+    if (ope.lit_.empty()) { set_error(); }
+  }
+  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }
+  void visit(Capture &ope) override { ope.ope_->accept(*this); }
+  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }
+  void visit(Ignore &ope) override { ope.ope_->accept(*this); }
+  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }
+  void visit(Holder &ope) override { ope.ope_->accept(*this); }
+  void visit(Reference &ope) override;
+  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }
+  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }
+
+  bool is_empty = false;
+  const char *error_s = nullptr;
+  std::string error_name;
+
+private:
+  void set_error() {
+    is_empty = true;
+    error_s = refs_.back().first;
+    error_name = refs_.back().second;
+  }
+  std::list<std::pair<const char *, std::string>> &refs_;
+};
+
+struct DetectInfiniteLoop : public Ope::Visitor {
+  using Ope::Visitor::visit;
+
+  DetectInfiniteLoop(const char *s, const std::string &name) {
+    refs_.emplace_back(s, name);
+  }
+
+  void visit(Sequence &ope) override {
+    for (auto op : ope.opes_) {
+      op->accept(*this);
+      if (has_error) { return; }
+    }
+  }
+  void visit(PrioritizedChoice &ope) override {
+    for (auto op : ope.opes_) {
+      op->accept(*this);
+      if (has_error) { return; }
+    }
+  }
+  void visit(Repetition &ope) override {
+    if (ope.max_ == std::numeric_limits<size_t>::max()) {
+      HasEmptyElement vis(refs_);
+      ope.ope_->accept(vis);
+      if (vis.is_empty) {
+        has_error = true;
+        error_s = vis.error_s;
+        error_name = vis.error_name;
+      }
+    } else {
+      ope.ope_->accept(*this);
+    }
+  }
+  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }
+  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }
+  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }
+  void visit(Capture &ope) override { ope.ope_->accept(*this); }
+  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }
+  void visit(Ignore &ope) override { ope.ope_->accept(*this); }
+  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }
+  void visit(Holder &ope) override { ope.ope_->accept(*this); }
+  void visit(Reference &ope) override;
+  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }
+  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }
+
+  bool has_error = false;
+  const char *error_s = nullptr;
+  std::string error_name;
+
+private:
+  std::list<std::pair<const char *, std::string>> refs_;
+};
+
+struct ReferenceChecker : public Ope::Visitor {
+  using Ope::Visitor::visit;
+
+  ReferenceChecker(const Grammar &grammar,
+                   const std::vector<std::string> &params)
+      : grammar_(grammar), params_(params) {}
+
+  void visit(Sequence &ope) override {
+    for (auto op : ope.opes_) {
+      op->accept(*this);
+    }
+  }
+  void visit(PrioritizedChoice &ope) override {
+    for (auto op : ope.opes_) {
+      op->accept(*this);
+    }
+  }
+  void visit(Repetition &ope) override { ope.ope_->accept(*this); }
+  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }
+  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }
+  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }
+  void visit(Capture &ope) override { ope.ope_->accept(*this); }
+  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }
+  void visit(Ignore &ope) override { ope.ope_->accept(*this); }
+  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }
+  void visit(Holder &ope) override { ope.ope_->accept(*this); }
+  void visit(Reference &ope) override;
+  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }
+  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }
+
+  std::unordered_map<std::string, const char *> error_s;
+  std::unordered_map<std::string, std::string> error_message;
+
+private:
+  const Grammar &grammar_;
+  const std::vector<std::string> &params_;
+};
+
+struct LinkReferences : public Ope::Visitor {
+  using Ope::Visitor::visit;
+
+  LinkReferences(Grammar &grammar, const std::vector<std::string> &params)
+      : grammar_(grammar), params_(params) {}
+
+  void visit(Sequence &ope) override {
+    for (auto op : ope.opes_) {
+      op->accept(*this);
+    }
+  }
+  void visit(PrioritizedChoice &ope) override {
+    for (auto op : ope.opes_) {
+      op->accept(*this);
+    }
+  }
+  void visit(Repetition &ope) override { ope.ope_->accept(*this); }
+  void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }
+  void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }
+  void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }
+  void visit(Capture &ope) override { ope.ope_->accept(*this); }
+  void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }
+  void visit(Ignore &ope) override { ope.ope_->accept(*this); }
+  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }
+  void visit(Holder &ope) override { ope.ope_->accept(*this); }
+  void visit(Reference &ope) override;
+  void visit(Whitespace &ope) override { ope.ope_->accept(*this); }
+  void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }
+
+private:
+  Grammar &grammar_;
+  const std::vector<std::string> &params_;
+};
+
+struct FindReference : public Ope::Visitor {
+  using Ope::Visitor::visit;
+
+  FindReference(const std::vector<std::shared_ptr<Ope>> &args,
+                const std::vector<std::string> &params)
+      : args_(args), params_(params) {}
+
+  void visit(Sequence &ope) override {
+    std::vector<std::shared_ptr<Ope>> opes;
+    for (auto o : ope.opes_) {
+      o->accept(*this);
+      opes.push_back(found_ope);
+    }
+    found_ope = std::make_shared<Sequence>(opes);
+  }
+  void visit(PrioritizedChoice &ope) override {
+    std::vector<std::shared_ptr<Ope>> opes;
+    for (auto o : ope.opes_) {
+      o->accept(*this);
+      opes.push_back(found_ope);
+    }
+    found_ope = std::make_shared<PrioritizedChoice>(opes);
+  }
+  void visit(Repetition &ope) override {
+    ope.ope_->accept(*this);
+    found_ope = rep(found_ope, ope.min_, ope.max_);
+  }
+  void visit(AndPredicate &ope) override {
+    ope.ope_->accept(*this);
+    found_ope = apd(found_ope);
+  }
+  void visit(NotPredicate &ope) override {
+    ope.ope_->accept(*this);
+    found_ope = npd(found_ope);
+  }
+  void visit(Dictionary &ope) override { found_ope = ope.shared_from_this(); }
+  void visit(LiteralString &ope) override {
+    found_ope = ope.shared_from_this();
+  }
+  void visit(CharacterClass &ope) override {
+    found_ope = ope.shared_from_this();
+  }
+  void visit(Character &ope) override { found_ope = ope.shared_from_this(); }
+  void visit(AnyCharacter &ope) override { found_ope = ope.shared_from_this(); }
+  void visit(CaptureScope &ope) override {
+    ope.ope_->accept(*this);
+    found_ope = csc(found_ope);
+  }
+  void visit(Capture &ope) override {
+    ope.ope_->accept(*this);
+    found_ope = cap(found_ope, ope.match_action_);
+  }
+  void visit(TokenBoundary &ope) override {
+    ope.ope_->accept(*this);
+    found_ope = tok(found_ope);
+  }
+  void visit(Ignore &ope) override {
+    ope.ope_->accept(*this);
+    found_ope = ign(found_ope);
+  }
+  void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }
+  void visit(Holder &ope) override { ope.ope_->accept(*this); }
+  void visit(Reference &ope) override;
+  void visit(Whitespace &ope) override {
+    ope.ope_->accept(*this);
+    found_ope = wsp(found_ope);
+  }
+  void visit(PrecedenceClimbing &ope) override {
+    ope.atom_->accept(*this);
+    found_ope = csc(found_ope);
+  }
+
+  std::shared_ptr<Ope> found_ope;
+
+private:
+  const std::vector<std::shared_ptr<Ope>> &args_;
+  const std::vector<std::string> &params_;
+};
+
+struct IsPrioritizedChoice : public Ope::Visitor {
+  using Ope::Visitor::visit;
+
+  void visit(PrioritizedChoice & /*ope*/) override { result_ = true; }
+
+  static bool check(Ope &ope) {
+    IsPrioritizedChoice vis;
+    ope.accept(vis);
+    return vis.result_;
+  }
+
+private:
+  bool result_ = false;
+};
+
+/*
+ * Keywords
+ */
+static const char *WHITESPACE_DEFINITION_NAME = "%whitespace";
+static const char *WORD_DEFINITION_NAME = "%word";
+
+/*
+ * Definition
+ */
+class Definition {
+public:
+  struct Result {
+    bool ret;
+    size_t len;
+    const char *error_pos;
+    const char *message_pos;
+    const std::string message;
+  };
+
+  Definition() : holder_(std::make_shared<Holder>(this)) {}
+
+  Definition(const Definition &rhs) : name(rhs.name), holder_(rhs.holder_) {
+    holder_->outer_ = this;
+  }
+
+  Definition(const std::shared_ptr<Ope> &ope)
+      : holder_(std::make_shared<Holder>(this)) {
+    *this <= ope;
+  }
+
+  operator std::shared_ptr<Ope>() {
+    return std::make_shared<WeakHolder>(holder_);
+  }
+
+  Definition &operator<=(const std::shared_ptr<Ope> &ope) {
+    holder_->ope_ = ope;
+    return *this;
+  }
+
+  Result parse(const char *s, size_t n, const char *path = nullptr) const {
+    SemanticValues sv;
+    any dt;
+    return parse_core(s, n, sv, dt, path);
+  }
+
+  Result parse(const char *s, const char *path = nullptr) const {
+    auto n = strlen(s);
+    return parse(s, n, path);
+  }
+
+  Result parse(const char *s, size_t n, any &dt,
+               const char *path = nullptr) const {
+    SemanticValues sv;
+    return parse_core(s, n, sv, dt, path);
+  }
+
+  Result parse(const char *s, any &dt, const char *path = nullptr) const {
+    auto n = strlen(s);
+    return parse(s, n, dt, path);
+  }
+
+  template <typename T>
+  Result parse_and_get_value(const char *s, size_t n, T &val,
+                             const char *path = nullptr) const {
+    SemanticValues sv;
+    any dt;
+    auto r = parse_core(s, n, sv, dt, path);
+    if (r.ret && !sv.empty() && sv.front().has_value()) {
+      val = any_cast<T>(sv[0]);
+    }
+    return r;
+  }
+
+  template <typename T>
+  Result parse_and_get_value(const char *s, T &val,
+                             const char *path = nullptr) const {
+    auto n = strlen(s);
+    return parse_and_get_value(s, n, val, path);
+  }
+
+  template <typename T>
+  Result parse_and_get_value(const char *s, size_t n, any &dt, T &val,
+                             const char *path = nullptr) const {
+    SemanticValues sv;
+    auto r = parse_core(s, n, sv, dt, path);
+    if (r.ret && !sv.empty() && sv.front().has_value()) {
+      val = any_cast<T>(sv[0]);
+    }
+    return r;
+  }
+
+  template <typename T>
+  Result parse_and_get_value(const char *s, any &dt, T &val,
+                             const char *path = nullptr) const {
+    auto n = strlen(s);
+    return parse_and_get_value(s, n, dt, val, path);
+  }
+
+  Action operator=(Action a) {
+    action = a;
+    return a;
+  }
+
+  template <typename T> Definition &operator,(T fn) {
+    operator=(fn);
+    return *this;
+  }
+
+  Definition &operator~() {
+    ignoreSemanticValue = true;
+    return *this;
+  }
+
+  void accept(Ope::Visitor &v) { holder_->accept(v); }
+
+  std::shared_ptr<Ope> get_core_operator() const { return holder_->ope_; }
+
+  bool is_token() const {
+    std::call_once(is_token_init_, [this]() {
+      is_token_ = TokenChecker::is_token(*get_core_operator());
+    });
+    return is_token_;
+  }
+
+  std::string name;
+  const char *s_ = nullptr;
+
+  size_t id = 0;
+  Action action;
+  std::function<void(const char *s, size_t n, any &dt)> enter;
+  std::function<void(const char *s, size_t n, size_t matchlen, any &value,
+                     any &dt)>
+      leave;
+  std::function<std::string()> error_message;
+  bool ignoreSemanticValue = false;
+  std::shared_ptr<Ope> whitespaceOpe;
+  std::shared_ptr<Ope> wordOpe;
+  bool enablePackratParsing = false;
+  bool is_macro = false;
+  std::vector<std::string> params;
+  TracerEnter tracer_enter;
+  TracerLeave tracer_leave;
+  bool disable_action = false;
+
+private:
+  friend class Reference;
+  friend class ParserGenerator;
+
+  Definition &operator=(const Definition &rhs);
+  Definition &operator=(Definition &&rhs);
+
+  void initialize_definition_ids() const {
+    std::call_once(definition_ids_init_, [&]() {
+      AssignIDToDefinition vis;
+      holder_->accept(vis);
+      if (whitespaceOpe) { whitespaceOpe->accept(vis); }
+      if (wordOpe) { wordOpe->accept(vis); }
+      definition_ids_.swap(vis.ids);
+    });
+  }
+
+  Result parse_core(const char *s, size_t n, SemanticValues &sv, any &dt,
+                    const char *path) const {
+    initialize_definition_ids();
+
+    std::shared_ptr<Ope> ope = holder_;
+    if (whitespaceOpe) { ope = std::make_shared<Sequence>(whitespaceOpe, ope); }
+
+    Context cxt(path, s, n, definition_ids_.size(), whitespaceOpe, wordOpe,
+                enablePackratParsing, tracer_enter, tracer_leave);
+
+    auto len = ope->parse(s, n, sv, cxt, dt);
+    return Result{success(len), len, cxt.error_pos, cxt.message_pos,
+                  cxt.message};
+  }
+
+  std::shared_ptr<Holder> holder_;
+  mutable std::once_flag is_token_init_;
+  mutable bool is_token_ = false;
+  mutable std::once_flag assign_id_to_definition_init_;
+  mutable std::once_flag definition_ids_init_;
+  mutable std::unordered_map<void *, size_t> definition_ids_;
+};
+
+/*
+ * Implementations
+ */
+
+inline size_t parse_literal(const char *s, size_t n, SemanticValues &sv,
+                            Context &c, any &dt, const std::string &lit,
+                            std::once_flag &init_is_word, bool &is_word,
+                            bool ignore_case) {
+  size_t i = 0;
+  for (; i < lit.size(); i++) {
+    if (i >= n || (ignore_case ? (std::tolower(s[i]) != std::tolower(lit[i]))
+                               : (s[i] != lit[i]))) {
+      c.set_error_pos(s);
+      return static_cast<size_t>(-1);
+    }
+  }
+
+  // Word check
+  static Context dummy_c(nullptr, c.s, c.l, 0, nullptr, nullptr, false, nullptr,
+                         nullptr);
+  static SemanticValues dummy_sv;
+  static any dummy_dt;
+
+  std::call_once(init_is_word, [&]() {
+    if (c.wordOpe) {
+      auto len =
+          c.wordOpe->parse(lit.data(), lit.size(), dummy_sv, dummy_c, dummy_dt);
+      is_word = success(len);
+    }
+  });
+
+  if (is_word) {
+    NotPredicate ope(c.wordOpe);
+    auto len = ope.parse(s + i, n - i, dummy_sv, dummy_c, dummy_dt);
+    if (fail(len)) { return static_cast<size_t>(-1); }
+    i += len;
+  }
+
+  // Skip whiltespace
+  if (!c.in_token_boundary_count) {
+    if (c.whitespaceOpe) {
+      auto len = c.whitespaceOpe->parse(s + i, n - i, sv, c, dt);
+      if (fail(len)) { return static_cast<size_t>(-1); }
+      i += len;
+    }
+  }
+
+  return i;
+}
+
+inline void Context::trace_enter(const char *name, const char *a_s, size_t n,
+                                 SemanticValues &sv, any &dt) const {
+  trace_ids.push_back(next_trace_id++);
+  tracer_enter(name, a_s, n, sv, *this, dt);
+}
+
+inline void Context::trace_leave(const char *name, const char *a_s, size_t n,
+                                 SemanticValues &sv, any &dt,
+                                 size_t len) const {
+  tracer_leave(name, a_s, n, sv, *this, dt, len);
+  trace_ids.pop_back();
+}
+
+inline bool Context::is_traceable(const Ope &ope) const {
+  if (tracer_enter && tracer_leave) {
+    IsReference vis;
+    const_cast<Ope &>(ope).accept(vis);
+    return !vis.is_reference;
+  }
+  return false;
+}
+
+inline size_t Ope::parse(const char *s, size_t n, SemanticValues &sv,
+                         Context &c, any &dt) const {
+  if (c.is_traceable(*this)) {
+    TraceOpeName vis;
+    const_cast<Ope &>(*this).accept(vis);
+    c.trace_enter(vis.name, s, n, sv, dt);
+    auto len = parse_core(s, n, sv, c, dt);
+    c.trace_leave(vis.name, s, n, sv, dt, len);
+    return len;
+  }
+  return parse_core(s, n, sv, c, dt);
+}
+
+inline size_t Dictionary::parse_core(const char *s, size_t n,
+                                     SemanticValues & /*sv*/, Context &c,
+                                     any & /*dt*/) const {
+  auto len = trie_.match(s, n);
+  if (len > 0) { return len; }
+  c.set_error_pos(s);
+  return static_cast<size_t>(-1);
+}
+
+inline size_t LiteralString::parse_core(const char *s, size_t n,
+                                        SemanticValues &sv, Context &c,
+                                        any &dt) const {
+  return parse_literal(s, n, sv, c, dt, lit_, init_is_word_, is_word_,
+                       ignore_case_);
+}
+
+inline size_t TokenBoundary::parse_core(const char *s, size_t n,
+                                        SemanticValues &sv, Context &c,
+                                        any &dt) const {
+  size_t len;
+  {
+    c.in_token_boundary_count++;
+    auto se = make_scope_exit([&]() { c.in_token_boundary_count--; });
+    len = ope_->parse(s, n, sv, c, dt);
+  }
+
+  if (success(len)) {
+    sv.tokens.emplace_back(std::make_pair(s, len));
+
+    if (!c.in_token_boundary_count) {
+      if (c.whitespaceOpe) {
+        auto l = c.whitespaceOpe->parse(s + len, n - len, sv, c, dt);
+        if (fail(l)) { return static_cast<size_t>(-1); }
+        len += l;
+      }
+    }
+  }
+  return len;
+}
+
+inline size_t Holder::parse_core(const char *s, size_t n, SemanticValues &sv,
+                                 Context &c, any &dt) const {
+  if (!ope_) {
+    throw std::logic_error("Uninitialized definition ope was used...");
+  }
+
+  // Macro reference
+  if (outer_->is_macro) {
+    c.rule_stack.push_back(outer_);
+    auto len = ope_->parse(s, n, sv, c, dt);
+    c.rule_stack.pop_back();
+    return len;
+  }
+
+  size_t len;
+  any val;
+
+  c.packrat(s, outer_->id, len, val, [&](any &a_val) {
+    if (outer_->enter) { outer_->enter(s, n, dt); }
+
+    auto se2 = make_scope_exit([&]() {
+      c.pop();
+
+      if (outer_->leave) { outer_->leave(s, n, len, a_val, dt); }
+    });
+
+    auto &chldsv = c.push();
+
+    c.rule_stack.push_back(outer_);
+    len = ope_->parse(s, n, chldsv, c, dt);
+    c.rule_stack.pop_back();
+
+    // Invoke action
+    if (success(len)) {
+      chldsv.s_ = s;
+      chldsv.n_ = len;
+      chldsv.name_ = outer_->name;
+
+      if (!IsPrioritizedChoice::check(*ope_)) {
+        chldsv.choice_count_ = 0;
+        chldsv.choice_ = 0;
+      }
+
+      try {
+        a_val = reduce(chldsv, dt);
+      } catch (const parse_error &e) {
+        if (e.what()) {
+          if (c.message_pos < s) {
+            c.message_pos = s;
+            c.message = e.what();
+          }
+        }
+        len = static_cast<size_t>(-1);
+      }
+    }
+  });
+
+  if (success(len)) {
+    if (!outer_->ignoreSemanticValue) {
+      sv.emplace_back(std::move(val));
+      sv.tags.emplace_back(str2tag(outer_->name.c_str()));
+    }
+  } else {
+    if (outer_->error_message) {
+      if (c.message_pos < s) {
+        c.message_pos = s;
+        c.message = outer_->error_message();
+      }
+    }
+  }
+
+  return len;
+}
+
+inline any Holder::reduce(SemanticValues &sv, any &dt) const {
+  if (outer_->action && !outer_->disable_action) {
+    return outer_->action(sv, dt);
+  } else if (sv.empty()) {
+    return any();
+  } else {
+    return std::move(sv.front());
+  }
+}
+
+inline const char *Holder::trace_name() const {
+  if (trace_name_.empty()) { trace_name_ = "[" + outer_->name + "]"; }
+  return trace_name_.c_str();
+}
+
+inline size_t Reference::parse_core(const char *s, size_t n, SemanticValues &sv,
+                                    Context &c, any &dt) const {
+  if (rule_) {
+    // Reference rule
+    if (rule_->is_macro) {
+      // Macro
+      FindReference vis(c.top_args(), c.rule_stack.back()->params);
+
+      // Collect arguments
+      std::vector<std::shared_ptr<Ope>> args;
+      for (auto arg : args_) {
+        arg->accept(vis);
+        args.emplace_back(std::move(vis.found_ope));
+      }
+
+      c.push_args(std::move(args));
+      auto se = make_scope_exit([&]() { c.pop_args(); });
+      auto ope = get_core_operator();
+      return ope->parse(s, n, sv, c, dt);
+    } else {
+      // Definition
+      c.push_args(std::vector<std::shared_ptr<Ope>>());
+      auto se = make_scope_exit([&]() { c.pop_args(); });
+      auto ope = get_core_operator();
+      return ope->parse(s, n, sv, c, dt);
+    }
+  } else {
+    // Reference parameter in macro
+    const auto &args = c.top_args();
+    return args[iarg_]->parse(s, n, sv, c, dt);
+  }
+}
+
+inline std::shared_ptr<Ope> Reference::get_core_operator() const {
+  return rule_->holder_;
+}
+
+inline size_t BackReference::parse_core(const char *s, size_t n,
+                                        SemanticValues &sv, Context &c,
+                                        any &dt) const {
+  auto size = static_cast<int>(c.capture_scope_stack_size);
+  for (auto i = size - 1; i >= 0; i--) {
+    auto index = static_cast<size_t>(i);
+    const auto &cs = c.capture_scope_stack[index];
+    if (cs.find(name_) != cs.end()) {
+      const auto &lit = cs.at(name_);
+      std::once_flag init_is_word;
+      auto is_word = false;
+      return parse_literal(s, n, sv, c, dt, lit, init_is_word, is_word, false);
+    }
+  }
+  throw std::runtime_error("Invalid back reference...");
+}
+
+inline Definition &
+PrecedenceClimbing::get_reference_for_binop(Context &c) const {
+  if (rule_.is_macro) {
+    // Reference parameter in macro
+    const auto &args = c.top_args();
+    auto iarg = dynamic_cast<Reference &>(*binop_).iarg_;
+    auto arg = args[iarg];
+    return *dynamic_cast<Reference &>(*arg).rule_;
+  }
+
+  return *dynamic_cast<Reference &>(*binop_).rule_;
+}
+
+inline size_t PrecedenceClimbing::parse_expression(const char *s, size_t n,
+                                                   SemanticValues &sv,
+                                                   Context &c, any &dt,
+                                                   size_t min_prec) const {
+  auto len = atom_->parse(s, n, sv, c, dt);
+  if (fail(len)) { return len; }
+
+  std::string tok;
+  auto &rule = get_reference_for_binop(c);
+  auto action = rule.action;
+
+  rule.action = [&](SemanticValues &sv2, any &dt2) -> any {
+    tok = sv2.token();
+    if (action) {
+      return action(sv2, dt2);
+    } else if (!sv2.empty()) {
+      return sv2[0];
+    }
+    return any();
+  };
+  auto action_se = make_scope_exit([&]() { rule.action = action; });
+
+  auto save_error_pos = c.error_pos;
+
+  auto i = len;
+  while (i < n) {
+    std::vector<any> save_values(sv.begin(), sv.end());
+    auto save_tokens = sv.tokens;
+
+    auto chv = c.push();
+    auto chl = binop_->parse(s + i, n - i, chv, c, dt);
+    c.pop();
+
+    if (fail(chl)) {
+      c.error_pos = save_error_pos;
+      break;
+    }
+
+    auto it = info_.find(tok);
+    if (it == info_.end()) { break; }
+
+    auto level = std::get<0>(it->second);
+    auto assoc = std::get<1>(it->second);
+
+    if (level < min_prec) { break; }
+
+    sv.emplace_back(std::move(chv[0]));
+    i += chl;
+
+    auto next_min_prec = level;
+    if (assoc == 'L') { next_min_prec = level + 1; }
+
+    chv = c.push();
+    chl = parse_expression(s + i, n - i, chv, c, dt, next_min_prec);
+    c.pop();
+
+    if (fail(chl)) {
+      sv.assign(save_values.begin(), save_values.end());
+      sv.tokens = save_tokens;
+      c.error_pos = save_error_pos;
+      break;
+    }
+
+    sv.emplace_back(std::move(chv[0]));
+    i += chl;
+
+    any val;
+    if (rule_.action) {
+      sv.s_ = s;
+      sv.n_ = i;
+      val = rule_.action(sv, dt);
+    } else if (!sv.empty()) {
+      val = sv[0];
+    }
+    sv.clear();
+    sv.emplace_back(std::move(val));
+  }
+
+  return i;
+}
+
+inline void Sequence::accept(Visitor &v) { v.visit(*this); }
+inline void PrioritizedChoice::accept(Visitor &v) { v.visit(*this); }
+inline void Repetition::accept(Visitor &v) { v.visit(*this); }
+inline void AndPredicate::accept(Visitor &v) { v.visit(*this); }
+inline void NotPredicate::accept(Visitor &v) { v.visit(*this); }
+inline void Dictionary::accept(Visitor &v) { v.visit(*this); }
+inline void LiteralString::accept(Visitor &v) { v.visit(*this); }
+inline void CharacterClass::accept(Visitor &v) { v.visit(*this); }
+inline void Character::accept(Visitor &v) { v.visit(*this); }
+inline void AnyCharacter::accept(Visitor &v) { v.visit(*this); }
+inline void CaptureScope::accept(Visitor &v) { v.visit(*this); }
+inline void Capture::accept(Visitor &v) { v.visit(*this); }
+inline void TokenBoundary::accept(Visitor &v) { v.visit(*this); }
+inline void Ignore::accept(Visitor &v) { v.visit(*this); }
+inline void User::accept(Visitor &v) { v.visit(*this); }
+inline void WeakHolder::accept(Visitor &v) { v.visit(*this); }
+inline void Holder::accept(Visitor &v) { v.visit(*this); }
+inline void Reference::accept(Visitor &v) { v.visit(*this); }
+inline void Whitespace::accept(Visitor &v) { v.visit(*this); }
+inline void BackReference::accept(Visitor &v) { v.visit(*this); }
+inline void PrecedenceClimbing::accept(Visitor &v) { v.visit(*this); }
+
+inline void AssignIDToDefinition::visit(Holder &ope) {
+  auto p = static_cast<void *>(ope.outer_);
+  if (ids.count(p)) { return; }
+  auto id = ids.size();
+  ids[p] = id;
+  ope.outer_->id = id;
+  ope.ope_->accept(*this);
+}
+
+inline void AssignIDToDefinition::visit(Reference &ope) {
+  if (ope.rule_) {
+    for (auto arg : ope.args_) {
+      arg->accept(*this);
+    }
+    ope.rule_->accept(*this);
+  }
+}
+
+inline void AssignIDToDefinition::visit(PrecedenceClimbing &ope) {
+  ope.atom_->accept(*this);
+  ope.binop_->accept(*this);
+}
+
+inline void TokenChecker::visit(WeakHolder & /*ope*/) { has_rule_ = true; }
+
+inline void TokenChecker::visit(Reference &ope) {
+  if (ope.is_macro_) {
+    ope.rule_->accept(*this);
+    for (auto arg : ope.args_) {
+      arg->accept(*this);
+    }
+  } else {
+    has_rule_ = true;
+  }
+}
+
+inline void DetectLeftRecursion::visit(Reference &ope) {
+  if (ope.name_ == name_) {
+    error_s = ope.s_;
+  } else if (!refs_.count(ope.name_)) {
+    refs_.insert(ope.name_);
+    if (ope.rule_) {
+      ope.rule_->accept(*this);
+      if (done_ == false) { return; }
+    }
+  }
+  done_ = true;
+}
+
+inline void HasEmptyElement::visit(Reference &ope) {
+  auto it = std::find_if(refs_.begin(), refs_.end(),
+                         [&](const std::pair<const char *, std::string> &ref) {
+                           return ope.name_ == ref.second;
+                         });
+  if (it != refs_.end()) { return; }
+
+  if (ope.rule_) {
+    refs_.emplace_back(ope.s_, ope.name_);
+    ope.rule_->accept(*this);
+    refs_.pop_back();
+  }
+}
+
+inline void DetectInfiniteLoop::visit(Reference &ope) {
+  auto it = std::find_if(refs_.begin(), refs_.end(),
+                         [&](const std::pair<const char *, std::string> &ref) {
+                           return ope.name_ == ref.second;
+                         });
+  if (it != refs_.end()) { return; }
+
+  if (ope.rule_) {
+    refs_.emplace_back(ope.s_, ope.name_);
+    ope.rule_->accept(*this);
+    refs_.pop_back();
+  }
+}
+
+inline void ReferenceChecker::visit(Reference &ope) {
+  auto it = std::find(params_.begin(), params_.end(), ope.name_);
+  if (it != params_.end()) { return; }
+
+  if (!grammar_.count(ope.name_)) {
+    error_s[ope.name_] = ope.s_;
+    error_message[ope.name_] = "'" + ope.name_ + "' is not defined.";
+  } else {
+    const auto &rule = grammar_.at(ope.name_);
+    if (rule.is_macro) {
+      if (!ope.is_macro_ || ope.args_.size() != rule.params.size()) {
+        error_s[ope.name_] = ope.s_;
+        error_message[ope.name_] = "incorrect number of arguments.";
+      }
+    } else if (ope.is_macro_) {
+      error_s[ope.name_] = ope.s_;
+      error_message[ope.name_] = "'" + ope.name_ + "' is not macro.";
+    }
+  }
+}
+
+inline void LinkReferences::visit(Reference &ope) {
+  // Check if the reference is a macro parameter
+  auto found_param = false;
+  for (size_t i = 0; i < params_.size(); i++) {
+    const auto &param = params_[i];
+    if (param == ope.name_) {
+      ope.iarg_ = i;
+      found_param = true;
+      break;
+    }
+  }
+
+  // Check if the reference is a definition rule
+  if (!found_param && grammar_.count(ope.name_)) {
+    auto &rule = grammar_.at(ope.name_);
+    ope.rule_ = &rule;
+  }
+
+  for (auto arg : ope.args_) {
+    arg->accept(*this);
+  }
+}
+
+inline void FindReference::visit(Reference &ope) {
+  for (size_t i = 0; i < args_.size(); i++) {
+    const auto &name = params_[i];
+    if (name == ope.name_) {
+      found_ope = args_[i];
+      return;
+    }
+  }
+  found_ope = ope.shared_from_this();
+}
+
+/*-----------------------------------------------------------------------------
+ *  PEG parser generator
+ *---------------------------------------------------------------------------*/
+
+typedef std::unordered_map<std::string, std::shared_ptr<Ope>> Rules;
+typedef std::function<void(size_t, size_t, const std::string &)> Log;
+
+class ParserGenerator {
+public:
+  static std::shared_ptr<Grammar> parse(const char *s, size_t n,
+                                        const Rules &rules, std::string &start,
+                                        Log log) {
+    return get_instance().perform_core(s, n, rules, start, log);
+  }
+
+  static std::shared_ptr<Grammar> parse(const char *s, size_t n,
+                                        std::string &start, Log log) {
+    Rules dummy;
+    return parse(s, n, dummy, start, log);
+  }
+
+  // For debuging purpose
+  static Grammar &grammar() { return get_instance().g; }
+
+private:
+  static ParserGenerator &get_instance() {
+    static ParserGenerator instance;
+    return instance;
+  }
+
+  ParserGenerator() {
+    make_grammar();
+    setup_actions();
+  }
+
+  struct Instruction {
+    std::string type;
+    any data;
+  };
+
+  struct Data {
+    std::shared_ptr<Grammar> grammar;
+    std::string start;
+    const char *start_pos = nullptr;
+    std::vector<std::pair<std::string, const char *>> duplicates;
+    std::map<std::string, Instruction> instructions;
+
+    Data() : grammar(std::make_shared<Grammar>()) {}
+  };
+
+  void make_grammar() {
+    // Setup PEG syntax parser
+    g["Grammar"] <= seq(g["Spacing"], oom(g["Definition"]), g["EndOfFile"]);
+    g["Definition"] <=
+        cho(seq(g["Ignore"], g["IdentCont"], g["Parameters"], g["LEFTARROW"],
+                g["Expression"], opt(g["Instruction"])),
+            seq(g["Ignore"], g["Identifier"], g["LEFTARROW"], g["Expression"],
+                opt(g["Instruction"])));
+    g["Expression"] <= seq(g["Sequence"], zom(seq(g["SLASH"], g["Sequence"])));
+    g["Sequence"] <= zom(g["Prefix"]);
+    g["Prefix"] <= seq(opt(cho(g["AND"], g["NOT"])), g["Suffix"]);
+    g["Suffix"] <= seq(g["Primary"], opt(g["Loop"]));
+    g["Loop"] <= cho(g["QUESTION"], g["STAR"], g["PLUS"], g["Repetition"]);
+    g["Primary"] <=
+        cho(seq(g["Ignore"], g["IdentCont"], g["Arguments"],
+                npd(g["LEFTARROW"])),
+            seq(g["Ignore"], g["Identifier"],
+                npd(seq(opt(g["Parameters"]), g["LEFTARROW"]))),
+            seq(g["OPEN"], g["Expression"], g["CLOSE"]),
+            seq(g["BeginTok"], g["Expression"], g["EndTok"]),
+            seq(g["BeginCapScope"], g["Expression"], g["EndCapScope"]),
+            seq(g["BeginCap"], g["Expression"], g["EndCap"]), g["BackRef"],
+            g["LiteralI"], g["Dictionary"], g["Literal"], g["NegatedClass"],
+            g["Class"], g["DOT"]);
+
+    g["Identifier"] <= seq(g["IdentCont"], g["Spacing"]);
+    g["IdentCont"] <= seq(g["IdentStart"], zom(g["IdentRest"]));
+
+    const static std::vector<std::pair<char32_t, char32_t>> range = {
+        {0x0080, 0xFFFF}};
+    g["IdentStart"] <= cho(cls("a-zA-Z_%"), cls(range));
+
+    g["IdentRest"] <= cho(g["IdentStart"], cls("0-9"));
+
+    g["Dictionary"] <= seq(g["LiteralD"], oom(seq(g["PIPE"], g["LiteralD"])));
+
+    auto lit_ope = cho(seq(cls("'"), tok(zom(seq(npd(cls("'")), g["Char"]))),
+                           cls("'"), g["Spacing"]),
+                       seq(cls("\""), tok(zom(seq(npd(cls("\"")), g["Char"]))),
+                           cls("\""), g["Spacing"]));
+    g["Literal"] <= lit_ope;
+    g["LiteralD"] <= lit_ope;
+
+    g["LiteralI"] <=
+        cho(seq(cls("'"), tok(zom(seq(npd(cls("'")), g["Char"]))), lit("'i"),
+                g["Spacing"]),
+            seq(cls("\""), tok(zom(seq(npd(cls("\"")), g["Char"]))), lit("\"i"),
+                g["Spacing"]));
+
+    // NOTE: The original Brian Ford's paper uses 'zom' instead of 'oom'.
+    g["Class"] <= seq(chr('['), npd(chr('^')),
+                      tok(oom(seq(npd(chr(']')), g["Range"]))), chr(']'),
+                      g["Spacing"]);
+    g["NegatedClass"] <= seq(lit("[^"),
+                             tok(oom(seq(npd(chr(']')), g["Range"]))), chr(']'),
+                             g["Spacing"]);
+
+    g["Range"] <= cho(seq(g["Char"], chr('-'), g["Char"]), g["Char"]);
+    g["Char"] <= cho(seq(chr('\\'), cls("nrt'\"[]\\^")),
+                     seq(chr('\\'), cls("0-3"), cls("0-7"), cls("0-7")),
+                     seq(chr('\\'), cls("0-7"), opt(cls("0-7"))),
+                     seq(lit("\\x"), cls("0-9a-fA-F"), opt(cls("0-9a-fA-F"))),
+                     seq(lit("\\u"), cls("0-9a-fA-F"), cls("0-9a-fA-F"),
+                         cls("0-9a-fA-F"), cls("0-9a-fA-F")),
+                     seq(npd(chr('\\')), dot()));
+
+    g["Repetition"] <=
+        seq(g["BeginBlacket"], g["RepetitionRange"], g["EndBlacket"]);
+    g["RepetitionRange"] <= cho(seq(g["Number"], g["COMMA"], g["Number"]),
+                                seq(g["Number"], g["COMMA"]), g["Number"],
+                                seq(g["COMMA"], g["Number"]));
+    g["Number"] <= seq(oom(cls("0-9")), g["Spacing"]);
+
+    g["LEFTARROW"] <=
+        seq(cho(lit("<-"), lit(reinterpret_cast<const char *>(u8""))),
+            g["Spacing"]);
+    ~g["SLASH"] <= seq(chr('/'), g["Spacing"]);
+    ~g["PIPE"] <= seq(chr('|'), g["Spacing"]);
+    g["AND"] <= seq(chr('&'), g["Spacing"]);
+    g["NOT"] <= seq(chr('!'), g["Spacing"]);
+    g["QUESTION"] <= seq(chr('?'), g["Spacing"]);
+    g["STAR"] <= seq(chr('*'), g["Spacing"]);
+    g["PLUS"] <= seq(chr('+'), g["Spacing"]);
+    ~g["OPEN"] <= seq(chr('('), g["Spacing"]);
+    ~g["CLOSE"] <= seq(chr(')'), g["Spacing"]);
+    g["DOT"] <= seq(chr('.'), g["Spacing"]);
+
+    ~g["Spacing"] <= zom(cho(g["Space"], g["Comment"]));
+    g["Comment"] <=
+        seq(chr('#'), zom(seq(npd(g["EndOfLine"]), dot())), g["EndOfLine"]);
+    g["Space"] <= cho(chr(' '), chr('\t'), g["EndOfLine"]);
+    g["EndOfLine"] <= cho(lit("\r\n"), chr('\n'), chr('\r'));
+    g["EndOfFile"] <= npd(dot());
+
+    ~g["BeginTok"] <= seq(chr('<'), g["Spacing"]);
+    ~g["EndTok"] <= seq(chr('>'), g["Spacing"]);
+
+    ~g["BeginCapScope"] <= seq(chr('$'), chr('('), g["Spacing"]);
+    ~g["EndCapScope"] <= seq(chr(')'), g["Spacing"]);
+
+    g["BeginCap"] <= seq(chr('$'), tok(g["IdentCont"]), chr('<'), g["Spacing"]);
+    ~g["EndCap"] <= seq(chr('>'), g["Spacing"]);
+
+    g["BackRef"] <= seq(chr('$'), tok(g["IdentCont"]), g["Spacing"]);
+
+    g["IGNORE"] <= chr('~');
+
+    g["Ignore"] <= opt(g["IGNORE"]);
+    g["Parameters"] <= seq(g["OPEN"], g["Identifier"],
+                           zom(seq(g["COMMA"], g["Identifier"])), g["CLOSE"]);
+    g["Arguments"] <= seq(g["OPEN"], g["Expression"],
+                          zom(seq(g["COMMA"], g["Expression"])), g["CLOSE"]);
+    ~g["COMMA"] <= seq(chr(','), g["Spacing"]);
+
+    // Instruction grammars
+    g["Instruction"] <=
+        seq(g["BeginBlacket"], cho(g["PrecedenceClimbing"]), g["EndBlacket"]);
+
+    ~g["SpacesZom"] <= zom(g["Space"]);
+    ~g["SpacesOom"] <= oom(g["Space"]);
+    ~g["BeginBlacket"] <= seq(chr('{'), g["Spacing"]);
+    ~g["EndBlacket"] <= seq(chr('}'), g["Spacing"]);
+
+    // PrecedenceClimbing instruction
+    g["PrecedenceClimbing"] <=
+        seq(lit("precedence"), g["SpacesZom"], g["PrecedenceInfo"],
+            zom(seq(g["SpacesOom"], g["PrecedenceInfo"])), g["SpacesZom"]);
+    g["PrecedenceInfo"] <=
+        seq(g["PrecedenceAssoc"],
+            oom(seq(ign(g["SpacesOom"]), g["PrecedenceOpe"])));
+    g["PrecedenceOpe"] <=
+        tok(oom(
+            seq(npd(cho(g["PrecedenceAssoc"], g["Space"], chr('}'))), dot())));
+    g["PrecedenceAssoc"] <= cls("LR");
+
+    // Set definition names
+    for (auto &x : g) {
+      x.second.name = x.first;
+    }
+  }
+
+  void setup_actions() {
+    g["Definition"] = [&](const SemanticValues &sv, any &dt) {
+      Data &data = *any_cast<Data *>(dt);
+
+      auto is_macro = sv.choice() == 0;
+      auto ignore = any_cast<bool>(sv[0]);
+      auto name = any_cast<std::string>(sv[1]);
+
+      std::vector<std::string> params;
+      std::shared_ptr<Ope> ope;
+      if (is_macro) {
+        params = any_cast<std::vector<std::string>>(sv[2]);
+        ope = any_cast<std::shared_ptr<Ope>>(sv[4]);
+        if (sv.size() == 6) {
+          data.instructions[name] = any_cast<Instruction>(sv[5]);
+        }
+      } else {
+        ope = any_cast<std::shared_ptr<Ope>>(sv[3]);
+        if (sv.size() == 5) {
+          data.instructions[name] = any_cast<Instruction>(sv[4]);
+        }
+      }
+
+      auto &grammar = *data.grammar;
+      if (!grammar.count(name)) {
+        auto &rule = grammar[name];
+        rule <= ope;
+        rule.name = name;
+        rule.s_ = sv.c_str();
+        rule.ignoreSemanticValue = ignore;
+        rule.is_macro = is_macro;
+        rule.params = params;
+
+        if (data.start.empty()) {
+          data.start = name;
+          data.start_pos = sv.c_str();
+        }
+      } else {
+        data.duplicates.emplace_back(name, sv.c_str());
+      }
+    };
+
+    g["Expression"] = [&](const SemanticValues &sv) {
+      if (sv.size() == 1) {
+        return any_cast<std::shared_ptr<Ope>>(sv[0]);
+      } else {
+        std::vector<std::shared_ptr<Ope>> opes;
+        for (auto i = 0u; i < sv.size(); i++) {
+          opes.emplace_back(any_cast<std::shared_ptr<Ope>>(sv[i]));
+        }
+        const std::shared_ptr<Ope> ope =
+            std::make_shared<PrioritizedChoice>(opes);
+        return ope;
+      }
+    };
+
+    g["Sequence"] = [&](const SemanticValues &sv) {
+      if (sv.size() == 1) {
+        return any_cast<std::shared_ptr<Ope>>(sv[0]);
+      } else {
+        std::vector<std::shared_ptr<Ope>> opes;
+        for (const auto &x : sv) {
+          opes.emplace_back(any_cast<std::shared_ptr<Ope>>(x));
+        }
+        const std::shared_ptr<Ope> ope = std::make_shared<Sequence>(opes);
+        return ope;
+      }
+    };
+
+    g["Prefix"] = [&](const SemanticValues &sv) {
+      std::shared_ptr<Ope> ope;
+      if (sv.size() == 1) {
+        ope = any_cast<std::shared_ptr<Ope>>(sv[0]);
+      } else {
+        assert(sv.size() == 2);
+        auto tok = any_cast<char>(sv[0]);
+        ope = any_cast<std::shared_ptr<Ope>>(sv[1]);
+        if (tok == '&') {
+          ope = apd(ope);
+        } else { // '!'
+          ope = npd(ope);
+        }
+      }
+      return ope;
+    };
+
+    struct Loop {
+      enum class Type { opt = 0, zom, oom, rep };
+      Type type;
+      std::pair<size_t, size_t> range;
+    };
+
+    g["Suffix"] = [&](const SemanticValues &sv) {
+      auto ope = any_cast<std::shared_ptr<Ope>>(sv[0]);
+      if (sv.size() == 1) {
+        return ope;
+      } else {
+        assert(sv.size() == 2);
+        auto loop = any_cast<Loop>(sv[1]);
+        switch (loop.type) {
+        case Loop::Type::opt: return opt(ope);
+        case Loop::Type::zom: return zom(ope);
+        case Loop::Type::oom: return oom(ope);
+        default: // Regex-like repetition
+          return rep(ope, loop.range.first, loop.range.second);
+        }
+      }
+    };
+
+    g["Loop"] = [&](const SemanticValues &sv) {
+      switch (sv.choice()) {
+      case 0: // Option
+        return Loop{Loop::Type::opt, std::pair<size_t, size_t>()};
+      case 1: // Zero or More
+        return Loop{Loop::Type::zom, std::pair<size_t, size_t>()};
+      case 2: // One or More
+        return Loop{Loop::Type::oom, std::pair<size_t, size_t>()};
+      default: // Regex-like repetition
+        return Loop{Loop::Type::rep,
+                    any_cast<std::pair<size_t, size_t>>(sv[0])};
+      }
+    };
+
+    g["RepetitionRange"] = [&](const SemanticValues &sv) {
+      switch (sv.choice()) {
+      case 0: { // Number COMMA Number
+        auto min = any_cast<size_t>(sv[0]);
+        auto max = any_cast<size_t>(sv[1]);
+        return std::make_pair(min, max);
+      }
+      case 1: // Number COMMA
+        return std::make_pair(any_cast<size_t>(sv[0]),
+                              std::numeric_limits<size_t>::max());
+      case 2: { // Number
+        auto n = any_cast<size_t>(sv[0]);
+        return std::make_pair(n, n);
+      }
+      default: // COMMA Number
+        return std::make_pair(std::numeric_limits<size_t>::min(),
+                              any_cast<size_t>(sv[0]));
+      }
+    };
+    g["Number"] = [&](const SemanticValues &sv) {
+      std::stringstream ss(sv.str());
+      size_t n;
+      ss >> n;
+      return n;
+    };
+
+    g["Primary"] = [&](const SemanticValues &sv, any &dt) {
+      Data &data = *any_cast<Data *>(dt);
+
+      switch (sv.choice()) {
+      case 0:   // Macro Reference
+      case 1: { // Reference
+        auto is_macro = sv.choice() == 0;
+        auto ignore = any_cast<bool>(sv[0]);
+        const auto &ident = any_cast<std::string>(sv[1]);
+
+        std::vector<std::shared_ptr<Ope>> args;
+        if (is_macro) {
+          args = any_cast<std::vector<std::shared_ptr<Ope>>>(sv[2]);
+        }
+
+        std::shared_ptr<Ope> ope =
+            ref(*data.grammar, ident, sv.c_str(), is_macro, args);
+
+        if (ignore) {
+          return ign(ope);
+        } else {
+          return ope;
+        }
+      }
+      case 2: { // (Expression)
+        return any_cast<std::shared_ptr<Ope>>(sv[0]);
+      }
+      case 3: { // TokenBoundary
+        return tok(any_cast<std::shared_ptr<Ope>>(sv[0]));
+      }
+      case 4: { // CaptureScope
+        return csc(any_cast<std::shared_ptr<Ope>>(sv[0]));
+      }
+      case 5: { // Capture
+        const auto &name = any_cast<std::string>(sv[0]);
+        auto ope = any_cast<std::shared_ptr<Ope>>(sv[1]);
+        return cap(ope, [name](const char *a_s, size_t a_n, Context &c) {
+          auto &cs = c.capture_scope_stack[c.capture_scope_stack_size - 1];
+          cs[name] = std::string(a_s, a_n);
+        });
+      }
+      default: {
+        return any_cast<std::shared_ptr<Ope>>(sv[0]);
+      }
+      }
+    };
+
+    g["IdentCont"] = [](const SemanticValues &sv) {
+      return std::string(sv.c_str(), sv.length());
+    };
+
+    g["Dictionary"] = [](const SemanticValues &sv) {
+      auto items = sv.transform<std::string>();
+      return dic(items);
+    };
+
+    g["Literal"] = [](const SemanticValues &sv) {
+      const auto &tok = sv.tokens.front();
+      return lit(resolve_escape_sequence(tok.first, tok.second));
+    };
+    g["LiteralI"] = [](const SemanticValues &sv) {
+      const auto &tok = sv.tokens.front();
+      return liti(resolve_escape_sequence(tok.first, tok.second));
+    };
+    g["LiteralD"] = [](const SemanticValues &sv) {
+      auto &tok = sv.tokens.front();
+      return resolve_escape_sequence(tok.first, tok.second);
+    };
+
+    g["Class"] = [](const SemanticValues &sv) {
+      auto ranges = sv.transform<std::pair<char32_t, char32_t>>();
+      return cls(ranges);
+    };
+    g["NegatedClass"] = [](const SemanticValues &sv) {
+      auto ranges = sv.transform<std::pair<char32_t, char32_t>>();
+      return ncls(ranges);
+    };
+    g["Range"] = [](const SemanticValues &sv) {
+      switch (sv.choice()) {
+      case 0: {
+        auto s1 = any_cast<std::string>(sv[0]);
+        auto s2 = any_cast<std::string>(sv[1]);
+        auto cp1 = decode_codepoint(s1.c_str(), s1.length());
+        auto cp2 = decode_codepoint(s2.c_str(), s2.length());
+        return std::make_pair(cp1, cp2);
+      }
+      case 1: {
+        auto s = any_cast<std::string>(sv[0]);
+        auto cp = decode_codepoint(s.c_str(), s.length());
+        return std::make_pair(cp, cp);
+      }
+      }
+      return std::make_pair<char32_t, char32_t>(0, 0);
+    };
+    g["Char"] = [](const SemanticValues &sv) {
+      return resolve_escape_sequence(sv.c_str(), sv.length());
+    };
+
+    g["AND"] = [](const SemanticValues &sv) { return *sv.c_str(); };
+    g["NOT"] = [](const SemanticValues &sv) { return *sv.c_str(); };
+    g["QUESTION"] = [](const SemanticValues &sv) { return *sv.c_str(); };
+    g["STAR"] = [](const SemanticValues &sv) { return *sv.c_str(); };
+    g["PLUS"] = [](const SemanticValues &sv) { return *sv.c_str(); };
+
+    g["DOT"] = [](const SemanticValues & /*sv*/) { return dot(); };
+
+    g["BeginCap"] = [](const SemanticValues &sv) { return sv.token(); };
+
+    g["BackRef"] = [&](const SemanticValues &sv) { return bkr(sv.token()); };
+
+    g["Ignore"] = [](const SemanticValues &sv) { return sv.size() > 0; };
+
+    g["Parameters"] = [](const SemanticValues &sv) {
+      return sv.transform<std::string>();
+    };
+
+    g["Arguments"] = [](const SemanticValues &sv) {
+      return sv.transform<std::shared_ptr<Ope>>();
+    };
+
+    g["PrecedenceClimbing"] = [](const SemanticValues &sv) {
+      PrecedenceClimbing::BinOpeInfo binOpeInfo;
+      size_t level = 1;
+      for (auto v : sv) {
+        auto tokens = any_cast<std::vector<std::string>>(v);
+        auto assoc = tokens[0][0];
+        for (size_t i = 1; i < tokens.size(); i++) {
+          const auto &tok = tokens[i];
+          binOpeInfo[tok] = std::make_pair(level, assoc);
+        }
+        level++;
+      }
+      Instruction instruction;
+      instruction.type = "precedence";
+      instruction.data = binOpeInfo;
+      return instruction;
+    };
+    g["PrecedenceInfo"] = [](const SemanticValues &sv) {
+      return sv.transform<std::string>();
+    };
+    g["PrecedenceOpe"] = [](const SemanticValues &sv) { return sv.token(); };
+    g["PrecedenceAssoc"] = [](const SemanticValues &sv) { return sv.token(); };
+  }
+
+  bool apply_precedence_instruction(Definition &rule,
+                                    const PrecedenceClimbing::BinOpeInfo &info,
+                                    const char *s, Log log) {
+    try {
+      auto &seq = dynamic_cast<Sequence &>(*rule.get_core_operator());
+      auto atom = seq.opes_[0];
+      auto &rep = dynamic_cast<Repetition &>(*seq.opes_[1]);
+      auto &seq1 = dynamic_cast<Sequence &>(*rep.ope_);
+      auto binop = seq1.opes_[0];
+      auto atom1 = seq1.opes_[1];
+
+      auto atom_name = dynamic_cast<Reference &>(*atom).name_;
+      auto binop_name = dynamic_cast<Reference &>(*binop).name_;
+      auto atom1_name = dynamic_cast<Reference &>(*atom1).name_;
+
+      if (!rep.is_zom() || atom_name != atom1_name || atom_name == binop_name) {
+        if (log) {
+          auto line = line_info(s, rule.s_);
+          log(line.first, line.second,
+              "'precedence' instruction cannt be applied to '" + rule.name +
+                  "'.");
+        }
+        return false;
+      }
+
+      rule.holder_->ope_ = pre(atom, binop, info, rule);
+      rule.disable_action = true;
+    } catch (...) {
+      if (log) {
+        auto line = line_info(s, rule.s_);
+        log(line.first, line.second,
+            "'precedence' instruction cannt be applied to '" + rule.name +
+                "'.");
+      }
+      return false;
+    }
+    return true;
+  }
+
+  std::shared_ptr<Grammar> perform_core(const char *s, size_t n,
+                                        const Rules &rules, std::string &start,
+                                        Log log) {
+    Data data;
+    any dt = &data;
+    auto r = g["Grammar"].parse(s, n, dt);
+
+    if (!r.ret) {
+      if (log) {
+        if (r.message_pos) {
+          auto line = line_info(s, r.message_pos);
+          log(line.first, line.second, r.message);
+        } else {
+          auto line = line_info(s, r.error_pos);
+          log(line.first, line.second, "syntax error");
+        }
+      }
+      return nullptr;
+    }
+
+    auto &grammar = *data.grammar;
+
+    // User provided rules
+    for (const auto &x : rules) {
+      auto name = x.first;
+      bool ignore = false;
+      if (!name.empty() && name[0] == '~') {
+        ignore = true;
+        name.erase(0, 1);
+      }
+      if (!name.empty()) {
+        auto &rule = grammar[name];
+        rule <= x.second;
+        rule.name = name;
+        rule.ignoreSemanticValue = ignore;
+      }
+    }
+
+    // Check duplicated definitions
+    bool ret = data.duplicates.empty();
+
+    for (const auto &x : data.duplicates) {
+      if (log) {
+        const auto &name = x.first;
+        auto ptr = x.second;
+        auto line = line_info(s, ptr);
+        log(line.first, line.second, "'" + name + "' is already defined.");
+      }
+    }
+
+    // Check if the start rule has ignore operator
+    {
+      auto &rule = grammar[data.start];
+      if (rule.ignoreSemanticValue) {
+        if (log) {
+          auto line = line_info(s, rule.s_);
+          log(line.first, line.second,
+              "Ignore operator cannot be applied to '" + rule.name + "'.");
+        }
+        ret = false;
+      }
+    }
+
+    if (!ret) { return nullptr; }
+
+    // Check missing definitions
+    for (auto &x : grammar) {
+      auto &rule = x.second;
+
+      ReferenceChecker vis(*data.grammar, rule.params);
+      rule.accept(vis);
+      for (const auto &y : vis.error_s) {
+        const auto &name = y.first;
+        const auto ptr = y.second;
+        if (log) {
+          auto line = line_info(s, ptr);
+          log(line.first, line.second, vis.error_message[name]);
+        }
+        ret = false;
+      }
+    }
+
+    if (!ret) { return nullptr; }
+
+    // Link references
+    for (auto &x : grammar) {
+      auto &rule = x.second;
+      LinkReferences vis(*data.grammar, rule.params);
+      rule.accept(vis);
+    }
+
+    // Check left recursion
+    ret = true;
+
+    for (auto &x : grammar) {
+      const auto &name = x.first;
+      auto &rule = x.second;
+
+      DetectLeftRecursion vis(name);
+      rule.accept(vis);
+      if (vis.error_s) {
+        if (log) {
+          auto line = line_info(s, vis.error_s);
+          log(line.first, line.second, "'" + name + "' is left recursive.");
+        }
+        ret = false;
+      }
+    }
+
+    if (!ret) { return nullptr; }
+
+    // Set root definition
+    auto &start_rule = (*data.grammar)[data.start];
+
+    // Check infinite loop
+    {
+      DetectInfiniteLoop vis(data.start_pos, data.start);
+      start_rule.accept(vis);
+      if (vis.has_error) {
+        if (log) {
+          auto line = line_info(s, vis.error_s);
+          log(line.first, line.second,
+              "infinite loop is detected in '" + vis.error_name + "'.");
+        }
+        return nullptr;
+      }
+    }
+
+    // Automatic whitespace skipping
+    if (grammar.count(WHITESPACE_DEFINITION_NAME)) {
+      for (auto &x : grammar) {
+        auto &rule = x.second;
+        auto ope = rule.get_core_operator();
+        if (IsLiteralToken::check(*ope)) { rule <= tok(ope); }
+      }
+
+      start_rule.whitespaceOpe =
+          wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());
+    }
+
+    // Word expression
+    if (grammar.count(WORD_DEFINITION_NAME)) {
+      start_rule.wordOpe =
+          (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();
+    }
+
+    // Apply instructions
+    for (const auto &item : data.instructions) {
+      const auto &name = item.first;
+      const auto &instruction = item.second;
+      auto &rule = grammar[name];
+
+      if (instruction.type == "precedence") {
+        const auto &info =
+            any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data);
+
+        if (!apply_precedence_instruction(rule, info, s, log)) {
+          return nullptr;
+        }
+      }
+    }
+
+    // Set root definition
+    start = data.start;
+
+    return data.grammar;
+  }
+
+  Grammar g;
+};
+
+/*-----------------------------------------------------------------------------
+ *  AST
+ *---------------------------------------------------------------------------*/
+
+template <typename Annotation> struct AstBase : public Annotation {
+  AstBase(const char *a_path, size_t a_line, size_t a_column,
+          const char *a_name,
+          const std::vector<std::shared_ptr<AstBase>> &a_nodes,
+          size_t a_position = 0, size_t a_length = 0, size_t a_choice_count = 0,
+          size_t a_choice = 0)
+      : path(a_path ? a_path : ""), line(a_line), column(a_column),
+        name(a_name), position(a_position), length(a_length),
+        choice_count(a_choice_count), choice(a_choice), original_name(a_name),
+        original_choice_count(a_choice_count), original_choice(a_choice),
+        tag(str2tag(a_name)), original_tag(tag), is_token(false),
+        nodes(a_nodes) {}
+
+  AstBase(const char *a_path, size_t a_line, size_t a_column,
+          const char *a_name, const std::string &a_token, size_t a_position = 0,
+          size_t a_length = 0, size_t a_choice_count = 0, size_t a_choice = 0)
+      : path(a_path ? a_path : ""), line(a_line), column(a_column),
+        name(a_name), position(a_position), length(a_length),
+        choice_count(a_choice_count), choice(a_choice), original_name(a_name),
+        original_choice_count(a_choice_count), original_choice(a_choice),
+        tag(str2tag(a_name)), original_tag(tag), is_token(true),
+        token(a_token) {}
+
+  AstBase(const AstBase &ast, const char *a_original_name,
+          size_t a_position = 0, size_t a_length = 0,
+          size_t a_original_choice_count = 0, size_t a_original_choise = 0)
+      : path(ast.path), line(ast.line), column(ast.column), name(ast.name),
+        position(a_position), length(a_length), choice_count(ast.choice_count),
+        choice(ast.choice), original_name(a_original_name),
+        original_choice_count(a_original_choice_count),
+        original_choice(a_original_choise), tag(ast.tag),
+        original_tag(str2tag(a_original_name)), is_token(ast.is_token),
+        token(ast.token), nodes(ast.nodes), parent(ast.parent) {}
+
+  const std::string path;
+  const size_t line = 1;
+  const size_t column = 1;
+
+  const std::string name;
+  size_t position;
+  size_t length;
+  const size_t choice_count;
+  const size_t choice;
+  const std::string original_name;
+  const size_t original_choice_count;
+  const size_t original_choice;
+  const unsigned int tag;
+  const unsigned int original_tag;
+
+  const bool is_token;
+  const std::string token;
+
+  std::vector<std::shared_ptr<AstBase<Annotation>>> nodes;
+  std::weak_ptr<AstBase<Annotation>> parent;
+};
+
+template <typename T>
+void ast_to_s_core(const std::shared_ptr<T> &ptr, std::string &s, int level,
+                   std::function<std::string(const T &ast, int level)> fn) {
+  const auto &ast = *ptr;
+  for (auto i = 0; i < level; i++) {
+    s += "  ";
+  }
+  auto name = ast.original_name;
+  if (ast.original_choice_count > 0) {
+    name += "/" + std::to_string(ast.original_choice);
+  }
+  if (ast.name != ast.original_name) { name += "[" + ast.name + "]"; }
+  if (ast.is_token) {
+    s += "- " + name + " (" + ast.token + ")\n";
+  } else {
+    s += "+ " + name + "\n";
+  }
+  if (fn) { s += fn(ast, level + 1); }
+  for (auto node : ast.nodes) {
+    ast_to_s_core(node, s, level + 1, fn);
+  }
+}
+
+template <typename T>
+std::string
+ast_to_s(const std::shared_ptr<T> &ptr,
+         std::function<std::string(const T &ast, int level)> fn = nullptr) {
+  std::string s;
+  ast_to_s_core(ptr, s, 0, fn);
+  return s;
+}
+
+struct AstOptimizer {
+  AstOptimizer(bool mode, const std::vector<std::string> &rules = {})
+      : mode_(mode), rules_(rules) {}
+
+  template <typename T>
+  std::shared_ptr<T> optimize(std::shared_ptr<T> original,
+                              std::shared_ptr<T> parent = nullptr) {
+    auto found =
+        std::find(rules_.begin(), rules_.end(), original->name) != rules_.end();
+    bool opt = mode_ ? !found : found;
+
+    if (opt && original->nodes.size() == 1) {
+      auto child = optimize(original->nodes[0], parent);
+      return std::make_shared<T>(*child, original->name.c_str(),
+                                 original->choice_count, original->position,
+                                 original->length, original->choice);
+    }
+
+    auto ast = std::make_shared<T>(*original);
+    ast->parent = parent;
+    ast->nodes.clear();
+    for (auto node : original->nodes) {
+      auto child = optimize(node, ast);
+      ast->nodes.push_back(child);
+    }
+    return ast;
+  }
+
+private:
+  const bool mode_;
+  const std::vector<std::string> rules_;
+};
+
+struct EmptyType {};
+typedef AstBase<EmptyType> Ast;
+
+template <typename T = Ast> void add_ast_action(Definition &rule) {
+  rule.action = [&](const SemanticValues &sv) {
+    auto line = sv.line_info();
+
+    if (rule.is_token()) {
+      return std::make_shared<T>(sv.path, line.first, line.second,
+                                 rule.name.c_str(), sv.token(),
+                                 std::distance(sv.ss, sv.c_str()), sv.length(),
+                                 sv.choice_count(), sv.choice());
+    }
+
+    auto ast = std::make_shared<T>(
+        sv.path, line.first, line.second, rule.name.c_str(),
+        sv.transform<std::shared_ptr<T>>(), std::distance(sv.ss, sv.c_str()),
+        sv.length(), sv.choice_count(), sv.choice());
+
+    for (auto node : ast->nodes) {
+      node->parent = ast;
+    }
+    return ast;
+  };
+}
+
+#define PEG_EXPAND(...) __VA_ARGS__
+#define PEG_CONCAT(a, b) a##b
+#define PEG_CONCAT2(a, b) PEG_CONCAT(a, b)
+
+#define PEG_PICK(                                                              \
+    a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, \
+    a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, \
+    a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, \
+    a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, \
+    a62, a63, a64, a65, a66, a67, a68, a69, a70, a71, a72, a73, a74, a75, a76, \
+    a77, a78, a79, a80, a81, a82, a83, a84, a85, a86, a87, a88, a89, a90, a91, \
+    a92, a93, a94, a95, a96, a97, a98, a99, a100, ...)                         \
+  a100
+
+#define PEG_COUNT(...)                                                         \
+  PEG_EXPAND(PEG_PICK(                                                         \
+      __VA_ARGS__, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87,    \
+      86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69,  \
+      68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51,  \
+      50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33,  \
+      32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15,  \
+      14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0))
+
+#define PEG_DEF_1(r)                                                           \
+  peg::Definition r;                                                           \
+  r.name = #r;                                                                 \
+  peg::add_ast_action(r);
+
+#define PEG_DEF_2(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_1(__VA_ARGS__))
+#define PEG_DEF_3(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_2(__VA_ARGS__))
+#define PEG_DEF_4(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_3(__VA_ARGS__))
+#define PEG_DEF_5(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_4(__VA_ARGS__))
+#define PEG_DEF_6(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_5(__VA_ARGS__))
+#define PEG_DEF_7(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_6(__VA_ARGS__))
+#define PEG_DEF_8(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_7(__VA_ARGS__))
+#define PEG_DEF_9(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_8(__VA_ARGS__))
+#define PEG_DEF_10(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_9(__VA_ARGS__))
+#define PEG_DEF_11(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_10(__VA_ARGS__))
+#define PEG_DEF_12(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_11(__VA_ARGS__))
+#define PEG_DEF_13(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_12(__VA_ARGS__))
+#define PEG_DEF_14(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_13(__VA_ARGS__))
+#define PEG_DEF_15(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_14(__VA_ARGS__))
+#define PEG_DEF_16(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_15(__VA_ARGS__))
+#define PEG_DEF_17(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_16(__VA_ARGS__))
+#define PEG_DEF_18(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_17(__VA_ARGS__))
+#define PEG_DEF_19(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_18(__VA_ARGS__))
+#define PEG_DEF_20(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_19(__VA_ARGS__))
+#define PEG_DEF_21(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_20(__VA_ARGS__))
+#define PEG_DEF_22(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_21(__VA_ARGS__))
+#define PEG_DEF_23(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_22(__VA_ARGS__))
+#define PEG_DEF_24(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_23(__VA_ARGS__))
+#define PEG_DEF_25(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_24(__VA_ARGS__))
+#define PEG_DEF_26(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_25(__VA_ARGS__))
+#define PEG_DEF_27(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_26(__VA_ARGS__))
+#define PEG_DEF_28(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_27(__VA_ARGS__))
+#define PEG_DEF_29(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_28(__VA_ARGS__))
+#define PEG_DEF_30(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_29(__VA_ARGS__))
+#define PEG_DEF_31(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_30(__VA_ARGS__))
+#define PEG_DEF_32(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_31(__VA_ARGS__))
+#define PEG_DEF_33(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_32(__VA_ARGS__))
+#define PEG_DEF_34(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_33(__VA_ARGS__))
+#define PEG_DEF_35(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_34(__VA_ARGS__))
+#define PEG_DEF_36(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_35(__VA_ARGS__))
+#define PEG_DEF_37(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_36(__VA_ARGS__))
+#define PEG_DEF_38(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_37(__VA_ARGS__))
+#define PEG_DEF_39(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_38(__VA_ARGS__))
+#define PEG_DEF_40(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_39(__VA_ARGS__))
+#define PEG_DEF_41(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_40(__VA_ARGS__))
+#define PEG_DEF_42(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_41(__VA_ARGS__))
+#define PEG_DEF_43(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_42(__VA_ARGS__))
+#define PEG_DEF_44(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_43(__VA_ARGS__))
+#define PEG_DEF_45(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_44(__VA_ARGS__))
+#define PEG_DEF_46(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_45(__VA_ARGS__))
+#define PEG_DEF_47(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_46(__VA_ARGS__))
+#define PEG_DEF_48(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_47(__VA_ARGS__))
+#define PEG_DEF_49(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_48(__VA_ARGS__))
+#define PEG_DEF_50(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_49(__VA_ARGS__))
+#define PEG_DEF_51(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_50(__VA_ARGS__))
+#define PEG_DEF_52(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_51(__VA_ARGS__))
+#define PEG_DEF_53(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_52(__VA_ARGS__))
+#define PEG_DEF_54(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_53(__VA_ARGS__))
+#define PEG_DEF_55(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_54(__VA_ARGS__))
+#define PEG_DEF_56(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_55(__VA_ARGS__))
+#define PEG_DEF_57(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_56(__VA_ARGS__))
+#define PEG_DEF_58(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_57(__VA_ARGS__))
+#define PEG_DEF_59(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_58(__VA_ARGS__))
+#define PEG_DEF_60(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_59(__VA_ARGS__))
+#define PEG_DEF_61(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_60(__VA_ARGS__))
+#define PEG_DEF_62(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_61(__VA_ARGS__))
+#define PEG_DEF_63(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_62(__VA_ARGS__))
+#define PEG_DEF_64(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_63(__VA_ARGS__))
+#define PEG_DEF_65(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_64(__VA_ARGS__))
+#define PEG_DEF_66(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_65(__VA_ARGS__))
+#define PEG_DEF_67(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_66(__VA_ARGS__))
+#define PEG_DEF_68(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_67(__VA_ARGS__))
+#define PEG_DEF_69(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_68(__VA_ARGS__))
+#define PEG_DEF_70(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_69(__VA_ARGS__))
+#define PEG_DEF_71(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_70(__VA_ARGS__))
+#define PEG_DEF_72(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_71(__VA_ARGS__))
+#define PEG_DEF_73(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_72(__VA_ARGS__))
+#define PEG_DEF_74(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_73(__VA_ARGS__))
+#define PEG_DEF_75(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_74(__VA_ARGS__))
+#define PEG_DEF_76(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_75(__VA_ARGS__))
+#define PEG_DEF_77(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_76(__VA_ARGS__))
+#define PEG_DEF_78(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_77(__VA_ARGS__))
+#define PEG_DEF_79(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_78(__VA_ARGS__))
+#define PEG_DEF_80(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_79(__VA_ARGS__))
+#define PEG_DEF_81(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_80(__VA_ARGS__))
+#define PEG_DEF_82(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_81(__VA_ARGS__))
+#define PEG_DEF_83(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_82(__VA_ARGS__))
+#define PEG_DEF_84(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_83(__VA_ARGS__))
+#define PEG_DEF_85(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_84(__VA_ARGS__))
+#define PEG_DEF_86(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_85(__VA_ARGS__))
+#define PEG_DEF_87(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_86(__VA_ARGS__))
+#define PEG_DEF_88(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_87(__VA_ARGS__))
+#define PEG_DEF_89(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_88(__VA_ARGS__))
+#define PEG_DEF_90(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_89(__VA_ARGS__))
+#define PEG_DEF_91(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_90(__VA_ARGS__))
+#define PEG_DEF_92(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_91(__VA_ARGS__))
+#define PEG_DEF_93(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_92(__VA_ARGS__))
+#define PEG_DEF_94(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_93(__VA_ARGS__))
+#define PEG_DEF_95(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_94(__VA_ARGS__))
+#define PEG_DEF_96(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_95(__VA_ARGS__))
+#define PEG_DEF_97(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_96(__VA_ARGS__))
+#define PEG_DEF_98(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_97(__VA_ARGS__))
+#define PEG_DEF_99(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_98(__VA_ARGS__))
+#define PEG_DEF_100(r1, ...) PEG_EXPAND(PEG_DEF_1(r1) PEG_DEF_99(__VA_ARGS__))
+
+#define AST_DEFINITIONS(...)                                                   \
+  PEG_EXPAND(PEG_CONCAT2(PEG_DEF_, PEG_COUNT(__VA_ARGS__))(__VA_ARGS__))
+
+/*-----------------------------------------------------------------------------
+ *  parser
+ *---------------------------------------------------------------------------*/
+
+class parser {
+public:
+  parser() = default;
+
+  parser(const char *s, size_t n, const Rules &rules) {
+    load_grammar(s, n, rules);
+  }
+
+  parser(const char *s, const Rules &rules) : parser(s, strlen(s), rules) {}
+
+  parser(const char *s, size_t n) : parser(s, n, Rules()) {}
+
+  parser(const char *s) : parser(s, strlen(s), Rules()) {}
+
+  operator bool() { return grammar_ != nullptr; }
+
+  bool load_grammar(const char *s, size_t n, const Rules &rules) {
+    grammar_ = ParserGenerator::parse(s, n, rules, start_, log);
+    return grammar_ != nullptr;
+  }
+
+  bool load_grammar(const char *s, size_t n) {
+    return load_grammar(s, n, Rules());
+  }
+
+  bool load_grammar(const char *s, const Rules &rules) {
+    auto n = strlen(s);
+    return load_grammar(s, n, rules);
+  }
+
+  bool load_grammar(const char *s) {
+    auto n = strlen(s);
+    return load_grammar(s, n);
+  }
+
+  bool parse_n(const char *s, size_t n, const char *path = nullptr) const {
+    if (grammar_ != nullptr) {
+      const auto &rule = (*grammar_)[start_];
+      auto r = rule.parse(s, n, path);
+      output_log(s, n, r);
+      return r.ret && r.len == n;
+    }
+    return false;
+  }
+
+  bool parse(const char *s, const char *path = nullptr) const {
+    auto n = strlen(s);
+    return parse_n(s, n, path);
+  }
+
+  bool parse_n(const char *s, size_t n, any &dt,
+               const char *path = nullptr) const {
+    if (grammar_ != nullptr) {
+      const auto &rule = (*grammar_)[start_];
+      auto r = rule.parse(s, n, dt, path);
+      output_log(s, n, r);
+      return r.ret && r.len == n;
+    }
+    return false;
+  }
+
+  bool parse(const char *s, any &dt, const char *path = nullptr) const {
+    auto n = strlen(s);
+    return parse_n(s, n, dt, path);
+  }
+
+  template <typename T>
+  bool parse_n(const char *s, size_t n, T &val,
+               const char *path = nullptr) const {
+    if (grammar_ != nullptr) {
+      const auto &rule = (*grammar_)[start_];
+      auto r = rule.parse_and_get_value(s, n, val, path);
+      output_log(s, n, r);
+      return r.ret && r.len == n;
+    }
+    return false;
+  }
+
+  template <typename T>
+  bool parse(const char *s, T &val, const char *path = nullptr) const {
+    auto n = strlen(s);
+    return parse_n(s, n, val, path);
+  }
+
+  template <typename T>
+  bool parse_n(const char *s, size_t n, any &dt, T &val,
+               const char *path = nullptr) const {
+    if (grammar_ != nullptr) {
+      const auto &rule = (*grammar_)[start_];
+      auto r = rule.parse_and_get_value(s, n, dt, val, path);
+      output_log(s, n, r);
+      return r.ret && r.len == n;
+    }
+    return false;
+  }
+
+  template <typename T>
+  bool parse(const char *s, any &dt, T &val,
+             const char * /*path*/ = nullptr) const {
+    auto n = strlen(s);
+    return parse_n(s, n, dt, val);
+  }
+
+  Definition &operator[](const char *s) { return (*grammar_)[s]; }
+
+  const Definition &operator[](const char *s) const { return (*grammar_)[s]; }
+
+  std::vector<std::string> get_rule_names() {
+    std::vector<std::string> rules;
+    rules.reserve(grammar_->size());
+    for (auto const &r : *grammar_) {
+      rules.emplace_back(r.first);
+    }
+    return rules;
+  }
+
+  void enable_packrat_parsing() {
+    if (grammar_ != nullptr) {
+      auto &rule = (*grammar_)[start_];
+      rule.enablePackratParsing = true;
+    }
+  }
+
+  template <typename T = Ast> parser &enable_ast() {
+    for (auto &x : *grammar_) {
+      auto &rule = x.second;
+      if (!rule.action) { add_ast_action<T>(rule); }
+    }
+    return *this;
+  }
+
+  void enable_trace(TracerEnter tracer_enter, TracerLeave tracer_leave) {
+    if (grammar_ != nullptr) {
+      auto &rule = (*grammar_)[start_];
+      rule.tracer_enter = tracer_enter;
+      rule.tracer_leave = tracer_leave;
+    }
+  }
+
+  Log log;
+
+private:
+  void output_log(const char *s, size_t n, const Definition::Result &r) const {
+    if (log) {
+      if (!r.ret) {
+        if (r.message_pos) {
+          auto line = line_info(s, r.message_pos);
+          log(line.first, line.second, r.message);
+        } else {
+          auto line = line_info(s, r.error_pos);
+          log(line.first, line.second, "syntax error");
+        }
+      } else if (r.len != n) {
+        auto line = line_info(s, s + r.len);
+        log(line.first, line.second, "syntax error");
+      }
+    }
+  }
+
+  std::shared_ptr<Grammar> grammar_;
+  std::string start_;
+};
+
+} // namespace peg
+
+#endif
+
+// vim: et ts=2 sw=2 cin cino={1s ff=unix
diff --git a/plugins/epan/generic/precomp.h b/plugins/epan/generic/precomp.h
new file mode 100644
index 00000000000..c71fa7728e3
--- /dev/null
+++ b/plugins/epan/generic/precomp.h
@@ -0,0 +1,6 @@
+
+#ifndef WIN32
+#ifdef _WIN32
+#define WIN32
+#endif
+#endif
diff --git a/plugins/epan/generic/scoped_copyable_ptr.h b/plugins/epan/generic/scoped_copyable_ptr.h
new file mode 100644
index 00000000000..f63f5610f3e
--- /dev/null
+++ b/plugins/epan/generic/scoped_copyable_ptr.h
@@ -0,0 +1,171 @@
+/*
+ * Copyright 2009-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef scoped_copyable_ptr_h
+#define scoped_copyable_ptr_h
+
+//*****************************************************************************
+// scoped_copyable_ptr mimics a built-in pointer except that
+//  it takes care of :
+// - deletion (destructor, operator=, reset ...)
+// - copy, assign = deep copy 
+//
+// This is NOT a shared pointer.
+//
+// Note: initial code from Boost (http://www.boost.org) scoped_ptr
+//       Boost scoped_ptr is NOT copyable
+// The reason for which Boost does NOT provide a copyable pointer is (I guess)
+//  that this kind of pointer is dangerous due to the slicing problem.
+//
+// And this version has been designed only for a little usage scope.
+//
+// Do not use <scoped_copyable_ptr object>.get() as parameter of
+//  a scoped_copyable_ptr method expecting a simple pointer.
+// -> no deep copy, 2 objects have the same pointer !!!
+//
+// So it must be used very carefully.
+//*****************************************************************************
+
+template<class T> class scoped_copyable_ptr
+{
+private:
+
+    T * ptr;
+
+    typedef scoped_copyable_ptr<T> this_type;
+
+    void operator==( scoped_copyable_ptr const& ) const;
+    void operator!=( scoped_copyable_ptr const& ) const;
+
+public:
+
+    typedef T element_type;
+
+    // Do not use <scoped_copyable_ptr object>.get() as parameter !!!
+    explicit scoped_copyable_ptr(T * p = nullptr): ptr(p) // never throws
+    {
+    }
+
+    // I do not use auto_ptr
+    // Not accepted by gcc 4.4.1
+#if 0
+    explicit scoped_copyable_ptr(std::auto_ptr<T> p): ptr(p.release()) // never throws
+    {
+    }
+#endif
+
+    explicit scoped_copyable_ptr(scoped_copyable_ptr const & rhs)
+        :ptr(nullptr)
+    {
+        if (rhs.ptr != nullptr)
+        {
+            ptr = new T(*rhs.ptr);
+        }
+    }
+
+    scoped_copyable_ptr & operator=(scoped_copyable_ptr const & rhs)
+    {
+        if (ptr != rhs.ptr)
+        {
+            delete  ptr;
+            ptr = new T(*rhs.ptr);
+        }
+        return  *this;
+    }
+#if 0
+    // Dangereux ?
+    scoped_copyable_ptr & operator=(T * p)
+    {
+        if (ptr != p)
+        {
+            delete  ptr;
+            ptr = p;
+        }
+        return  *this;
+    }
+#endif
+    ~scoped_copyable_ptr() // never throws
+    {
+        delete  ptr;
+    }
+
+    // Do not use <scoped_copyable_ptr object>.get() as parameter !!!
+    void reset(T * p = nullptr) // never throws
+    {
+        if (p != ptr)
+        {
+            delete  ptr;
+            ptr = p;
+        }
+    }
+
+    T & operator*() const // never throws
+    {
+        return *ptr;
+    }
+
+    T * operator->() const // never throws
+    {
+        return ptr;
+    }
+
+    T * get() const // never throws
+    {
+        return ptr;
+    }
+
+    bool operator! () const // never throws
+    {
+        return ptr == nullptr;
+    }
+
+    operator bool () const
+    {
+        return ptr != nullptr;
+    }
+
+    void swap(scoped_copyable_ptr & b) // never throws
+    {
+        T * tmp = b.ptr;
+        b.ptr = ptr;
+        ptr = tmp;
+    }
+
+    bool operator==(nullptr_t) const
+    {
+        return ptr == nullptr;
+    }
+    bool operator!=(nullptr_t) const
+    {
+        return ptr != nullptr;
+    }
+};
+
+template<class T> inline void swap(scoped_copyable_ptr<T> & a, scoped_copyable_ptr<T> & b) // never throws
+{
+    a.swap(b);
+}
+
+// get_pointer(p) is a generic way to say p.get()
+
+template<class T> inline T * get_pointer(scoped_copyable_ptr<T> const & p)
+{
+    return p.get();
+}
+
+#endif
diff --git a/plugins/epan/generic/shark_wsutil_aes.c b/plugins/epan/generic/shark_wsutil_aes.c
new file mode 100644
index 00000000000..7441ab74fd3
--- /dev/null
+++ b/plugins/epan/generic/shark_wsutil_aes.c
@@ -0,0 +1,1254 @@
+/**
+ * aes.c
+ *
+ * Copied from airpdcap_rijndael.c and broken out into its own file
+ *
+ * @version 3.0 (December 2000)
+ *
+ * Optimised ANSI C code for the Rijndael cipher (now AES)
+ *
+ * @author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be>
+ * @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be>
+ * @author Paulo Barreto <paulo.barreto@terra.com.br>
+ *
+ * This code is hereby placed in the public domain.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <glib.h>
+#include "shark_wsutil_aes.h"
+
+/******************************************************************************/
+
+/* Note: this code were copied from FreeBSD source code, RELENG 6,				*/
+/*		sys/crypto/rijndael/rijndael-alg-fst.c												*/
+
+/******************************************************************************/
+
+#define FULL_UNROLL
+
+#define SWAP(x) (_lrotl(x, 8) & 0x00ff00ff | _lrotr(x, 8) & 0xff00ff00)
+
+#define GETU32(pt) (((guint32)(pt)[0] << 24) ^ ((guint32)(pt)[1] << 16) ^ ((guint32)(pt)[2] <<  8) ^ ((guint32)(pt)[3]))
+
+#define PUTU32(ct, st) { (ct)[0] = (guint8)((st) >> 24); (ct)[1] = (guint8)((st) >> 16); (ct)[2] = (guint8)((st) >>  8); (ct)[3] = (guint8)(st); }
+
+static const guint32 Te0[256] = {
+	0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,
+	0xfff2f20dU, 0xd66b6bbdU, 0xde6f6fb1U, 0x91c5c554U,
+	0x60303050U, 0x02010103U, 0xce6767a9U, 0x562b2b7dU,
+	0xe7fefe19U, 0xb5d7d762U, 0x4dababe6U, 0xec76769aU,
+	0x8fcaca45U, 0x1f82829dU, 0x89c9c940U, 0xfa7d7d87U,
+	0xeffafa15U, 0xb25959ebU, 0x8e4747c9U, 0xfbf0f00bU,
+	0x41adadecU, 0xb3d4d467U, 0x5fa2a2fdU, 0x45afafeaU,
+	0x239c9cbfU, 0x53a4a4f7U, 0xe4727296U, 0x9bc0c05bU,
+	0x75b7b7c2U, 0xe1fdfd1cU, 0x3d9393aeU, 0x4c26266aU,
+	0x6c36365aU, 0x7e3f3f41U, 0xf5f7f702U, 0x83cccc4fU,
+	0x6834345cU, 0x51a5a5f4U, 0xd1e5e534U, 0xf9f1f108U,
+	0xe2717193U, 0xabd8d873U, 0x62313153U, 0x2a15153fU,
+	0x0804040cU, 0x95c7c752U, 0x46232365U, 0x9dc3c35eU,
+	0x30181828U, 0x379696a1U, 0x0a05050fU, 0x2f9a9ab5U,
+	0x0e070709U, 0x24121236U, 0x1b80809bU, 0xdfe2e23dU,
+	0xcdebeb26U, 0x4e272769U, 0x7fb2b2cdU, 0xea75759fU,
+	0x1209091bU, 0x1d83839eU, 0x582c2c74U, 0x341a1a2eU,
+	0x361b1b2dU, 0xdc6e6eb2U, 0xb45a5aeeU, 0x5ba0a0fbU,
+	0xa45252f6U, 0x763b3b4dU, 0xb7d6d661U, 0x7db3b3ceU,
+	0x5229297bU, 0xdde3e33eU, 0x5e2f2f71U, 0x13848497U,
+	0xa65353f5U, 0xb9d1d168U, 0x00000000U, 0xc1eded2cU,
+	0x40202060U, 0xe3fcfc1fU, 0x79b1b1c8U, 0xb65b5bedU,
+	0xd46a6abeU, 0x8dcbcb46U, 0x67bebed9U, 0x7239394bU,
+	0x944a4adeU, 0x984c4cd4U, 0xb05858e8U, 0x85cfcf4aU,
+	0xbbd0d06bU, 0xc5efef2aU, 0x4faaaae5U, 0xedfbfb16U,
+	0x864343c5U, 0x9a4d4dd7U, 0x66333355U, 0x11858594U,
+	0x8a4545cfU, 0xe9f9f910U, 0x04020206U, 0xfe7f7f81U,
+	0xa05050f0U, 0x783c3c44U, 0x259f9fbaU, 0x4ba8a8e3U,
+	0xa25151f3U, 0x5da3a3feU, 0x804040c0U, 0x058f8f8aU,
+	0x3f9292adU, 0x219d9dbcU, 0x70383848U, 0xf1f5f504U,
+	0x63bcbcdfU, 0x77b6b6c1U, 0xafdada75U, 0x42212163U,
+	0x20101030U, 0xe5ffff1aU, 0xfdf3f30eU, 0xbfd2d26dU,
+	0x81cdcd4cU, 0x180c0c14U, 0x26131335U, 0xc3ecec2fU,
+	0xbe5f5fe1U, 0x359797a2U, 0x884444ccU, 0x2e171739U,
+	0x93c4c457U, 0x55a7a7f2U, 0xfc7e7e82U, 0x7a3d3d47U,
+	0xc86464acU, 0xba5d5de7U, 0x3219192bU, 0xe6737395U,
+	0xc06060a0U, 0x19818198U, 0x9e4f4fd1U, 0xa3dcdc7fU,
+	0x44222266U, 0x542a2a7eU, 0x3b9090abU, 0x0b888883U,
+	0x8c4646caU, 0xc7eeee29U, 0x6bb8b8d3U, 0x2814143cU,
+	0xa7dede79U, 0xbc5e5ee2U, 0x160b0b1dU, 0xaddbdb76U,
+	0xdbe0e03bU, 0x64323256U, 0x743a3a4eU, 0x140a0a1eU,
+	0x924949dbU, 0x0c06060aU, 0x4824246cU, 0xb85c5ce4U,
+	0x9fc2c25dU, 0xbdd3d36eU, 0x43acacefU, 0xc46262a6U,
+	0x399191a8U, 0x319595a4U, 0xd3e4e437U, 0xf279798bU,
+	0xd5e7e732U, 0x8bc8c843U, 0x6e373759U, 0xda6d6db7U,
+	0x018d8d8cU, 0xb1d5d564U, 0x9c4e4ed2U, 0x49a9a9e0U,
+	0xd86c6cb4U, 0xac5656faU, 0xf3f4f407U, 0xcfeaea25U,
+	0xca6565afU, 0xf47a7a8eU, 0x47aeaee9U, 0x10080818U,
+	0x6fbabad5U, 0xf0787888U, 0x4a25256fU, 0x5c2e2e72U,
+	0x381c1c24U, 0x57a6a6f1U, 0x73b4b4c7U, 0x97c6c651U,
+	0xcbe8e823U, 0xa1dddd7cU, 0xe874749cU, 0x3e1f1f21U,
+	0x964b4bddU, 0x61bdbddcU, 0x0d8b8b86U, 0x0f8a8a85U,
+	0xe0707090U, 0x7c3e3e42U, 0x71b5b5c4U, 0xcc6666aaU,
+	0x904848d8U, 0x06030305U, 0xf7f6f601U, 0x1c0e0e12U,
+	0xc26161a3U, 0x6a35355fU, 0xae5757f9U, 0x69b9b9d0U,
+	0x17868691U, 0x99c1c158U, 0x3a1d1d27U, 0x279e9eb9U,
+	0xd9e1e138U, 0xebf8f813U, 0x2b9898b3U, 0x22111133U,
+	0xd26969bbU, 0xa9d9d970U, 0x078e8e89U, 0x339494a7U,
+	0x2d9b9bb6U, 0x3c1e1e22U, 0x15878792U, 0xc9e9e920U,
+	0x87cece49U, 0xaa5555ffU, 0x50282878U, 0xa5dfdf7aU,
+	0x038c8c8fU, 0x59a1a1f8U, 0x09898980U, 0x1a0d0d17U,
+	0x65bfbfdaU, 0xd7e6e631U, 0x844242c6U, 0xd06868b8U,
+	0x824141c3U, 0x299999b0U, 0x5a2d2d77U, 0x1e0f0f11U,
+	0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,
+};
+
+static const guint32 Te1[256] = {
+	0xa5c66363U, 0x84f87c7cU, 0x99ee7777U, 0x8df67b7bU,
+	0x0dfff2f2U, 0xbdd66b6bU, 0xb1de6f6fU, 0x5491c5c5U,
+	0x50603030U, 0x03020101U, 0xa9ce6767U, 0x7d562b2bU,
+	0x19e7fefeU, 0x62b5d7d7U, 0xe64dababU, 0x9aec7676U,
+	0x458fcacaU, 0x9d1f8282U, 0x4089c9c9U, 0x87fa7d7dU,
+	0x15effafaU, 0xebb25959U, 0xc98e4747U, 0x0bfbf0f0U,
+	0xec41adadU, 0x67b3d4d4U, 0xfd5fa2a2U, 0xea45afafU,
+	0xbf239c9cU, 0xf753a4a4U, 0x96e47272U, 0x5b9bc0c0U,
+	0xc275b7b7U, 0x1ce1fdfdU, 0xae3d9393U, 0x6a4c2626U,
+	0x5a6c3636U, 0x417e3f3fU, 0x02f5f7f7U, 0x4f83ccccU,
+	0x5c683434U, 0xf451a5a5U, 0x34d1e5e5U, 0x08f9f1f1U,
+	0x93e27171U, 0x73abd8d8U, 0x53623131U, 0x3f2a1515U,
+	0x0c080404U, 0x5295c7c7U, 0x65462323U, 0x5e9dc3c3U,
+	0x28301818U, 0xa1379696U, 0x0f0a0505U, 0xb52f9a9aU,
+	0x090e0707U, 0x36241212U, 0x9b1b8080U, 0x3ddfe2e2U,
+	0x26cdebebU, 0x694e2727U, 0xcd7fb2b2U, 0x9fea7575U,
+	0x1b120909U, 0x9e1d8383U, 0x74582c2cU, 0x2e341a1aU,
+	0x2d361b1bU, 0xb2dc6e6eU, 0xeeb45a5aU, 0xfb5ba0a0U,
+	0xf6a45252U, 0x4d763b3bU, 0x61b7d6d6U, 0xce7db3b3U,
+	0x7b522929U, 0x3edde3e3U, 0x715e2f2fU, 0x97138484U,
+	0xf5a65353U, 0x68b9d1d1U, 0x00000000U, 0x2cc1ededU,
+	0x60402020U, 0x1fe3fcfcU, 0xc879b1b1U, 0xedb65b5bU,
+	0xbed46a6aU, 0x468dcbcbU, 0xd967bebeU, 0x4b723939U,
+	0xde944a4aU, 0xd4984c4cU, 0xe8b05858U, 0x4a85cfcfU,
+	0x6bbbd0d0U, 0x2ac5efefU, 0xe54faaaaU, 0x16edfbfbU,
+	0xc5864343U, 0xd79a4d4dU, 0x55663333U, 0x94118585U,
+	0xcf8a4545U, 0x10e9f9f9U, 0x06040202U, 0x81fe7f7fU,
+	0xf0a05050U, 0x44783c3cU, 0xba259f9fU, 0xe34ba8a8U,
+	0xf3a25151U, 0xfe5da3a3U, 0xc0804040U, 0x8a058f8fU,
+	0xad3f9292U, 0xbc219d9dU, 0x48703838U, 0x04f1f5f5U,
+	0xdf63bcbcU, 0xc177b6b6U, 0x75afdadaU, 0x63422121U,
+	0x30201010U, 0x1ae5ffffU, 0x0efdf3f3U, 0x6dbfd2d2U,
+	0x4c81cdcdU, 0x14180c0cU, 0x35261313U, 0x2fc3ececU,
+	0xe1be5f5fU, 0xa2359797U, 0xcc884444U, 0x392e1717U,
+	0x5793c4c4U, 0xf255a7a7U, 0x82fc7e7eU, 0x477a3d3dU,
+	0xacc86464U, 0xe7ba5d5dU, 0x2b321919U, 0x95e67373U,
+	0xa0c06060U, 0x98198181U, 0xd19e4f4fU, 0x7fa3dcdcU,
+	0x66442222U, 0x7e542a2aU, 0xab3b9090U, 0x830b8888U,
+	0xca8c4646U, 0x29c7eeeeU, 0xd36bb8b8U, 0x3c281414U,
+	0x79a7dedeU, 0xe2bc5e5eU, 0x1d160b0bU, 0x76addbdbU,
+	0x3bdbe0e0U, 0x56643232U, 0x4e743a3aU, 0x1e140a0aU,
+	0xdb924949U, 0x0a0c0606U, 0x6c482424U, 0xe4b85c5cU,
+	0x5d9fc2c2U, 0x6ebdd3d3U, 0xef43acacU, 0xa6c46262U,
+	0xa8399191U, 0xa4319595U, 0x37d3e4e4U, 0x8bf27979U,
+	0x32d5e7e7U, 0x438bc8c8U, 0x596e3737U, 0xb7da6d6dU,
+	0x8c018d8dU, 0x64b1d5d5U, 0xd29c4e4eU, 0xe049a9a9U,
+	0xb4d86c6cU, 0xfaac5656U, 0x07f3f4f4U, 0x25cfeaeaU,
+	0xafca6565U, 0x8ef47a7aU, 0xe947aeaeU, 0x18100808U,
+	0xd56fbabaU, 0x88f07878U, 0x6f4a2525U, 0x725c2e2eU,
+	0x24381c1cU, 0xf157a6a6U, 0xc773b4b4U, 0x5197c6c6U,
+	0x23cbe8e8U, 0x7ca1ddddU, 0x9ce87474U, 0x213e1f1fU,
+	0xdd964b4bU, 0xdc61bdbdU, 0x860d8b8bU, 0x850f8a8aU,
+	0x90e07070U, 0x427c3e3eU, 0xc471b5b5U, 0xaacc6666U,
+	0xd8904848U, 0x05060303U, 0x01f7f6f6U, 0x121c0e0eU,
+	0xa3c26161U, 0x5f6a3535U, 0xf9ae5757U, 0xd069b9b9U,
+	0x91178686U, 0x5899c1c1U, 0x273a1d1dU, 0xb9279e9eU,
+	0x38d9e1e1U, 0x13ebf8f8U, 0xb32b9898U, 0x33221111U,
+	0xbbd26969U, 0x70a9d9d9U, 0x89078e8eU, 0xa7339494U,
+	0xb62d9b9bU, 0x223c1e1eU, 0x92158787U, 0x20c9e9e9U,
+	0x4987ceceU, 0xffaa5555U, 0x78502828U, 0x7aa5dfdfU,
+	0x8f038c8cU, 0xf859a1a1U, 0x80098989U, 0x171a0d0dU,
+	0xda65bfbfU, 0x31d7e6e6U, 0xc6844242U, 0xb8d06868U,
+	0xc3824141U, 0xb0299999U, 0x775a2d2dU, 0x111e0f0fU,
+	0xcb7bb0b0U, 0xfca85454U, 0xd66dbbbbU, 0x3a2c1616U,
+};
+
+static const guint32 Te2[256] = {
+	0x63a5c663U, 0x7c84f87cU, 0x7799ee77U, 0x7b8df67bU,
+	0xf20dfff2U, 0x6bbdd66bU, 0x6fb1de6fU, 0xc55491c5U,
+	0x30506030U, 0x01030201U, 0x67a9ce67U, 0x2b7d562bU,
+	0xfe19e7feU, 0xd762b5d7U, 0xabe64dabU, 0x769aec76U,
+	0xca458fcaU, 0x829d1f82U, 0xc94089c9U, 0x7d87fa7dU,
+	0xfa15effaU, 0x59ebb259U, 0x47c98e47U, 0xf00bfbf0U,
+	0xadec41adU, 0xd467b3d4U, 0xa2fd5fa2U, 0xafea45afU,
+	0x9cbf239cU, 0xa4f753a4U, 0x7296e472U, 0xc05b9bc0U,
+	0xb7c275b7U, 0xfd1ce1fdU, 0x93ae3d93U, 0x266a4c26U,
+	0x365a6c36U, 0x3f417e3fU, 0xf702f5f7U, 0xcc4f83ccU,
+	0x345c6834U, 0xa5f451a5U, 0xe534d1e5U, 0xf108f9f1U,
+	0x7193e271U, 0xd873abd8U, 0x31536231U, 0x153f2a15U,
+	0x040c0804U, 0xc75295c7U, 0x23654623U, 0xc35e9dc3U,
+	0x18283018U, 0x96a13796U, 0x050f0a05U, 0x9ab52f9aU,
+	0x07090e07U, 0x12362412U, 0x809b1b80U, 0xe23ddfe2U,
+	0xeb26cdebU, 0x27694e27U, 0xb2cd7fb2U, 0x759fea75U,
+	0x091b1209U, 0x839e1d83U, 0x2c74582cU, 0x1a2e341aU,
+	0x1b2d361bU, 0x6eb2dc6eU, 0x5aeeb45aU, 0xa0fb5ba0U,
+	0x52f6a452U, 0x3b4d763bU, 0xd661b7d6U, 0xb3ce7db3U,
+	0x297b5229U, 0xe33edde3U, 0x2f715e2fU, 0x84971384U,
+	0x53f5a653U, 0xd168b9d1U, 0x00000000U, 0xed2cc1edU,
+	0x20604020U, 0xfc1fe3fcU, 0xb1c879b1U, 0x5bedb65bU,
+	0x6abed46aU, 0xcb468dcbU, 0xbed967beU, 0x394b7239U,
+	0x4ade944aU, 0x4cd4984cU, 0x58e8b058U, 0xcf4a85cfU,
+	0xd06bbbd0U, 0xef2ac5efU, 0xaae54faaU, 0xfb16edfbU,
+	0x43c58643U, 0x4dd79a4dU, 0x33556633U, 0x85941185U,
+	0x45cf8a45U, 0xf910e9f9U, 0x02060402U, 0x7f81fe7fU,
+	0x50f0a050U, 0x3c44783cU, 0x9fba259fU, 0xa8e34ba8U,
+	0x51f3a251U, 0xa3fe5da3U, 0x40c08040U, 0x8f8a058fU,
+	0x92ad3f92U, 0x9dbc219dU, 0x38487038U, 0xf504f1f5U,
+	0xbcdf63bcU, 0xb6c177b6U, 0xda75afdaU, 0x21634221U,
+	0x10302010U, 0xff1ae5ffU, 0xf30efdf3U, 0xd26dbfd2U,
+	0xcd4c81cdU, 0x0c14180cU, 0x13352613U, 0xec2fc3ecU,
+	0x5fe1be5fU, 0x97a23597U, 0x44cc8844U, 0x17392e17U,
+	0xc45793c4U, 0xa7f255a7U, 0x7e82fc7eU, 0x3d477a3dU,
+	0x64acc864U, 0x5de7ba5dU, 0x192b3219U, 0x7395e673U,
+	0x60a0c060U, 0x81981981U, 0x4fd19e4fU, 0xdc7fa3dcU,
+	0x22664422U, 0x2a7e542aU, 0x90ab3b90U, 0x88830b88U,
+	0x46ca8c46U, 0xee29c7eeU, 0xb8d36bb8U, 0x143c2814U,
+	0xde79a7deU, 0x5ee2bc5eU, 0x0b1d160bU, 0xdb76addbU,
+	0xe03bdbe0U, 0x32566432U, 0x3a4e743aU, 0x0a1e140aU,
+	0x49db9249U, 0x060a0c06U, 0x246c4824U, 0x5ce4b85cU,
+	0xc25d9fc2U, 0xd36ebdd3U, 0xacef43acU, 0x62a6c462U,
+	0x91a83991U, 0x95a43195U, 0xe437d3e4U, 0x798bf279U,
+	0xe732d5e7U, 0xc8438bc8U, 0x37596e37U, 0x6db7da6dU,
+	0x8d8c018dU, 0xd564b1d5U, 0x4ed29c4eU, 0xa9e049a9U,
+	0x6cb4d86cU, 0x56faac56U, 0xf407f3f4U, 0xea25cfeaU,
+	0x65afca65U, 0x7a8ef47aU, 0xaee947aeU, 0x08181008U,
+	0xbad56fbaU, 0x7888f078U, 0x256f4a25U, 0x2e725c2eU,
+	0x1c24381cU, 0xa6f157a6U, 0xb4c773b4U, 0xc65197c6U,
+	0xe823cbe8U, 0xdd7ca1ddU, 0x749ce874U, 0x1f213e1fU,
+	0x4bdd964bU, 0xbddc61bdU, 0x8b860d8bU, 0x8a850f8aU,
+	0x7090e070U, 0x3e427c3eU, 0xb5c471b5U, 0x66aacc66U,
+	0x48d89048U, 0x03050603U, 0xf601f7f6U, 0x0e121c0eU,
+	0x61a3c261U, 0x355f6a35U, 0x57f9ae57U, 0xb9d069b9U,
+	0x86911786U, 0xc15899c1U, 0x1d273a1dU, 0x9eb9279eU,
+	0xe138d9e1U, 0xf813ebf8U, 0x98b32b98U, 0x11332211U,
+	0x69bbd269U, 0xd970a9d9U, 0x8e89078eU, 0x94a73394U,
+	0x9bb62d9bU, 0x1e223c1eU, 0x87921587U, 0xe920c9e9U,
+	0xce4987ceU, 0x55ffaa55U, 0x28785028U, 0xdf7aa5dfU,
+	0x8c8f038cU, 0xa1f859a1U, 0x89800989U, 0x0d171a0dU,
+	0xbfda65bfU, 0xe631d7e6U, 0x42c68442U, 0x68b8d068U,
+	0x41c38241U, 0x99b02999U, 0x2d775a2dU, 0x0f111e0fU,
+	0xb0cb7bb0U, 0x54fca854U, 0xbbd66dbbU, 0x163a2c16U,
+};
+
+static const guint32 Te3[256] = {
+	0x6363a5c6U, 0x7c7c84f8U, 0x777799eeU, 0x7b7b8df6U,
+	0xf2f20dffU, 0x6b6bbdd6U, 0x6f6fb1deU, 0xc5c55491U,
+	0x30305060U, 0x01010302U, 0x6767a9ceU, 0x2b2b7d56U,
+	0xfefe19e7U, 0xd7d762b5U, 0xababe64dU, 0x76769aecU,
+	0xcaca458fU, 0x82829d1fU, 0xc9c94089U, 0x7d7d87faU,
+	0xfafa15efU, 0x5959ebb2U, 0x4747c98eU, 0xf0f00bfbU,
+	0xadadec41U, 0xd4d467b3U, 0xa2a2fd5fU, 0xafafea45U,
+	0x9c9cbf23U, 0xa4a4f753U, 0x727296e4U, 0xc0c05b9bU,
+	0xb7b7c275U, 0xfdfd1ce1U, 0x9393ae3dU, 0x26266a4cU,
+	0x36365a6cU, 0x3f3f417eU, 0xf7f702f5U, 0xcccc4f83U,
+	0x34345c68U, 0xa5a5f451U, 0xe5e534d1U, 0xf1f108f9U,
+	0x717193e2U, 0xd8d873abU, 0x31315362U, 0x15153f2aU,
+	0x04040c08U, 0xc7c75295U, 0x23236546U, 0xc3c35e9dU,
+	0x18182830U, 0x9696a137U, 0x05050f0aU, 0x9a9ab52fU,
+	0x0707090eU, 0x12123624U, 0x80809b1bU, 0xe2e23ddfU,
+	0xebeb26cdU, 0x2727694eU, 0xb2b2cd7fU, 0x75759feaU,
+	0x09091b12U, 0x83839e1dU, 0x2c2c7458U, 0x1a1a2e34U,
+	0x1b1b2d36U, 0x6e6eb2dcU, 0x5a5aeeb4U, 0xa0a0fb5bU,
+	0x5252f6a4U, 0x3b3b4d76U, 0xd6d661b7U, 0xb3b3ce7dU,
+	0x29297b52U, 0xe3e33eddU, 0x2f2f715eU, 0x84849713U,
+	0x5353f5a6U, 0xd1d168b9U, 0x00000000U, 0xeded2cc1U,
+	0x20206040U, 0xfcfc1fe3U, 0xb1b1c879U, 0x5b5bedb6U,
+	0x6a6abed4U, 0xcbcb468dU, 0xbebed967U, 0x39394b72U,
+	0x4a4ade94U, 0x4c4cd498U, 0x5858e8b0U, 0xcfcf4a85U,
+	0xd0d06bbbU, 0xefef2ac5U, 0xaaaae54fU, 0xfbfb16edU,
+	0x4343c586U, 0x4d4dd79aU, 0x33335566U, 0x85859411U,
+	0x4545cf8aU, 0xf9f910e9U, 0x02020604U, 0x7f7f81feU,
+	0x5050f0a0U, 0x3c3c4478U, 0x9f9fba25U, 0xa8a8e34bU,
+	0x5151f3a2U, 0xa3a3fe5dU, 0x4040c080U, 0x8f8f8a05U,
+	0x9292ad3fU, 0x9d9dbc21U, 0x38384870U, 0xf5f504f1U,
+	0xbcbcdf63U, 0xb6b6c177U, 0xdada75afU, 0x21216342U,
+	0x10103020U, 0xffff1ae5U, 0xf3f30efdU, 0xd2d26dbfU,
+	0xcdcd4c81U, 0x0c0c1418U, 0x13133526U, 0xecec2fc3U,
+	0x5f5fe1beU, 0x9797a235U, 0x4444cc88U, 0x1717392eU,
+	0xc4c45793U, 0xa7a7f255U, 0x7e7e82fcU, 0x3d3d477aU,
+	0x6464acc8U, 0x5d5de7baU, 0x19192b32U, 0x737395e6U,
+	0x6060a0c0U, 0x81819819U, 0x4f4fd19eU, 0xdcdc7fa3U,
+	0x22226644U, 0x2a2a7e54U, 0x9090ab3bU, 0x8888830bU,
+	0x4646ca8cU, 0xeeee29c7U, 0xb8b8d36bU, 0x14143c28U,
+	0xdede79a7U, 0x5e5ee2bcU, 0x0b0b1d16U, 0xdbdb76adU,
+	0xe0e03bdbU, 0x32325664U, 0x3a3a4e74U, 0x0a0a1e14U,
+	0x4949db92U, 0x06060a0cU, 0x24246c48U, 0x5c5ce4b8U,
+	0xc2c25d9fU, 0xd3d36ebdU, 0xacacef43U, 0x6262a6c4U,
+	0x9191a839U, 0x9595a431U, 0xe4e437d3U, 0x79798bf2U,
+	0xe7e732d5U, 0xc8c8438bU, 0x3737596eU, 0x6d6db7daU,
+	0x8d8d8c01U, 0xd5d564b1U, 0x4e4ed29cU, 0xa9a9e049U,
+	0x6c6cb4d8U, 0x5656faacU, 0xf4f407f3U, 0xeaea25cfU,
+	0x6565afcaU, 0x7a7a8ef4U, 0xaeaee947U, 0x08081810U,
+	0xbabad56fU, 0x787888f0U, 0x25256f4aU, 0x2e2e725cU,
+	0x1c1c2438U, 0xa6a6f157U, 0xb4b4c773U, 0xc6c65197U,
+	0xe8e823cbU, 0xdddd7ca1U, 0x74749ce8U, 0x1f1f213eU,
+	0x4b4bdd96U, 0xbdbddc61U, 0x8b8b860dU, 0x8a8a850fU,
+	0x707090e0U, 0x3e3e427cU, 0xb5b5c471U, 0x6666aaccU,
+	0x4848d890U, 0x03030506U, 0xf6f601f7U, 0x0e0e121cU,
+	0x6161a3c2U, 0x35355f6aU, 0x5757f9aeU, 0xb9b9d069U,
+	0x86869117U, 0xc1c15899U, 0x1d1d273aU, 0x9e9eb927U,
+	0xe1e138d9U, 0xf8f813ebU, 0x9898b32bU, 0x11113322U,
+	0x6969bbd2U, 0xd9d970a9U, 0x8e8e8907U, 0x9494a733U,
+	0x9b9bb62dU, 0x1e1e223cU, 0x87879215U, 0xe9e920c9U,
+	0xcece4987U, 0x5555ffaaU, 0x28287850U, 0xdfdf7aa5U,
+	0x8c8c8f03U, 0xa1a1f859U, 0x89898009U, 0x0d0d171aU,
+	0xbfbfda65U, 0xe6e631d7U, 0x4242c684U, 0x6868b8d0U,
+	0x4141c382U, 0x9999b029U, 0x2d2d775aU, 0x0f0f111eU,
+	0xb0b0cb7bU, 0x5454fca8U, 0xbbbbd66dU, 0x16163a2cU,
+};
+
+static const guint32 Te4[256] = {
+	0x63636363U, 0x7c7c7c7cU, 0x77777777U, 0x7b7b7b7bU,
+	0xf2f2f2f2U, 0x6b6b6b6bU, 0x6f6f6f6fU, 0xc5c5c5c5U,
+	0x30303030U, 0x01010101U, 0x67676767U, 0x2b2b2b2bU,
+	0xfefefefeU, 0xd7d7d7d7U, 0xababababU, 0x76767676U,
+	0xcacacacaU, 0x82828282U, 0xc9c9c9c9U, 0x7d7d7d7dU,
+	0xfafafafaU, 0x59595959U, 0x47474747U, 0xf0f0f0f0U,
+	0xadadadadU, 0xd4d4d4d4U, 0xa2a2a2a2U, 0xafafafafU,
+	0x9c9c9c9cU, 0xa4a4a4a4U, 0x72727272U, 0xc0c0c0c0U,
+	0xb7b7b7b7U, 0xfdfdfdfdU, 0x93939393U, 0x26262626U,
+	0x36363636U, 0x3f3f3f3fU, 0xf7f7f7f7U, 0xccccccccU,
+	0x34343434U, 0xa5a5a5a5U, 0xe5e5e5e5U, 0xf1f1f1f1U,
+	0x71717171U, 0xd8d8d8d8U, 0x31313131U, 0x15151515U,
+	0x04040404U, 0xc7c7c7c7U, 0x23232323U, 0xc3c3c3c3U,
+	0x18181818U, 0x96969696U, 0x05050505U, 0x9a9a9a9aU,
+	0x07070707U, 0x12121212U, 0x80808080U, 0xe2e2e2e2U,
+	0xebebebebU, 0x27272727U, 0xb2b2b2b2U, 0x75757575U,
+	0x09090909U, 0x83838383U, 0x2c2c2c2cU, 0x1a1a1a1aU,
+	0x1b1b1b1bU, 0x6e6e6e6eU, 0x5a5a5a5aU, 0xa0a0a0a0U,
+	0x52525252U, 0x3b3b3b3bU, 0xd6d6d6d6U, 0xb3b3b3b3U,
+	0x29292929U, 0xe3e3e3e3U, 0x2f2f2f2fU, 0x84848484U,
+	0x53535353U, 0xd1d1d1d1U, 0x00000000U, 0xededededU,
+	0x20202020U, 0xfcfcfcfcU, 0xb1b1b1b1U, 0x5b5b5b5bU,
+	0x6a6a6a6aU, 0xcbcbcbcbU, 0xbebebebeU, 0x39393939U,
+	0x4a4a4a4aU, 0x4c4c4c4cU, 0x58585858U, 0xcfcfcfcfU,
+	0xd0d0d0d0U, 0xefefefefU, 0xaaaaaaaaU, 0xfbfbfbfbU,
+	0x43434343U, 0x4d4d4d4dU, 0x33333333U, 0x85858585U,
+	0x45454545U, 0xf9f9f9f9U, 0x02020202U, 0x7f7f7f7fU,
+	0x50505050U, 0x3c3c3c3cU, 0x9f9f9f9fU, 0xa8a8a8a8U,
+	0x51515151U, 0xa3a3a3a3U, 0x40404040U, 0x8f8f8f8fU,
+	0x92929292U, 0x9d9d9d9dU, 0x38383838U, 0xf5f5f5f5U,
+	0xbcbcbcbcU, 0xb6b6b6b6U, 0xdadadadaU, 0x21212121U,
+	0x10101010U, 0xffffffffU, 0xf3f3f3f3U, 0xd2d2d2d2U,
+	0xcdcdcdcdU, 0x0c0c0c0cU, 0x13131313U, 0xececececU,
+	0x5f5f5f5fU, 0x97979797U, 0x44444444U, 0x17171717U,
+	0xc4c4c4c4U, 0xa7a7a7a7U, 0x7e7e7e7eU, 0x3d3d3d3dU,
+	0x64646464U, 0x5d5d5d5dU, 0x19191919U, 0x73737373U,
+	0x60606060U, 0x81818181U, 0x4f4f4f4fU, 0xdcdcdcdcU,
+	0x22222222U, 0x2a2a2a2aU, 0x90909090U, 0x88888888U,
+	0x46464646U, 0xeeeeeeeeU, 0xb8b8b8b8U, 0x14141414U,
+	0xdedededeU, 0x5e5e5e5eU, 0x0b0b0b0bU, 0xdbdbdbdbU,
+	0xe0e0e0e0U, 0x32323232U, 0x3a3a3a3aU, 0x0a0a0a0aU,
+	0x49494949U, 0x06060606U, 0x24242424U, 0x5c5c5c5cU,
+	0xc2c2c2c2U, 0xd3d3d3d3U, 0xacacacacU, 0x62626262U,
+	0x91919191U, 0x95959595U, 0xe4e4e4e4U, 0x79797979U,
+	0xe7e7e7e7U, 0xc8c8c8c8U, 0x37373737U, 0x6d6d6d6dU,
+	0x8d8d8d8dU, 0xd5d5d5d5U, 0x4e4e4e4eU, 0xa9a9a9a9U,
+	0x6c6c6c6cU, 0x56565656U, 0xf4f4f4f4U, 0xeaeaeaeaU,
+	0x65656565U, 0x7a7a7a7aU, 0xaeaeaeaeU, 0x08080808U,
+	0xbabababaU, 0x78787878U, 0x25252525U, 0x2e2e2e2eU,
+	0x1c1c1c1cU, 0xa6a6a6a6U, 0xb4b4b4b4U, 0xc6c6c6c6U,
+	0xe8e8e8e8U, 0xddddddddU, 0x74747474U, 0x1f1f1f1fU,
+	0x4b4b4b4bU, 0xbdbdbdbdU, 0x8b8b8b8bU, 0x8a8a8a8aU,
+	0x70707070U, 0x3e3e3e3eU, 0xb5b5b5b5U, 0x66666666U,
+	0x48484848U, 0x03030303U, 0xf6f6f6f6U, 0x0e0e0e0eU,
+	0x61616161U, 0x35353535U, 0x57575757U, 0xb9b9b9b9U,
+	0x86868686U, 0xc1c1c1c1U, 0x1d1d1d1dU, 0x9e9e9e9eU,
+	0xe1e1e1e1U, 0xf8f8f8f8U, 0x98989898U, 0x11111111U,
+	0x69696969U, 0xd9d9d9d9U, 0x8e8e8e8eU, 0x94949494U,
+	0x9b9b9b9bU, 0x1e1e1e1eU, 0x87878787U, 0xe9e9e9e9U,
+	0xcecececeU, 0x55555555U, 0x28282828U, 0xdfdfdfdfU,
+	0x8c8c8c8cU, 0xa1a1a1a1U, 0x89898989U, 0x0d0d0d0dU,
+	0xbfbfbfbfU, 0xe6e6e6e6U, 0x42424242U, 0x68686868U,
+	0x41414141U, 0x99999999U, 0x2d2d2d2dU, 0x0f0f0f0fU,
+	0xb0b0b0b0U, 0x54545454U, 0xbbbbbbbbU, 0x16161616U,
+};
+
+static const guint32 Td0[256] = {
+	0x51f4a750U, 0x7e416553U, 0x1a17a4c3U, 0x3a275e96U,
+	0x3bab6bcbU, 0x1f9d45f1U, 0xacfa58abU, 0x4be30393U,
+	0x2030fa55U, 0xad766df6U, 0x88cc7691U, 0xf5024c25U,
+	0x4fe5d7fcU, 0xc52acbd7U, 0x26354480U, 0xb562a38fU,
+	0xdeb15a49U, 0x25ba1b67U, 0x45ea0e98U, 0x5dfec0e1U,
+	0xc32f7502U, 0x814cf012U, 0x8d4697a3U, 0x6bd3f9c6U,
+	0x038f5fe7U, 0x15929c95U, 0xbf6d7aebU, 0x955259daU,
+	0xd4be832dU, 0x587421d3U, 0x49e06929U, 0x8ec9c844U,
+	0x75c2896aU, 0xf48e7978U, 0x99583e6bU, 0x27b971ddU,
+	0xbee14fb6U, 0xf088ad17U, 0xc920ac66U, 0x7dce3ab4U,
+	0x63df4a18U, 0xe51a3182U, 0x97513360U, 0x62537f45U,
+	0xb16477e0U, 0xbb6bae84U, 0xfe81a01cU, 0xf9082b94U,
+	0x70486858U, 0x8f45fd19U, 0x94de6c87U, 0x527bf8b7U,
+	0xab73d323U, 0x724b02e2U, 0xe31f8f57U, 0x6655ab2aU,
+	0xb2eb2807U, 0x2fb5c203U, 0x86c57b9aU, 0xd33708a5U,
+	0x302887f2U, 0x23bfa5b2U, 0x02036abaU, 0xed16825cU,
+	0x8acf1c2bU, 0xa779b492U, 0xf307f2f0U, 0x4e69e2a1U,
+	0x65daf4cdU, 0x0605bed5U, 0xd134621fU, 0xc4a6fe8aU,
+	0x342e539dU, 0xa2f355a0U, 0x058ae132U, 0xa4f6eb75U,
+	0x0b83ec39U, 0x4060efaaU, 0x5e719f06U, 0xbd6e1051U,
+	0x3e218af9U, 0x96dd063dU, 0xdd3e05aeU, 0x4de6bd46U,
+	0x91548db5U, 0x71c45d05U, 0x0406d46fU, 0x605015ffU,
+	0x1998fb24U, 0xd6bde997U, 0x894043ccU, 0x67d99e77U,
+	0xb0e842bdU, 0x07898b88U, 0xe7195b38U, 0x79c8eedbU,
+	0xa17c0a47U, 0x7c420fe9U, 0xf8841ec9U, 0x00000000U,
+	0x09808683U, 0x322bed48U, 0x1e1170acU, 0x6c5a724eU,
+	0xfd0efffbU, 0x0f853856U, 0x3daed51eU, 0x362d3927U,
+	0x0a0fd964U, 0x685ca621U, 0x9b5b54d1U, 0x24362e3aU,
+	0x0c0a67b1U, 0x9357e70fU, 0xb4ee96d2U, 0x1b9b919eU,
+	0x80c0c54fU, 0x61dc20a2U, 0x5a774b69U, 0x1c121a16U,
+	0xe293ba0aU, 0xc0a02ae5U, 0x3c22e043U, 0x121b171dU,
+	0x0e090d0bU, 0xf28bc7adU, 0x2db6a8b9U, 0x141ea9c8U,
+	0x57f11985U, 0xaf75074cU, 0xee99ddbbU, 0xa37f60fdU,
+	0xf701269fU, 0x5c72f5bcU, 0x44663bc5U, 0x5bfb7e34U,
+	0x8b432976U, 0xcb23c6dcU, 0xb6edfc68U, 0xb8e4f163U,
+	0xd731dccaU, 0x42638510U, 0x13972240U, 0x84c61120U,
+	0x854a247dU, 0xd2bb3df8U, 0xaef93211U, 0xc729a16dU,
+	0x1d9e2f4bU, 0xdcb230f3U, 0x0d8652ecU, 0x77c1e3d0U,
+	0x2bb3166cU, 0xa970b999U, 0x119448faU, 0x47e96422U,
+	0xa8fc8cc4U, 0xa0f03f1aU, 0x567d2cd8U, 0x223390efU,
+	0x87494ec7U, 0xd938d1c1U, 0x8ccaa2feU, 0x98d40b36U,
+	0xa6f581cfU, 0xa57ade28U, 0xdab78e26U, 0x3fadbfa4U,
+	0x2c3a9de4U, 0x5078920dU, 0x6a5fcc9bU, 0x547e4662U,
+	0xf68d13c2U, 0x90d8b8e8U, 0x2e39f75eU, 0x82c3aff5U,
+	0x9f5d80beU, 0x69d0937cU, 0x6fd52da9U, 0xcf2512b3U,
+	0xc8ac993bU, 0x10187da7U, 0xe89c636eU, 0xdb3bbb7bU,
+	0xcd267809U, 0x6e5918f4U, 0xec9ab701U, 0x834f9aa8U,
+	0xe6956e65U, 0xaaffe67eU, 0x21bccf08U, 0xef15e8e6U,
+	0xbae79bd9U, 0x4a6f36ceU, 0xea9f09d4U, 0x29b07cd6U,
+	0x31a4b2afU, 0x2a3f2331U, 0xc6a59430U, 0x35a266c0U,
+	0x744ebc37U, 0xfc82caa6U, 0xe090d0b0U, 0x33a7d815U,
+	0xf104984aU, 0x41ecdaf7U, 0x7fcd500eU, 0x1791f62fU,
+	0x764dd68dU, 0x43efb04dU, 0xccaa4d54U, 0xe49604dfU,
+	0x9ed1b5e3U, 0x4c6a881bU, 0xc12c1fb8U, 0x4665517fU,
+	0x9d5eea04U, 0x018c355dU, 0xfa877473U, 0xfb0b412eU,
+	0xb3671d5aU, 0x92dbd252U, 0xe9105633U, 0x6dd64713U,
+	0x9ad7618cU, 0x37a10c7aU, 0x59f8148eU, 0xeb133c89U,
+	0xcea927eeU, 0xb761c935U, 0xe11ce5edU, 0x7a47b13cU,
+	0x9cd2df59U, 0x55f2733fU, 0x1814ce79U, 0x73c737bfU,
+	0x53f7cdeaU, 0x5ffdaa5bU, 0xdf3d6f14U, 0x7844db86U,
+	0xcaaff381U, 0xb968c43eU, 0x3824342cU, 0xc2a3405fU,
+	0x161dc372U, 0xbce2250cU, 0x283c498bU, 0xff0d9541U,
+	0x39a80171U, 0x080cb3deU, 0xd8b4e49cU, 0x6456c190U,
+	0x7bcb8461U, 0xd532b670U, 0x486c5c74U, 0xd0b85742U,
+};
+
+static const guint32 Td1[256] = {
+	0x5051f4a7U, 0x537e4165U, 0xc31a17a4U, 0x963a275eU,
+	0xcb3bab6bU, 0xf11f9d45U, 0xabacfa58U, 0x934be303U,
+	0x552030faU, 0xf6ad766dU, 0x9188cc76U, 0x25f5024cU,
+	0xfc4fe5d7U, 0xd7c52acbU, 0x80263544U, 0x8fb562a3U,
+	0x49deb15aU, 0x6725ba1bU, 0x9845ea0eU, 0xe15dfec0U,
+	0x02c32f75U, 0x12814cf0U, 0xa38d4697U, 0xc66bd3f9U,
+	0xe7038f5fU, 0x9515929cU, 0xebbf6d7aU, 0xda955259U,
+	0x2dd4be83U, 0xd3587421U, 0x2949e069U, 0x448ec9c8U,
+	0x6a75c289U, 0x78f48e79U, 0x6b99583eU, 0xdd27b971U,
+	0xb6bee14fU, 0x17f088adU, 0x66c920acU, 0xb47dce3aU,
+	0x1863df4aU, 0x82e51a31U, 0x60975133U, 0x4562537fU,
+	0xe0b16477U, 0x84bb6baeU, 0x1cfe81a0U, 0x94f9082bU,
+	0x58704868U, 0x198f45fdU, 0x8794de6cU, 0xb7527bf8U,
+	0x23ab73d3U, 0xe2724b02U, 0x57e31f8fU, 0x2a6655abU,
+	0x07b2eb28U, 0x032fb5c2U, 0x9a86c57bU, 0xa5d33708U,
+	0xf2302887U, 0xb223bfa5U, 0xba02036aU, 0x5ced1682U,
+	0x2b8acf1cU, 0x92a779b4U, 0xf0f307f2U, 0xa14e69e2U,
+	0xcd65daf4U, 0xd50605beU, 0x1fd13462U, 0x8ac4a6feU,
+	0x9d342e53U, 0xa0a2f355U, 0x32058ae1U, 0x75a4f6ebU,
+	0x390b83ecU, 0xaa4060efU, 0x065e719fU, 0x51bd6e10U,
+	0xf93e218aU, 0x3d96dd06U, 0xaedd3e05U, 0x464de6bdU,
+	0xb591548dU, 0x0571c45dU, 0x6f0406d4U, 0xff605015U,
+	0x241998fbU, 0x97d6bde9U, 0xcc894043U, 0x7767d99eU,
+	0xbdb0e842U, 0x8807898bU, 0x38e7195bU, 0xdb79c8eeU,
+	0x47a17c0aU, 0xe97c420fU, 0xc9f8841eU, 0x00000000U,
+	0x83098086U, 0x48322bedU, 0xac1e1170U, 0x4e6c5a72U,
+	0xfbfd0effU, 0x560f8538U, 0x1e3daed5U, 0x27362d39U,
+	0x640a0fd9U, 0x21685ca6U, 0xd19b5b54U, 0x3a24362eU,
+	0xb10c0a67U, 0x0f9357e7U, 0xd2b4ee96U, 0x9e1b9b91U,
+	0x4f80c0c5U, 0xa261dc20U, 0x695a774bU, 0x161c121aU,
+	0x0ae293baU, 0xe5c0a02aU, 0x433c22e0U, 0x1d121b17U,
+	0x0b0e090dU, 0xadf28bc7U, 0xb92db6a8U, 0xc8141ea9U,
+	0x8557f119U, 0x4caf7507U, 0xbbee99ddU, 0xfda37f60U,
+	0x9ff70126U, 0xbc5c72f5U, 0xc544663bU, 0x345bfb7eU,
+	0x768b4329U, 0xdccb23c6U, 0x68b6edfcU, 0x63b8e4f1U,
+	0xcad731dcU, 0x10426385U, 0x40139722U, 0x2084c611U,
+	0x7d854a24U, 0xf8d2bb3dU, 0x11aef932U, 0x6dc729a1U,
+	0x4b1d9e2fU, 0xf3dcb230U, 0xec0d8652U, 0xd077c1e3U,
+	0x6c2bb316U, 0x99a970b9U, 0xfa119448U, 0x2247e964U,
+	0xc4a8fc8cU, 0x1aa0f03fU, 0xd8567d2cU, 0xef223390U,
+	0xc787494eU, 0xc1d938d1U, 0xfe8ccaa2U, 0x3698d40bU,
+	0xcfa6f581U, 0x28a57adeU, 0x26dab78eU, 0xa43fadbfU,
+	0xe42c3a9dU, 0x0d507892U, 0x9b6a5fccU, 0x62547e46U,
+	0xc2f68d13U, 0xe890d8b8U, 0x5e2e39f7U, 0xf582c3afU,
+	0xbe9f5d80U, 0x7c69d093U, 0xa96fd52dU, 0xb3cf2512U,
+	0x3bc8ac99U, 0xa710187dU, 0x6ee89c63U, 0x7bdb3bbbU,
+	0x09cd2678U, 0xf46e5918U, 0x01ec9ab7U, 0xa8834f9aU,
+	0x65e6956eU, 0x7eaaffe6U, 0x0821bccfU, 0xe6ef15e8U,
+	0xd9bae79bU, 0xce4a6f36U, 0xd4ea9f09U, 0xd629b07cU,
+	0xaf31a4b2U, 0x312a3f23U, 0x30c6a594U, 0xc035a266U,
+	0x37744ebcU, 0xa6fc82caU, 0xb0e090d0U, 0x1533a7d8U,
+	0x4af10498U, 0xf741ecdaU, 0x0e7fcd50U, 0x2f1791f6U,
+	0x8d764dd6U, 0x4d43efb0U, 0x54ccaa4dU, 0xdfe49604U,
+	0xe39ed1b5U, 0x1b4c6a88U, 0xb8c12c1fU, 0x7f466551U,
+	0x049d5eeaU, 0x5d018c35U, 0x73fa8774U, 0x2efb0b41U,
+	0x5ab3671dU, 0x5292dbd2U, 0x33e91056U, 0x136dd647U,
+	0x8c9ad761U, 0x7a37a10cU, 0x8e59f814U, 0x89eb133cU,
+	0xeecea927U, 0x35b761c9U, 0xede11ce5U, 0x3c7a47b1U,
+	0x599cd2dfU, 0x3f55f273U, 0x791814ceU, 0xbf73c737U,
+	0xea53f7cdU, 0x5b5ffdaaU, 0x14df3d6fU, 0x867844dbU,
+	0x81caaff3U, 0x3eb968c4U, 0x2c382434U, 0x5fc2a340U,
+	0x72161dc3U, 0x0cbce225U, 0x8b283c49U, 0x41ff0d95U,
+	0x7139a801U, 0xde080cb3U, 0x9cd8b4e4U, 0x906456c1U,
+	0x617bcb84U, 0x70d532b6U, 0x74486c5cU, 0x42d0b857U,
+};
+
+static const guint32 Td2[256] = {
+	0xa75051f4U, 0x65537e41U, 0xa4c31a17U, 0x5e963a27U,
+	0x6bcb3babU, 0x45f11f9dU, 0x58abacfaU, 0x03934be3U,
+	0xfa552030U, 0x6df6ad76U, 0x769188ccU, 0x4c25f502U,
+	0xd7fc4fe5U, 0xcbd7c52aU, 0x44802635U, 0xa38fb562U,
+	0x5a49deb1U, 0x1b6725baU, 0x0e9845eaU, 0xc0e15dfeU,
+	0x7502c32fU, 0xf012814cU, 0x97a38d46U, 0xf9c66bd3U,
+	0x5fe7038fU, 0x9c951592U, 0x7aebbf6dU, 0x59da9552U,
+	0x832dd4beU, 0x21d35874U, 0x692949e0U, 0xc8448ec9U,
+	0x896a75c2U, 0x7978f48eU, 0x3e6b9958U, 0x71dd27b9U,
+	0x4fb6bee1U, 0xad17f088U, 0xac66c920U, 0x3ab47dceU,
+	0x4a1863dfU, 0x3182e51aU, 0x33609751U, 0x7f456253U,
+	0x77e0b164U, 0xae84bb6bU, 0xa01cfe81U, 0x2b94f908U,
+	0x68587048U, 0xfd198f45U, 0x6c8794deU, 0xf8b7527bU,
+	0xd323ab73U, 0x02e2724bU, 0x8f57e31fU, 0xab2a6655U,
+	0x2807b2ebU, 0xc2032fb5U, 0x7b9a86c5U, 0x08a5d337U,
+	0x87f23028U, 0xa5b223bfU, 0x6aba0203U, 0x825ced16U,
+	0x1c2b8acfU, 0xb492a779U, 0xf2f0f307U, 0xe2a14e69U,
+	0xf4cd65daU, 0xbed50605U, 0x621fd134U, 0xfe8ac4a6U,
+	0x539d342eU, 0x55a0a2f3U, 0xe132058aU, 0xeb75a4f6U,
+	0xec390b83U, 0xefaa4060U, 0x9f065e71U, 0x1051bd6eU,
+
+	0x8af93e21U, 0x063d96ddU, 0x05aedd3eU, 0xbd464de6U,
+	0x8db59154U, 0x5d0571c4U, 0xd46f0406U, 0x15ff6050U,
+	0xfb241998U, 0xe997d6bdU, 0x43cc8940U, 0x9e7767d9U,
+	0x42bdb0e8U, 0x8b880789U, 0x5b38e719U, 0xeedb79c8U,
+	0x0a47a17cU, 0x0fe97c42U, 0x1ec9f884U, 0x00000000U,
+	0x86830980U, 0xed48322bU, 0x70ac1e11U, 0x724e6c5aU,
+	0xfffbfd0eU, 0x38560f85U, 0xd51e3daeU, 0x3927362dU,
+	0xd9640a0fU, 0xa621685cU, 0x54d19b5bU, 0x2e3a2436U,
+	0x67b10c0aU, 0xe70f9357U, 0x96d2b4eeU, 0x919e1b9bU,
+	0xc54f80c0U, 0x20a261dcU, 0x4b695a77U, 0x1a161c12U,
+	0xba0ae293U, 0x2ae5c0a0U, 0xe0433c22U, 0x171d121bU,
+	0x0d0b0e09U, 0xc7adf28bU, 0xa8b92db6U, 0xa9c8141eU,
+	0x198557f1U, 0x074caf75U, 0xddbbee99U, 0x60fda37fU,
+	0x269ff701U, 0xf5bc5c72U, 0x3bc54466U, 0x7e345bfbU,
+	0x29768b43U, 0xc6dccb23U, 0xfc68b6edU, 0xf163b8e4U,
+	0xdccad731U, 0x85104263U, 0x22401397U, 0x112084c6U,
+	0x247d854aU, 0x3df8d2bbU, 0x3211aef9U, 0xa16dc729U,
+	0x2f4b1d9eU, 0x30f3dcb2U, 0x52ec0d86U, 0xe3d077c1U,
+	0x166c2bb3U, 0xb999a970U, 0x48fa1194U, 0x642247e9U,
+	0x8cc4a8fcU, 0x3f1aa0f0U, 0x2cd8567dU, 0x90ef2233U,
+	0x4ec78749U, 0xd1c1d938U, 0xa2fe8ccaU, 0x0b3698d4U,
+	0x81cfa6f5U, 0xde28a57aU, 0x8e26dab7U, 0xbfa43fadU,
+	0x9de42c3aU, 0x920d5078U, 0xcc9b6a5fU, 0x4662547eU,
+	0x13c2f68dU, 0xb8e890d8U, 0xf75e2e39U, 0xaff582c3U,
+	0x80be9f5dU, 0x937c69d0U, 0x2da96fd5U, 0x12b3cf25U,
+	0x993bc8acU, 0x7da71018U, 0x636ee89cU, 0xbb7bdb3bU,
+	0x7809cd26U, 0x18f46e59U, 0xb701ec9aU, 0x9aa8834fU,
+	0x6e65e695U, 0xe67eaaffU, 0xcf0821bcU, 0xe8e6ef15U,
+	0x9bd9bae7U, 0x36ce4a6fU, 0x09d4ea9fU, 0x7cd629b0U,
+	0xb2af31a4U, 0x23312a3fU, 0x9430c6a5U, 0x66c035a2U,
+	0xbc37744eU, 0xcaa6fc82U, 0xd0b0e090U, 0xd81533a7U,
+	0x984af104U, 0xdaf741ecU, 0x500e7fcdU, 0xf62f1791U,
+	0xd68d764dU, 0xb04d43efU, 0x4d54ccaaU, 0x04dfe496U,
+	0xb5e39ed1U, 0x881b4c6aU, 0x1fb8c12cU, 0x517f4665U,
+	0xea049d5eU, 0x355d018cU, 0x7473fa87U, 0x412efb0bU,
+	0x1d5ab367U, 0xd25292dbU, 0x5633e910U, 0x47136dd6U,
+	0x618c9ad7U, 0x0c7a37a1U, 0x148e59f8U, 0x3c89eb13U,
+	0x27eecea9U, 0xc935b761U, 0xe5ede11cU, 0xb13c7a47U,
+	0xdf599cd2U, 0x733f55f2U, 0xce791814U, 0x37bf73c7U,
+	0xcdea53f7U, 0xaa5b5ffdU, 0x6f14df3dU, 0xdb867844U,
+	0xf381caafU, 0xc43eb968U, 0x342c3824U, 0x405fc2a3U,
+	0xc372161dU, 0x250cbce2U, 0x498b283cU, 0x9541ff0dU,
+	0x017139a8U, 0xb3de080cU, 0xe49cd8b4U, 0xc1906456U,
+	0x84617bcbU, 0xb670d532U, 0x5c74486cU, 0x5742d0b8U,
+};
+
+static const guint32 Td3[256] = {
+	0xf4a75051U, 0x4165537eU, 0x17a4c31aU, 0x275e963aU,
+	0xab6bcb3bU, 0x9d45f11fU, 0xfa58abacU, 0xe303934bU,
+	0x30fa5520U, 0x766df6adU, 0xcc769188U, 0x024c25f5U,
+	0xe5d7fc4fU, 0x2acbd7c5U, 0x35448026U, 0x62a38fb5U,
+	0xb15a49deU, 0xba1b6725U, 0xea0e9845U, 0xfec0e15dU,
+	0x2f7502c3U, 0x4cf01281U, 0x4697a38dU, 0xd3f9c66bU,
+	0x8f5fe703U, 0x929c9515U, 0x6d7aebbfU, 0x5259da95U,
+	0xbe832dd4U, 0x7421d358U, 0xe0692949U, 0xc9c8448eU,
+	0xc2896a75U, 0x8e7978f4U, 0x583e6b99U, 0xb971dd27U,
+	0xe14fb6beU, 0x88ad17f0U, 0x20ac66c9U, 0xce3ab47dU,
+	0xdf4a1863U, 0x1a3182e5U, 0x51336097U, 0x537f4562U,
+	0x6477e0b1U, 0x6bae84bbU, 0x81a01cfeU, 0x082b94f9U,
+	0x48685870U, 0x45fd198fU, 0xde6c8794U, 0x7bf8b752U,
+	0x73d323abU, 0x4b02e272U, 0x1f8f57e3U, 0x55ab2a66U,
+	0xeb2807b2U, 0xb5c2032fU, 0xc57b9a86U, 0x3708a5d3U,
+	0x2887f230U, 0xbfa5b223U, 0x036aba02U, 0x16825cedU,
+	0xcf1c2b8aU, 0x79b492a7U, 0x07f2f0f3U, 0x69e2a14eU,
+	0xdaf4cd65U, 0x05bed506U, 0x34621fd1U, 0xa6fe8ac4U,
+	0x2e539d34U, 0xf355a0a2U, 0x8ae13205U, 0xf6eb75a4U,
+	0x83ec390bU, 0x60efaa40U, 0x719f065eU, 0x6e1051bdU,
+	0x218af93eU, 0xdd063d96U, 0x3e05aeddU, 0xe6bd464dU,
+	0x548db591U, 0xc45d0571U, 0x06d46f04U, 0x5015ff60U,
+	0x98fb2419U, 0xbde997d6U, 0x4043cc89U, 0xd99e7767U,
+	0xe842bdb0U, 0x898b8807U, 0x195b38e7U, 0xc8eedb79U,
+	0x7c0a47a1U, 0x420fe97cU, 0x841ec9f8U, 0x00000000U,
+	0x80868309U, 0x2bed4832U, 0x1170ac1eU, 0x5a724e6cU,
+	0x0efffbfdU, 0x8538560fU, 0xaed51e3dU, 0x2d392736U,
+	0x0fd9640aU, 0x5ca62168U, 0x5b54d19bU, 0x362e3a24U,
+	0x0a67b10cU, 0x57e70f93U, 0xee96d2b4U, 0x9b919e1bU,
+	0xc0c54f80U, 0xdc20a261U, 0x774b695aU, 0x121a161cU,
+	0x93ba0ae2U, 0xa02ae5c0U, 0x22e0433cU, 0x1b171d12U,
+	0x090d0b0eU, 0x8bc7adf2U, 0xb6a8b92dU, 0x1ea9c814U,
+	0xf1198557U, 0x75074cafU, 0x99ddbbeeU, 0x7f60fda3U,
+	0x01269ff7U, 0x72f5bc5cU, 0x663bc544U, 0xfb7e345bU,
+	0x4329768bU, 0x23c6dccbU, 0xedfc68b6U, 0xe4f163b8U,
+	0x31dccad7U, 0x63851042U, 0x97224013U, 0xc6112084U,
+	0x4a247d85U, 0xbb3df8d2U, 0xf93211aeU, 0x29a16dc7U,
+	0x9e2f4b1dU, 0xb230f3dcU, 0x8652ec0dU, 0xc1e3d077U,
+	0xb3166c2bU, 0x70b999a9U, 0x9448fa11U, 0xe9642247U,
+	0xfc8cc4a8U, 0xf03f1aa0U, 0x7d2cd856U, 0x3390ef22U,
+	0x494ec787U, 0x38d1c1d9U, 0xcaa2fe8cU, 0xd40b3698U,
+	0xf581cfa6U, 0x7ade28a5U, 0xb78e26daU, 0xadbfa43fU,
+	0x3a9de42cU, 0x78920d50U, 0x5fcc9b6aU, 0x7e466254U,
+	0x8d13c2f6U, 0xd8b8e890U, 0x39f75e2eU, 0xc3aff582U,
+	0x5d80be9fU, 0xd0937c69U, 0xd52da96fU, 0x2512b3cfU,
+	0xac993bc8U, 0x187da710U, 0x9c636ee8U, 0x3bbb7bdbU,
+	0x267809cdU, 0x5918f46eU, 0x9ab701ecU, 0x4f9aa883U,
+	0x956e65e6U, 0xffe67eaaU, 0xbccf0821U, 0x15e8e6efU,
+	0xe79bd9baU, 0x6f36ce4aU, 0x9f09d4eaU, 0xb07cd629U,
+	0xa4b2af31U, 0x3f23312aU, 0xa59430c6U, 0xa266c035U,
+	0x4ebc3774U, 0x82caa6fcU, 0x90d0b0e0U, 0xa7d81533U,
+	0x04984af1U, 0xecdaf741U, 0xcd500e7fU, 0x91f62f17U,
+	0x4dd68d76U, 0xefb04d43U, 0xaa4d54ccU, 0x9604dfe4U,
+	0xd1b5e39eU, 0x6a881b4cU, 0x2c1fb8c1U, 0x65517f46U,
+	0x5eea049dU, 0x8c355d01U, 0x877473faU, 0x0b412efbU,
+	0x671d5ab3U, 0xdbd25292U, 0x105633e9U, 0xd647136dU,
+	0xd7618c9aU, 0xa10c7a37U, 0xf8148e59U, 0x133c89ebU,
+	0xa927eeceU, 0x61c935b7U, 0x1ce5ede1U, 0x47b13c7aU,
+	0xd2df599cU, 0xf2733f55U, 0x14ce7918U, 0xc737bf73U,
+	0xf7cdea53U, 0xfdaa5b5fU, 0x3d6f14dfU, 0x44db8678U,
+	0xaff381caU, 0x68c43eb9U, 0x24342c38U, 0xa3405fc2U,
+	0x1dc37216U, 0xe2250cbcU, 0x3c498b28U, 0x0d9541ffU,
+	0xa8017139U, 0x0cb3de08U, 0xb4e49cd8U, 0x56c19064U,
+	0xcb84617bU, 0x32b670d5U, 0x6c5c7448U, 0xb85742d0U,
+};
+
+static const guint32 Td4[256] = {
+    0x52525252U, 0x09090909U, 0x6a6a6a6aU, 0xd5d5d5d5U,
+    0x30303030U, 0x36363636U, 0xa5a5a5a5U, 0x38383838U,
+    0xbfbfbfbfU, 0x40404040U, 0xa3a3a3a3U, 0x9e9e9e9eU,
+    0x81818181U, 0xf3f3f3f3U, 0xd7d7d7d7U, 0xfbfbfbfbU,
+    0x7c7c7c7cU, 0xe3e3e3e3U, 0x39393939U, 0x82828282U,
+    0x9b9b9b9bU, 0x2f2f2f2fU, 0xffffffffU, 0x87878787U,
+    0x34343434U, 0x8e8e8e8eU, 0x43434343U, 0x44444444U,
+    0xc4c4c4c4U, 0xdedededeU, 0xe9e9e9e9U, 0xcbcbcbcbU,
+    0x54545454U, 0x7b7b7b7bU, 0x94949494U, 0x32323232U,
+    0xa6a6a6a6U, 0xc2c2c2c2U, 0x23232323U, 0x3d3d3d3dU,
+    0xeeeeeeeeU, 0x4c4c4c4cU, 0x95959595U, 0x0b0b0b0bU,
+    0x42424242U, 0xfafafafaU, 0xc3c3c3c3U, 0x4e4e4e4eU,
+    0x08080808U, 0x2e2e2e2eU, 0xa1a1a1a1U, 0x66666666U,
+    0x28282828U, 0xd9d9d9d9U, 0x24242424U, 0xb2b2b2b2U,
+    0x76767676U, 0x5b5b5b5bU, 0xa2a2a2a2U, 0x49494949U,
+    0x6d6d6d6dU, 0x8b8b8b8bU, 0xd1d1d1d1U, 0x25252525U,
+    0x72727272U, 0xf8f8f8f8U, 0xf6f6f6f6U, 0x64646464U,
+    0x86868686U, 0x68686868U, 0x98989898U, 0x16161616U,
+    0xd4d4d4d4U, 0xa4a4a4a4U, 0x5c5c5c5cU, 0xccccccccU,
+    0x5d5d5d5dU, 0x65656565U, 0xb6b6b6b6U, 0x92929292U,
+    0x6c6c6c6cU, 0x70707070U, 0x48484848U, 0x50505050U,
+    0xfdfdfdfdU, 0xededededU, 0xb9b9b9b9U, 0xdadadadaU,
+    0x5e5e5e5eU, 0x15151515U, 0x46464646U, 0x57575757U,
+    0xa7a7a7a7U, 0x8d8d8d8dU, 0x9d9d9d9dU, 0x84848484U,
+    0x90909090U, 0xd8d8d8d8U, 0xababababU, 0x00000000U,
+    0x8c8c8c8cU, 0xbcbcbcbcU, 0xd3d3d3d3U, 0x0a0a0a0aU,
+    0xf7f7f7f7U, 0xe4e4e4e4U, 0x58585858U, 0x05050505U,
+    0xb8b8b8b8U, 0xb3b3b3b3U, 0x45454545U, 0x06060606U,
+    0xd0d0d0d0U, 0x2c2c2c2cU, 0x1e1e1e1eU, 0x8f8f8f8fU,
+    0xcacacacaU, 0x3f3f3f3fU, 0x0f0f0f0fU, 0x02020202U,
+    0xc1c1c1c1U, 0xafafafafU, 0xbdbdbdbdU, 0x03030303U,
+    0x01010101U, 0x13131313U, 0x8a8a8a8aU, 0x6b6b6b6bU,
+    0x3a3a3a3aU, 0x91919191U, 0x11111111U, 0x41414141U,
+    0x4f4f4f4fU, 0x67676767U, 0xdcdcdcdcU, 0xeaeaeaeaU,
+    0x97979797U, 0xf2f2f2f2U, 0xcfcfcfcfU, 0xcecececeU,
+    0xf0f0f0f0U, 0xb4b4b4b4U, 0xe6e6e6e6U, 0x73737373U,
+    0x96969696U, 0xacacacacU, 0x74747474U, 0x22222222U,
+    0xe7e7e7e7U, 0xadadadadU, 0x35353535U, 0x85858585U,
+    0xe2e2e2e2U, 0xf9f9f9f9U, 0x37373737U, 0xe8e8e8e8U,
+    0x1c1c1c1cU, 0x75757575U, 0xdfdfdfdfU, 0x6e6e6e6eU,
+    0x47474747U, 0xf1f1f1f1U, 0x1a1a1a1aU, 0x71717171U,
+    0x1d1d1d1dU, 0x29292929U, 0xc5c5c5c5U, 0x89898989U,
+    0x6f6f6f6fU, 0xb7b7b7b7U, 0x62626262U, 0x0e0e0e0eU,
+    0xaaaaaaaaU, 0x18181818U, 0xbebebebeU, 0x1b1b1b1bU,
+    0xfcfcfcfcU, 0x56565656U, 0x3e3e3e3eU, 0x4b4b4b4bU,
+    0xc6c6c6c6U, 0xd2d2d2d2U, 0x79797979U, 0x20202020U,
+    0x9a9a9a9aU, 0xdbdbdbdbU, 0xc0c0c0c0U, 0xfefefefeU,
+    0x78787878U, 0xcdcdcdcdU, 0x5a5a5a5aU, 0xf4f4f4f4U,
+    0x1f1f1f1fU, 0xddddddddU, 0xa8a8a8a8U, 0x33333333U,
+    0x88888888U, 0x07070707U, 0xc7c7c7c7U, 0x31313131U,
+    0xb1b1b1b1U, 0x12121212U, 0x10101010U, 0x59595959U,
+    0x27272727U, 0x80808080U, 0xececececU, 0x5f5f5f5fU,
+    0x60606060U, 0x51515151U, 0x7f7f7f7fU, 0xa9a9a9a9U,
+    0x19191919U, 0xb5b5b5b5U, 0x4a4a4a4aU, 0x0d0d0d0dU,
+    0x2d2d2d2dU, 0xe5e5e5e5U, 0x7a7a7a7aU, 0x9f9f9f9fU,
+    0x93939393U, 0xc9c9c9c9U, 0x9c9c9c9cU, 0xefefefefU,
+    0xa0a0a0a0U, 0xe0e0e0e0U, 0x3b3b3b3bU, 0x4d4d4d4dU,
+    0xaeaeaeaeU, 0x2a2a2a2aU, 0xf5f5f5f5U, 0xb0b0b0b0U,
+    0xc8c8c8c8U, 0xebebebebU, 0xbbbbbbbbU, 0x3c3c3c3cU,
+    0x83838383U, 0x53535353U, 0x99999999U, 0x61616161U,
+    0x17171717U, 0x2b2b2b2bU, 0x04040404U, 0x7e7e7e7eU,
+    0xbabababaU, 0x77777777U, 0xd6d6d6d6U, 0x26262626U,
+    0xe1e1e1e1U, 0x69696969U, 0x14141414U, 0x63636363U,
+    0x55555555U, 0x21212121U, 0x0c0c0c0cU, 0x7d7d7d7dU,
+};
+
+static const guint32 rcon[] = {
+	0x01000000, 0x02000000, 0x04000000, 0x08000000,
+	0x10000000, 0x20000000, 0x40000000, 0x80000000,
+	0x1B000000, 0x36000000, /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */
+};
+
+static gint rijndaelKeySetupEnc(
+	guint32 rk[/*4*(Nr + 1)*/],
+	const guint8 cipherKey[],
+        gint keyBits)
+{
+	gint i = 0;
+	guint32 temp;
+
+	if (!(keyBits == 128 || keyBits == 192 || keyBits == 256))
+		return -1;
+
+	rk[0] = GETU32(cipherKey     );
+	rk[1] = GETU32(cipherKey +  4);
+	rk[2] = GETU32(cipherKey +  8);
+	rk[3] = GETU32(cipherKey + 12);
+	if (keyBits == 128) {
+		for (;;) {
+			temp  = rk[3];
+			rk[4] = rk[0] ^
+				(Te4[(temp >> 16) & 0xff] & 0xff000000) ^
+				(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
+				(Te4[(temp      ) & 0xff] & 0x0000ff00) ^
+				(Te4[(temp >> 24)       ] & 0x000000ff) ^
+				rcon[i];
+			rk[5] = rk[1] ^ rk[4];
+			rk[6] = rk[2] ^ rk[5];
+			rk[7] = rk[3] ^ rk[6];
+			if (++i == 10) {
+				return 10;
+			}
+			rk += 4;
+		}
+	}
+	rk[4] = GETU32(cipherKey + 16);
+	rk[5] = GETU32(cipherKey + 20);
+	if (keyBits == 192) {
+		for (;;) {
+			temp = rk[ 5];
+			rk[ 6] = rk[ 0] ^
+				(Te4[(temp >> 16) & 0xff] & 0xff000000) ^
+				(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
+				(Te4[(temp      ) & 0xff] & 0x0000ff00) ^
+				(Te4[(temp >> 24)       ] & 0x000000ff) ^
+				rcon[i];
+			rk[ 7] = rk[ 1] ^ rk[ 6];
+			rk[ 8] = rk[ 2] ^ rk[ 7];
+			rk[ 9] = rk[ 3] ^ rk[ 8];
+			if (++i == 8) {
+				return 12;
+			}
+			rk[10] = rk[ 4] ^ rk[ 9];
+			rk[11] = rk[ 5] ^ rk[10];
+			rk += 6;
+		}
+	}
+	rk[6] = GETU32(cipherKey + 24);
+	rk[7] = GETU32(cipherKey + 28);
+	if (keyBits == 256) {
+		for (;;) {
+			temp = rk[ 7];
+			rk[ 8] = rk[ 0] ^
+				(Te4[(temp >> 16) & 0xff] & 0xff000000) ^
+				(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
+				(Te4[(temp      ) & 0xff] & 0x0000ff00) ^
+				(Te4[(temp >> 24)       ] & 0x000000ff) ^
+				rcon[i];
+			rk[ 9] = rk[ 1] ^ rk[ 8];
+			rk[10] = rk[ 2] ^ rk[ 9];
+			rk[11] = rk[ 3] ^ rk[10];
+			if (++i == 7) {
+				return 14;
+			}
+			temp = rk[11];
+			rk[12] = rk[ 4] ^
+				(Te4[(temp >> 24)       ] & 0xff000000) ^
+				(Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^
+				(Te4[(temp >>  8) & 0xff] & 0x0000ff00) ^
+				(Te4[(temp      ) & 0xff] & 0x000000ff);
+			rk[13] = rk[ 5] ^ rk[12];
+			rk[14] = rk[ 6] ^ rk[13];
+			rk[15] = rk[ 7] ^ rk[14];
+
+			rk += 8;
+		}
+	}
+	return 0;
+}
+
+static gint rijndaelKeySetupDec(
+	guint32 rk[/*4*(Nr + 1)*/],
+	const guint8 cipherKey[],
+	gint keyBits)
+{
+	gint Nr, i, j;
+	guint32 temp;
+
+	/* expand the cipher key: */
+	Nr = rijndaelKeySetupEnc(rk, cipherKey, keyBits);
+	/* invert the order of the round keys: */
+	for (i = 0, j = 4*Nr; i < j; i += 4, j -= 4) {
+		temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;
+		temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;
+		temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;
+		temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;
+	}
+	/* apply the inverse MixColumn transform to all round keys but the first and the last: */
+	for (i = 1; i < Nr; i++) {
+		rk += 4;
+		rk[0] =
+			Td0[Te4[(rk[0] >> 24)       ] & 0xff] ^
+			Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^
+			Td2[Te4[(rk[0] >>  8) & 0xff] & 0xff] ^
+			Td3[Te4[(rk[0]      ) & 0xff] & 0xff];
+		rk[1] =
+			Td0[Te4[(rk[1] >> 24)       ] & 0xff] ^
+			Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^
+			Td2[Te4[(rk[1] >>  8) & 0xff] & 0xff] ^
+			Td3[Te4[(rk[1]      ) & 0xff] & 0xff];
+		rk[2] =
+			Td0[Te4[(rk[2] >> 24)       ] & 0xff] ^
+			Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^
+			Td2[Te4[(rk[2] >>  8) & 0xff] & 0xff] ^
+			Td3[Te4[(rk[2]      ) & 0xff] & 0xff];
+		rk[3] =
+			Td0[Te4[(rk[3] >> 24)       ] & 0xff] ^
+			Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^
+			Td2[Te4[(rk[3] >>  8) & 0xff] & 0xff] ^
+			Td3[Te4[(rk[3]      ) & 0xff] & 0xff];
+	}
+	return Nr;
+}
+
+/* TODO: this is inefficient. We are building both the encryption and decryption key
+         regardless of how we want to use the key. Would be faster to build the one
+         key we need. */
+void fdesc_rijndael_set_key(
+	rijndael_ctx *ctx,
+	const guchar *key,
+	gint bits)
+{
+	ctx->Nr = rijndaelKeySetupEnc(ctx->ek, key, bits);
+	rijndaelKeySetupDec(ctx->dk, key, bits);
+}
+
+static void rijndaelEncrypt(
+	const guint32 rk[/*4*(Nr + 1)*/],
+	gint Nr,
+	const guint8 pt[16],
+	guint8 ct[16])
+{
+	guint32 s0, s1, s2, s3, t0, t1, t2, t3;
+#ifndef FULL_UNROLL
+	gint r;
+#endif /* ?FULL_UNROLL */
+
+	/*
+	* map byte array block to cipher state
+	* and add initial round key:
+	*/
+	s0 = GETU32(pt     ) ^ rk[0];
+	s1 = GETU32(pt +  4) ^ rk[1];
+	s2 = GETU32(pt +  8) ^ rk[2];
+	s3 = GETU32(pt + 12) ^ rk[3];
+#ifdef FULL_UNROLL
+	/* round 1: */
+	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 4];
+	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 5];
+	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 6];
+	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 7];
+	/* round 2: */
+	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 8];
+	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 9];
+	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];
+	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];
+	/* round 3: */
+	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[12];
+	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[13];
+	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[14];
+	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[15];
+	/* round 4: */
+	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[16];
+	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[17];
+	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[18];
+	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[19];
+	/* round 5: */
+	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[20];
+	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[21];
+	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[22];
+	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[23];
+	/* round 6: */
+	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[24];
+	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[25];
+	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[26];
+	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[27];
+	/* round 7: */
+	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[28];
+	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[29];
+	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[30];
+	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[31];
+	/* round 8: */
+	s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[32];
+	s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[33];
+	s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[34];
+	s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[35];
+	/* round 9: */
+	t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[36];
+	t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[37];
+	t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[38];
+	t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[39];
+	if (Nr > 10) {
+		/* round 10: */
+		s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[40];
+		s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[41];
+		s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[42];
+		s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[43];
+		/* round 11: */
+		t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[44];
+		t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[45];
+		t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[46];
+		t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[47];
+		if (Nr > 12) {
+			/* round 12: */
+			s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[48];
+			s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[49];
+			s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[50];
+			s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[51];
+			/* round 13: */
+			t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[52];
+			t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[53];
+			t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[54];
+			t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[55];
+		}
+	}
+	rk += Nr << 2;
+#else  /* !FULL_UNROLL */
+	/*
+	* Nr - 1 full rounds:
+	*/
+	r = Nr >> 1;
+	for (;;) {
+		t0 =
+			Te0[(s0 >> 24)       ] ^
+			Te1[(s1 >> 16) & 0xff] ^
+			Te2[(s2 >>  8) & 0xff] ^
+			Te3[(s3      ) & 0xff] ^
+			rk[4];
+		t1 =
+			Te0[(s1 >> 24)       ] ^
+			Te1[(s2 >> 16) & 0xff] ^
+			Te2[(s3 >>  8) & 0xff] ^
+			Te3[(s0      ) & 0xff] ^
+			rk[5];
+		t2 =
+			Te0[(s2 >> 24)       ] ^
+			Te1[(s3 >> 16) & 0xff] ^
+			Te2[(s0 >>  8) & 0xff] ^
+			Te3[(s1      ) & 0xff] ^
+			rk[6];
+		t3 =
+			Te0[(s3 >> 24)       ] ^
+			Te1[(s0 >> 16) & 0xff] ^
+			Te2[(s1 >>  8) & 0xff] ^
+			Te3[(s2      ) & 0xff] ^
+			rk[7];
+
+		rk += 8;
+		if (--r == 0) {
+			break;
+		}
+
+		s0 =
+			Te0[(t0 >> 24)       ] ^
+			Te1[(t1 >> 16) & 0xff] ^
+			Te2[(t2 >>  8) & 0xff] ^
+			Te3[(t3      ) & 0xff] ^
+			rk[0];
+		s1 =
+			Te0[(t1 >> 24)       ] ^
+			Te1[(t2 >> 16) & 0xff] ^
+			Te2[(t3 >>  8) & 0xff] ^
+			Te3[(t0      ) & 0xff] ^
+			rk[1];
+		s2 =
+			Te0[(t2 >> 24)       ] ^
+			Te1[(t3 >> 16) & 0xff] ^
+			Te2[(t0 >>  8) & 0xff] ^
+			Te3[(t1      ) & 0xff] ^
+			rk[2];
+		s3 =
+			Te0[(t3 >> 24)       ] ^
+			Te1[(t0 >> 16) & 0xff] ^
+			Te2[(t1 >>  8) & 0xff] ^
+			Te3[(t2      ) & 0xff] ^
+			rk[3];
+	}
+#endif /* ?FULL_UNROLL */
+	/*
+	* apply last round and
+	* map cipher state to byte array block:
+	*/
+	s0 =
+		(Te4[(t0 >> 24)       ] & 0xff000000) ^
+		(Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^
+		(Te4[(t2 >>  8) & 0xff] & 0x0000ff00) ^
+		(Te4[(t3      ) & 0xff] & 0x000000ff) ^
+		rk[0];
+	PUTU32(ct     , s0);
+	s1 =
+		(Te4[(t1 >> 24)       ] & 0xff000000) ^
+		(Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^
+		(Te4[(t3 >>  8) & 0xff] & 0x0000ff00) ^
+		(Te4[(t0      ) & 0xff] & 0x000000ff) ^
+		rk[1];
+	PUTU32(ct +  4, s1);
+	s2 =
+		(Te4[(t2 >> 24)       ] & 0xff000000) ^
+		(Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^
+		(Te4[(t0 >>  8) & 0xff] & 0x0000ff00) ^
+		(Te4[(t1      ) & 0xff] & 0x000000ff) ^
+		rk[2];
+	PUTU32(ct +  8, s2);
+	s3 =
+		(Te4[(t3 >> 24)       ] & 0xff000000) ^
+		(Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^
+		(Te4[(t1 >>  8) & 0xff] & 0x0000ff00) ^
+		(Te4[(t2      ) & 0xff] & 0x000000ff) ^
+		rk[3];
+	PUTU32(ct + 12, s3);
+}
+
+void fdesc_rijndael_encrypt(
+	const rijndael_ctx *ctx,
+	const guchar *src,
+	guchar *dst)
+{
+
+	rijndaelEncrypt(ctx->ek, ctx->Nr, src, dst);
+}
+
+
+static void rijndaelDecrypt(const guint32 rk[/*4*(Nr + 1)*/], gint Nr, const guint8 ct[16], guint8 pt[16]) {
+	guint32 s0, s1, s2, s3, t0, t1, t2, t3;
+#ifndef FULL_UNROLL
+    gint r;
+#endif /* ?FULL_UNROLL */
+
+    /*
+	 * map byte array block to cipher state
+	 * and add initial round key:
+	 */
+    s0 = GETU32(ct     ) ^ rk[0];
+    s1 = GETU32(ct +  4) ^ rk[1];
+    s2 = GETU32(ct +  8) ^ rk[2];
+    s3 = GETU32(ct + 12) ^ rk[3];
+#ifdef FULL_UNROLL
+    /* round 1: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[ 4];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[ 5];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[ 6];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[ 7];
+    /* round 2: */
+    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[ 8];
+    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[ 9];
+    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[10];
+    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[11];
+    /* round 3: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[12];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[13];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[14];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[15];
+    /* round 4: */
+    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[16];
+    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[17];
+    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[18];
+    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[19];
+    /* round 5: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[20];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[21];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[22];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[23];
+    /* round 6: */
+    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[24];
+    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[25];
+    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[26];
+    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[27];
+    /* round 7: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[28];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[29];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[30];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[31];
+    /* round 8: */
+    s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[32];
+    s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[33];
+    s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[34];
+    s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[35];
+    /* round 9: */
+    t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[36];
+    t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[37];
+    t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[38];
+    t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[39];
+    if (Nr > 10) {
+        /* round 10: */
+        s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[40];
+        s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[41];
+        s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[42];
+        s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[43];
+        /* round 11: */
+        t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[44];
+        t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[45];
+        t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[46];
+        t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[47];
+        if (Nr > 12) {
+            /* round 12: */
+            s0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[48];
+            s1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[49];
+            s2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[50];
+            s3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[51];
+            /* round 13: */
+            t0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[52];
+            t1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[53];
+            t2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[54];
+            t3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[55];
+        }
+    }
+	rk += Nr << 2;
+#else  /* !FULL_UNROLL */
+    /*
+     * Nr - 1 full rounds:
+     */
+    r = Nr >> 1;
+    for (;;) {
+        t0 =
+            Td0[(s0 >> 24)       ] ^
+            Td1[(s3 >> 16) & 0xff] ^
+            Td2[(s2 >>  8) & 0xff] ^
+            Td3[(s1      ) & 0xff] ^
+            rk[4];
+        t1 =
+            Td0[(s1 >> 24)       ] ^
+            Td1[(s0 >> 16) & 0xff] ^
+            Td2[(s3 >>  8) & 0xff] ^
+            Td3[(s2      ) & 0xff] ^
+            rk[5];
+        t2 =
+            Td0[(s2 >> 24)       ] ^
+            Td1[(s1 >> 16) & 0xff] ^
+            Td2[(s0 >>  8) & 0xff] ^
+            Td3[(s3      ) & 0xff] ^
+            rk[6];
+        t3 =
+            Td0[(s3 >> 24)       ] ^
+            Td1[(s2 >> 16) & 0xff] ^
+            Td2[(s1 >>  8) & 0xff] ^
+            Td3[(s0      ) & 0xff] ^
+            rk[7];
+
+        rk += 8;
+        if (--r == 0) {
+            break;
+        }
+
+        s0 =
+            Td0[(t0 >> 24)       ] ^
+            Td1[(t3 >> 16) & 0xff] ^
+            Td2[(t2 >>  8) & 0xff] ^
+            Td3[(t1      ) & 0xff] ^
+            rk[0];
+        s1 =
+            Td0[(t1 >> 24)       ] ^
+            Td1[(t0 >> 16) & 0xff] ^
+            Td2[(t3 >>  8) & 0xff] ^
+            Td3[(t2      ) & 0xff] ^
+            rk[1];
+        s2 =
+            Td0[(t2 >> 24)       ] ^
+            Td1[(t1 >> 16) & 0xff] ^
+            Td2[(t0 >>  8) & 0xff] ^
+            Td3[(t3      ) & 0xff] ^
+            rk[2];
+        s3 =
+            Td0[(t3 >> 24)       ] ^
+            Td1[(t2 >> 16) & 0xff] ^
+            Td2[(t1 >>  8) & 0xff] ^
+            Td3[(t0      ) & 0xff] ^
+            rk[3];
+    }
+#endif /* ?FULL_UNROLL */
+    /*
+	 * apply last round and
+	 * map cipher state to byte array block:
+	 */
+   	s0 =
+   		(Td4[(t0 >> 24)       ] & 0xff000000) ^
+   		(Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^
+   		(Td4[(t2 >>  8) & 0xff] & 0x0000ff00) ^
+   		(Td4[(t1      ) & 0xff] & 0x000000ff) ^
+   		rk[0];
+	PUTU32(pt     , s0);
+   	s1 =
+   		(Td4[(t1 >> 24)       ] & 0xff000000) ^
+   		(Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^
+   		(Td4[(t3 >>  8) & 0xff] & 0x0000ff00) ^
+   		(Td4[(t2      ) & 0xff] & 0x000000ff) ^
+   		rk[1];
+	PUTU32(pt +  4, s1);
+   	s2 =
+   		(Td4[(t2 >> 24)       ] & 0xff000000) ^
+   		(Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^
+   		(Td4[(t0 >>  8) & 0xff] & 0x0000ff00) ^
+   		(Td4[(t3      ) & 0xff] & 0x000000ff) ^
+   		rk[2];
+	PUTU32(pt +  8, s2);
+   	s3 =
+   		(Td4[(t3 >> 24)       ] & 0xff000000) ^
+   		(Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^
+   		(Td4[(t1 >>  8) & 0xff] & 0x0000ff00) ^
+   		(Td4[(t0      ) & 0xff] & 0x000000ff) ^
+   		rk[3];
+	PUTU32(pt + 12, s3);
+}
+
+
+void fdesc_rijndael_decrypt(
+	const rijndael_ctx *ctx,
+	const guchar *src,
+	guchar *dst)
+{
+	rijndaelDecrypt(ctx->dk, ctx->Nr, src, dst);
+}
+
+
diff --git a/plugins/epan/generic/shark_wsutil_aes.h b/plugins/epan/generic/shark_wsutil_aes.h
new file mode 100644
index 00000000000..69dfd41991f
--- /dev/null
+++ b/plugins/epan/generic/shark_wsutil_aes.h
@@ -0,0 +1,66 @@
+/**
+ * aes.h
+ *
+ * Copied from airpdcap_rijndael.h
+ *
+ * @version 3.0 (December 2000)
+ *
+ * Optimised ANSI C code for the Rijndael cipher (now AES)
+ *
+ * @author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be>
+ * @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be>
+ * @author Paulo Barreto <paulo.barreto@terra.com.br>
+ *
+ * This code is hereby placed in the public domain.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Note: copied AirPDcap/rijndael/rijndael.h */
+
+#ifndef	_AES
+#define	_AES
+
+//#include "ws_symbol_export.h"
+
+#define RIJNDAEL_MAXKC  (256/32)
+#define RIJNDAEL_MAXKB  (256/8)
+#define RIJNDAEL_MAXNR  14
+
+typedef struct s_rijndael_ctx {
+	gint     Nr;             /* key-length-dependent number of rounds */
+	guint32  ek[4 * (RIJNDAEL_MAXNR + 1)];  /* encrypt key schedule */
+	guint32  dk[4 * (RIJNDAEL_MAXNR + 1)];  /* decrypt key schedule */
+} rijndael_ctx;
+
+
+//WS_DLL_PUBLIC
+void fdesc_rijndael_set_key(
+	rijndael_ctx *ctx,
+	const guchar *key,
+	gint bits);
+
+//WS_DLL_PUBLIC
+void fdesc_rijndael_encrypt(
+	const rijndael_ctx *ctx,
+	const guchar *src,
+	guchar *dst);
+
+//WS_DLL_PUBLIC
+void fdesc_rijndael_decrypt(
+	const rijndael_ctx *ctx,
+	const guchar *src,
+	guchar *dst);
+
+
+#endif
diff --git a/plugins/epan/generic/unitary_test_build_field.cpp b/plugins/epan/generic/unitary_test_build_field.cpp
new file mode 100644
index 00000000000..839382b79d8
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_build_field.cpp
@@ -0,0 +1,435 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+
+#define M_TEST_EXPR_STR_EQ(VAL1,VAL2)            M_TEST_EQ(VAL1,VAL2)
+
+
+//*****************************************************************************
+// test_build_field
+//*****************************************************************************
+
+M_TEST_FCT(test_build_field)
+{
+    T_type_definitions    type_definitions;
+
+    // Field 
+    {
+        string         first_word = "uint3";
+        istringstream  iss("toto;follow");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "follow");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false);                  // var
+        M_TEST_EQ(field_type_name.orig_type, "uint3");
+        M_TEST_EQ(field_type_name.type, "uint3");                           // type
+        M_TEST_EQ(field_type_name.basic_type_bit_size, 3);
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "toto");
+        M_TEST_EQ(field_type_name.get_display_name(), "toto");
+        M_TEST_EQ(field_type_name.get_filter_name(), "toto");
+        M_TEST_EQ(field_type_name.get_extended_name(), "toto");
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // Field var float
+    {
+        string         first_word = "var";
+        istringstream  iss("float32  val = 12;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), true);                   // var
+        M_TEST_EQ(field_type_name.orig_type, "float32");
+        M_TEST_EQ(field_type_name.type, "float32");                         // type
+        M_TEST_EQ(field_type_name.basic_type_bit_size, 32);
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), true);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "val");
+        M_TEST_EQ(field_type_name.get_display_name(), "val");
+        M_TEST_EQ(field_type_name.get_filter_name(), "val");
+        M_TEST_EQ(field_type_name.get_extended_name(), "val");
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "12");
+        M_TEST_EQ(field_type_name.get_var_expression().compute_expression_static(type_definitions).get_int(), 12);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // Field var float
+    {
+        string         first_word = "var";
+        istringstream  iss("float32  val = 12.3;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), true);                   // var
+        M_TEST_EQ(field_type_name.orig_type, "float32");
+        M_TEST_EQ(field_type_name.type, "float32");                         // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), true);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "val");
+        M_TEST_EQ(field_type_name.get_display_name(), "val");
+        M_TEST_EQ(field_type_name.get_filter_name(), "val");
+        M_TEST_EQ(field_type_name.get_extended_name(), "val");
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "12.3");
+        M_TEST_EQ(field_type_name.get_var_expression().compute_expression_static(type_definitions).get_flt(), 12.3);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // Field var float
+    {
+        string         first_word = "var";
+        istringstream  iss("float32  val = 12.3e2;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), true);                   // var
+        M_TEST_EQ(field_type_name.orig_type, "float32");
+        M_TEST_EQ(field_type_name.type, "float32");                         // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), true);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "val");
+        M_TEST_EQ(field_type_name.get_display_name(), "val");
+        M_TEST_EQ(field_type_name.get_filter_name(), "val");
+        M_TEST_EQ(field_type_name.get_extended_name(), "val");
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "12.3e2");
+        M_TEST_EQ(field_type_name.get_var_expression().compute_expression_static(type_definitions).get_flt(), 1230.0);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // Field with {...} and spaces
+    {
+        string         first_word = "hide";
+        istringstream  iss(" var"
+            " uint3{ns=0}"
+            " toto = 4;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+    }
+    {
+        string         first_word = "hide";
+        istringstream  iss(" var"
+            " uint3{ns=0}{q=.2:o=-.2}"
+            " toto = 4;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+    }
+    {
+        string         first_word = "hide";
+        istringstream  iss(" var"
+            " uint3{ns=0}{q=.2:o=-.2}{min=-3.2:max=2.3}{de=\"hello world\"}[ val + 2 ]"
+            " toto = 4;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), true);                       // hide
+        M_TEST_EQ(field_type_name.is_a_variable(), true);                   // var
+        M_TEST_EQ(field_type_name.orig_type, "uint3{ns=0}{q=.2:o=-.2}{min=-3.2:max=2.3}{de=\"hello world\"}[ val + 2 ]");
+        M_TEST_EQ(field_type_name.type, "uint3");                           // type
+        M_TEST_EQ(field_type_name.no_statement.get_int(), 0);               // ns
+        M_TEST_EQ(field_type_name.transform_quantum.get_flt(), 0.2);        // q
+        M_TEST_EQ(field_type_name.transform_offset.get_flt(), -0.2);        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), true);
+        M_TEST_EQ(field_type_name.constraints.size(), 1);                   // min & max
+        M_TEST_EQ(field_type_name.constraints[0].min.get_flt(), -3.2);      // min
+        M_TEST_EQ(field_type_name.constraints[0].max.get_flt(), 2.3);       // max
+        M_TEST_EQ(field_type_name.str_display_expression, "\"hello world\"");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 1);
+        M_TEST_EQ(field_type_name.str_arrays[0].size_type, T_field_type_name::T_array::E_size_normal);
+        M_TEST_EQ(field_type_name.str_arrays[0].size_expression.get_original_string_expression(), " val + 2 ");
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "toto");
+        M_TEST_EQ(field_type_name.get_display_name(), "toto");
+        M_TEST_EQ(field_type_name.get_filter_name(), "toto");
+        M_TEST_EQ(field_type_name.get_extended_name(), "toto");
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "4");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // Field 
+    {
+        string         first_word = "uint3{de='hello' + ' world'}";
+        istringstream  iss("toto;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.type, "uint3");                           // type
+        M_TEST_EQ(field_type_name.str_display_expression, "'hello' + ' world'");
+        M_TEST_EQ(field_type_name.name, "toto");
+    }
+
+    // Field with transform expression
+    {
+        string         first_word = "hide";
+        istringstream  iss(" "
+            " uint3{ns=0}{tef=.2*this-.2}{min=-3.2:max=2.3}[ val + 2 ]"
+            " toto;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), true);                       // hide
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "uint3{ns=0}{tef=.2*this-.2}{min=-3.2:max=2.3}[ val + 2 ]");
+        M_TEST_EQ(field_type_name.type, "uint3");                           // type
+        M_TEST_EQ(field_type_name.no_statement.get_int(), 0);               // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.get_original_string_expression(), ".2*this-.2");
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_float);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), true);
+        M_TEST_EQ(field_type_name.constraints.size(), 1);                   // min & max
+        M_TEST_EQ(field_type_name.constraints[0].min.get_flt(), -3.2);      // min
+        M_TEST_EQ(field_type_name.constraints[0].max.get_flt(), 2.3);       // max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 1);
+        M_TEST_EQ(field_type_name.str_arrays[0].size_type, T_field_type_name::T_array::E_size_normal);
+        M_TEST_TRIM_EQ(field_type_name.str_arrays[0].size_expression.get_original_string_expression(), " val + 2 ");
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "toto");
+        M_TEST_EQ(field_type_name.get_display_name(), "toto");
+        M_TEST_EQ(field_type_name.get_filter_name(), "toto");
+        M_TEST_EQ(field_type_name.get_extended_name(), "toto");
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // Field with size and specifications before and after
+    {
+        string         first_word = "hide";
+        istringstream  iss(" "
+            " string{decoder=decode_utf8}(50){d=string is %s}[ val + 2 ]"
+            " toto;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), true);                       // hide
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "string{decoder=decode_utf8}(50){d=string is %s}[ val + 2 ]");
+        M_TEST_EQ(field_type_name.type, "string");                          // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_decoder_function, "decode_utf8");
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "50");
+        M_TEST_EQ(field_type_name.str_display, "string is %s");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 1);
+        M_TEST_EQ(field_type_name.str_arrays[0].size_type, T_field_type_name::T_array::E_size_normal);
+        M_TEST_TRIM_EQ(field_type_name.str_arrays[0].size_expression.get_original_string_expression(), " val + 2 ");
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "50");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "decode_utf8");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "toto");
+        M_TEST_EQ(field_type_name.get_display_name(), "toto");
+        M_TEST_EQ(field_type_name.get_filter_name(), "toto");
+        M_TEST_EQ(field_type_name.get_extended_name(), "toto");
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_build_field_bitfield_bitstream.cpp b/plugins/epan/generic/unitary_test_build_field_bitfield_bitstream.cpp
new file mode 100644
index 00000000000..fd61beaab99
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_build_field_bitfield_bitstream.cpp
@@ -0,0 +1,181 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+
+#define M_TEST_EXPR_STR_EQ(VAL1,VAL2)            M_TEST_EQ(VAL1,VAL2)
+
+
+//*****************************************************************************
+// test_build_field_bitfield_bitstream
+//*****************************************************************************
+
+M_TEST_FCT(test_build_field_bitfield_bitstream)
+{
+    T_type_definitions    type_definitions;
+
+    // bitfield inline
+    {
+        string         first_word = "forget";
+        istringstream  iss(" "
+            " bitfield16"
+            " {"
+            "   uint1  c0;"
+            "   uint3  c1;"
+            " } toto;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, true);                       // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "bitfield");                        // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "toto");
+        M_TEST_EQ(field_type_name.get_display_name(), "toto");
+        M_TEST_EQ(field_type_name.get_filter_name(), "toto");
+        M_TEST_EQ(field_type_name.get_extended_name(), "toto");
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_EQ(field_type_name.P_bitfield_inline->is_a_bitstream, false);
+        M_TEST_EQ(field_type_name.P_bitfield_inline->master_field.type, "uint16");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->master_field.name, "last_bitfield_value");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->master_field.output_directive, T_field_type_name::E_output_directive_hide);
+        M_TEST_EQ(field_type_name.P_bitfield_inline->master_field.str_display, "hex");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition.size(), 2);
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[0].type, "uint32");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[0].name, "c0");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[0].is_a_variable(), true);
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[0].get_var_expression().get_original_string_expression(),
+                                                                          "((last_bitfield_value >> 0) & 1)");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[1].type, "uint32");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[1].name, "c1");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[1].is_a_variable(), true);
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[1].get_var_expression().get_original_string_expression(),
+                                                                          "((last_bitfield_value >> 1) & 7)");
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // bitstream inline
+    {
+        string         first_word = "forget";
+        istringstream  iss(" "
+            " bitstream24"
+            " {"
+            "   var int64  hc = 123456789;"
+            "   uint1  c0;"
+            "   set c0 = 1;"
+            "   uint3  c1;"
+            " } toto;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, true);                       // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "bitfield");                        // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "toto");
+        M_TEST_EQ(field_type_name.get_display_name(), "toto");
+        M_TEST_EQ(field_type_name.get_filter_name(), "toto");
+        M_TEST_EQ(field_type_name.get_extended_name(), "toto");
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_EQ(field_type_name.P_bitfield_inline->is_a_bitstream, true);
+        M_TEST_EQ(field_type_name.P_bitfield_inline->master_field.type, "uint24");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->master_field.name, "last_bitfield_value");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->master_field.output_directive, T_field_type_name::E_output_directive_hide);
+        M_TEST_EQ(field_type_name.P_bitfield_inline->master_field.str_display, "hex");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition.size(), 4);
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[0].type, "int64");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[0].name, "hc");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[1].type, "uint32");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[1].name, "c0");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[1].is_a_variable(), true);
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[1].get_var_expression().get_original_string_expression(),
+                                                                          "((last_bitfield_value >> 23) & 1)");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[2].type, "set");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[2].name, "c0");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[3].type, "uint32");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[3].name, "c1");
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[3].is_a_variable(), true);
+        M_TEST_EQ(field_type_name.P_bitfield_inline->fields_definition[3].get_var_expression().get_original_string_expression(),
+                                                                          "((last_bitfield_value >> 20) & 7)");
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_build_field_call_function.cpp b/plugins/epan/generic/unitary_test_build_field_call_function.cpp
new file mode 100644
index 00000000000..7d2ab9c0613
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_build_field_call_function.cpp
@@ -0,0 +1,299 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+
+#define M_TEST_EXPR_STR_EQ(VAL1,VAL2)            M_TEST_EQ(VAL1,VAL2)
+
+
+//*****************************************************************************
+// test_build_field_call_function
+//*****************************************************************************
+
+M_TEST_FCT(test_build_field_call_function)
+{
+    T_type_definitions    type_definitions;
+
+    // Add some types
+    istringstream         iss(
+        "function void  return_nothing () "
+        "{ "
+        "} "
+        "function void  return_nothing_2 (in int64  value, out bool8  value_modified) "
+        "{ "
+        "} "
+    );
+    build_types(iss, type_definitions);
+
+    // call function
+    {
+        string         first_word = "call";
+        istringstream  iss(" "
+            " return_nothing ();");      // space is currently mandatory
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "call");                            // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "return_nothing");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // call function
+    {
+        string         first_word = "call";
+        istringstream  iss(" "
+            " return_nothing_2 (12+7, 1 - 1 );");      // space is currently mandatory
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "call");                            // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "return_nothing_2");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 2);
+        M_TEST_EQ(field_type_name.fct_parameters[0].get_original_string_expression(), "12+7");
+        M_TEST_EQ(field_type_name.fct_parameters[1].get_original_string_expression(), "1 - 1");
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // call inner function (...) 
+    {
+        string         first_word = "chat";
+        istringstream  iss("(12+7, 1 - 1 );");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "chat");                            // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "(12+7, 1 - 1 )");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // call inner function "..."
+    {
+        string         first_word = "print";
+        istringstream  iss(" \"Yo les potos\" ;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "print");                           // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "\"Yo les potos\"");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // call inner function name.*
+    {
+        string         first_word = "debug_print";
+        istringstream  iss(" name.* ;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "debug_print");                     // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "name.*");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_build_field_const_enum.cpp b/plugins/epan/generic/unitary_test_build_field_const_enum.cpp
new file mode 100644
index 00000000000..dee48cb4f13
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_build_field_const_enum.cpp
@@ -0,0 +1,165 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+
+#define M_TEST_EXPR_STR_EQ(VAL1,VAL2)            M_TEST_EQ(VAL1,VAL2)
+
+
+//*****************************************************************************
+// test_build_field_const_enum
+//*****************************************************************************
+
+M_TEST_FCT(test_build_field_const_enum)
+{
+    T_type_definitions    type_definitions;
+
+    // Add some types
+    build_types ("unitary_tests_basic.fdesc",
+                 type_definitions);
+
+    // Use const and enum (::) in many places
+    {
+        string         first_word = "hide";
+        istringstream  iss(" "
+            " uint3"
+            "{ns=T_enum3::value0}"
+            "{q=konst::int_enum:o=T_enum4::Val13}"
+            "{min=konst::int_enum:max=T_enum4::Val13}"
+            "[ val + T_enum2::enu2 ]"
+            " toto;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), true);                       // hide
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "uint3"
+                                             "{ns=T_enum3::value0}"
+                                             "{q=konst::int_enum:o=T_enum4::Val13}"
+                                             "{min=konst::int_enum:max=T_enum4::Val13}"
+                                             "[ val + T_enum2::enu2 ]");
+        M_TEST_EQ(field_type_name.type, "uint3");                           // type
+        M_TEST_EQ(field_type_name.no_statement.get_int(), 0);               // ns
+        M_TEST_EQ(field_type_name.transform_quantum.get_int(), 0);          // q
+        M_TEST_EQ(field_type_name.transform_offset.get_int(), 13);          // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), true);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 1);                   // min & max
+        M_TEST_EQ(field_type_name.constraints[0].min.get_int(), 0);         // min
+        M_TEST_EQ(field_type_name.constraints[0].max.get_int(), 13);        // max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 1);
+        M_TEST_EQ(field_type_name.str_arrays[0].size_type, T_field_type_name::T_array::E_size_normal);
+        M_TEST_TRIM_EQ(field_type_name.str_arrays[0].size_expression.get_original_string_expression(), " val + T_enum2::enu2 ");
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "toto");
+        M_TEST_EQ(field_type_name.get_display_name(), "toto");
+        M_TEST_EQ(field_type_name.get_filter_name(), "toto");
+        M_TEST_EQ(field_type_name.get_extended_name(), "toto");
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+    {
+        string         first_word = "hide";
+        istringstream  iss(" "
+            " uint3"
+            "{ns=T_enum3::value0}"
+            "{tef=.2*this-.2+T_enum3::value0}"
+            "{min=konst::int_enum:max=T_enum4::Val13}"
+            "[ val + T_enum2::enu2 ]"
+            " toto;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), true);                       // hide
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "uint3"
+                                             "{ns=T_enum3::value0}"
+                                             "{tef=.2*this-.2+T_enum3::value0}"
+                                             "{min=konst::int_enum:max=T_enum4::Val13}"
+                                             "[ val + T_enum2::enu2 ]");
+        M_TEST_EQ(field_type_name.type, "uint3");                           // type
+        M_TEST_EQ(field_type_name.no_statement.get_int(), 0);               // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.get_original_string_expression(), ".2*this-.2+T_enum3::value0");
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_float);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), true);
+        M_TEST_EQ(field_type_name.constraints.size(), 1);                   // min & max
+        M_TEST_EQ(field_type_name.constraints[0].min.get_int(), 0);         // min
+        M_TEST_EQ(field_type_name.constraints[0].max.get_int(), 13);        // max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 1);
+        M_TEST_EQ(field_type_name.str_arrays[0].size_type, T_field_type_name::T_array::E_size_normal);
+        M_TEST_TRIM_EQ(field_type_name.str_arrays[0].size_expression.get_original_string_expression(), " val + T_enum2::enu2 ");
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "toto");
+        M_TEST_EQ(field_type_name.get_display_name(), "toto");
+        M_TEST_EQ(field_type_name.get_filter_name(), "toto");
+        M_TEST_EQ(field_type_name.get_extended_name(), "toto");
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_build_field_invalid_syntax.cpp b/plugins/epan/generic/unitary_test_build_field_invalid_syntax.cpp
new file mode 100644
index 00000000000..eab1e6ce7ad
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_build_field_invalid_syntax.cpp
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+
+#define M_TEST_EXPR_STR_EQ(VAL1,VAL2)            M_TEST_EQ(VAL1,VAL2)
+
+
+//*****************************************************************************
+// test_build_field_invalid_syntax
+//*****************************************************************************
+
+M_TEST_FCT(test_build_field_invalid_syntax)
+{
+    T_type_definitions    type_definitions;
+
+    // Invalid syntax field name []
+    {
+        string         first_word = "float32";
+        istringstream  iss(" x[6];");
+
+        T_field_type_name    field_type_name;
+        M_TEST_CATCH_EXCEPTION(
+            build_field(iss, type_definitions, first_word, field_type_name),
+            C_byte_interpret_exception);
+    }
+
+    // Invalid syntax field name {}
+    {
+        string         first_word = "uint32";
+        istringstream  iss(" x{ns=0};");
+
+        T_field_type_name    field_type_name;
+        M_TEST_CATCH_EXCEPTION(
+            build_field(iss, type_definitions, first_word, field_type_name),
+            C_byte_interpret_exception);
+    }
+
+    // Invalid syntax field name ()
+    {
+        string         first_word = "string";
+        istringstream  iss(" x(50);");
+
+        T_field_type_name    field_type_name;
+        M_TEST_CATCH_EXCEPTION(
+            build_field(iss, type_definitions, first_word, field_type_name),
+            C_byte_interpret_exception);
+    }
+
+    // Invalid syntax field name ::
+    {
+        string         first_word = "uint32";
+        istringstream  iss(" konst::one_hundred;");
+
+        T_field_type_name    field_type_name;
+        M_TEST_CATCH_EXCEPTION(
+            build_field(iss, type_definitions, first_word, field_type_name),
+            C_byte_interpret_exception);
+    }
+
+    // Invalid syntax field name ::
+    {
+        string         first_word = "var";
+        istringstream  iss("uint32 konst::one_hundred = 100;");
+
+        T_field_type_name    field_type_name;
+        M_TEST_CATCH_EXCEPTION(
+            build_field(iss, type_definitions, first_word, field_type_name),
+            C_byte_interpret_exception);
+    }
+
+    // Invalid const syntax field name
+    {
+        string         first_word = "konst";
+        istringstream  iss("uint32 konst::one_hundred = 100;");
+
+        T_field_type_name    field_type_name;
+        M_TEST_CATCH_EXCEPTION(
+            build_field(iss, type_definitions, first_word, field_type_name),
+            C_byte_interpret_exception);
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_build_field_loop_condition.cpp b/plugins/epan/generic/unitary_test_build_field_loop_condition.cpp
new file mode 100644
index 00000000000..207ebf23626
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_build_field_loop_condition.cpp
@@ -0,0 +1,397 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+
+#define M_TEST_EXPR_STR_EQ(VAL1,VAL2)            M_TEST_EQ(VAL1,VAL2)
+
+
+//*****************************************************************************
+// test_build_field_loop_condition
+//*****************************************************************************
+
+M_TEST_FCT(test_build_field_loop_condition)
+{
+    T_type_definitions    type_definitions;
+
+    // loop_size_bytes
+    {
+        string         first_word = "show";
+        istringstream  iss(" "
+            " loop_size_bytes  12"
+            " {"
+            "   uint8  c0;"
+            "    int8  c1;"
+            " }");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), true);                       // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "loop_size_bytes");                 // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "12");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "12");
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_EQ(field_type_name.P_sub_struct->fields.size(), 2);
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[0].type, "uint8");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[0].name, "c0");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[1].type, "int8");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[1].name, "c1");
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // loop_size_bits
+    {
+        string         first_word = "show";
+        istringstream  iss(" "
+            " loop_size_bits  (12 + 7)"
+            " {"
+            "   uint8  c0;"
+            "    int8  c1;"
+            " }");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), true);                       // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "loop_size_bits");                  // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "(12 + 7)");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EXPR_STR_EQ(field_type_name.condition_expression.get_original_string_expression(), "(12 + 7)");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_EQ(field_type_name.P_sub_struct->fields.size(), 2);
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[0].type, "uint8");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[0].name, "c0");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[1].type, "int8");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[1].name, "c1");
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // if
+    {
+        string         first_word = "forget";   // currently accepted, but ...
+        istringstream  iss(" "
+            " if  (12 + 7 > 18)"
+            " {"
+            "   uint8  c0;"
+            "    int8  c1;"
+            " }");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, true);                       // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "if");                              // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "(12 + 7 > 18)");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EXPR_STR_EQ(field_type_name.condition_expression.get_original_string_expression(), "(12 + 7 > 18)");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_EQ(field_type_name.P_sub_struct->fields.size(), 2);
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[0].type, "uint8");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[0].name, "c0");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[1].type, "int8");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[1].name, "c1");
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // if else
+    {
+        string         first_word = "forget";   // currently accepted, but ...
+        istringstream  iss(" "
+            " if  (12 + 7 > 18)"
+            " {"
+            "   uint8  c0;"
+            "    int8  c1;"
+            " }"
+            " else"
+            " {"
+            "   string    c2;"
+            "   int13[2]  c3;"
+            " }");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, true);                       // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "if");                              // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "(12 + 7 > 18)");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EXPR_STR_EQ(field_type_name.condition_expression.get_original_string_expression(), "(12 + 7 > 18)");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_EQ(field_type_name.P_sub_struct->fields.size(), 2);
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[0].type, "uint8");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[0].name, "c0");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[1].type, "int8");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[1].name, "c1");
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 2);
+        M_TEST_EQ(field_type_name.sub_struct_2[0].type, "string");
+        M_TEST_EQ(field_type_name.sub_struct_2[0].name, "c2");
+        M_TEST_EQ(field_type_name.sub_struct_2[1].type, "int13");
+        M_TEST_EQ(field_type_name.sub_struct_2[1].name, "c3");
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // while
+    {
+        string         first_word = "hide";   // currently accepted, but ...
+        istringstream  iss(" "
+            " while  (12 + 7 > 18)"
+            " {"
+            "   uint8  c0;"
+            "    int8  c1;"
+            " }");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), true);                       // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "while");                           // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "(12 + 7 > 18)");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EXPR_STR_EQ(field_type_name.condition_expression.get_original_string_expression(), "(12 + 7 > 18)");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_EQ(field_type_name.P_sub_struct->fields.size(), 2);
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[0].type, "uint8");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[0].name, "c0");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[1].type, "int8");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[1].name, "c1");
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // do while
+    {
+        string         first_word = "hide";   // currently accepted, but ...
+        istringstream  iss(" "
+            " do"
+            " {"
+            "   uint8  c0;"
+            "    int8  c1;"
+            " }"
+            " while  (12 + 7 > 18) ;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), true);                       // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "do_while");                        // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "(12 + 7 > 18)");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EXPR_STR_EQ(field_type_name.condition_expression.get_original_string_expression(), "(12 + 7 > 18)");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_EQ(field_type_name.P_sub_struct->fields.size(), 2);
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[0].type, "uint8");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[0].name, "c0");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[1].type, "int8");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[1].name, "c1");
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_build_field_misc.cpp b/plugins/epan/generic/unitary_test_build_field_misc.cpp
new file mode 100644
index 00000000000..07e47124679
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_build_field_misc.cpp
@@ -0,0 +1,294 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+
+#define M_TEST_EXPR_STR_EQ(VAL1,VAL2)            M_TEST_EQ(VAL1,VAL2)
+
+
+//*****************************************************************************
+// test_build_field_misc
+//*****************************************************************************
+
+M_TEST_FCT(test_build_field_misc)
+{
+    T_type_definitions    type_definitions;
+
+    // set
+    {
+        string         first_word = "set";
+        istringstream  iss(" name = 22 +variable[7][2].toto ;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "set");                             // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), true);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "name");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.new_expression.get_original_string_expression(), "22 +variable[7][2].toto");
+
+        auto expressions = field_type_name.new_expression.get_expressions_for_UT();
+        M_TEST_EQ(expressions.size(), 2);
+        M_TEST_EQ(expressions[1].is_a_variable(), true);
+
+        auto array_expressions = expressions[1].get_expressions_for_UT();
+        M_TEST_EQ(array_expressions.size(), 2);
+        M_TEST_EQ(array_expressions[0].get_original_string_expression(), "7");
+        M_TEST_EQ(array_expressions[1].get_original_string_expression(), "2");
+
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // return
+    {
+        string         first_word = "return";
+        istringstream  iss(" ;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "return");                          // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // output
+    {
+        string         first_word = "output";
+        istringstream  iss(" ++ ;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "output");                          // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "++");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // byte_order
+    {
+        string         first_word = "byte_order";
+        istringstream  iss(" little_endian ;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "byte_order");                      // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "little_endian");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // break
+    {
+        string         first_word = "break";
+        istringstream  iss("  ;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "break");                           // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_build_field_position.cpp b/plugins/epan/generic/unitary_test_build_field_position.cpp
new file mode 100644
index 00000000000..beb67d874b6
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_build_field_position.cpp
@@ -0,0 +1,235 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+
+#define M_TEST_EXPR_STR_EQ(VAL1,VAL2)            M_TEST_EQ(VAL1,VAL2)
+
+
+//*****************************************************************************
+// test_build_field_position
+//*****************************************************************************
+
+M_TEST_FCT(test_build_field_position)
+{
+    T_type_definitions    type_definitions;
+
+    // save_position
+    {
+        string         first_word = "save_position";
+        istringstream  iss(" pos_name ;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "save_position");                   // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "pos_name");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // goto_position
+    {
+        string         first_word = "goto_position";
+        istringstream  iss(" pos::name ;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "goto_position");                   // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "pos::name");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // move_position_bytes
+    {
+        string         first_word = "move_position_bytes";
+        istringstream  iss(" 11+ 2 ;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "move_position_bytes");             // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "11+ 2");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // move_position_bits
+    {
+        string         first_word = "move_position_bits";
+        istringstream  iss(" 11- 3 ;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.must_show(), false);                      // show
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "move_position_bits");              // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EXPR_STR_EQ(field_type_name.name, "11- 3");
+        M_TEST_EQ(field_type_name.get_display_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_filter_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_extended_name(), field_type_name.name);
+        M_TEST_EQ(field_type_name.get_var_expression().get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_build_field_switch_struct.cpp b/plugins/epan/generic/unitary_test_build_field_switch_struct.cpp
new file mode 100644
index 00000000000..00da13c801b
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_build_field_switch_struct.cpp
@@ -0,0 +1,236 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+
+#define M_TEST_EXPR_STR_EQ(VAL1,VAL2)            M_TEST_EQ(VAL1,VAL2)
+
+
+//*****************************************************************************
+// test_build_field_switch_struct
+//*****************************************************************************
+
+M_TEST_FCT(test_build_field_switch_struct)
+{
+    T_type_definitions    type_definitions;
+
+     // switch inline
+    {
+        string         first_word = "hide";
+        istringstream  iss(" "
+            " switch"
+            " (1)"
+            " {"
+            "   case 0 : uint8  c0;"
+            "   case 1 : uint8  c1; uint8  c1bis;"
+//            "   case 2:  uint8  c2;"                // space is mandatory before :
+            "   default : uint8  df;"
+            " }");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), true);                       // hide
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "switch");                          // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "1");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "");
+        M_TEST_EQ(field_type_name.get_display_name(), "");
+        M_TEST_EQ(field_type_name.get_filter_name(), "");
+        M_TEST_EQ(field_type_name.get_extended_name(), "");
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_EQ(field_type_name.P_switch_inline->is_switch_expr, false);
+        M_TEST_EQ(field_type_name.P_switch_inline->case_type, "");
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases.size(), 3);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[0].is_default_case, false);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[0].case_value.get_int(), 0);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[0].fields.size(), 1);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[0].fields[0].name, "c0");
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[1].is_default_case, false);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[1].case_value.get_int(), 1);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[1].fields.size(), 2);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[1].fields[0].name, "c1");
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[1].fields[1].name, "c1bis");
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[2].is_default_case, true);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[2].fields.size(), 1);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[2].fields[0].name, "df");
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // switch_expr inline
+    {
+        string         first_word = "hide";
+        istringstream  iss(" "
+            " switch_expr"
+            " "
+            " {"
+            "   case (0 == 0)     : uint8  c0;"
+            "   case (1 == a_var) : uint8  c1; uint8  c1bis;"
+//            "   case 2:  uint8  c2;"                // space is mandatory before :
+            "   default : uint8  df;"
+            " }");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), true);                       // hide
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "switch");                          // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "");
+        M_TEST_EQ(field_type_name.get_display_name(), "");
+        M_TEST_EQ(field_type_name.get_filter_name(), "");
+        M_TEST_EQ(field_type_name.get_extended_name(), "");
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_EQ(field_type_name.P_switch_inline->is_switch_expr, true);
+        M_TEST_EQ(field_type_name.P_switch_inline->case_type, "");
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases.size(), 3);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[0].is_default_case, false);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[0].case_expr.get_original_string_expression(), "(0 == 0)");
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[0].fields.size(), 1);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[0].fields[0].name, "c0");
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[1].is_default_case, false);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[1].case_expr.get_original_string_expression(), "(1 == a_var)");
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[1].fields.size(), 2);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[1].fields[0].name, "c1");
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[1].fields[1].name, "c1bis");
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[2].is_default_case, true);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[2].fields.size(), 1);
+        M_TEST_EQ(field_type_name.P_switch_inline->switch_cases[2].fields[0].name, "df");
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+
+    // struct inline
+    {
+        string         first_word = "forget";
+        istringstream  iss(" "
+            " struct"
+            " {"
+            "   uint8  c0;"
+            "    int8  c1;"
+            " } toto;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, true);                       // forget
+        M_TEST_EQ(field_type_name.must_hide(), false);                      // hide
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "");
+        M_TEST_EQ(field_type_name.type, "struct");                          // type
+        M_TEST_EQ(field_type_name.no_statement.as_string(), "");            // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 0);                   // min & max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 0);
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "toto");
+        M_TEST_EQ(field_type_name.get_display_name(), "toto");
+        M_TEST_EQ(field_type_name.get_filter_name(), "toto");
+        M_TEST_EQ(field_type_name.get_extended_name(), "toto");
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_EQ(field_type_name.P_sub_struct->fields.size(), 2);
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[0].type, "uint8");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[0].name, "c0");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[1].type, "int8");
+        M_TEST_EQ(field_type_name.P_sub_struct->fields[1].name, "c1");
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_build_field_ternary.cpp b/plugins/epan/generic/unitary_test_build_field_ternary.cpp
new file mode 100644
index 00000000000..35a5a9525ce
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_build_field_ternary.cpp
@@ -0,0 +1,165 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+
+#define M_TEST_EXPR_STR_EQ(VAL1,VAL2)            M_TEST_EQ(VAL1,VAL2)
+
+
+//*****************************************************************************
+// test_build_field_ternary_condition
+//*****************************************************************************
+
+M_TEST_FCT(test_build_field_ternary_condition)
+{
+    T_type_definitions    type_definitions;
+
+    // Add some types
+    build_types ("unitary_tests_basic.fdesc",
+                 type_definitions);
+
+    // Use condition ? xxx : yyy in many places
+    {
+        string         first_word = "hide";
+        istringstream  iss(" "
+            " uint3"
+            "{ns=T_enum3::value0 == 0 ? 1 : 2}"
+            "{q=T_enum4::Val13 != 13 ? konst::int_enum : 12:o=(konst::int_enum != 0 ? T_enum3::value0 : T_enum4::Val13)}"
+            "{min=T_enum4::Val13 == 13 ? konst::int_enum : 12:max=(konst::int_enum == 0 ? T_enum4::Val13 : T_enum3::value0)}"
+            "[ val + (T_enum3::value0 != 0 ? 1 : 2) ]"
+            " toto;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), true);                       // hide
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "uint3"
+                                             "{ns=T_enum3::value0 == 0 ? 1 : 2}"
+                                             "{q=T_enum4::Val13 != 13 ? konst::int_enum : 12:o=(konst::int_enum != 0 ? T_enum3::value0 : T_enum4::Val13)}"
+                                             "{min=T_enum4::Val13 == 13 ? konst::int_enum : 12:max=(konst::int_enum == 0 ? T_enum4::Val13 : T_enum3::value0)}"
+                                             "[ val + (T_enum3::value0 != 0 ? 1 : 2) ]");
+        M_TEST_EQ(field_type_name.type, "uint3");                           // type
+        M_TEST_EQ(field_type_name.no_statement.get_int(), 1);               // ns
+        M_TEST_EQ(field_type_name.transform_quantum.get_int(), 12);         // q
+        M_TEST_EQ(field_type_name.transform_offset.get_int(), 13);          // o
+        M_TEST_EQ(field_type_name.transform_expression.is_defined(), false);
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_msg);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), true);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), false);
+        M_TEST_EQ(field_type_name.constraints.size(), 1);                   // min & max
+        M_TEST_EQ(field_type_name.constraints[0].min.get_int(), 0);         // min
+        M_TEST_EQ(field_type_name.constraints[0].max.get_int(), 13);        // max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 1);
+        M_TEST_EQ(field_type_name.str_arrays[0].size_type, T_field_type_name::T_array::E_size_normal);
+        M_TEST_TRIM_EQ(field_type_name.str_arrays[0].size_expression.get_original_string_expression(), " val + (T_enum3::value0 != 0 ? 1 : 2) ");
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "toto");
+        M_TEST_EQ(field_type_name.get_display_name(), "toto");
+        M_TEST_EQ(field_type_name.get_filter_name(), "toto");
+        M_TEST_EQ(field_type_name.get_extended_name(), "toto");
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+    {
+        string         first_word = "hide";
+        istringstream  iss(" "
+            " uint3"
+            "{ns=T_enum3::value0 == 0 ? 1 : 2}"
+            "{tef=.2*this-.2+(konst::int_enum == 0 ? T_enum3::value0 : T_enum4::Val13)}"
+            "{min=T_enum4::Val13 == 13 ? konst::int_enum : 12:max=(konst::int_enum == 0 ? T_enum4::Val13 : T_enum3::value0)}"
+            "[ val + (T_enum3::value0 != 0 ? 1 : 2) ]"
+            " toto;");
+
+        T_field_type_name    field_type_name;
+
+        M_TEST_EQ(build_field(iss, type_definitions, first_word, field_type_name), "");
+        M_TEST_EQ(field_type_name.must_forget, false);                      // forget
+        M_TEST_EQ(field_type_name.must_hide(), true);                       // hide
+        M_TEST_EQ(field_type_name.is_a_variable(), false)                   // var
+        M_TEST_EQ(field_type_name.orig_type, "uint3"
+                                             "{ns=T_enum3::value0 == 0 ? 1 : 2}"
+                                             "{tef=.2*this-.2+(konst::int_enum == 0 ? T_enum3::value0 : T_enum4::Val13)}"
+                                             "{min=T_enum4::Val13 == 13 ? konst::int_enum : 12:max=(konst::int_enum == 0 ? T_enum4::Val13 : T_enum3::value0)}"
+                                             "[ val + (T_enum3::value0 != 0 ? 1 : 2) ]");
+        M_TEST_EQ(field_type_name.type, "uint3");                           // type
+        M_TEST_EQ(field_type_name.no_statement.get_int(), 1);               // ns
+        M_TEST_EQ(field_type_name.transform_quantum.as_string(), "");       // q
+        M_TEST_EQ(field_type_name.transform_offset.as_string(), "");        // o
+        M_TEST_EQ(field_type_name.transform_expression.get_original_string_expression(), ".2*this-.2+(konst::int_enum == 0 ? T_enum3::value0 : T_enum4::Val13)");
+        M_TEST_EQ(field_type_name.transform_expression_type, C_value::E_type_float);  // not set
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_int(), false);
+        M_TEST_EQ(field_type_name.must_force_manage_as_biggest_float(), true);
+        M_TEST_EQ(field_type_name.constraints.size(), 1);                   // min & max
+        M_TEST_EQ(field_type_name.constraints[0].min.get_int(), 0);         // min
+        M_TEST_EQ(field_type_name.constraints[0].max.get_int(), 13);        // max
+        M_TEST_EQ(field_type_name.str_display_expression, "");
+        M_TEST_EQ(field_type_name.str_arrays.size(), 1);
+        M_TEST_EQ(field_type_name.str_arrays[0].size_type, T_field_type_name::T_array::E_size_normal);
+        M_TEST_TRIM_EQ(field_type_name.str_arrays[0].size_expression.get_original_string_expression(), " val + (T_enum3::value0 != 0 ? 1 : 2) ");
+        M_TEST_EQ(field_type_name.str_size_or_parameter, "");
+        M_TEST_EQ(field_type_name.str_byte_order, "");
+        M_TEST_EQ(field_type_name.str_decoder_function, "");
+        M_TEST_EQ(field_type_name.str_dissector, "");
+        M_TEST_EQ(field_type_name.name, "toto");
+        M_TEST_EQ(field_type_name.get_display_name(), "toto");
+        M_TEST_EQ(field_type_name.get_filter_name(), "toto");
+        M_TEST_EQ(field_type_name.get_extended_name(), "toto");
+        M_TEST_EQ(field_type_name.get_var_expression().is_defined(), false);
+        M_TEST_EQ(field_type_name.condition_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.return_expression.get_original_string_expression(), "");
+        M_TEST_EQ(field_type_name.fct_parameters.size(), 0);
+        M_TEST_NULL(field_type_name.P_sub_struct);
+        M_TEST_EQ(field_type_name.sub_struct_2.size(), 0);
+        M_TEST_NULL(field_type_name.P_bitfield_inline);
+        M_TEST_NULL(field_type_name.P_switch_inline);
+        M_TEST_EQ(field_type_name.wsgd_field_idx, -1);
+        M_TEST_NULL(field_type_name.pf_frame_to_any);
+        M_TEST_NULL(field_type_name.pf_frame_to_field);
+        M_TEST_NULL(field_type_name.P_type_enum_def);
+        M_TEST_NULL(field_type_name.P_type_struct_def);
+        M_TEST_NULL(field_type_name.P_type_switch_def);
+        M_TEST_NULL(field_type_name.P_type_bitfield_def);
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_build_types_and_interpret_bytes.cpp b/plugins/epan/generic/unitary_test_build_types_and_interpret_bytes.cpp
new file mode 100644
index 00000000000..1493ef6f74c
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_build_types_and_interpret_bytes.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "unitary_tests_ut_interpret_bytes.h"
+
+#include "byte_interpret.h"
+
+
+//*****************************************************************************
+// test_build_types_and_interpret_bytes
+//*****************************************************************************
+
+M_TEST_FCT(test_build_types_and_interpret_bytes)
+{
+    T_byte_vector    msg_1_frame;
+    {
+        const char  * msg_1_str = "6c000b000000000000000000";
+        string_hexa_to_frame(msg_1_str, msg_1_frame);
+    }
+
+    const T_byte  * P_bytes = &msg_1_frame[0];
+    size_t          sizeof_bytes = msg_1_frame.size();
+    istringstream   iss("uint8[12]  uint8;");
+    ostringstream   oss;
+
+    bool  result = build_types_and_interpret_bytes (
+        P_bytes,
+        sizeof_bytes,
+        iss,
+        oss,
+        oss);
+
+    M_TEST_EQ(result, true);
+    M_TEST_EQ(sizeof_bytes, 0);
+}
diff --git a/plugins/epan/generic/unitary_test_decode_stream_frame.cpp b/plugins/epan/generic/unitary_test_decode_stream_frame.cpp
new file mode 100644
index 00000000000..ea804ed9406
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_decode_stream_frame.cpp
@@ -0,0 +1,193 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "T_interpret_inside_frame.h"
+
+
+//*****************************************************************************
+// test_decode_stream_frame
+//*****************************************************************************
+
+M_TEST_FCT(test_decode_stream_frame)
+{
+    T_decode_stream_frame  decode_stream_frame;
+    memset(decode_stream_frame.decoded_data, 0, sizeof(decode_stream_frame.decoded_data));
+
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 0);
+
+    // Add 1 byte : size changed, frame_data position inchanged
+    decode_stream_frame.write_1_byte(136);
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 8);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 8);
+
+    // Add 1 byte : size changed, frame_data position inchanged
+    decode_stream_frame.write_1_byte(137);
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 16);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 16);
+
+    // Add 3 bytes : size changed, frame_data position inchanged
+    T_byte  data1[] = { 138, 139, 140 };
+    decode_stream_frame.write_n_bytes(data1, sizeof(data1));
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 40);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 40);
+
+    // Read 1 byte : size inchanged, frame_data position changed
+    M_TEST_EQ(decode_stream_frame.frame_data.read_1_byte(), 136);
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 40);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 8);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 32);
+
+    // Read 1 byte : size inchanged, frame_data position changed
+    M_TEST_EQ(decode_stream_frame.frame_data.read_1_byte(), 137);
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 40);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 16);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 24);
+
+    // Add 5 bytes : size changed, frame_data position inchanged
+    T_byte  data2[] = { 141, 142, 143, 144, 145 };
+    decode_stream_frame.write_n_bytes(data2, sizeof(data2));
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 80);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 16);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 64);
+
+    // Change nothing because not all is read into frame_data
+    decode_stream_frame.synchronize();
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 80);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 16);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 64);
+
+    // Read 4 bytes : size inchanged, frame_data position changed
+    M_TEST_EQ(decode_stream_frame.frame_data.read_1_byte(), 138);
+    M_TEST_EQ(decode_stream_frame.frame_data.read_1_byte(), 139);
+    M_TEST_EQ(decode_stream_frame.frame_data.read_1_byte(), 140);
+    M_TEST_EQ(decode_stream_frame.frame_data.read_1_byte(), 141);
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 80);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 48);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 32);
+
+    // Change nothing because not all is read into frame_data
+    decode_stream_frame.synchronize();
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 80);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 48);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 32);
+
+    // Read 4 bytes : size inchanged, frame_data position changed
+    M_TEST_EQ(decode_stream_frame.frame_data.read_1_byte(), 142);
+    M_TEST_EQ(decode_stream_frame.frame_data.read_1_byte(), 143);
+    M_TEST_EQ(decode_stream_frame.frame_data.read_1_byte(), 144);
+    M_TEST_EQ(decode_stream_frame.frame_data.read_1_byte(), 145);
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 80);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 80);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 0);
+
+    // Add 1 byte : size changed, frame_data position inchanged
+    decode_stream_frame.write_1_byte(146);
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 88);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 80);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 8);
+
+    // Read 1 byte : size inchanged, frame_data position changed
+    M_TEST_EQ(decode_stream_frame.frame_data.read_1_byte(), 146);
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 88);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 88);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 0);
+
+    // All has been read into frame_data, so data is reseted
+    decode_stream_frame.synchronize();
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 0);
+
+    // Add 4 bits : size changed, frame_data position inchanged
+    decode_stream_frame.write_less_1_byte(147 >> 4, 4);         // less significant bits are take
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 4);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 4);
+
+    // Change nothing because not all is read into frame_data
+    decode_stream_frame.synchronize();
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 4);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 4);
+
+    // Add 4 bits : size changed, frame_data position inchanged
+    decode_stream_frame.write_less_1_byte(147, 4);
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 8);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 8);
+
+    // Change nothing because not all is read into frame_data
+    decode_stream_frame.synchronize();
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 8);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 8);
+
+    // Read 1 byte : size inchanged, frame_data position changed
+    M_TEST_EQ(decode_stream_frame.frame_data.read_1_byte(), 147);
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 8);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 8);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 0);
+
+    // All has been read into frame_data, so data is reseted
+    decode_stream_frame.synchronize();
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 0);
+
+    // Add 4 bits : size changed, frame_data position inchanged
+    decode_stream_frame.write_less_1_byte(148 >> 4, 4);         // less significant bits are take
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 4);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 4);
+
+    // Read 2 bits : size inchanged, frame_data position changed
+    M_TEST_EQ(decode_stream_frame.frame_data.read_less_1_byte(2), 2);    // 2 = (148 >> 4) >> 2
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 4);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 2);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 2);
+
+    // Change nothing because not all is read into frame_data
+    decode_stream_frame.synchronize();
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 4);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 2);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 2);
+
+    // Read 2 bits : size inchanged, frame_data position changed
+    M_TEST_EQ(decode_stream_frame.frame_data.read_less_1_byte(2), 1);    // 1 = (148 >> 4) & b11
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 4);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 4);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 0);
+
+    // All has been read into frame_data, so data is reseted
+    decode_stream_frame.synchronize();
+    M_TEST_EQ(decode_stream_frame.decoded_data_bit_size, 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_bit_offset(), 0);
+    M_TEST_EQ(decode_stream_frame.frame_data.get_remaining_bits(), 0);
+}
diff --git a/plugins/epan/generic/unitary_test_decompose_left_sep_middle_sep_right.cpp b/plugins/epan/generic/unitary_test_decompose_left_sep_middle_sep_right.cpp
new file mode 100644
index 00000000000..199d98e6760
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_decompose_left_sep_middle_sep_right.cpp
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+
+
+//*****************************************************************************
+// test_decompose_left_sep_middle_sep_right
+//*****************************************************************************
+
+M_TEST_FCT(test_decompose_left_sep_middle_sep_right)
+{
+    string    str_left;
+    string    str_middle;
+    string    str_right;
+
+#define M_TEST_NOT_OK(STR,SEP_LEFT,SEP_RIGHT)                                              \
+    M_TEST_EQ(decompose_left_sep_middle_sep_right(STR, SEP_LEFT, SEP_RIGHT, str_left, str_middle, str_right), E_rc_not_found)
+
+#define M_TEST_OK(STR,SEP_LEFT,SEP_RIGHT,LEFT,MIDDLE,RIGHT)                                                       \
+    M_TEST_EQ(decompose_left_sep_middle_sep_right(STR, SEP_LEFT, SEP_RIGHT, str_left, str_middle, str_right), E_rc_ok);  \
+    M_TEST_EQ(str_left, LEFT);                                                                                    \
+    M_TEST_EQ(str_middle, MIDDLE);                                                                                \
+    M_TEST_EQ(str_right, RIGHT)
+
+    M_TEST_NOT_OK("aqsdfghjk", '(', ')');
+    M_TEST_NOT_OK("aqsdfghj)", '(', ')');
+    M_TEST_NOT_OK("aq(dfghjk", '(', ')');
+
+    M_TEST_OK("aq(dfgh)k", '(', ')', "aq", "dfgh", "k");
+    M_TEST_OK("(aqdfghk)", '(', ')', "", "aqdfghk", "");
+    M_TEST_OK("asaqs(dfghj)", '(', ')', "asaqs", "dfghj", "");
+    M_TEST_OK("{aqs}{dfghj}", '{', '}', "", "aqs", "{dfghj}");
+    M_TEST_OK("a[a][f[gh]k]", '[', ']', "a", "a", "[f[gh]k]");
+    M_TEST_OK("[]a[a][f[ghk", '[', ']', "", "", "a[a][f[ghk");
+
+    M_TEST_NOT_OK("a[a[f[_gh]k]du", '[', ']');             // missing 1 ]
+    M_TEST_OK("a[a[f[]g[h]k]]du", '[', ']', "a", "a[f[]g[h]k]", "du");
+
+
+#undef  M_TEST_NOT_OK
+#undef  M_TEST_OK
+}
diff --git a/plugins/epan/generic/unitary_test_decompose_type_sep_value_sep.cpp b/plugins/epan/generic/unitary_test_decompose_type_sep_value_sep.cpp
new file mode 100644
index 00000000000..1bfed1d5b42
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_decompose_type_sep_value_sep.cpp
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+
+
+//*****************************************************************************
+// test_decompose_type_sep_value_sep
+//*****************************************************************************
+
+M_TEST_FCT(test_decompose_type_sep_value_sep)
+{
+    string    str_left;
+    string    str_right;
+
+#define M_TEST_NOT_OK(STR,SEP_LEFT,SEP_RIGHT)                                              \
+    M_TEST_EQ(decompose_type_sep_value_sep(STR, SEP_LEFT, SEP_RIGHT, str_left, str_right), E_rc_not_found)
+
+#define M_TEST_OK(STR,SEP_LEFT,SEP_RIGHT,LEFT,RIGHT)                                                  \
+    M_TEST_EQ(decompose_type_sep_value_sep(STR, SEP_LEFT, SEP_RIGHT, str_left, str_right), E_rc_ok);  \
+    M_TEST_EQ(str_left, LEFT);                                                                        \
+    M_TEST_EQ(str_right, RIGHT)
+
+    M_TEST_NOT_OK("aqsdfghjk", '(', ')');
+    M_TEST_NOT_OK("aqsdfghj)", '(', ')');
+    M_TEST_NOT_OK("aq(dfghjk", '(', ')');
+    M_TEST_NOT_OK("aq(dfgh)k", '(', ')');
+    M_TEST_NOT_OK("(aqdfghk)", '(', ')');  // do NOT accept empty left
+
+    M_TEST_OK("asaqs(dfghj)", '(', ')', "asaqs", "dfghj");
+    M_TEST_OK("{aqs}{dfghj}", '{', '}', "{aqs}", "dfghj");
+    M_TEST_OK("a[a][f[gh]k]", '[', ']', "a[a]", "f[gh]k");
+    M_TEST_OK("a[a][f[ghk[]", '[', ']', "a[a][f[ghk", "");
+
+    M_TEST_NOT_OK("a[a][f_gh]k]", '[', ']');             // missing 1 [
+    M_TEST_OK("a[a][f[]g[h]k]", '[', ']', "a[a]", "f[]g[h]k");
+
+
+#undef  M_TEST_NOT_OK
+#undef  M_TEST_OK
+}
diff --git a/plugins/epan/generic/unitary_test_expression.cpp b/plugins/epan/generic/unitary_test_expression.cpp
new file mode 100644
index 00000000000..61400f31585
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_expression.cpp
@@ -0,0 +1,894 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "C_perf_chrono.h"
+
+#include "byte_interpret_parse.h"
+#include "byte_interpret_compute_expression.h"
+#include "byte_interpret.h"
+#include "T_expression.h"
+
+//*****************************************************************************
+// test_expression_perf_operation
+//*****************************************************************************
+
+void    test_expression_perf_operation(
+                const T_type_definitions  & type_definitions)
+{
+    T_interpret_data                  interpret_data;
+
+    //-------------------------------------------------------------------------
+    // perf operation expression
+    //-------------------------------------------------------------------------
+    const string     perf_expression =
+        "((31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+#if 0		// Too long for win64 & VS 2019 : 0xC00000FD: Stack overflow
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+#if 0		// Too long for win64 (ok for win32 or linux)
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+        " (31*(2**27)+24*3600*1000) -"
+        " (31*(2**27)+24*3600*1000) +"
+#endif
+#endif
+        " (31*(2**27)+24*3600*1000))";
+    const long long  perf_expression_result =  4247149568LL;
+
+    {
+        C_value    value;
+        {
+            C_perf_chrono  perf_chrono(interpret_data, "perf integer expression operation", 0);
+            value = compute_expression_no_io (type_definitions, interpret_data, perf_expression);
+        }
+        M_TEST_EQ(value.get_int(), perf_expression_result);
+        value.as_string();
+    }
+    {
+        T_expression    expression;
+        expression.build_expression(type_definitions, perf_expression);
+        C_value    value;
+        {
+            value = expression.compute_expression_no_io (type_definitions, interpret_data);
+            // x  1 =  0 ms
+            // x 10 = 62 ms !!!
+            C_perf_chrono  perf_chrono(interpret_data, "perf integer expression operation T_expression x 10", 0);
+            for (int idx = 0; idx < 10; ++idx)
+            {
+                expression.compute_expression_no_io (type_definitions, interpret_data);
+            }
+        }
+        M_TEST_EQ(value.get_int(), perf_expression_result);
+        value.as_string();
+    }
+    {
+        T_expression    expression;
+        expression.build_expression(type_definitions, perf_expression);
+        expression.pre_compute_expression(type_definitions);
+        C_value    value;
+        {
+            value = expression.compute_expression_no_io (type_definitions, interpret_data);
+            // x    10 =  0 ms
+            // x 40000 = 66 ms
+            C_perf_chrono  perf_chrono(interpret_data, "perf integer expression operation T_expression x 40000 pre_compute", 0);
+            for (int idx = 0; idx < 40000; ++idx)
+            {
+                expression.compute_expression_no_io (type_definitions, interpret_data);
+            }
+        }
+        M_TEST_EQ(value.get_int(), perf_expression_result);
+        value.as_string();
+    }
+
+    //-------------------------------------------------------------------------
+    // operation expression with unexistent_variable
+    //-------------------------------------------------------------------------
+    {
+        T_expression    expression;
+        expression.build_expression(type_definitions, "2 + unexistent_variable");
+        expression.pre_compute_expression(type_definitions);
+
+        M_TEST_CATCH_EXCEPTION(
+            C_value    value = expression.compute_expression_no_io (type_definitions, interpret_data),
+            C_byte_interpret_exception);
+    }
+}
+
+//*****************************************************************************
+// test_expression_perf_function
+//*****************************************************************************
+
+void    test_expression_perf_function(
+                const T_type_definitions  & type_definitions)
+{
+    T_interpret_data                  interpret_data;
+
+    //-------------------------------------------------------------------------
+    // perf expression
+    //-------------------------------------------------------------------------
+    const string     perf_expression = "perf(1,4201)";
+    const long long  perf_expression_result =  4201LL;
+
+    {
+        C_value    value;
+        {
+            C_perf_chrono  perf_chrono(interpret_data, "perf integer expression function", 0);
+            value = compute_expression_no_io (type_definitions, interpret_data, perf_expression);
+        }
+        M_TEST_EQ(value.get_int(), perf_expression_result);
+        value.as_string();
+    }
+    {
+        T_expression    expression;
+        expression.build_expression(type_definitions, perf_expression);
+        C_value    value;
+        {
+            value = expression.compute_expression_no_io (type_definitions, interpret_data);
+            C_perf_chrono  perf_chrono(interpret_data, "perf integer expression function T_expression x 1", 0);
+            for (int idx = 0; idx < 1; ++idx)
+            {
+                expression.compute_expression_no_io (type_definitions, interpret_data);
+            }
+        }
+        M_TEST_EQ(value.get_int(), perf_expression_result);
+        value.as_string();
+    }
+    {
+        T_expression    expression;
+        expression.build_expression(type_definitions, perf_expression);
+        expression.pre_compute_expression(type_definitions);
+        C_value    value;
+        {
+            value = expression.compute_expression_no_io (type_definitions, interpret_data);
+            // x    10 =  0 ms
+            // x 40000 = 66 ms
+            C_perf_chrono  perf_chrono(interpret_data, "perf integer expression function T_expression x 1 pre_compute", 0);
+            for (int idx = 0; idx < 1; ++idx)
+            {
+                expression.compute_expression_no_io (type_definitions, interpret_data);
+            }
+        }
+        M_TEST_EQ(value.get_int(), perf_expression_result);
+        value.as_string();
+    }
+
+    //-------------------------------------------------------------------------
+    // function expression with unexistent_variable
+    //-------------------------------------------------------------------------
+    {
+        T_expression    expression;
+        expression.build_expression(type_definitions, "perf_value(1,4201)");
+        expression.pre_compute_expression(type_definitions);
+#if 0
+        M_TEST_CATCH_EXCEPTION(
+            C_value    value = expression.compute_expression_no_io (type_definitions, interpret_data),
+            C_byte_interpret_exception);
+#endif
+    }
+}
+
+//*****************************************************************************
+// get_int_value_bit_pos_size
+//*****************************************************************************
+
+C_value  get_int_value_bit_pos_size(long long  basic_value,
+                                    int        bit_offset,
+                                    int        bit_size)
+{
+    C_value  value(basic_value);
+    value.set_bit_position_offset_size(bit_offset, bit_size);
+    return  value;
+}
+
+//*****************************************************************************
+// get_flt_value_bit_pos_size
+//*****************************************************************************
+
+C_value  get_flt_value_bit_pos_size(double     basic_value,
+                                    int        bit_offset,
+                                    int        bit_size)
+{
+    C_value  value(basic_value);
+    value.set_bit_position_offset_size(bit_offset, bit_size);
+    return  value;
+}
+
+//*****************************************************************************
+// test_expression
+//*****************************************************************************
+
+M_TEST_FCT(test_expression)
+{
+    T_type_definitions    type_definitions;
+    {
+        istringstream  iss(
+            "enum16 T_Operation {  CREATION 0   MODIFICATION 1   DELETION 2 }" "\n"
+
+            "function any  addition (in any lhs, in any rhs)" "\n"
+            "{" "\n"
+            "  return  (lhs + rhs) ;" "\n"
+            "}" "\n"
+
+            "function int64  perf (in int64 incr, in int64 limit)" "\n"
+            "{" "\n"
+            "  hide var int64  value = 0;" "\n"
+            "  while (value < limit)" "\n"
+            "  {" "\n"
+            "    set value = value + incr;" "\n"
+            "  }" "\n"
+            "  return  value ;" "\n"
+            "}" "\n"
+
+            "function int64  perf_value (in int64 incr, in int64 limit)" "\n"
+            "{" "\n"
+            "  while (value < limit)" "\n"
+            "  {" "\n"
+            "    set value = value + incr;" "\n"
+            "  }" "\n"
+            "  return  value ;" "\n"
+            "}" "\n"
+
+            "" "\n");
+
+        string    last_word_not_treated = build_types (iss, type_definitions);
+        M_FATAL_IF_NE(last_word_not_treated, "");
+    }
+    {
+        istringstream  iss(
+            "const int32    k::int = -17;" "\n"
+            "const float32  k::flt = -234.9;" "\n"
+            "const string   k::str = \"hello world\";" "\n"
+
+            "" "\n");
+
+        string    last_word_not_treated = build_types (iss, type_definitions);
+        M_FATAL_IF_NE(last_word_not_treated, "");
+    }
+
+    //-------------------------------------------------------------------------
+    // integer static expression
+    //-------------------------------------------------------------------------
+    {
+        struct T_test_expr_int_result
+        {
+            const char  * expr;
+            long long     expected_result;
+        };
+
+        const T_test_expr_int_result    expressions[] = {
+            { "27", 27 },
+            { "-234", -234 },
+            { "23+4", 27 },
+            { "-1345-65", -1410 },
+            { "234 * 2 - 5 + 1", 464 },
+            { "(234 * 2) - 5 + 1", 464 },
+            { "(234 * 2) - (5 + 1)", 462 },
+            { "234 - 2 * 5 + 1", 225 },
+            { "-(2**31)", -2147483648LL },
+            { "-2**31", -2147483648LL },
+            { "-2**2", 4 },
+            { "(2**31)-1", 2147483647LL },
+            { "2**31-1", 2147483647LL },
+            { "31*(2**27)+24*3600*1000", 4247149568LL },
+            { "31*2**27+24*3600*1000", 4247149568LL },
+            { "2**32-1", 4294967295LL },
+            { "3*2**2", 12 },
+            { "36/2**2", 9 },
+            { "7%2**2", 3 },
+            { "0x045", 69 },
+            { "-0Xdf", -223 },
+            { "0x045 * 1", 69 },
+            { "-0Xdf / 1", -223 },
+            { "-0Xdf / -1", 223 },
+            { "-0Xdf * -1", 223 },
+            { "-0Xdf + -(-1+2)", -0Xe0 },
+            { "007", 7 },
+            { "03456", 1838 },
+            { "007 / 0x7", 1 },
+            { "03456/1838", 1 },
+            { "007 % 0x5", 2 },
+            // const
+            { "136 + k::int", 119 },
+            // bit operations
+            { "007 & 0x5", 5 },
+            { "007 & 0x9", 1 },
+            { "007 | 0x5", 7 },
+            { "007 | 0x9", 15 },
+            { "007 ^ 0x5", 2 },
+            { "007 ^ 0x9", 14 },
+            // condition
+            { "7 ? 2 : 0x5", 2 },
+            { "0 ? 2 : 0x5", 5 },
+            // complex
+            { "(007 | 0x5) > (27 - 4 * 5) ? 2 - 2 : 31*(2**27)+24*3600*1000", 4247149568LL },
+            // function
+            { " addition (3, 7) ", 10 }
+        };
+        for (const auto & expr_result : expressions)
+        {
+            const char       * expr            = expr_result.expr;
+            const long long    expected_result = expr_result.expected_result;
+
+            cout << "int expression : ";
+            cout.width(25);
+            cout << expr;
+#if 1
+            C_value    value = compute_expression_static (type_definitions, expr);
+#else
+            C_value    value;
+            {
+                T_interpret_data  interpret_data;
+                C_perf_chrono  perf_chrono(interpret_data, expr, 0);
+                value = compute_expression_static (type_definitions, expr);
+            }
+#endif
+            cout << "    gives " << value.as_string() << endl;
+            M_TEST_EQ(value.get_int(), expected_result);
+            M_TEST_EQ(value.get_bit_position_offset(), -1);
+            M_TEST_EQ(value.get_bit_position_size(), -1);
+        }
+    }
+
+    //-------------------------------------------------------------------------
+    // bool static expression
+    //-------------------------------------------------------------------------
+    {
+        struct T_test_expr_int_result
+        {
+            const char  * expr;
+            long long     expected_result;
+        };
+
+        const T_test_expr_int_result    expressions[] = {
+            { "007 <  0x7", 0 },
+            { "007 <  0x8", 1 },
+            { "007 <= 0x6", 0 },
+            { "007 <= 0x7", 1 },
+            { "007 >  0x7", 0 },
+            { "007 >  0x6", 1 },
+            { "007 >= 0x8", 0 },
+            { "007 >= 0x7", 1 },
+            { "007 == 0x5", 0 },
+            { "007 == 0x7", 1 },
+            { "007 != 0x7", 0 },
+            { "007 != 0x5", 1 },
+            { "007 && 0x5", 1 },
+            { "(007 != 0x5) && (007 != 0x7)", 0 },
+            { "007 != 0x5 && 007 != 0x7", 0 },
+            { "007 != 0x5 && 007 == 0x7", 1 },
+            { "007 == 0x5 || 007 != 0x7", 0 },
+            { "007 == 0x5 || 007 == 0x7", 1 },
+            { "1   == 0x1", 1 }
+        };
+        for (const auto & expr_result : expressions)
+        {
+            const char       * expr            = expr_result.expr;
+            const long long    expected_result = expr_result.expected_result;
+
+            cout << "int expression : ";
+            cout.width(25);
+            cout << expr;
+            C_value    value = compute_expression_static (type_definitions, expr);
+            cout << "    gives " << value.as_string() << endl;
+            M_TEST_EQ(value.get_bool(), expected_result);
+            M_TEST_EQ(value.get_bit_position_offset(), -1);
+            M_TEST_EQ(value.get_bit_position_size(), -1);
+        }
+    }
+
+    //-------------------------------------------------------------------------
+    // float static expression
+    //-------------------------------------------------------------------------
+    {
+        struct T_test_expr_flt_result
+        {
+            const char  * expr;
+            double        expected_result;
+        };
+
+        const T_test_expr_flt_result    expressions[] = {
+            { "27.1", 27.1 },
+            { "-234.9", -234.9 },
+            { "-234.9E3", -234900.0 },
+            { "-234.9E-1", -23.49 },     // exception
+            { "-234.9E+1", -2349.0 },    // exception
+            { "23+4.0", 27.0 },
+            { "-1345.0-65", -1410.0 },
+            { "234 * 2.003 - 5 + 1", 464.702 },
+            { "0x045 + 1.0", 70.0 },
+            { "-0Xdf / 1.0", -223.0 },
+            { "-0Xdf // 1", -223.0 },      // // always gives float
+            { "-0Xde / 2.0", -111.0 },
+            { "-0Xde // 2", -111.0 },      // // always gives float
+            { "(7 / 3) // 1", 2.0 },       // // always gives float
+            { "007 * 1.0", 7.0 },
+            { "03456 - 1.0", 1837.0 },
+            { "235.9 + k::flt", 1 },			// const
+            { " addition (3.0, 7) ", 10}
+        };
+        for (const auto& expr_result : expressions)
+        {
+            const char   * expr = expr_result.expr;
+            const double   expected_result = expr_result.expected_result;
+
+            cout << "flt expression : ";
+            cout.width(25);
+            cout << expr;
+            if (!strcmp(expr, "-234.9E-1") || !strcmp(expr, "-234.9E+1"))
+            {
+                M_TEST_EXCEPTION_ALREADY_KNOWN(compute_expression_static (type_definitions, expr));
+                continue;
+            }
+            C_value    value = compute_expression_static (type_definitions, expr);
+            cout << "    gives " << value.as_string() << endl;
+            M_TEST_EQ(value.get_flt(), expected_result);
+            M_TEST_EQ(value.get_bit_position_offset(), -1);
+            M_TEST_EQ(value.get_bit_position_size(), -1);
+        }
+    }
+
+    //-------------------------------------------------------------------------
+    // string static expression
+    //-------------------------------------------------------------------------
+    {
+        struct T_test_expr_str_result
+        {
+            const char  * expr;
+            const char  * expected_result;
+        };
+
+        const T_test_expr_str_result    expressions[] = {
+            { "\"salut\"", "salut" },
+            { "\"Hello world!\"", "Hello world!" },
+            { "\"Hello \" + \"world!\"", "Hello world!" },
+            { "\"Hello \"+ \"world!\"", "Hello world!" },
+            { "\"Hello \" +\"world!\"", "Hello world!" },
+            { "\"Hello \"+\"world!\"", "Hello world!" },
+            { "(\"Hello \" + \"world!\")", "Hello world!" },
+            { "(\"Hello \"+ \"world!\")", "Hello world!" },
+            { "(\"Hello \" +\"world!\")", "Hello world!" },
+            { "(\"Hello \"+\"world!\")", "Hello world!" },
+            { "\"last test\"", "last test" },
+            { "\"136\" + k::str", "136hello world" },			// const
+            { " addition (\"3.0\", \"7\") ", "3.07"}
+        };
+        for (const auto & expr_result : expressions)
+        {
+            const char       * expr            = expr_result.expr;
+            const string       expected_result = expr_result.expected_result;
+
+            cout << "str expression : ";
+            cout.width(25);
+            cout << expr;
+            C_value    value = compute_expression_static (type_definitions, expr);
+            cout << "    gives : " << value.as_string() << endl;
+            M_TEST_EQ(value.get_str(), expected_result);
+            M_TEST_EQ(value.get_bit_position_offset(), -1);
+            M_TEST_EQ(value.get_bit_position_size(), -1);
+        }
+    }
+
+    //-------------------------------------------------------------------------
+    // enum static expression
+    //-------------------------------------------------------------------------
+    {
+        C_value    value = compute_expression_static (type_definitions, "T_Operation::MODIFICATION");
+        M_TEST_EQ(value.get_int(), 1);
+        M_TEST_EQ(value.get_bit_position_offset(), -1);
+        M_TEST_EQ(value.get_bit_position_size(), -1);
+        value.as_string();
+    }
+
+    //-------------------------------------------------------------------------
+    // NOT static expression
+    //-------------------------------------------------------------------------
+    T_interpret_data                  interpret_data;
+
+    interpret_data.read_variable_group_begin("niv");
+    interpret_data.add_read_variable("salut", get_int_value_bit_pos_size(-32,12,7));
+    {
+        C_value   value = compute_expression_no_io (type_definitions, interpret_data, "salut");
+        M_TEST_EQ(value.get_int(), -32);
+        M_TEST_EQ(value.get_bit_position_offset(), 12);
+        M_TEST_EQ(value.get_bit_position_size(), 7);
+        value.as_string();
+    }
+    {
+        C_value   value = compute_expression_no_io (type_definitions, interpret_data, "niv.salut");
+        M_TEST_EQ(value.get_int(), -32);
+        M_TEST_EQ(value.get_bit_position_offset(), 12);
+        M_TEST_EQ(value.get_bit_position_size(), 7);
+        value.as_string();
+    }
+
+    interpret_data.read_variable_group_begin("e2");
+    interpret_data.add_read_variable("toi", get_int_value_bit_pos_size(-3450000,19,15));
+    interpret_data.read_variable_group_end();
+    {
+        C_value   value = compute_expression_no_io (type_definitions, interpret_data, "salut * e2.toi");
+        M_TEST_EQ(value.get_int(), 110400000);
+        M_TEST_EQ(value.get_bit_position_offset(), 12);
+        M_TEST_EQ(value.get_bit_position_size(), 22);
+        value.as_string();
+    }
+    {
+        C_value   value = compute_expression_no_io (type_definitions, interpret_data, "salut * e2.toi + T_Operation::DELETION");
+        M_TEST_EQ(value.get_int(), 110400000 + 2);
+        M_TEST_EQ(value.get_bit_position_offset(), 12);
+        M_TEST_EQ(value.get_bit_position_size(), 22);
+        value.as_string();
+    }
+
+    interpret_data.read_variable_group_begin("eau");
+    interpret_data.add_read_variable("la", get_int_value_bit_pos_size(3402340,30,31));
+    interpret_data.read_variable_group_end();
+    {
+        C_value   value = compute_expression_no_io (type_definitions, interpret_data, "salut * e2.toi / eau.la");
+        M_TEST_EQ(value.get_int(), 32);
+        M_TEST_EQ(value.get_bit_position_offset(), 12);
+        M_TEST_EQ(value.get_bit_position_size(), 49);
+        value.as_string();
+    }
+
+    interpret_data.add_read_variable("matelas", get_flt_value_bit_pos_size(45.3465,67,2));
+    {
+        C_value   value = compute_expression_no_io (type_definitions, interpret_data, "niv.salut * niv.e2.toi / niv.eau.la - niv.matelas");
+        M_TEST_EQ_APPROX(value.get_flt(), -13.3465);
+        M_TEST_EQ(value.get_bit_position_offset(), 12);
+        M_TEST_EQ(value.get_bit_position_size(), 57);
+        value.as_string();
+    }
+    {
+        C_value   value = compute_expression_no_io (type_definitions, interpret_data, "addition(niv.salut * niv.e2.toi, niv.eau.la / niv.matelas)");
+        M_TEST_EQ_APPROX(value.get_flt(), 110475607.5556);
+        M_TEST_EQ(value.get_bit_position_offset(), 12);
+        M_TEST_EQ(value.get_bit_position_size(), 57);
+        value.as_string();
+    }
+    {
+        C_value   value = compute_expression_no_io (type_definitions, interpret_data, "perf(niv.eau.la, 3402341)");
+        M_TEST_EQ(value.get_int(), 6804680);
+        M_TEST_EQ(value.get_bit_position_offset(), 30);
+        M_TEST_EQ(value.get_bit_position_size(), 31);
+        value.as_string();
+    }
+
+    //-------------------------------------------------------------------------
+    // Test array
+    //-------------------------------------------------------------------------
+    interpret_data.add_read_variable("an_array[0]", 1000);
+    interpret_data.add_read_variable("an_array[1]", 1001);
+    interpret_data.add_read_variable("an_array[2]", 1002);
+    interpret_data.add_read_variable("an_array[3]", 1003);
+    {
+        C_value   value = compute_expression_no_io (type_definitions, interpret_data, "an_array[0]");
+        M_TEST_EQ(value.get_int(), 1000);
+        value.as_string();
+    }
+
+    interpret_data.add_read_variable("idx", 1);
+    {
+        C_value   value = compute_expression_no_io (type_definitions, interpret_data, "an_array[idx]");
+        M_TEST_EQ(value.get_int(), 1001);
+        value.as_string();
+    }
+    {
+        C_value   value = compute_expression_no_io (type_definitions, interpret_data, "an_array[idx-1]");
+        M_TEST_EQ(value.get_int(), 1000);
+        value.as_string();
+    }
+    {
+        C_value   value = compute_expression_no_io (type_definitions, interpret_data, "an_array[idx+2]");
+        M_TEST_EQ(value.get_int(), 1003);
+        value.as_string();
+    }
+
+    //-------------------------------------------------------------------------
+    // Test array multiple
+    //-------------------------------------------------------------------------
+    interpret_data.add_read_variable("a_multiple_array[0][0]", "00");
+    interpret_data.add_read_variable("a_multiple_array[0][1]", "01");
+    interpret_data.add_read_variable("a_multiple_array[1][0]", "10");
+    interpret_data.add_read_variable("a_multiple_array[1][1]", "11");
+    interpret_data.add_read_variable("a_multiple_array[2][0]", "20");
+    interpret_data.add_read_variable("a_multiple_array[2][1]", "21");
+    interpret_data.add_read_variable("a_multiple_array[3][0]", "30");
+    interpret_data.add_read_variable("a_multiple_array[3][1]", "31");
+    interpret_data.add_read_variable("idx", 1);
+    {
+        C_value   value = compute_expression_no_io (type_definitions, interpret_data, "a_multiple_array[idx+2][idx-1]");
+        M_TEST_EQ(value.get_str(), "30");
+    }
+
+    interpret_data.add_read_variable("s_multiple_array[0][0].toto", "00");
+    interpret_data.add_read_variable("s_multiple_array[0][1].toto", "01");
+    interpret_data.add_read_variable("s_multiple_array[1][0].toto", "10");
+    interpret_data.add_read_variable("s_multiple_array[1][1].toto", "11");
+    interpret_data.add_read_variable("s_multiple_array[2][0].toto", "20");
+    interpret_data.add_read_variable("s_multiple_array[2][1].toto", "21");
+    interpret_data.add_read_variable("s_multiple_array[3][0].toto", "30");
+    interpret_data.add_read_variable("s_multiple_array[3][1].toto", "31");
+    interpret_data.add_read_variable("idx", 1);
+    {
+        C_value   value = compute_expression_no_io(type_definitions, interpret_data, "s_multiple_array[idx+1][idx].toto");
+        M_TEST_EQ(value.get_str(), "21");
+    }
+
+    //-------------------------------------------------------------------------
+    // NOT static expression build and compute
+    //-------------------------------------------------------------------------
+    {
+        T_expression    expression;
+        expression.build_expression(type_definitions, "another_value == 0 ? 4 : 6");
+
+        C_value    value;
+
+        interpret_data.add_read_variable("another_value", 1);
+        value = expression.compute_expression_no_io (type_definitions, interpret_data);
+        M_TEST_EQ(value.get_int(), 6);
+        value.as_string();
+
+        interpret_data.add_read_variable("another_value", 0);
+        value = expression.compute_expression_no_io (type_definitions, interpret_data);
+        M_TEST_EQ(value.get_int(), 4);
+        value.as_string();
+
+        interpret_data.add_read_variable("another_value", 2);
+        value = expression.compute_expression_no_io (type_definitions, interpret_data);
+        M_TEST_EQ(value.get_int(), 6);
+        value.as_string();
+    }
+
+    //-------------------------------------------------------------------------
+    // perf expression
+    //-------------------------------------------------------------------------
+    test_expression_perf_operation(type_definitions);
+    test_expression_perf_function(type_definitions);
+}
diff --git a/plugins/epan/generic/unitary_test_frame_data.cpp b/plugins/epan/generic/unitary_test_frame_data.cpp
new file mode 100644
index 00000000000..6f384b5a731
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_frame_data.cpp
@@ -0,0 +1,612 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "T_interpret_inside_frame.h"
+#include "T_frame_data_write.h"
+
+
+bool    read_data(T_frame_data& in_out_frame_data,
+    void* P_value_param,
+    const char* TYPE_NAME,
+    const size_t          TYPE_BIT_SIZE,
+    const char* TYPE_IMPL_STR,
+    const size_t          TYPE_IMPL_BIT_SIZE,
+    const bool            must_invert_bytes,
+    const bool            is_signed_integer);
+
+
+//*****************************************************************************
+// test_frame_data
+//*****************************************************************************
+
+M_TEST_FCT(test_frame_data)
+{
+    const unsigned char  bytes[] = { 0, 0, 0, 0, 1, 0, 1, 2, 3, 4, 0xff, 0xaa, 0x37 };
+    const long           initial_sizeof_bytes = sizeof(bytes)/sizeof(bytes[0]);
+
+    T_frame_data    frame_data(bytes, 0, initial_sizeof_bytes * 8);
+
+    // Position and movements.
+
+    M_TEST_EQ(frame_data.get_bit_offset(), 0);
+    M_TEST_EQ(frame_data.is_physically_at_beginning_of_byte(), true);
+    M_TEST_EQ(frame_data.get_P_bytes(), bytes);
+    M_TEST_EQ(frame_data.get_remaining_bits(), initial_sizeof_bytes*8);
+    M_TEST_EQ(frame_data.get_remaining_entire_bytes(), initial_sizeof_bytes);
+    M_TEST_EQ(frame_data.get_initial_sizeof_bits(), initial_sizeof_bytes * 8);
+
+    M_TEST_EQ(frame_data.can_move_1_byte_forward(), true);
+    frame_data.move_1_byte_forward();
+    M_TEST_EQ(frame_data.get_bit_offset(), 8);
+    M_TEST_EQ(frame_data.is_physically_at_beginning_of_byte(), true);
+    M_TEST_EQ(frame_data.get_remaining_bits(), (initial_sizeof_bytes-1)*8);
+    M_TEST_EQ(frame_data.get_remaining_entire_bytes(), initial_sizeof_bytes-1);
+    M_TEST_EQ(frame_data.get_initial_sizeof_bits(), initial_sizeof_bytes * 8);
+
+    M_TEST_EQ(frame_data.can_move_forward(2, 1), true);
+    frame_data.move_forward(2, 1);
+    M_TEST_EQ(frame_data.get_bit_offset(), 25);
+    M_TEST_EQ(frame_data.is_physically_at_beginning_of_byte(), false);
+    M_TEST_EQ(frame_data.get_remaining_bits(), (initial_sizeof_bytes*8)-frame_data.get_bit_offset());
+    M_TEST_EQ(frame_data.get_remaining_entire_bytes(), initial_sizeof_bytes-3-1);
+    M_TEST_EQ(frame_data.get_initial_sizeof_bits(), initial_sizeof_bytes * 8);
+
+    M_TEST_EQ(frame_data.can_move_bit_forward(3), true);
+    frame_data.move_bit_forward(3);
+    M_TEST_EQ(frame_data.get_bit_offset(), 28);
+    M_TEST_EQ(frame_data.is_physically_at_beginning_of_byte(), false);
+    M_TEST_EQ(frame_data.get_remaining_bits(), (initial_sizeof_bytes*8)-frame_data.get_bit_offset());
+    M_TEST_EQ(frame_data.get_remaining_entire_bytes(), initial_sizeof_bytes-3-1);
+    M_TEST_EQ(frame_data.get_initial_sizeof_bits(), initial_sizeof_bytes * 8);
+
+    M_TEST_EQ(frame_data.can_move_bit(-3), true);
+    frame_data.move_bit(-3);
+    M_TEST_EQ(frame_data.get_bit_offset(), 25);
+    M_TEST_EQ(frame_data.is_physically_at_beginning_of_byte(), false);
+    M_TEST_EQ(frame_data.get_remaining_bits(), (initial_sizeof_bytes*8)-frame_data.get_bit_offset());
+    M_TEST_EQ(frame_data.get_remaining_entire_bytes(), initial_sizeof_bytes-3-1);
+    M_TEST_EQ(frame_data.get_initial_sizeof_bits(), initial_sizeof_bytes * 8);
+
+    M_TEST_EQ(frame_data.can_move(-2, -1), true);
+    frame_data.move(-2, -1);
+    M_TEST_EQ(frame_data.get_bit_offset(), 8);
+    M_TEST_EQ(frame_data.is_physically_at_beginning_of_byte(), true);
+    M_TEST_EQ(frame_data.get_remaining_bits(), (initial_sizeof_bytes-1)*8);
+    M_TEST_EQ(frame_data.get_remaining_entire_bytes(), initial_sizeof_bytes-1);
+    M_TEST_EQ(frame_data.get_initial_sizeof_bits(), initial_sizeof_bytes * 8);
+
+    frame_data.set_offset(3, 7);
+    M_TEST_EQ(frame_data.get_bit_offset(), 31);
+    M_TEST_EQ(frame_data.is_physically_at_beginning_of_byte(), false);
+    M_TEST_EQ(frame_data.get_remaining_bits(), (initial_sizeof_bytes*8)-frame_data.get_bit_offset());
+    M_TEST_EQ(frame_data.get_remaining_entire_bytes(), initial_sizeof_bytes-3-1);
+    M_TEST_EQ(frame_data.get_initial_sizeof_bits(), initial_sizeof_bytes * 8);
+
+    frame_data.set_bit_offset(37);
+    M_TEST_EQ(frame_data.get_bit_offset(), 37);
+    M_TEST_EQ(frame_data.is_physically_at_beginning_of_byte(), false);
+    M_TEST_EQ(frame_data.get_remaining_bits(), (initial_sizeof_bytes*8)-frame_data.get_bit_offset());
+    M_TEST_EQ(frame_data.get_remaining_entire_bytes(), initial_sizeof_bytes-4-1);
+    M_TEST_EQ(frame_data.get_initial_sizeof_bits(), initial_sizeof_bytes * 8);
+
+
+#define M_TEST_READ_EQ(READ_OPER,VALUE)                          \
+{                                                                \
+    const long  value_read = READ_OPER;                          \
+    M_TEST_EQ(value_read, VALUE);                                \
+}
+
+    // Read bytes on byte position.
+    frame_data.set_bit_offset(0);
+
+    M_TEST_EQ(frame_data.read_1_byte(), 0);
+
+    {
+        unsigned char  bytes_read[4];
+        const long     initial_sizeof_bytes_read = sizeof(bytes_read)/sizeof(bytes_read[0]);
+
+        frame_data.read_n_bytes(initial_sizeof_bytes_read, bytes_read);
+
+        T_frame_data    frame_data_read(bytes_read, 0, initial_sizeof_bytes_read * 8);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 0);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 0);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 0);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 1);
+        M_TEST_READ_EQ(frame_data_read.can_move_bit_forward(1), false);
+    }
+    {
+        unsigned char  bytes_read[5];
+        const long     initial_sizeof_bytes_read = sizeof(bytes_read)/sizeof(bytes_read[0]);
+
+        frame_data.read_n_bytes(initial_sizeof_bytes_read, bytes_read);
+
+        T_frame_data    frame_data_read(bytes_read, 0, initial_sizeof_bytes_read * 8);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 0);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 1);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 2);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 3);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 4);
+        M_TEST_READ_EQ(frame_data_read.can_move_bit_forward(1), false);
+    }
+    {
+        unsigned char  bytes_read[3];
+        const long     initial_sizeof_bytes_read = sizeof(bytes_read)/sizeof(bytes_read[0]);
+
+        frame_data.read_n_bytes(initial_sizeof_bytes_read, bytes_read);
+
+        T_frame_data    frame_data_read(bytes_read, 0, initial_sizeof_bytes_read * 8);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 0xff);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 0xaa);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 0x37);
+        M_TEST_READ_EQ(frame_data_read.can_move_bit_forward(1), false);
+    }
+    M_TEST_EQ(frame_data.can_move_bit_forward(1), false);
+
+
+    // Read byte on bit position.
+    frame_data.set_bit_offset(0);
+
+    frame_data.move_bit_forward(1);
+    M_TEST_READ_EQ(frame_data.read_1_byte(), 0);
+
+    frame_data.move_bit_forward(1);
+    M_TEST_READ_EQ(frame_data.read_1_byte(), 0);
+
+    frame_data.move_bit_forward(1);
+    M_TEST_READ_EQ(frame_data.read_1_byte(), 0);
+
+    frame_data.move_bit_forward(1);
+    M_TEST_READ_EQ(frame_data.read_1_byte(), 0);
+
+    frame_data.move_bit_forward(1);
+    M_TEST_READ_EQ(frame_data.read_1_byte(), 32);
+
+    frame_data.move_bit_forward(1);
+    M_TEST_READ_EQ(frame_data.read_1_byte(), 0);
+
+    M_TEST_READ_EQ(frame_data.read_1_byte(), 64);
+    M_TEST_READ_EQ(frame_data.read_1_byte(), 128);
+    M_TEST_READ_EQ(frame_data.read_1_byte(), 192+1);
+    M_TEST_READ_EQ(frame_data.read_1_byte(), 63);
+    M_TEST_READ_EQ(frame_data.read_1_byte(), 128+64+32+ 0+8+0+2+0);
+    M_TEST_READ_EQ(frame_data.read_1_byte(), 128+ 0+ 0+ 0+8+4+0+1);
+
+    M_TEST_EQ(frame_data.can_move_bit_forward(2), true);
+    M_TEST_EQ(frame_data.can_move_bit_forward(3), false);
+
+    frame_data.move_bit(-6);
+    M_TEST_READ_EQ(frame_data.read_1_byte(), 0x37);
+
+
+    // Read bytes on bit position.
+    frame_data.set_bit_offset(0);
+
+    frame_data.move_bit_forward(1);
+    M_TEST_READ_EQ(frame_data.read_1_byte(), 0);
+
+    {
+        unsigned char  bytes_read[4];
+        const long     initial_sizeof_bytes_read = sizeof(bytes_read)/sizeof(bytes_read[0]);
+
+        frame_data.read_n_bytes(initial_sizeof_bytes_read, bytes_read);
+
+        T_frame_data    frame_data_read(bytes_read, 0, initial_sizeof_bytes_read * 8);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 0);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 0);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 0);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 2);
+        M_TEST_READ_EQ(frame_data_read.can_move_bit_forward(1), false);
+    }
+    {
+        unsigned char  bytes_read[5];
+        const long     initial_sizeof_bytes_read = sizeof(bytes_read)/sizeof(bytes_read[0]);
+
+        frame_data.read_n_bytes(initial_sizeof_bytes_read, bytes_read);
+
+        T_frame_data    frame_data_read(bytes_read, 0, initial_sizeof_bytes_read * 8);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 0);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 2);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 4);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 6);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 8+1);
+        M_TEST_READ_EQ(frame_data_read.can_move_bit_forward(1), false);
+    }
+    {
+        unsigned char  bytes_read[2];
+        const long     initial_sizeof_bytes_read = sizeof(bytes_read)/sizeof(bytes_read[0]);
+
+        frame_data.read_n_bytes(initial_sizeof_bytes_read, bytes_read);
+
+        T_frame_data    frame_data_read(bytes_read, 0, initial_sizeof_bytes_read * 8);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 0xff);
+        M_TEST_READ_EQ(frame_data_read.read_1_byte(), 0x54);
+        M_TEST_READ_EQ(frame_data_read.can_move_bit_forward(1), false);
+    }
+    M_TEST_EQ(frame_data.can_move_bit_forward(7),  true);
+    M_TEST_EQ(frame_data.can_move_bit_forward(8), false);
+
+    // Read bits.
+    frame_data.set_bit_offset(0);
+
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(7), 0);
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(7), 0);
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(7), 0);
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(7), 0);
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(7), 0);
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(7), 4);
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(7), 0);
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(7), 1);
+
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(7), 1);
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(7), 0);
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(7), 64+32);
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(7), 64+ 0+ 0+8+4+2+1);
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(7), 64+32+16+8+4+0+1);
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(7),  0+32+ 0+8+0+0+0);
+    M_TEST_READ_EQ(frame_data.read_less_1_byte(6),    32+16+0+4+2+1);
+    M_TEST_EQ(frame_data.can_move_bit_forward(1), false);
+}
+
+//*****************************************************************************
+// test_frame_data_write
+//*****************************************************************************
+
+M_TEST_FCT(test_frame_data_write)
+{
+    unsigned char  bytes[200];
+    long           initial_sizeof_bytes = sizeof(bytes)/sizeof(bytes[0]);
+
+    unsigned char  data[] = { 0xe0, 0xd7, 0xc3, 0x20, 0x31, 0x40, 0x51, 0x72, 0x03, 0x04, 0xff, 0xaa, 0x37 };
+    long           initial_sizeof_data = sizeof(data)/sizeof(data[0]);
+
+    // write_1_byte
+    {
+        memset(bytes, 0, sizeof(bytes));
+        T_frame_data_write    frame_data_write(bytes, 0, initial_sizeof_data * 8);
+        T_frame_data          frame_data      (bytes, 0, initial_sizeof_data * 8);
+
+        for (int  idx = 0; idx < initial_sizeof_data; ++idx)
+        {
+            frame_data_write.write_1_byte(data[idx]);
+            M_TEST_EQ(frame_data.read_1_byte(), data[idx]);
+        }
+
+        M_TEST_EQ(frame_data_write.get_remaining_bits(), 0);
+        M_TEST_EQ(frame_data.get_remaining_bits(), 0);
+    }
+
+    // write_less_1_byte
+    {
+        memset(bytes, 0, sizeof(bytes));
+        T_frame_data_write    frame_data_write(bytes, 0, initial_sizeof_data * 8);
+        T_frame_data          frame_data      (bytes, 0, initial_sizeof_data * 8);
+
+        for (int  idx = 0; idx < initial_sizeof_data; ++idx)
+        {
+            const short  n_bits = 1 + (idx % 7);
+            frame_data_write.write_less_1_byte(data[idx], n_bits);
+            M_TEST_EQ(frame_data.read_less_1_byte(n_bits), bit_erase_left(data[idx], 8-n_bits));
+        }
+
+        M_TEST_EQ(frame_data_write.get_bit_offset(), frame_data.get_bit_offset());
+    }
+
+    // A tester : write_n_bytes
+    // A tester : write_n_bits
+}
+
+//*****************************************************************************
+// test_read_data
+//*****************************************************************************
+
+M_TEST_FCT(test_read_data)
+{
+    bool            is_signed_integer = false;
+
+    // Float.
+    is_signed_integer = false;
+    {
+        double          frame_data_value = -23655869876.44864;
+        T_frame_data    frame_data(&frame_data_value, 0, sizeof(frame_data_value) * 8);
+
+        double          read_value = 0;
+        M_TEST_EQ(read_data(frame_data,
+                            &read_value,
+                            "float64", 64,
+                            "double", 64,
+                            false,
+                            is_signed_integer), true);
+        M_TEST_EQ(read_value, frame_data_value);
+    }
+    {
+        float           frame_data_value = -23655869876.44864e32;
+        T_frame_data    frame_data(&frame_data_value, 0, sizeof(frame_data_value) * 8);
+
+        float           read_value = 0;
+        M_TEST_EQ(read_data(frame_data,
+                            &read_value,
+                            "float32", 32,
+                            "float", 32,
+                            false,
+                            is_signed_integer), true);
+        M_TEST_EQ(read_value, frame_data_value);
+    }
+
+    // Signed byte integers.
+    is_signed_integer = true;
+    {
+        signed long long      frame_data_value = -123456789012345LL;
+        T_frame_data    frame_data(&frame_data_value, 0, sizeof(frame_data_value) * 8);
+
+        signed long long    read_value = 0;
+        M_TEST_EQ(read_data(frame_data,
+                            &read_value,
+                            "int64", 64,
+                            "signed long long", 64,
+                            false,
+                            is_signed_integer), true);
+        M_TEST_EQ(read_value, frame_data_value);
+    }
+    {
+        signed int      frame_data_value = -23456789;
+        T_frame_data    frame_data(&frame_data_value, 0, sizeof(frame_data_value) * 8);
+
+        signed int    read_value = 0;
+        M_TEST_EQ(read_data(frame_data,
+                            &read_value,
+                            "int32", 32,
+                            "signed int", 32,
+                            false,
+                            is_signed_integer), true);
+        M_TEST_EQ(read_value, frame_data_value);
+    }
+    {
+        signed int      frame_data_value = -3456789;
+        T_frame_data    frame_data(&frame_data_value, 0, sizeof(frame_data_value) * 8);  // intel only
+
+        signed int      read_value = 0;
+        M_TEST_EQ(read_data(frame_data,
+                            &read_value,
+                            "int24", 24,
+                            "signed int", 32,
+                            false,
+                            is_signed_integer), true);
+        M_TEST_EQ(read_value, frame_data_value);
+    }
+    {
+        signed short    frame_data_value = -26789;
+        T_frame_data    frame_data(&frame_data_value, 0, sizeof(frame_data_value) * 8);
+
+        signed short    read_value = 0;
+        M_TEST_EQ(read_data(frame_data,
+                            &read_value,
+                            "int16", 16,
+                            "signed short", 16,
+                            false,
+                            is_signed_integer), true);
+        M_TEST_EQ(read_value, frame_data_value);
+    }
+    {
+        signed char     frame_data_value = -119;
+        T_frame_data    frame_data(&frame_data_value, 0, sizeof(frame_data_value) * 8);
+
+        signed char     read_value = 0;
+        M_TEST_EQ(read_data(frame_data,
+                            &read_value,
+                            "int8", 8,
+                            "signed char", 8,
+                            false,
+                            is_signed_integer), true);
+        M_TEST_EQ(read_value, frame_data_value);
+    }
+
+    // Signed bit integers.
+    {
+        signed char     frame_data_value = -128;
+        T_frame_data    frame_data(&frame_data_value, 0, sizeof(frame_data_value) * 8);
+
+        {
+            signed char     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int7", 7,
+                                "signed char", 8,
+                                false,
+                                is_signed_integer), true);
+            M_TEST_EQ(read_value, -64);
+        }
+        frame_data.set_bit_offset(0);
+        {
+            signed char     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int4", 4,
+                                "signed char", 8,
+                                false,
+                                is_signed_integer), true);
+            M_TEST_EQ(read_value, -8);
+        }
+        frame_data.set_bit_offset(0);
+        {
+            signed char     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int2", 2,
+                                "signed char", 8,
+                                false,
+                                is_signed_integer), true);
+            M_TEST_EQ(read_value, -2);
+        }
+        frame_data.set_bit_offset(0);
+        {
+            signed short     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int7", 7,
+                                "signed short", 16,
+                                false,
+                                is_signed_integer), true);
+            M_TEST_EQ(read_value, -64);
+        }
+        frame_data.set_bit_offset(0);
+        {
+            signed int     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int4", 4,
+                                "signed int", 32,
+                                false,
+                                is_signed_integer), true);
+            M_TEST_EQ(read_value, -8);
+        }
+        frame_data.set_bit_offset(0);
+        {
+            signed long long     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int2", 2,
+                                "signed long long", 64,
+                                false,
+                                is_signed_integer), true);
+            M_TEST_EQ(read_value, -2);
+        }
+    }
+    {
+        signed int      frame_data_value = -128;    // 0xffffff80 -> 80 ff ff ff
+
+        T_frame_data    frame_data(&frame_data_value, 0, sizeof(frame_data_value) * 8);
+
+        frame_data.set_bit_offset(0);
+        {
+            signed int     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int4", 4,
+                                "signed int", 32,
+                                false,
+                                is_signed_integer), true);    // bits read = (1)000 -> 7 +1
+            M_TEST_EQ(read_value, -8);
+        }
+        frame_data.set_bit_offset(0);
+        {
+            signed int     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int7", 7,
+                                "signed int", 32,
+                                false,
+                                is_signed_integer), true);    // bits read = (1)000000 -> 63 +1
+            M_TEST_EQ(read_value, -64);
+        }
+        frame_data.set_bit_offset(0);
+        {
+            signed int     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int8", 8,
+                                "signed int", 32,
+                                false,
+                                is_signed_integer), true);    // bits read = (1)0000000 -> 127 +1
+            M_TEST_EQ(read_value, -128);
+        }
+        frame_data.set_bit_offset(0);
+        {
+            signed int     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int9", 9,
+                                "signed int", 32,
+                                false,
+                                is_signed_integer), true);    // bits read = (1) 00000001 -> 254 +1
+            M_TEST_EQ(read_value, -255);
+        }
+        frame_data.set_bit_offset(0);
+        {
+            signed int     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int10", 10,
+                                "signed int", 32,
+                                false,
+                                is_signed_integer), true);    // bits read = (1)1 00000010 -> 253 +1
+            M_TEST_EQ(read_value, -254);
+        }
+        frame_data.set_bit_offset(0);
+        {
+            signed int     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int11", 11,
+                                "signed int", 32,
+                                false,
+                                is_signed_integer), true);    // bits read = (1)11 00000100 -> 251 +1
+            M_TEST_EQ(read_value, -252);
+        }
+        frame_data.set_bit_offset(0);
+        {
+            signed int     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int15", 15,
+                                "signed int", 32,
+                                false,
+                                is_signed_integer), true);    // bits read = (1)111111 01000000 -> 191 +1
+            M_TEST_EQ(read_value, -192);
+        }
+        frame_data.set_bit_offset(0);
+        {
+            signed int     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int16", 16,
+                                "signed int", 32,
+                                false,
+                                is_signed_integer), true);    // bits read = (1)1111111 10000000 -> 127 +1
+            M_TEST_EQ(read_value, -128);
+        }
+        frame_data.set_bit_offset(0);
+        {
+            signed int     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int17", 17,
+                                "signed int", 32,
+                                false,
+                                is_signed_integer), true);    // bits read = (1)1111111 00000001 00000001 -> 65278 +1
+            M_TEST_EQ(read_value, -65279);
+        }
+        frame_data.set_bit_offset(0);
+        {
+            signed int     read_value = 0;
+            M_TEST_EQ(read_data(frame_data,
+                                &read_value,
+                                "int31", 31,
+                                "signed int", 32,
+                                false,
+                                is_signed_integer), true);    // bits read = (1)111111 1..1 01111111 01000000 ->  +1
+            M_TEST_EQ(read_value, -32960);
+        }
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_generic_protocol_data_base.cpp b/plugins/epan/generic/unitary_test_generic_protocol_data_base.cpp
new file mode 100644
index 00000000000..b46a255043b
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_generic_protocol_data_base.cpp
@@ -0,0 +1,461 @@
+/*
+ * Copyright 2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_common_exception.h"
+#include "T_generic_protocol_data_base.h"
+
+
+//*****************************************************************************
+// test_read_file_wsgd_until_types__ko_PROTO_TYPE_DEFINITIONS_not_found
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_until_types__ko_PROTO_TYPE_DEFINITIONS_not_found)
+{
+    T_generic_protocol_data_base  protocol_data;
+    T_stats                       stats;
+
+    istringstream  iss("");
+
+    M_TEST_CATCH_EXCEPTION(
+        read_file_wsgd_until_types(iss, protocol_data, stats),
+        C_byte_interpret_exception);
+    M_TEST_EQ(protocol_data.DEBUG, false);
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_until_types__ok_empty
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_until_types__ok_empty)
+{
+    T_generic_protocol_data_base  protocol_data;
+    T_stats                       stats;
+
+    {
+        istringstream  iss("PROTO_TYPE_DEFINITIONS");
+        read_file_wsgd_until_types(iss, protocol_data, stats);
+        M_TEST_EQ(protocol_data.DEBUG, E_debug_status_OFF);
+    }
+    {
+        istringstream  iss(R"(
+
+
+PROTO_TYPE_DEFINITIONS
+
+)");
+        read_file_wsgd_until_types(iss, protocol_data, stats);
+        M_TEST_EQ(protocol_data.DEBUG, E_debug_status_OFF);
+    }
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_until_types__ok_DEBUG
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_until_types__ok_DEBUG)
+{
+    T_generic_protocol_data_base  protocol_data;
+    T_stats                       stats;
+
+    {
+        istringstream  iss(R"(
+DEBUG
+PROTO_TYPE_DEFINITIONS)");
+        read_file_wsgd_until_types(iss, protocol_data, stats);
+        M_TEST_EQ(protocol_data.DEBUG, E_debug_status_ON);
+    }
+    {
+        istringstream  iss(R"(
+DEBUG_NO_TIME
+PROTO_TYPE_DEFINITIONS)");
+        read_file_wsgd_until_types(iss, protocol_data, stats);
+        M_TEST_EQ(protocol_data.DEBUG, E_debug_status_ON_NO_TIME);
+    }
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_until_types__ok_proto_ident
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_until_types__ok_proto_ident)
+{
+    T_generic_protocol_data_base  protocol_data;
+    T_stats                       stats;
+
+    {
+        istringstream  iss(R"(
+PROTONAME         Samsung TV Remote Control  
+PROTOSHORTNAME    SR  
+PROTOABBREV       samsung_remote  
+PROTO_TYPE_DEFINITIONS)");
+        read_file_wsgd_until_types(iss, protocol_data, stats);
+
+        M_TEST_EQ(protocol_data.PROTONAME, "Samsung TV Remote Control");
+        M_TEST_EQ(protocol_data.PROTOSHORTNAME, "SR");
+        M_TEST_EQ(protocol_data.PROTOABBREV, "samsung_remote");
+    }
+    // Double definition is forbidden
+    {
+        istringstream  iss(R"(
+PROTONAME         New TV Remote Control  
+PROTO_TYPE_DEFINITIONS)");
+        M_TEST_CATCH_EXCEPTION(
+            read_file_wsgd_until_types(iss, protocol_data, stats),
+            C_byte_interpret_exception);
+
+        M_TEST_EQ(protocol_data.PROTONAME, "Samsung TV Remote Control");
+    }
+    {
+        istringstream  iss(R"(
+PROTOSHORTNAME    NEW  
+PROTO_TYPE_DEFINITIONS)");
+        M_TEST_CATCH_EXCEPTION(
+            read_file_wsgd_until_types(iss, protocol_data, stats),
+            C_byte_interpret_exception);
+
+        M_TEST_EQ(protocol_data.PROTOSHORTNAME, "SR");
+    }
+    {
+        istringstream  iss(R"(
+PROTOABBREV       new_remote  
+PROTO_TYPE_DEFINITIONS)");
+        M_TEST_CATCH_EXCEPTION(
+            read_file_wsgd_until_types(iss, protocol_data, stats),
+            C_byte_interpret_exception);
+
+        M_TEST_EQ(protocol_data.PROTOABBREV, "samsung_remote");
+    }
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_until_types__ok_PARENT_SUBFIELD
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_until_types__ok_PARENT_SUBFIELD)
+{
+    {
+        // values = string
+        T_generic_protocol_data_base  protocol_data;
+        T_stats                       stats;
+
+        istringstream  iss(R"(
+PARENT_SUBFIELD          tcp.port
+PARENT_SUBFIELD_VALUES   "55000" "toto"
+PROTO_TYPE_DEFINITIONS)");
+        read_file_wsgd_until_types(iss, protocol_data, stats);
+
+        M_TEST_EQ(protocol_data.PARENTS.size(), 1);
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD, "tcp.port");
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD_VALUES_str.size(), 2);
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD_VALUES_str[0], "55000");
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD_VALUES_str[1], "toto");
+    }
+    {
+        // values = int
+        T_generic_protocol_data_base  protocol_data;
+        T_stats                       stats;
+
+        istringstream  iss(R"(
+PARENT_SUBFIELD          udp.port
+PARENT_SUBFIELD_VALUES   55000 55001
+PROTO_TYPE_DEFINITIONS)");
+        read_file_wsgd_until_types(iss, protocol_data, stats);
+
+        M_TEST_EQ(protocol_data.PARENTS.size(), 1);
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD, "udp.port");
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD_VALUES_int.size(), 2);
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD_VALUES_int[0], 55000);
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD_VALUES_int[1], 55001);
+    }
+    {
+        // values = range
+        T_generic_protocol_data_base  protocol_data;
+        T_stats                       stats;
+
+        istringstream  iss(R"(
+PARENT_SUBFIELD          some.thing
+PARENT_SUBFIELD_RANGE    55000 55100
+PROTO_TYPE_DEFINITIONS)");
+        read_file_wsgd_until_types(iss, protocol_data, stats);
+
+        M_TEST_EQ(protocol_data.PARENTS.size(), 1);
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD, "some.thing");
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD_RANGES_int.size(), 1);
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD_RANGES_int[0].first, 55000);
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD_RANGES_int[0].second, 55100);
+    }
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_until_types__ko_PARENT_SUBFIELD_mixed
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_until_types__ko_PARENT_SUBFIELD_mixed)
+{
+    {
+        // KO mixed values 
+        T_generic_protocol_data_base  protocol_data;
+        T_stats                       stats;
+
+        istringstream  iss(R"(
+PARENT_SUBFIELD          tcp.port
+PARENT_SUBFIELD_VALUES   55000 "55001"
+PROTO_TYPE_DEFINITIONS)");
+        M_TEST_CATCH_EXCEPTION(
+            read_file_wsgd_until_types(iss, protocol_data, stats),
+            C_byte_interpret_exception);
+    }
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_until_types__ok_multiple_PARENT_SUBFIELD
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_until_types__ok_multiple_PARENT_SUBFIELD)
+{
+    {
+        // values = string
+        T_generic_protocol_data_base  protocol_data;
+        T_stats                       stats;
+
+        istringstream  iss(R"(
+PARENT_SUBFIELD          tcp.port
+PARENT_SUBFIELD_VALUES   "55000" "toto"
+
+PARENT_SUBFIELD          udp.port
+PARENT_SUBFIELD_VALUES   55000 55001
+
+PARENT_SUBFIELD          some.thing
+PARENT_SUBFIELD_RANGE    55000 55100
+
+PROTO_TYPE_DEFINITIONS)");
+        read_file_wsgd_until_types(iss, protocol_data, stats);
+
+        M_TEST_EQ(protocol_data.PARENTS.size(), 3);
+
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD, "tcp.port");
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD_VALUES_str.size(), 2);
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD_VALUES_str[0], "55000");
+        M_TEST_EQ(protocol_data.PARENTS[0].PARENT_SUBFIELD_VALUES_str[1], "toto");
+
+        M_TEST_EQ(protocol_data.PARENTS[1].PARENT_SUBFIELD, "udp.port");
+        M_TEST_EQ(protocol_data.PARENTS[1].PARENT_SUBFIELD_VALUES_int.size(), 2);
+        M_TEST_EQ(protocol_data.PARENTS[1].PARENT_SUBFIELD_VALUES_int[0], 55000);
+        M_TEST_EQ(protocol_data.PARENTS[1].PARENT_SUBFIELD_VALUES_int[1], 55001);
+
+        M_TEST_EQ(protocol_data.PARENTS[2].PARENT_SUBFIELD, "some.thing");
+        M_TEST_EQ(protocol_data.PARENTS[2].PARENT_SUBFIELD_RANGES_int.size(), 1);
+        M_TEST_EQ(protocol_data.PARENTS[2].PARENT_SUBFIELD_RANGES_int[0].first, 55000);
+        M_TEST_EQ(protocol_data.PARENTS[2].PARENT_SUBFIELD_RANGES_int[0].second, 55100);
+    }
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_until_types__ok_PARENT_HEURISTIC
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_until_types__ok_PARENT_HEURISTIC)
+{
+    T_generic_protocol_data_base  protocol_data;
+    T_stats                       stats;
+
+    istringstream  iss(R"(
+PARENT_HEURISTIC         tcp  
+PARENT_HEURISTIC         another_proto
+HEURISTIC_FUNCTION       "the_function_to_call"
+PROTO_TYPE_DEFINITIONS)");
+    read_file_wsgd_until_types(iss, protocol_data, stats);
+
+    M_TEST_EQ(protocol_data.PARENTS_HEURISTIC.size(), 2);
+    M_TEST_EQ(protocol_data.PARENTS_HEURISTIC[0], "tcp");
+    M_TEST_EQ(protocol_data.PARENTS_HEURISTIC[1], "another_proto");
+    M_TEST_EQ(protocol_data.HEURISTIC_FUNCTION, "the_function_to_call");
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_until_types__ok_ADD_FOR_DECODE_AS_TABLE
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_until_types__ok_ADD_FOR_DECODE_AS_TABLE)
+{
+    T_generic_protocol_data_base  protocol_data;
+    T_stats                       stats;
+
+    istringstream  iss(R"(
+ADD_FOR_DECODE_AS_TABLE         table  
+ADD_FOR_DECODE_AS_TABLE         another_table
+PROTO_TYPE_DEFINITIONS)");
+    read_file_wsgd_until_types(iss, protocol_data, stats);
+
+    M_TEST_EQ(protocol_data.ADD_FOR_DECODE_AS_TABLES.size(), 2);
+    M_TEST_EQ(protocol_data.ADD_FOR_DECODE_AS_TABLES[0], "table");
+    M_TEST_EQ(protocol_data.ADD_FOR_DECODE_AS_TABLES[1], "another_table");
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_until_types__SUBFIELD
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_until_types__SUBFIELD)
+{
+    {
+        T_generic_protocol_data_base  protocol_data;
+        T_stats                       stats;
+
+        istringstream  iss(R"(
+SUBFIELD         field  uint8  
+PROTO_TYPE_DEFINITIONS)");
+        read_file_wsgd_until_types(iss, protocol_data, stats);
+
+        M_TEST_EQ(protocol_data.SUBPROTO_SUBFIELD, "field");
+        M_TEST_EQ(protocol_data.SUBPROTO_SUBFIELD_TYPE, "uint8");
+        M_TEST_EQ(protocol_data.SUBPROTO_SUBFIELD_TYPE_WS, FT_UINT8);
+
+        {
+            // ko SUBPROTO_SUBFIELD already defined
+            istringstream  iss(R"(
+SUBFIELD         field  uint8  
+PROTO_TYPE_DEFINITIONS)");
+            M_TEST_CATCH_EXCEPTION(
+                read_file_wsgd_until_types(iss, protocol_data, stats),
+                C_byte_interpret_exception);
+        }
+    }
+    {
+        // ko bad type
+        T_generic_protocol_data_base  protocol_data;
+        T_stats                       stats;
+
+        istringstream  iss(R"(
+SUBFIELD         field  int8  
+PROTO_TYPE_DEFINITIONS)");
+        M_TEST_CATCH_EXCEPTION(
+            read_file_wsgd_until_types(iss, protocol_data, stats),
+            C_byte_interpret_exception);
+    }
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_until_types__SUBFIELD_from
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_until_types__SUBFIELD_from)
+{
+    {
+        T_generic_protocol_data_base  protocol_data;
+        T_stats                       stats;
+
+        istringstream  iss(R"(
+SUBFIELD         pseudo_field  string  from  real1  real2  real3
+PROTO_TYPE_DEFINITIONS)");
+        read_file_wsgd_until_types(iss, protocol_data, stats);
+
+        M_TEST_EQ(protocol_data.SUBPROTO_SUBFIELD, "pseudo_field");
+        M_TEST_EQ(protocol_data.SUBPROTO_SUBFIELD_TYPE, "string");
+        M_TEST_EQ(protocol_data.SUBPROTO_SUBFIELD_TYPE_WS, FT_STRING);
+        M_TEST_EQ(protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_1, "real1");
+        M_TEST_EQ(protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_2, "real2");
+        M_TEST_EQ(protocol_data.SUBPROTO_SUBFIELD_FROM_REAL_3, "real3");
+    }
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_until_types__MSG
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_until_types__MSG)
+{
+    T_generic_protocol_data_base  protocol_data;
+    T_stats                       stats;
+
+    istringstream  iss(R"(
+MSG_HEADER_TYPE                      a_type
+MSG_ID_FIELD_NAME                    msg_id
+MSG_TITLE                            msg_title
+MSG_SUMMARY_SUBSIDIARY_FIELD_NAMES   field1  field2
+MSG_MAIN_TYPE                        main_type
+MSG_FROM_MAIN_TYPE                   from_type
+MSG_TO_MAIN_TYPE                     to_type
+MSG_TOTAL_LENGTH                     Size + 12  
+MSG_HEADER_LENGTH                    12
+MSG_TRAILER_LENGTH                   2
+GLOBAL_DATA_TYPE                     global_type
+PROTO_TYPE_DEFINITIONS)");
+    read_file_wsgd_until_types(iss, protocol_data, stats);
+
+    M_TEST_EQ(protocol_data.MSG_HEADER_TYPE, "a_type");
+    M_TEST_EQ(protocol_data.MSG_ID_FIELD_NAME, "msg_id");
+    M_TEST_EQ(protocol_data.MSG_TITLE, "msg_title");
+    M_TEST_EQ(protocol_data.MSG_SUMMARY_SUBSIDIARY_FIELD_NAMES.size(), 2);
+    M_TEST_EQ(protocol_data.MSG_SUMMARY_SUBSIDIARY_FIELD_NAMES[0], "field1");
+    M_TEST_EQ(protocol_data.MSG_SUMMARY_SUBSIDIARY_FIELD_NAMES[1], "field2");
+    M_TEST_EQ(protocol_data.MSG_MAIN_TYPE, "main_type");
+    M_TEST_EQ(protocol_data.MSG_FROM_MAIN_TYPE, "from_type");
+    M_TEST_EQ(protocol_data.MSG_TO_MAIN_TYPE, "to_type");
+    M_TEST_EQ(protocol_data.MSG_TOTAL_LENGTH, "Size + 12  ");
+    M_TEST_EQ(protocol_data.MSG_HEADER_LENGTH, 12);
+    M_TEST_EQ(protocol_data.MSG_TRAILER_LENGTH, 2);
+    M_TEST_EQ(protocol_data.GLOBAL_DATA_TYPE, "global_type");
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_until_types__MSG_bool
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_until_types__MSG_bool)
+{
+    T_generic_protocol_data_base  protocol_data;
+    T_stats                       stats;
+
+    istringstream  iss(R"(
+PACKET_CONTAINS_ONLY_1_MSG         yes
+PACKET_CONTAINS_ONLY_COMPLETE_MSG  true
+MANAGE_WIRESHARK_PINFO             no
+PROTO_TYPE_DEFINITIONS)");
+    read_file_wsgd_until_types(iss, protocol_data, stats);
+
+    M_TEST_EQ(protocol_data.PACKET_CONTAINS_ONLY_1_MSG, true);
+    M_TEST_EQ(protocol_data.PACKET_CONTAINS_ONLY_COMPLETE_MSG, true);
+    M_TEST_EQ(protocol_data.MANAGE_WIRESHARK_PINFO, false);
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_until_types__statistics
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_until_types__statistics)
+{
+    T_generic_protocol_data_base  protocol_data;
+    T_stats                       stats;
+
+    istringstream  iss(R"(
+STATISTICS    "menu"  [ "topic" field ]
+PROTO_TYPE_DEFINITIONS)");
+    read_file_wsgd_until_types(iss, protocol_data, stats);
+
+    M_TEST_EQ(stats.groups.size(), 1);
+    M_TEST_EQ(stats.groups[0].group_name, "menu");
+    // other checks : see unitary_test_generic_statistics.cpp
+}
diff --git a/plugins/epan/generic/unitary_test_generic_statistics.cpp b/plugins/epan/generic/unitary_test_generic_statistics.cpp
new file mode 100644
index 00000000000..262137e5d21
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_generic_statistics.cpp
@@ -0,0 +1,345 @@
+/*
+ * Copyright 2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "T_generic_statistics.h"
+#include "byte_interpret_common_exception.h"
+
+
+//*****************************************************************************
+// test_read_file_wsgd_statistics_basic
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_statistics__basic)
+{
+    T_stats        stats;
+    istringstream  iss(R"( "Samsung TV Remote Control" [ "Type" [ "Message Type"   MessageType ] ]# comment  
+)");
+    read_file_wsgd_statistics(iss, stats);
+
+    M_TEST_EQ(stats.groups.size(), 1);
+    M_TEST_EQ(stats.groups[0].group_name, "Samsung TV Remote Control");
+    M_TEST_EQ(stats.groups[0].sub_groups.size(), 1);
+    M_TEST_EQ(stats.groups[0].sub_groups[0].sub_group_name, "Type");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].full_name, "Samsung TV Remote Control/Type");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics.size(), 1);
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics[0].topic_name, "Message Type");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics[0].variable_name, "MessageType");
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_statistics_ko_1_token_missing
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_statistics_ko_1_token_missing)
+{
+    T_stats        stats;
+    istringstream  iss(R"( "Samsung TV Remote Control" [ "Type" [ "Message Type" ] ]# comment  
+)");
+    M_TEST_CATCH_EXCEPTION(
+        read_file_wsgd_statistics(iss, stats),
+        C_byte_interpret_exception);
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_statistics_ko_1_token_too_much
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_statistics_ko_1_token_too_much)
+{
+    T_stats        stats;
+    istringstream  iss(R"( "Samsung TV Remote Control" [ "Type" [ "Message Type"   MessageType TooMuch ] ]# comment  
+)");
+    M_TEST_CATCH_EXCEPTION(
+        read_file_wsgd_statistics(iss, stats),
+        C_byte_interpret_exception);
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_statistics_ko_not_a_string
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_statistics_ko_not_a_string)
+{
+    T_stats        stats;
+    istringstream  iss(R"( "Samsung TV Remote Control" [ Type [ "Message Type"   MessageType ] ]# comment  
+)");
+    M_TEST_CATCH_EXCEPTION(
+        read_file_wsgd_statistics(iss, stats),
+        C_byte_interpret_exception);
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_statistics_ko_is_a_string
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_statistics_ko_is_a_string)
+{
+    T_stats        stats;
+    istringstream  iss(R"( "Samsung TV Remote Control" [ "Type" [ "Message Type"   "MessageType" ] ]# comment  
+)");
+    M_TEST_CATCH_EXCEPTION(
+        read_file_wsgd_statistics(iss, stats),
+        C_byte_interpret_exception);
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_statistics__no_sub_group
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_statistics__no_sub_group)
+{
+    T_stats        stats;
+    istringstream  iss(R"( "Samsung TV Remote Control Type" [   # comment  
+    "Message Type"   MessageType,                               # comment2a
+    "Message Title"  Msg_Title ,                                # comment2b
+    "Message Size"   MessageSize,                               # comment2c
+]                                                               # comment3  
+)");
+    read_file_wsgd_statistics(iss, stats);
+
+    M_TEST_EQ(stats.groups.size(), 1);
+    M_TEST_EQ(stats.groups[0].group_name, "Samsung TV Remote Control Type");
+    M_TEST_EQ(stats.groups[0].sub_groups.size(), 1);
+    M_TEST_EQ(stats.groups[0].sub_groups[0].sub_group_name, "");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].full_name, "Samsung TV Remote Control Type");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics.size(), 3);
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics[0].topic_name, "Message Type");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics[0].variable_name, "MessageType");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics[1].topic_name, "Message Title");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics[1].variable_name, "Msg_Title");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics[2].topic_name, "Message Size");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics[2].variable_name, "MessageSize");
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_statistics_ko_array_must_start_on_current_line
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_statistics_ko_array_must_start_on_current_line)
+{
+    T_stats        stats;
+    istringstream  iss(R"( "Samsung TV Remote Control Type"
+    [  # ko must be on previous line
+    "Message Type"   MessageType
+]                                                               # comment3  
+)");
+    M_TEST_CATCH_EXCEPTION(
+        read_file_wsgd_statistics(iss, stats),
+        C_byte_interpret_exception);
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_statistics_ko_reject_multiline_string
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_statistics_ko_reject_multiline_string)
+{
+    T_stats        stats;
+    istringstream  iss(R"( "Samsung TV Remote Control
+ Type" [                            # ko reject multiline string
+    "Message Type"   MessageType,
+]
+)");
+    M_TEST_CATCH_EXCEPTION(
+        read_file_wsgd_statistics(iss, stats),
+        C_byte_interpret_exception);
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_statistics__multiple_sub_group
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_statistics__multiple_sub_group)
+{
+    T_stats        stats;
+    istringstream  iss(R"( "Samsung TV Remote Control" [   # comment  
+    "Type"   [ "Message Type"   MessageType ] ,
+    "Title"  [ "Message Title"  Msg_Title,  "Message Size" MessageSize , ],
+    "Length" [ "Message Length"   MessageLength ] ,
+]
+)");
+    read_file_wsgd_statistics(iss, stats);
+
+    M_TEST_EQ(stats.groups.size(), 1);
+    M_TEST_EQ(stats.groups[0].group_name, "Samsung TV Remote Control");
+    M_TEST_EQ(stats.groups[0].sub_groups.size(), 3);
+    M_TEST_EQ(stats.groups[0].sub_groups[0].sub_group_name, "Type");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].full_name, "Samsung TV Remote Control/Type");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics.size(), 1);
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics[0].topic_name, "Message Type");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics[0].variable_name, "MessageType");
+    M_TEST_EQ(stats.groups[0].sub_groups[1].sub_group_name, "Title");
+    M_TEST_EQ(stats.groups[0].sub_groups[1].full_name, "Samsung TV Remote Control/Title");
+    M_TEST_EQ(stats.groups[0].sub_groups[1].topics.size(), 2);
+    M_TEST_EQ(stats.groups[0].sub_groups[1].topics[0].topic_name, "Message Title");
+    M_TEST_EQ(stats.groups[0].sub_groups[1].topics[0].variable_name, "Msg_Title");
+    M_TEST_EQ(stats.groups[0].sub_groups[1].topics[1].topic_name, "Message Size");
+    M_TEST_EQ(stats.groups[0].sub_groups[1].topics[1].variable_name, "MessageSize");
+    M_TEST_EQ(stats.groups[0].sub_groups[2].sub_group_name, "Length");
+    M_TEST_EQ(stats.groups[0].sub_groups[2].full_name, "Samsung TV Remote Control/Length");
+    M_TEST_EQ(stats.groups[0].sub_groups[2].topics.size(), 1);
+    M_TEST_EQ(stats.groups[0].sub_groups[2].topics[0].topic_name, "Message Length");
+    M_TEST_EQ(stats.groups[0].sub_groups[2].topics[0].variable_name, "MessageLength");
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_statistics__ko_doubles
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_statistics__ko_doubles)
+{
+    {
+        T_stats        stats;
+        istringstream  iss(R"( "Samsung TV Remote Control" [ "something" [ "Message Type"   MessageType ] ]# comment  
+)");
+        read_file_wsgd_statistics(iss, stats);
+
+        // Same menu name is forbidden
+        istringstream  iss2(R"( "Samsung TV Remote Control" [ "other" [ "Message Type"   MessageType ] ]# comment  
+)");
+        M_TEST_CATCH_EXCEPTION(read_file_wsgd_statistics(iss2, stats), C_byte_interpret_exception);
+    }
+    {
+        T_stats        stats;
+        istringstream  iss(R"( "Samsung TV Remote Control" [   # comment  
+    "Type"   [ "Message Type"   MessageType ] ,
+    "Title"  [ "Message Title"  Msg_Title,  "Message Size" MessageSize , ],
+    "Type"   [ "Message Type"   MessageType ] ,
+]
+)");
+        M_TEST_CATCH_EXCEPTION(read_file_wsgd_statistics(iss, stats), C_byte_interpret_exception);
+    }
+}
+
+//*****************************************************************************
+// test_read_file_wsgd_statistics
+//*****************************************************************************
+
+M_TEST_FCT(test_read_file_wsgd_statistics)
+{
+    T_stats        stats;
+    istringstream  iss(R"(
+STATISTICS "Samsung TV Remote Control Type"  [ "Message Type"   MessageType ,]
+STATISTICS "Samsung TV Remote Control Title" [ "Message Title"  Msg_Title, ]
+STATISTICS "Samsung TV Remote Control" [
+    "Type"  [ "Message Type"   MessageType ] ,
+    "Title" [ "Message Title"  Msg_Title   ] ,
+    "Type & Title" [        "Message Type"   MessageType, 
+        "Message Title"   Msg_Title ,
+        "Message Length"  MessageLength, 
+    ]
+]  
+another_thing
+)");
+
+    // STATISTICS \"Samsung TV Remote Control Type\"  [ \"Message Type\"   MessageType ,]
+    {
+        std::string  keyword;
+        iss >> keyword;
+        M_TEST_EQ(keyword, "STATISTICS");
+    }
+    read_file_wsgd_statistics(iss, stats);
+
+    M_TEST_EQ(stats.groups.size(), 1);
+    M_TEST_EQ(stats.groups[0].group_name, "Samsung TV Remote Control Type");
+    M_TEST_EQ(stats.groups[0].sub_groups.size(), 1);
+    M_TEST_EQ(stats.groups[0].sub_groups[0].sub_group_name, "");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].full_name, "Samsung TV Remote Control Type");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics.size(), 1);
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics[0].topic_name, "Message Type");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics[0].variable_name, "MessageType");
+
+    // STATISTICS \"Samsung TV Remote Control Title\" [ \"Message Title\"  Msg_Title, ]
+    {
+        std::string  keyword;
+        iss >> keyword;
+        M_TEST_EQ(keyword, "STATISTICS");
+    }
+    read_file_wsgd_statistics(iss, stats);
+
+    M_TEST_EQ(stats.groups.size(), 2);
+    M_TEST_EQ(stats.groups[1].group_name, "Samsung TV Remote Control Title");
+    M_TEST_EQ(stats.groups[1].sub_groups.size(), 1);
+    M_TEST_EQ(stats.groups[1].sub_groups[0].sub_group_name, "");
+    M_TEST_EQ(stats.groups[1].sub_groups[0].full_name, "Samsung TV Remote Control Title");
+    M_TEST_EQ(stats.groups[1].sub_groups[0].topics.size(), 1);
+    M_TEST_EQ(stats.groups[1].sub_groups[0].topics[0].topic_name, "Message Title");
+    M_TEST_EQ(stats.groups[1].sub_groups[0].topics[0].variable_name, "Msg_Title");
+
+    // STATISTICS \"Samsung TV Remote Control\" [ ...
+    {
+        std::string  keyword;
+        iss >> keyword;
+        M_TEST_EQ(keyword, "STATISTICS");
+    }
+    read_file_wsgd_statistics(iss, stats);
+
+    M_TEST_EQ(stats.groups.size(), 3);
+    M_TEST_EQ(stats.groups[2].group_name, "Samsung TV Remote Control");
+    M_TEST_EQ(stats.groups[2].sub_groups.size(), 3);
+    M_TEST_EQ(stats.groups[2].sub_groups[0].sub_group_name, "Type");
+    M_TEST_EQ(stats.groups[2].sub_groups[0].full_name, "Samsung TV Remote Control/Type");
+    M_TEST_EQ(stats.groups[2].sub_groups[0].topics.size(), 1);
+    M_TEST_EQ(stats.groups[2].sub_groups[0].topics[0].topic_name, "Message Type");
+    M_TEST_EQ(stats.groups[2].sub_groups[0].topics[0].variable_name, "MessageType");
+    M_TEST_EQ(stats.groups[2].sub_groups[1].sub_group_name, "Title");
+    M_TEST_EQ(stats.groups[2].sub_groups[1].full_name, "Samsung TV Remote Control/Title");
+    M_TEST_EQ(stats.groups[2].sub_groups[1].topics.size(), 1);
+    M_TEST_EQ(stats.groups[2].sub_groups[1].topics[0].topic_name, "Message Title");
+    M_TEST_EQ(stats.groups[2].sub_groups[1].topics[0].variable_name, "Msg_Title");
+    M_TEST_EQ(stats.groups[2].sub_groups[2].sub_group_name, "Type & Title");
+    M_TEST_EQ(stats.groups[2].sub_groups[2].full_name, "Samsung TV Remote Control/Type & Title");
+    M_TEST_EQ(stats.groups[2].sub_groups[2].topics.size(), 3);
+    M_TEST_EQ(stats.groups[2].sub_groups[2].topics[0].topic_name, "Message Type");
+    M_TEST_EQ(stats.groups[2].sub_groups[2].topics[0].variable_name, "MessageType");
+    M_TEST_EQ(stats.groups[2].sub_groups[2].topics[1].topic_name, "Message Title");
+    M_TEST_EQ(stats.groups[2].sub_groups[2].topics[1].variable_name, "Msg_Title");
+    M_TEST_EQ(stats.groups[2].sub_groups[2].topics[2].topic_name, "Message Length");
+    M_TEST_EQ(stats.groups[2].sub_groups[2].topics[2].variable_name, "MessageLength");
+
+    // Check previous data are still here
+    M_TEST_EQ(stats.groups[0].group_name, "Samsung TV Remote Control Type");
+    M_TEST_EQ(stats.groups[0].sub_groups.size(), 1);
+    M_TEST_EQ(stats.groups[0].sub_groups[0].sub_group_name, "");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].full_name, "Samsung TV Remote Control Type");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics.size(), 1);
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics[0].topic_name, "Message Type");
+    M_TEST_EQ(stats.groups[0].sub_groups[0].topics[0].variable_name, "MessageType");
+
+    M_TEST_EQ(stats.groups[1].group_name, "Samsung TV Remote Control Title");
+    M_TEST_EQ(stats.groups[1].sub_groups.size(), 1);
+    M_TEST_EQ(stats.groups[1].sub_groups[0].sub_group_name, "");
+    M_TEST_EQ(stats.groups[1].sub_groups[0].full_name, "Samsung TV Remote Control Title");
+    M_TEST_EQ(stats.groups[1].sub_groups[0].topics.size(), 1);
+    M_TEST_EQ(stats.groups[1].sub_groups[0].topics[0].topic_name, "Message Title");
+    M_TEST_EQ(stats.groups[1].sub_groups[0].topics[0].variable_name, "Msg_Title");
+
+    // another_thing
+    {
+        std::string  keyword;
+        iss >> keyword;
+        M_TEST_EQ(keyword, "another_thing");
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_get_before_separator_after.cpp b/plugins/epan/generic/unitary_test_get_before_separator_after.cpp
new file mode 100644
index 00000000000..e2382be4c44
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_get_before_separator_after.cpp
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+
+
+//*****************************************************************************
+// test_get_before_separator_after
+//*****************************************************************************
+
+M_TEST_FCT(test_get_before_separator_after)
+{
+    string    str_left;
+    string    str_right;
+
+#define M_TEST_NOT_OK(STR,SEP)                                              \
+    M_TEST_EQ(get_before_separator_after(STR, SEP, str_left, str_right), E_rc_not_found)
+
+#define M_TEST_OK(STR,SEP,LEFT,RIGHT)                                       \
+    M_TEST_EQ(get_before_separator_after(STR, SEP, str_left, str_right), E_rc_ok);  \
+    M_TEST_EQ(str_left, LEFT);                                              \
+    M_TEST_EQ(str_right, RIGHT)
+
+    M_TEST_NOT_OK("aqsdfghjk", ':');
+
+    M_TEST_OK("aqsdfghjk", 'd', "aqs", "fghjk");
+    M_TEST_OK("aqs:dfg:hjk", ':', "aqs", "dfg:hjk");    // takes the 1st one
+    M_TEST_OK(":aqs:dfg:hjk", ':', "", "aqs:dfg:hjk");  // no warranty : accept empty left
+
+    M_TEST_OK("aqs::fghjk", "::", "aqs", "fghjk");
+
+#undef  M_TEST_NOT_OK
+#undef  M_TEST_OK
+}
diff --git a/plugins/epan/generic/unitary_test_get_number.cpp b/plugins/epan/generic/unitary_test_get_number.cpp
new file mode 100644
index 00000000000..0f52135cfd3
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_get_number.cpp
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+
+
+//*****************************************************************************
+// test_get_number
+//*****************************************************************************
+
+M_TEST_FCT(test_get_number)
+{
+    long long    int_number = 0;
+    double       flt_number = 0.0;
+
+#define M_TEST_NOT_OK(STR)                                                  \
+    M_TEST_EQ(get_number(STR, int_number), false);                          \
+    M_TEST_EQ(get_number(STR, flt_number), false)
+
+#define M_TEST_INT(STR,VAL_INT)                                             \
+    M_TEST_EQ(get_number(STR, int_number), true);                           \
+    M_TEST_EQ(int_number, VAL_INT);                                         \
+    M_TEST_EQ(get_number(STR, flt_number), false)
+
+#define M_TEST_FLT(STR,VAL_FLT)                                             \
+    M_TEST_EQ(get_number(STR, int_number), false);                          \
+    M_TEST_EQ(get_number(STR, flt_number), true);                           \
+    M_TEST_EQ(flt_number, VAL_FLT)
+
+#define M_TEST_INT_FLT(STR,VAL_INT,VAL_FLT)                                 \
+    M_TEST_EQ(get_number(STR, int_number), true);                           \
+    M_TEST_EQ(int_number, VAL_INT);                                         \
+    M_TEST_EQ(get_number(STR, flt_number), true);                           \
+    M_TEST_EQ(flt_number, VAL_FLT)
+
+    M_TEST_NOT_OK("aze");
+    M_TEST_NOT_OK("12g");
+    M_TEST_NOT_OK("g12");
+    M_TEST_NOT_OK("12a");
+    M_TEST_NOT_OK("a12");
+
+    M_TEST_FLT(  " 32.56",   32.56);
+    M_TEST_FLT(" -132.56", -132.56);
+    M_TEST_FLT( " 3.56e3", 3.56e3);
+    M_TEST_FLT( " 3.56e+3", 3.56e3);
+    M_TEST_FLT(" -3.56e-13", -3.56e-13);
+
+    M_TEST_INT_FLT(  "32",   32,   32.0);
+    M_TEST_INT_FLT("-132", -132, -132.0);
+    M_TEST_INT_FLT(" 32",   32,   32.0);
+    M_TEST_INT_FLT(" -132", -132, -132.0);
+
+    // strtod accept hexadecimal
+    M_TEST_INT_FLT(  "0xa32",  0xa32, 2610.0);
+    M_TEST_INT_FLT( " 0Xa32",  0xa32, 2610.0);
+    M_TEST_INT_FLT("-0Xfa32",  -0xfa32, -64050.0);
+
+    M_TEST_INT(   "032",   032);
+    M_TEST_INT( "-0777", -0777);
+
+#undef  M_TEST_NOT_OK
+}
diff --git a/plugins/epan/generic/unitary_test_interpret_forget.cpp b/plugins/epan/generic/unitary_test_interpret_forget.cpp
new file mode 100644
index 00000000000..7ee15b1f38c
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_interpret_forget.cpp
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "unitary_tests_ut_interpret_bytes.h"
+
+#include "T_interpret_data.h"
+#include "byte_interpret.h"
+
+
+//*****************************************************************************
+// test_interpret_forget
+//*****************************************************************************
+
+M_TEST_FCT(test_interpret_forget)
+{
+    T_type_definitions    type_definitions;
+    ut_interpret_bytes_init(type_definitions);
+    istringstream         iss(
+        "struct T_forget "
+        "{ "
+        "    var int32  struct_counter = struct_counter + 1; "
+        "} "
+    );
+    build_types(iss, type_definitions);
+
+    T_interpret_data      interpret_data;
+
+    // Test with simple variable
+    M_TEST_EQ(interpret_data.is_read_variable("value"), false);
+    M_TEST_SIMPLE("", " forget var uint32  value = 3457 ;", "value = 3457" K_eol);
+    M_TEST_EQ(interpret_data.is_read_variable("value"), false);            // value is forgotten
+    M_TEST_SIMPLE("", "        var uint32  value = 7 ;", "value = 7" K_eol);
+    M_TEST_EQ(interpret_data.is_read_variable("value"), true);
+    M_TEST_SIMPLE("", "        print (\"%d\", value);", "7" K_eol);
+    M_TEST_SIMPLE("", " forget var uint32  value = 3457 ;", "value = 3457" K_eol);
+    M_TEST_EQ(interpret_data.is_read_variable("value"), true);
+    M_TEST_SIMPLE("", "        print (\"%d\", value);", "7" K_eol);            // value 3457 is forgotten
+    M_TEST_SIMPLE("", "        var uint32  value = 3 ;", "value = 3" K_eol);
+    M_TEST_SIMPLE("", "        print (\"%d\", value);", "3" K_eol);
+    M_TEST_EQ(interpret_data.is_read_variable("value"), true);
+
+    // Test with struct
+    M_TEST_EQ(interpret_data.is_read_variable("struct_counter"), false);
+    M_TEST_SIMPLE("", "    var int32  struct_counter = 1000 ;", "struct_counter = 1000" K_eol);
+    M_TEST_SIMPLE("", "        T_forget      st1 ;", "st1.struct_counter = 1001" K_eol);
+    M_TEST_EQ(interpret_data.is_read_variable("struct_counter"), true);
+    M_TEST_SIMPLE("", " forget T_forget      st2 ;", "st2.struct_counter = 1002" K_eol);
+    M_TEST_EQ(interpret_data.is_read_variable("struct_counter"), true);
+    M_TEST_SIMPLE("", "        T_forget      st3 ;", "st3.struct_counter = 1002" K_eol);   // st2 (and its struct_counter) is forgotten
+    M_TEST_EQ(interpret_data.is_read_variable("struct_counter"), true);
+
+    // Test with array : each item of the array is forgot (one by one, not at the end of the array)
+    M_TEST_SIMPLE("", " forget T_forget[3]   sta ;", "sta[0].struct_counter = 1003" K_eol
+                                                     "sta[1].struct_counter = 1003" K_eol
+                                                     "sta[2].struct_counter = 1003" K_eol);
+    M_TEST_SIMPLE("", "        T_forget      st7 ;", "st7.struct_counter = 1003" K_eol);
+}
diff --git a/plugins/epan/generic/unitary_test_interpret_simple.cpp b/plugins/epan/generic/unitary_test_interpret_simple.cpp
new file mode 100644
index 00000000000..dde989a46e8
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_interpret_simple.cpp
@@ -0,0 +1,510 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "unitary_tests_ut_interpret_bytes.h"
+
+#include "T_interpret_data.h"
+
+
+//*****************************************************************************
+// test_interpret_simple
+//*****************************************************************************
+
+M_TEST_FCT(test_interpret_simple)
+{
+    T_type_definitions    type_definitions;
+    build_types ("unitary_tests_basic.fdesc",
+                 type_definitions);
+
+    T_interpret_data      interpret_data;
+
+
+    // global and pinfo must be instantiated at the beginning
+    interpret_data.global_variable_group_begin();
+    M_TEST_SIMPLE("", " var uint32  msg_counter = 0 ;", "msg_counter = 0" K_eol);
+    interpret_data.global_variable_group_end();
+
+    interpret_data.pinfo_variable_group_begin();
+    M_TEST_SIMPLE("", " var uint32  msg_counter = 0 ;", "msg_counter = 0" K_eol);
+    M_TEST_SIMPLE("", " var uint32  dstport = 133 ;"  , "dstport = 133" K_eol);
+    M_TEST_SIMPLE("", " var uint32  srcport = 5000 ;" , "srcport = 5000" K_eol);
+    interpret_data.read_variable_group_begin("fd");
+    M_TEST_SIMPLE("", " var string  pipo = \"str\" ;" , "pipo = str" K_eol);
+    interpret_data.read_variable_group_end();
+    interpret_data.pinfo_variable_group_end();
+
+
+    interpret_data.set_big_endian();
+    M_TEST_EQ(interpret_data.is_little_endian(), false);
+
+    // char test
+M_TEST_ERROR_ALREADY_KNOWN__OPEN(3535660, "char are displayed as integer")
+    M_TEST_SIMPLE("41", "char  char ;", "char = A" K_eol);
+    M_TEST_SIMPLE("81", "char  char ;", "char = " K_eol);
+    M_TEST_SIMPLE("81", "uchar  char ;", "char = " K_eol);
+}
+    M_TEST_SIMPLE("41", "char  char ;", "char = 65" K_eol);
+    M_TEST_SIMPLE("81", "char  char ;", "char = -127" K_eol);
+    M_TEST_SIMPLE("81", "uchar  char ;", "char = 129" K_eol);
+
+    // 2010/08/16
+    // no decode time = 0 ms
+    //    decode time = 2 ms
+    // 2010/10/16       0 ms
+    M_TEST_SIMPLE("ad", "uint8  uint8 ;", "uint8 = 173" K_eol);
+    M_TEST_SIMPLE("ad", " int8   int8 ;", "int8 = -83" K_eol);
+
+    M_TEST_SIMPLE("c23f", "uint16  val ;", "val = 49727" K_eol);
+    M_TEST_SIMPLE("c23f", " int16  val ;", "val = -15809" K_eol);
+
+    M_TEST_SIMPLE("c23fde", "uint24  val ;", "val = 12730334" K_eol);
+    M_TEST_SIMPLE("c23fde", " int24  val ;", "val = -4046882" K_eol);
+
+    M_TEST_SIMPLE("e23f6a77", "uint32  val ;", "val = 3795806839" K_eol);
+    M_TEST_SIMPLE("e23f6a77", " int32  val ;", "val = -499160457" K_eol);
+
+    M_TEST_SIMPLE("e23f6a77cb", "uint40  val ;", "val = 971726550987" K_eol);
+    M_TEST_SIMPLE("e23f6a77cb", " int40  val ;", "val = -127785076789" K_eol);
+
+    M_TEST_SIMPLE("e23f6a77cbf3", "uint48  val ;", "val = 248761997052915" K_eol);
+    M_TEST_SIMPLE("e23f6a77cbf3", " int48  val ;", "val = -32712979657741" K_eol);
+
+    // 2010/08/16
+    // no decode time =  0 ms
+    //    decode time = 18 ms
+    // 2010/09/25       14 ms
+    // 2010/10/14       13 ms
+    // 2010/10/16        0 ms
+    M_TEST_SIMPLE("e23f6a77cbf367a9", "int64  val ;", "val = -2143877834849687639" K_eol);
+
+    // ATTENTION : NOT really checked
+    M_TEST_SIMPLE("e23f6a77", "float32  val ;", "val = -8.8275e+20" K_eol);
+    M_TEST_SIMPLE("e23f6a77cbf367a9", "float64  val ;", "val = -1.80912e+165" K_eol);
+
+
+    // local byte order
+    M_TEST_SIMPLE("776a3fe2", "uint32{byte_order=little_endian}  val ;", "val = 3795806839" K_eol);
+    M_TEST_SIMPLE("776a3fe2", " int32{byte_order=little_endian}  val ;", "val = -499160457" K_eol);
+
+    M_TEST_EQ(interpret_data.is_little_endian(), false);
+
+
+    interpret_data.set_little_endian();
+    M_TEST_EQ(interpret_data.is_little_endian(), true);
+
+    // integer
+    M_TEST_SIMPLE("ad", "uint8  uint8 ;", "uint8 = 173" K_eol);
+    M_TEST_SIMPLE("ad", " int8   int8 ;", "int8 = -83" K_eol);
+
+    M_TEST_SIMPLE("3fc2", "uint16  val ;", "val = 49727" K_eol);
+    M_TEST_SIMPLE("3fc2", " int16  val ;", "val = -15809" K_eol);
+
+    M_TEST_SIMPLE("de3fc2", "uint24  val ;", "val = 12730334" K_eol);
+    M_TEST_SIMPLE("de3fc2", " int24  val ;", "val = -4046882" K_eol);
+
+    M_TEST_SIMPLE("776a3fe2", "uint32  val ;", "val = 3795806839" K_eol);
+    M_TEST_SIMPLE("776a3fe2", " int32  val ;", "val = -499160457" K_eol);
+
+    M_TEST_SIMPLE("cb776a3fe2", "uint40  val ;", "val = 971726550987" K_eol);
+    M_TEST_SIMPLE("cb776a3fe2", " int40  val ;", "val = -127785076789" K_eol);
+
+    M_TEST_SIMPLE("f3cb776a3fe2", "uint48  val ;", "val = 248761997052915" K_eol);
+    M_TEST_SIMPLE("f3cb776a3fe2", " int48  val ;", "val = -32712979657741" K_eol);
+
+    M_TEST_SIMPLE("a967f3cb776a3fe2", "int64  val ;", "val = -2143877834849687639" K_eol);
+
+    // float
+    // ATTENTION : NOT really checked
+    M_TEST_SIMPLE("776a3fe2", "float32  val ;", "val = -8.8275e+20" K_eol);
+    M_TEST_SIMPLE("a967f3cb776a3fe2", "float64  val ;", "val = -1.80912e+165" K_eol);
+
+    // string
+    M_TEST_SIMPLE("4249472d5245515545535453", "string(12)  val ;", "val = BIG-REQUESTS" K_eol);
+    M_TEST_SIMPLE("424947005245515545535453", "string(12)  val ;", "val = BIG" K_eol);
+    M_TEST_SIMPLE(""                        , "string(0)   val ;", "val = " K_eol);
+    M_TEST_SIMPLE("42494700"                , "string      val ;", "val = BIG" K_eol);
+    M_TEST_SIMPLE("424947005245515545535453",
+                  "string      val ; string(8)  val2 ;",
+                  "val = BIG" K_eol "val2 = REQUESTS" K_eol);
+    M_TEST_SIMPLE("424947005245515545535400",
+                  "string()    val ; string()  val2 ;",
+                  "val = BIG" K_eol "val2 = REQUEST" K_eol);
+    M_TEST_SIMPLE("424947005245515545535400",
+                  "string()    val ; string(0)  val2 ; string()  val3 ;",
+                  "val = BIG" K_eol "val2 = " K_eol "val3 = REQUEST" K_eol);
+    // string at bit position
+    M_TEST_SIMPLE("b4249472d5245515545535453e",
+                  "uint4  begin; string(12)  val ; uint4  end;",
+                  "begin = 11" K_eol
+                  "val = BIG-REQUESTS" K_eol
+                  "end = 14" K_eol);
+
+    // raw
+    M_TEST_SIMPLE("4249472d5245515545535453",
+                  "raw(12)  val ;",
+                  "val = " K_eol
+                  "00000000 : 42 49 47 2d 52 45 51 55 45 53 54 53              - BIG-REQUESTS    " K_eol);
+    M_TEST_SIMPLE("4249472d5245515545535453",
+                  "raw(*)  val ;",
+                  "val = " K_eol
+                  "00000000 : 42 49 47 2d 52 45 51 55 45 53 54 53              - BIG-REQUESTS    " K_eol);
+    M_TEST_SIMPLE("4249472d5245515545535453",
+                  "raw(2)  val ; raw(*)  val2 ;",
+                  "val = " K_eol
+                  "00000000 : 42 49                                            - BI              " K_eol
+                  "val2 = " K_eol
+                  "00000000 : 47 2d 52 45 51 55 45 53 54 53                    - G-REQUESTS      " K_eol);
+    M_TEST_SIMPLE("4249472d5245515545535453",
+                  "raw(0)  val ; raw(*)  val2 ;",
+                  "val2 = " K_eol
+                  "00000000 : 42 49 47 2d 52 45 51 55 45 53 54 53              - BIG-REQUESTS    " K_eol);
+
+    // int2 ...
+    M_TEST_SIMPLE("f3", "uint4  val ; uint4  val2 ;",
+                  "val = 15" K_eol
+                  "val2 = 3" K_eol);
+    M_TEST_SIMPLE("f3", "int4  val ; int4  val2 ;",
+                  "val = -1" K_eol
+                  "val2 = 3" K_eol);
+    M_TEST_SIMPLE("f3cb",
+                  "uint1  val ; uint2  val2; uint3  val3; uint4  val4; uint5  val5; uint1  val6;",
+                  "val = 1" K_eol
+                  "val2 = 3" K_eol
+                  "val3 = 4" K_eol
+                  "val4 = 15" K_eol
+                  "val5 = 5" K_eol
+                  "val6 = 1" K_eol);
+//	M_TEST_SIMPLE("f3cb776a3fe2", "uint48  val ;", "val = 248761997052915");
+
+    // enum
+    M_TEST_SIMPLE("de3fc2", "T_enum24                         val ;", "val = val12730334 (12730334)" K_eol);
+    M_TEST_SIMPLE("c23fde", "T_enum24{byte_order=big_endian}  val ;", "val = val12730334 (12730334)" K_eol);
+
+    M_TEST_SIMPLE("f3cb",
+                  "T_enum1  val ; T_enum2  val2; T_enum3  val3; T_enum4  val4; T_enum5  val5; T_enum1  val6;",
+                  "val = value1 (1)" K_eol
+                  "val2 = enu3 (3)" K_eol
+                  "val3 = val4 (4)" K_eol
+                  "val4 = Val15 (15)" K_eol
+                  "val5 = val5 (5)" K_eol
+                  "val6 = value1 (1)" K_eol);
+
+    // ICIOA ...
+
+    // transform quantum/offset
+    M_TEST_SIMPLE("3fc2", "uint16{q=2:o=13}    val ;", "val = 99467 (49727)" K_eol);
+    M_TEST_SIMPLE("3fc2", " int16{q=2:o=13.0}  val ;", "val = -31605 (-15809)" K_eol);
+    M_TEST_SIMPLE("3fc2", " int16{q=2:o=13.1}  val ;", "val = -31604.9 (-15809)" K_eol);
+    M_TEST_SIMPLE("3fc2", " int16{q=1+1:o=10.1+1*3}  val ;", "val = -31604.9 (-15809)" K_eol);
+    M_TEST_SIMPLE("3fc2", " int16{q=konst::int+0:o=konst::flt+15.7}  val ;", "val = -31604.9 (-15809)" K_eol);
+    M_TEST_SIMPLE("02"  , "T_enum8{q=2:o=11}    val ;", "val = Val15 (2)" K_eol);
+
+    // transform expression
+    M_TEST_SIMPLE("3fc2", "uint16{tei=2*this+13}    val ;", "val = 99467 (49727)" K_eol);
+    M_TEST_SIMPLE("3fc2", " int16{tef=2*this+13.0}  val ;", "val = -31605 (-15809)" K_eol);
+    M_TEST_SIMPLE("3fc2", " int16{tef=2*this+13.1}  val ;", "val = -31604.9 (-15809)" K_eol);
+    M_TEST_SIMPLE("3fc2", " int16{tef=addition(2*this,13.1)}  val ;", "val = -31604.9 (-15809)" K_eol);
+    M_TEST_SIMPLE("02"  , "T_enum8{tei=2*this+11}    val ;", "val = Val15 (2)" K_eol);
+
+    // decoder
+    M_TEST_SIMPLE("3fc2", "uint16{decoder=nil}  val ;", "val = 49727" K_eol);
+    M_TEST_SIMPLE("3fc2", " int16{decoder=nil}  val ;", "val = -15809" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{decoder=decode_stream_nothing}  val ;", "val = 49727" K_eol);
+    M_TEST_SIMPLE("3fc2", " int16{decoder=decode_stream_nothing}  val ;", "val = -15809" K_eol);
+    // 0x3f | 0xC2 = 0xFF
+    // 0x3f & 0xC2 = 0x02
+    // 0x02ff = 767
+    M_TEST_SIMPLE("3fc2", "uint16{decoder=decode_stream_test16}  val ;", "val = 767" K_eol);
+    M_TEST_SIMPLE("3fc2", " int16{decoder=decode_stream_test16}  val ;", "val = 767" K_eol);
+
+    // stringUtf8, stringUtf16Le & stringUtf16Be using decoder
+    // string original = abcde\r\n12345\r\n&"'(-_)=\r\n\r\n^$*,;:!\r\n%?./
+    // Characters not directly transformable to ascii are replaced by "."
+    M_TEST_SIMPLE("61626364650D0A31323334350D0A26C3A92227282DC3A85FC3A7C3A0293D0D0AE282AC0D0A5E24C3B92A2C3B3A210D0AC2A8C2A325C2B53F2E2FC2A7",
+        " stringUtf8     val ;",
+        "val = abcde\r\n12345\r\n&.\"'(-._..)=\r\n.\r\n^$.*,;:!\r\n..%.?./." K_eol);
+    // pb avec E900 ->  ou  (wsgd 2.6) ??? 
+    M_TEST_SIMPLE("610062006300640065000D000A00310032003300340035000D000A0026002200270028002D00E8005F00E700E00029003D000D000A00AC200D000A005E002400F9002A002C003B003A0021000D000A00A800A3002500B5003F002E002F00A700",
+        " stringUtf16Le  val ;",
+        "val = abcde\r\n12345\r\n&\"'(-_)=\r\n.\r\n^$*,;:!\r\n%?./" K_eol);
+    M_TEST_SIMPLE("00610062006300640065000D000A00310032003300340035000D000A0026002200270028002D00E8005F00E700E00029003D000D000A20AC000D000A005E002400F9002A002C003B003A0021000D000A00A800A3002500B5003F002E002F00A7",
+        " stringUtf16Be  val ;",
+        "val = abcde\r\n12345\r\n&\"'(-_)=\r\n.\r\n^$*,;:!\r\n%?./" K_eol);
+
+    // stringUtf8 using decoder with fixed asked size.
+    // Shows that, usingdecoder, the specified size is not the input raw size and the input raw size is variable.
+    // There is currently no way to specify input raw size with a decoder
+    M_TEST_SIMPLE("6126C3A9", " stringUtf8(3)     val ;", "val = a&." K_eol);
+    M_TEST_SIMPLE("612600"  , " stringUtf8(3)     val ;", "val = a&" K_eol);
+    M_TEST_SIMPLE("610000"  , " stringUtf8(3)     val ;", "val = a" K_eol);
+    
+
+    // min/max ok
+    M_TEST_SIMPLE("3fc2", "uint16{q=2:o=13}{min=99000}    val ;", "val = 99467 (49727)" K_eol);
+    M_TEST_SIMPLE("3fc2", " int16{q=2:o=13.6}{max=-30000} val ;", "val = -31604.4 (-15809)" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{q=2:o=13}{min=99000:max=99467}       val ;", "val = 99467 (49727)" K_eol);
+    M_TEST_SIMPLE("3fc2", " int16{q=2:o=13.6}{min=-31604.5:max=-30000} val ;", "val = -31604.4 (-15809)" K_eol);
+
+    // min/max ERROR
+    M_TEST_SIMPLE("3fc2", "uint16{q=2:o=13}{min=99468}    val ;", "val = 99467 (49727)\tERROR is < to 99468" K_eol);
+
+    // display
+    M_TEST_SIMPLE("3fc2", "uint16{d=hex}  val ;", "val = 0xc23f (49727)" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{d=oct}  val ;", "val = 0141077 (49727)" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{d=bin}  val ;", "val = b1100001000111111 (49727)" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{d=%s}   val ;", "val = 49727" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{d=%dmeters}   val ;", "val = 49727meters (49727)" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{d=%d meters}   val ;", "val = 49727 meters (49727)" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{d=%.1f}   val ;", "val = 49727.0 (49727)" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{d=%07d} val ;", "val = 0049727 (49727)" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{d=%7d}  val ;", "val =   49727 (49727)" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{d=%03d} val ;", "val = 49727" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{d=%3d}  val ;", "val = 49727" K_eol);
+    M_TEST_SIMPLE("de3fc2", "T_enum24{d=%d and ...}  val ;", "val = 12730334 and ... (12730334)" K_eol);
+
+    // display expression
+    M_TEST_SIMPLE("3fc2", "uint16{de=\"123\"}  val ;", "val = 123 (49727)" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{de=\"HelloWorld\"}  val ;", "val = HelloWorld (49727)" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{de=\"hello world\"}  val ;", "val = hello world (49727)" K_eol);  // space NOT ok
+    M_TEST_SIMPLE("3fc2", "uint16{de=to_string(this)}  val ;", "val = 49727" K_eol);
+    M_TEST_SIMPLE("3fc2", "uint16{de=print_ip(this)}  val ;", "val = 0.0.194.63 (49727)" K_eol);
+    M_TEST_SIMPLE("776a3fe2", "uint32{de=print_ip(this)}  val ;", "val = 226.63.106.119 (3795806839)" K_eol);
+    M_TEST_SIMPLE("de3fc2", "T_enum24{de=\"hello world\"}        val ;", "val = hello world (12730334)" K_eol);
+    M_TEST_SIMPLE("de3fc2", "T_enum24{de=print(\"%s 0x%x %d\", this, this, this)}  val ;", "val = val12730334 0xc23fde 12730334 (12730334)" K_eol);
+
+    // struct
+    M_TEST_SIMPLE("3fc2", "struct { uint8  val1; uint8 val2; }  str ;", "str.val1 = 63" K_eol "str.val2 = 194" K_eol);
+    M_TEST_SIMPLE("776a3fc2", "struct { uint16  val1; uint16 val2; }  str ;", "str.val1 = 27255" K_eol "str.val2 = 49727" K_eol);
+    M_TEST_SIMPLE("776a3fc2", "T_struct_16_16                         str ;", "str.val1 = 27255" K_eol "str.val2 = 49727" K_eol);
+
+    // struct with decoder
+    M_TEST_SIMPLE("776a3fc2", "T_struct_16_16{decoder=decode_stream_nothing} str ;", "str.val1 = 27255" K_eol "str.val2 = 49727" K_eol);
+    // 0x77 | 0x6a = 0x7F
+    // 0x77 & 0x6a = 0x62
+    // 0x627F = 25215
+    M_TEST_SIMPLE("776a3fc2", "T_struct_16_16{decoder=decode_stream_test16}  str ;", "str.val1 = 25215" K_eol "str.val2 = 767" K_eol);
+
+    // switch inline
+    M_TEST_SIMPLE("", "switch(T_enum1::value1) { "
+                          "  case 0                : var int8  val =  0;"
+                          "  case T_enum3::value1  : var int8  val = 10;"
+                          "  case T_enum2::enu2    : var int8  val = 30;"
+                          "  default               : var int8  val = -100;"
+                          "}", "val = 10" K_eol);
+    M_TEST_SIMPLE("", "switch(7) { "
+                          "  case 0 : var int8  val =  0;"
+                          "  case 1 : var int8  val = 10;"
+                          "  case 2 : var int8  val = 30;"
+                          "  default : var int8  val = -100;"
+                          "}", "val = -100" K_eol);
+    M_TEST_SIMPLE("", "switch_expr { "
+                          "  case (0 != 0) : var int8  val =  0;"
+                          "  case (1 >= 2) : var int8  val = 10;"
+                          "  case (2 == 2) : var int8  val = 30;"
+                          "  default : var int8  val = -100;"
+                          "}", "val = 30" K_eol);
+    M_TEST_SIMPLE("", "switch_expr { "
+                          "  case (pinfo.dstport <  100) : var int16  val = 100;"
+                          "  case (pinfo.dstport >= 200) : var int16  val = 200;"
+                          "  case (pinfo.dstport == 133) : var int16  val = 133;"
+                          "  case (pinfo.fd.pipo == \"tsr\")      : var int16  val =   1;"
+                          "  case (pinfo.fd.pipo == \"rst\")      : var int16  val =   2;"
+                          "  case (pinfo.fd.pipo == \"str\")      : var int16  val =   3;"
+                          "  default : var int8  val = -100;"
+                          "}", "val = 133" K_eol);
+    M_TEST_SIMPLE("", "switch_expr { "
+                          "  case (pinfo.dstport == 133 && pinfo.fd.pipo == \"rst\") : var int16  val = 1332;"
+                          "  case (pinfo.dstport <  100 && pinfo.fd.pipo == \"str\") : var int16  val = 1003;"
+                          "  case (pinfo.dstport <  100 && pinfo.fd.pipo == \"tsr\") : var int16  val = 1001;"
+                          "  case (pinfo.dstport >= 200 && pinfo.fd.pipo == \"rst\") : var int16  val = 2002;"
+                          "  case (pinfo.dstport == 133 && pinfo.fd.pipo == \"str\") : var int16  val = 1333;"
+                          "  case (pinfo.dstport <  100) : var int16  val = 100;"
+                          "  case (pinfo.dstport >= 200) : var int16  val = 200;"
+                          "  case (pinfo.dstport == 133) : var int16  val = 133;"
+                          "  default : var int8  val = -100;"
+                          "}", "val = 1333" K_eol);
+
+    // switch
+    M_TEST_SIMPLE("", "T_switch(3)   \"\";", "val = enu3" K_eol);
+    M_TEST_SIMPLE("", "T_switch_expr \"\";", "val = str" K_eol);
+
+    // array
+    M_TEST_SIMPLE("4249472d5245515545535453",
+                  "uint8[12]  val ;",
+                  "val[0] = 66" K_eol
+                  "val[1] = 73" K_eol
+                  "val[2] = 71" K_eol
+                  "val[3] = 45" K_eol
+                  "val[4] = 82" K_eol
+                  "val[5] = 69" K_eol
+                  "val[6] = 81" K_eol
+                  "val[7] = 85" K_eol
+                  "val[8] = 69" K_eol
+                  "val[9] = 83" K_eol
+                  "val[10] = 84" K_eol
+                  "val[11] = 83" K_eol);
+    {
+        C_ut_interpret_bytes_no_decode_guard  uibndg;    // [*] & [+] rejected with decode
+        M_TEST_SIMPLE("4249472d5245515545535453",
+                      "uint8[*]  val ;",
+                      "val[0] = 66" K_eol
+                      "val[1] = 73" K_eol
+                      "val[2] = 71" K_eol
+                      "val[3] = 45" K_eol
+                      "val[4] = 82" K_eol
+                      "val[5] = 69" K_eol
+                      "val[6] = 81" K_eol
+                      "val[7] = 85" K_eol
+                      "val[8] = 69" K_eol
+                      "val[9] = 83" K_eol
+                      "val[10] = 84" K_eol
+                      "val[11] = 83" K_eol);
+        M_TEST_SIMPLE("4249472d5245515545535453",
+                      "uint8[+]  val ;",
+                      "val[0] = 66" K_eol
+                      "val[1] = 73" K_eol
+                      "val[2] = 71" K_eol
+                      "val[3] = 45" K_eol
+                      "val[4] = 82" K_eol
+                      "val[5] = 69" K_eol
+                      "val[6] = 81" K_eol
+                      "val[7] = 85" K_eol
+                      "val[8] = 69" K_eol
+                      "val[9] = 83" K_eol
+                      "val[10] = 84" K_eol
+                      "val[11] = 83" K_eol);
+        M_TEST_SIMPLE("",
+                      "uint8[*]  val ;",
+                      "");
+        M_TEST_SIMPLE("42",
+                      "uint8[+]  val ;",
+                      "val[0] = 66" K_eol);
+    }
+    M_TEST_SIMPLE("4249472d5245515545535453" "4249472d5245515545535453",
+                  "uint8[24]  val ;",
+                  "val[0] = 66" K_eol
+                  "val[1] = 73" K_eol
+                  "val[2] = 71" K_eol
+                  "val[3] = 45" K_eol
+                  "val[4] = 82" K_eol
+                  "val[5] = 69" K_eol
+                  "val[6] = 81" K_eol
+                  "val[7] = 85" K_eol
+                  "val[8] = 69" K_eol
+                  "val[9] = 83" K_eol
+                  "val[10] = 84" K_eol
+                  "val[11] = 83" K_eol
+                  "val[12] = 66" K_eol
+                  "val[13] = 73" K_eol
+                  "val[14] = 71" K_eol
+                  "val[15] = 45" K_eol
+                  "val[16] = 82" K_eol
+                  "val[17] = 69" K_eol
+                  "val[18] = 81" K_eol
+                  "val[19] = 85" K_eol
+                  "val[20] = 69" K_eol
+                  "val[21] = 83" K_eol
+                  "val[22] = 84" K_eol
+                  "val[23] = 83" K_eol);
+    // Loop which show an acumulative problem
+    // 2010/08/16
+    // no decode time =    6,    7,    7,    7,    8,     8,     9,     8,     9,    10 ms
+    //    decode time = 2078, 3546, 5110, 6715, 8062, 10077, 12275, 14037, 16014, 17724 ms  -> +1600 ms at each test
+    // 2010/09/18
+    // removed "more" (a string always empty) inside T_attribute_value
+    // no decode time =    6,    7,    7,    7,    8,     9,     8,     9,     9,     9 ms
+    //    decode time = 2233, 3551, 5134, 6608, 8164,  9784, 11657, 13382, 15225, 16900 ms
+    // -> win ~600 ms on final time (17724)
+    // --> memory load is a problem
+    // --> vector<T_interpret_value> into T_interpret_read_values is a problem
+    // --> to not really erase a variable into T_interpret_read_values::sup_read_variable  is a problem
+    // --> to not erase local variable of a function is a bigger problem
+    // 2010/09/18
+    // removed 48 bytes inside T_attribute_value & T_interpret_value
+    // -> win between ~600 ms and zero on final time
+    // --> memory load is NOT a problem ?
+    // 2010/09/24
+    // erase done into T_interpret_read_values::sup_read_variable
+    // -> win ~3000 ms on final time (13550)
+    // 2010/09/25
+    // erase all data created during a function (behavior modification)
+    // -> win ~11690 ms on final time (1860)
+    //    acumulative problem still here
+    // 2010/10/09
+    // modif T_interpret_read_values::get_P_attribute_value_of_read_variable
+    // -> win ~190 ms on final time (1670)
+    // 2010/10/13  1622 ms
+    // 2010/10/13  1654 ms  avec le nouveau code de compute_expression !!!
+    // 2010/10/16
+    // Into get_complex_value,
+    //  move get_value_of_read_variable in 4th place (instead 1st)
+    // -> final time = 358 - 395 ms
+    //    no acumulative problem visible
+    // 2010/10/29 265 - 280 ms  T_expression var set call
+    // 2010/10/29 141 - 156 ms  T_expression condition return
+    // 2010/11/10 148 - 170 ms  T_expression pre_compute value & operation
+
+    for (int  idx_tst = 0; idx_tst < 10; ++idx_tst)
+    {
+        M_TRACE_WARNING("msg.size=" << interpret_data.DEBUG_get_msg().size());
+        ut_interpret_bytes(type_definitions,
+                       "4249472d5245515545535453" "4249472d5245515545535453"
+                       "4249472d5245515545535453" "4249472d5245515545535453"
+                       "4249472d5245515545535453" "4249472d5245515545535453"
+                       "4249472d5245515545535453" "4249472d5245515545535453"
+                       "4249472d5245515545535453" "4249472d5245515545535453"
+                       "4249472d5245515545535453" "4249472d5245515545535453"
+                       "4249472d5245515545535453" "4249472d5245515545535453"
+                       "4249472d5245515545535453" "4249472d5245515545535453"
+                       "4249472d5245515545535453" "4249472d5245515545535453"
+                       "4249472d5245515545535453" "4249472d5245515545535453",
+                       "uint8[240]  val ;",
+                       interpret_data,
+                       nullptr);
+    }
+  
+    interpret_data.read_variable_group_begin("A_current_path_not_empty");
+    for (int  idx_tst = 0; idx_tst < 40; ++idx_tst)
+    {
+        // global
+        ut_interpret_bytes(type_definitions, "", " set global.msg_counter = 0 ;", interpret_data, "");
+        ut_interpret_bytes(type_definitions, "", " set global.msg_counter = global.msg_counter + 1 ;", interpret_data, "");
+
+        // pinfo
+        ut_interpret_bytes(type_definitions, "", " set pinfo.msg_counter = 0 ;", interpret_data, "");
+        ut_interpret_bytes(type_definitions, "", " set pinfo.msg_counter = pinfo.msg_counter + 1 ;", interpret_data, "");
+        ut_interpret_bytes(type_definitions, "", " set pinfo.srcport = pinfo.dstport ;", interpret_data, "");
+        ut_interpret_bytes(type_definitions, "", " set pinfo.fd.pipo = \"a new string\" ;", interpret_data, "");
+    }
+    interpret_data.read_variable_group_end();
+    
+    type_definitions = T_type_definitions();
+    build_types ("unitary_tests_example_with_capture.fdesc",
+                 type_definitions);
+}
diff --git a/plugins/epan/generic/unitary_test_interpret_simple_decoder_aes.cpp b/plugins/epan/generic/unitary_test_interpret_simple_decoder_aes.cpp
new file mode 100644
index 00000000000..9babf671aa5
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_interpret_simple_decoder_aes.cpp
@@ -0,0 +1,390 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "unitary_tests_ut_interpret_bytes.h"
+
+#include "T_interpret_data.h"
+
+
+//*****************************************************************************
+// test_interpret_simple_decoder_aes
+//*****************************************************************************
+
+M_TEST_FCT(test_interpret_simple_decoder_aes)
+{
+    T_type_definitions    type_definitions;
+    istringstream         iss("");
+    build_types(iss, type_definitions);
+
+    T_interpret_data      interpret_data;
+
+    interpret_data.set_big_endian();
+
+
+    // Encrypted with :
+    // http://aes.online-domain-tools.com/   function=AES  mode=ECB (electronic codebook)
+
+
+    // key="1234567890123456"  value="string{decoder=decoder_aes}  val ;"
+    // value length = 35 (34 + zero end of string)
+    // decrypted length = 48 (3*16)
+    // So 13 padding bytes that must be read
+    interpret_data.add_read_variable("decoder_aes_key", "1234567890123456");
+    M_TEST_SIMPLE("1a	03	8c	23	70	bb	e8	59	d1	4f	d6	9e	b5	4d	f9	ad"
+                  "7c	bc	ca	75	d1	99	89	5d	0c	86	fa	8e	2f	35	63	0e"
+                  "de	5d	db	de	5e	56	af	7c	15	82	cb	fa	5e	e4	11	ce",
+                  "string{decoder=decoder_aes}  val ;"
+                  "hide raw(13)                 padding16bytes ;",
+                  "val = string{decoder=decoder_aes}  val ;" K_eol);
+
+
+    // key="abcdefghijklmnop"  value="string{decoder=decoder_aes}  val ;"
+    // value length = 35 (34 + zero end of string)
+    // decrypted length = 48 (3*16)
+    // So 13 padding bytes that must be read
+    interpret_data.add_read_variable("decoder_aes_key", "abcdefghijklmnop");
+    M_TEST_SIMPLE("dd	4f	b4	94	e3	03	43	b0	17	e1	eb	5c	c1	70	cb	2b"
+                  "68	57	7c	00	c6	4c	ad	18	e3	a3	2d	53	e1	9c	11	9e"
+                  "2f	b3	d3	f3	88	d8	f7	8d	03	56	af	15	c5	87	14	07",
+                  "string{decoder=decoder_aes}  val ;"
+                  "hide raw(13)                 padding16bytes ;",
+                  "val = string{decoder=decoder_aes}  val ;" K_eol);
+
+
+    // key="1234567890123456"  file=favicon.ico
+    // file length = 822
+    // decrypted length = 832 (52*16)
+    // So 10 padding bytes that must be read
+    interpret_data.set_read_variable("decoder_aes_key", "1234567890123456");
+    M_TEST_SIMPLE("42	d5	77	d8	f4	75	18	12	7b	ab	7c	38	02	17	c2	fb"
+                  "32	8e	d0	74	b6	64	99	ab	c0	f7	92	da	f7	22	6d	bb"
+                  "c0	d0	66	2f	70	a8	9a	b6	8f	45	7e	b9	96	1f	7d	e1"
+                  "94	50	78	17	60	ec	85	d9	0c	45	4e	71	ad	af	b9	b8"
+                  "12	9d	33	f7	05	14	61	f5	1d	12	73	d6	1d	c7	09	8c"
+                  "3b	7e	22	2f	d5	5d	17	3a	ad	40	d7	e7	28	d7	2d	f1"
+                  "ae	1d	df	5b	22	8d	78	92	c9	4c	36	f8	d6	a8	af	33"
+                  "aa	a9	15	5b	16	43	19	b4	78	45	da	c7	ce	23	e3	9a"
+                  "39	39	9a	58	e7	ba	65	a3	f3	d4	de	8e	fd	e7	4d	3d"
+                  "84	9a	4a	9a	2d	1d	0d	c8	1a	c0	c4	e4	b8	2c	68	4d"
+                  "a3	85	ba	a6	43	0d	18	0f	89	30	84	e7	91	7b	4b	ea"
+                  "e9	2d	b1	a7	8d	26	75	97	c5	51	78	2e	74	0a	72	9d"
+                  "5e	82	5a	f0	53	3c	52	d7	cf	50	42	a5	41	26	a4	f9"
+                  "03	ff	01	56	5a	4e	1d	f5	93	79	e5	43	fc	ce	6b	23"
+                  "5d	84	f5	f5	14	8d	a9	87	5b	4f	a2	b8	a7	ec	86	48"
+                  "00	97	1b	66	ff	50	0d	01	66	8e	77	45	a3	51	be	06"
+                  "66	cc	98	21	a4	eb	1c	d6	4e	3e	01	0f	56	74	de	1a"
+                  "4f	37	67	14	c3	13	f6	71	60	b6	61	0b	52	0c	ad	ea"
+                  "3f	61	83	f5	a3	70	ec	18	35	93	5a	0d	f9	6d	16	52"
+                  "32	27	51	ed	e4	34	a4	c3	d1	70	46	21	4c	77	b6	49"
+                  "3b	47	1f	8d	86	c9	44	e0	6a	01	66	93	a5	61	93	7e"
+                  "66	48	64	33	a2	51	e6	e1	b0	1d	68	dc	1d	34	90	51"
+                  "3a	f4	7b	76	c3	29	8b	64	23	17	aa	fc	2d	a8	e4	06"
+                  "a9	eb	47	88	f7	b5	8b	b8	a4	69	7d	0c	25	0d	cd	57"
+                  "15	69	27	c2	44	a1	29	98	88	54	48	fd	26	5d	1d	b1"
+                  "c4	55	d4	c6	25	ad	63	86	70	0b	72	74	86	09	c8	1e"
+                  "d6	f4	21	b2	c3	ef	31	04	70	3e	76	bc	e7	b2	2e	dd"
+                  "e6	81	2e	ae	6c	b9	78	b6	50	95	31	9a	da	43	fa	9e"
+                  "a0	61	55	4e	da	85	89	de	85	ea	65	0d	64	34	36	4c"
+                  "12	e3	7b	cf	c0	35	30	70	c3	8d	d5	61	a2	03	3f	a2"
+                  "e9	f3	59	b6	f5	b5	16	f5	2c	dc	bd	5c	81	d7	90	03"
+                  "e3	73	61	38	11	da	6f	d2	3d	5f	cc	b4	95	a6	66	2e"
+                  "aa	25	19	ac	51	2e	ad	04	2c	f1	f4	40	e1	83	c5	f5"
+                  "33	09	6f	dd	d6	d5	36	1d	5c	d2	e9	7e	ad	db	a6	31"
+                  "5e	61	27	48	da	6d	1c	2d	db	88	57	29	1a	4a	0f	55"
+                  "bb	49	c3	6b	15	37	ed	ac	d9	87	52	f4	e0	1d	2c	f0"
+                  "e3	ab	37	6b	38	e1	1b	ca	d0	cf	95	3e	76	1e	97	65"
+                  "46	a4	ec	e0	5a	78	59	2a	61	9e	2f	22	35	e2	ff	23"
+                  "d0	4a	27	87	e4	a5	eb	11	11	35	b3	31	54	a6	93	5f"
+                  "96	0f	54	a0	ef	b9	33	c5	15	f7	16	57	bb	02	1f	0f"
+                  "c3	55	f2	cf	d9	33	f2	27	66	45	56	81	44	da	82	c3"
+                  "e6	99	e2	7e	cb	4e	27	63	1c	9b	42	41	8a	41	7a	5e"
+                  "ec	74	d9	66	f1	39	da	cb	33	aa	7c	ac	20	61	21	bd"
+                  "fe	4b	a6	1d	10	dc	db	9a	e0	7a	c3	a5	a6	14	a8	d1"
+                  "23	ea	d9	2f	2a	9d	05	cc	5f	58	aa	02	28	52	fe	71"
+                  "b3	cf	7a	d3	20	55	31	f3	54	b9	c5	8a	c4	e2	1e	c5"
+                  "a0	e2	73	2e	28	76	52	e9	70	99	fd	30	00	1c	f9	98"
+                  "e5	2a	2c	62	7b	d4	79	27	b9	18	62	c3	b8	01	88	73"
+                  "12	69	9f	3d	e5	81	db	16	d6	bc	a9	23	69	0c	8b	4d"
+                  "3c	c6	96	24	f9	23	86	52	5b	82	9d	ea	48	f6	2f	f9"
+                  "f6	51	30	5f	76	0a	82	fe	8e	75	c5	45	f4	47	cf	0f"
+                  "17	23	a2	6b	8a	78	2e	b4	2f	24	ff	1c	6c	12	35	71",
+                  "decoder  decoder_aes;"
+                  "uint32{d=hex}[4*51]   val ;"
+                  "uint16{d=hex}         val1 ;"
+                  "uint16{d=hex}         val2 ;"
+                  "uint16{d=hex}         val3 ;"
+                  "hide raw(10)          padding16bytes ;",
+                  "val[0] = 0x424d3603 (1112356355)" K_eol
+                  "val[1] = 0x0 (0)" K_eol
+                  "val[2] = 0x3600 (13824)" K_eol
+                  "val[3] = 0x2800 (10240)" K_eol
+                  "val[4] = 0x1000 (4096)" K_eol
+                  "val[5] = 0x1000 (4096)" K_eol
+                  "val[6] = 0x100 (256)" K_eol
+                  "val[7] = 0x18000000 (402653184)" K_eol
+                  "val[8] = 0x3 (3)" K_eol
+                  "val[9] = 0x0 (0)" K_eol
+                  "val[10] = 0x0 (0)" K_eol
+                  "val[11] = 0x0 (0)" K_eol
+                  "val[12] = 0x0 (0)" K_eol
+                  "val[13] = 0x0 (0)" K_eol
+                  "val[14] = 0x3a3325 (3814181)" K_eol
+                  "val[15] = 0x44391c41 (1144593473)" K_eol
+                  "val[16] = 0x361b4134 (907755828)" K_eol
+                  "val[17] = 0x1b41341b (457258011)" K_eol
+                  "val[18] = 0x41341b41 (1093933889)" K_eol
+                  "val[19] = 0x341b4134 (874201396)" K_eol
+                  "val[20] = 0x1b41341b (457258011)" K_eol
+                  "val[21] = 0x41341b41 (1093933889)" K_eol
+                  "val[22] = 0x341b4134 (874201396)" K_eol
+                  "val[23] = 0x1b44391c (457455900)" K_eol
+                  "val[24] = 0x3a332500 (976430336)" K_eol
+                  "val[25] = 0x332d (13101)" K_eol
+                  "val[26] = 0x1e9c7215 (513569301)" K_eol
+                  "val[27] = 0xb0831fac (2961383340)" K_eol
+                  "val[28] = 0x811eac81 (2166271105)" K_eol
+                  "val[29] = 0x1eae811f (514752799)" K_eol
+                  "val[30] = 0xb18320b3 (2978160819)" K_eol
+                  "val[31] = 0x8421b384 (2216801156)" K_eol
+                  "val[32] = 0x21b38421 (565412897)" K_eol
+                  "val[33] = 0xb18320ae (2978160814)" K_eol
+                  "val[34] = 0x811fac81 (2166336641)" K_eol
+                  "val[35] = 0x1eb0831f (514884383)" K_eol
+                  "val[36] = 0x9c721533 (2624722227)" K_eol
+                  "val[37] = 0x2d1e4235 (756957749)" K_eol
+                  "val[38] = 0x19b48720 (431261472)" K_eol
+                  "val[39] = 0xaf8426b0 (2944673456)" K_eol
+                  "val[40] = 0x8526b286 (2233905798)" K_eol
+                  "val[41] = 0x27b28528 (666010920)" K_eol
+                  "val[42] = 0xb68729b8 (3062311352)" K_eol
+                  "val[43] = 0x8a29b98a (2317990282)" K_eol
+                  "val[44] = 0x29b88a29 (699959849)" K_eol
+                  "val[45] = 0xb68729b6 (3062311350)" K_eol
+                  "val[46] = 0x8928b587 (2301146503)" K_eol
+                  "val[47] = 0x27b08526 (665879846)" K_eol
+                  "val[48] = 0xb4872042 (3028754498)" K_eol
+                  "val[49] = 0x35193b31 (890846001)" K_eol
+                  "val[50] = 0x1b946f1a (462712602)" K_eol
+                  "val[51] = 0x936f1e99 (2473533081)" K_eol
+                  "val[52] = 0x7322af84 (1931652996)" K_eol
+                  "val[53] = 0x28ba8d2a (683314474)" K_eol
+                  "val[54] = 0xbb8d2cbf (3146591423)" K_eol
+                  "val[55] = 0x8f2cbf91 (2402074513)" K_eol
+                  "val[56] = 0x2dbe8f2c (767463212)" K_eol
+                  "val[57] = 0xc0912caf (3230739631)" K_eol
+                  "val[58] = 0x84289b73 (2217253747)" K_eol
+                  "val[59] = 0x22997222 (580481570)" K_eol
+                  "val[60] = 0x946f1a3b (2490309179)" K_eol
+                  "val[61] = 0x311b2520 (823862560)" K_eol
+                  "val[62] = 0x1644310c (373567756)" K_eol
+                  "val[63] = 0x45340f3f (1161039679)" K_eol
+                  "val[64] = 0x2f0f4d3a (789531962)" K_eol
+                  "val[65] = 0x12c8982f (315136047)" K_eol
+                  "val[66] = 0xc2932fc4 (3264425924)" K_eol
+                  "val[67] = 0x9631c597 (2519844247)" K_eol
+                  "val[68] = 0x31c79831 (835164209)" K_eol
+                  "val[69] = 0xbb8d2d36 (3146591542)" K_eol
+                  "val[70] = 0x2a0d4b39 (705514297)" K_eol
+                  "val[71] = 0x12473410 (306656272)" K_eol
+                  "val[72] = 0x44320d25 (1144130853)" K_eol
+                  "val[73] = 0x20164236 (538329654)" K_eol
+                  "val[74] = 0x1bb68721 (464946977)" K_eol
+                  "val[75] = 0xbd8d29b8 (3180145080)" K_eol
+                  "val[76] = 0x8c2a3e2f (2351578671)" K_eol
+                  "val[77] = 0xfbd8f2f (264081199)" K_eol
+                  "val[78] = 0xcb9a33cb (3415880651)" K_eol
+                  "val[79] = 0x9c34cc9d (2620705949)" K_eol
+                  "val[80] = 0x34d7a536 (886547766)" K_eol
+                  "val[81] = 0x85652159 (2237997401)" K_eol
+                  "val[82] = 0x4517d5a0 (1159189920)" K_eol
+                  "val[83] = 0x31c0922c (834703916)" K_eol
+                  "val[84] = 0xbc8b2444 (3163235396)" K_eol
+                  "val[85] = 0x371c4136 (924598582)" K_eol
+                  "val[86] = 0x1bb38421 (464749601)" K_eol
+                  "val[87] = 0xb88929ca (3095996874)" K_eol
+                  "val[88] = 0x992e4e3a (2569948730)" K_eol
+                  "val[89] = 0x13997526 (328824102)" K_eol
+                  "val[90] = 0xd7a638d3 (3617994963)" K_eol
+                  "val[91] = 0xa135d5a2 (2704659874)" K_eol
+                  "val[92] = 0x36e4ae3a (920956474)" K_eol
+                  "val[93] = 0x634c1a8a (1665931914)" K_eol
+                  "val[94] = 0x6922d19f (1763889567)" K_eol
+                  "val[95] = 0x32be8f2c (851349292)" K_eol
+                  "val[96] = 0xb9892444 (3112772676)" K_eol
+                  "val[97] = 0x371c4236 (924598838)" K_eol
+                  "val[98] = 0x1bb38521 (464749857)" K_eol
+                  "val[99] = 0xb88b2acb (3096128203)" K_eol
+                  "val[100] = 0x9a308465 (2586870885)" K_eol
+                  "val[101] = 0x1f5a4417 (526009367)" K_eol
+                  "val[102] = 0xe8b13cda (3903929562)" K_eol
+                  "val[103] = 0xa638dba8 (2788744104)" K_eol
+                  "val[104] = 0x3ae5ae3b (988130875)" K_eol
+                  "val[105] = 0x544116a7 (1413551783)" K_eol
+                  "val[106] = 0x7f2ace9d (2133511837)" K_eol
+                  "val[107] = 0x32c0912d (851480877)" K_eol
+                  "val[108] = 0xbb8b2444 (3146458180)" K_eol
+                  "val[109] = 0x381c4236 (941376054)" K_eol
+                  "val[110] = 0x1bb48522 (464815394)" K_eol
+                  "val[111] = 0xb98c2ac2 (3112970946)" K_eol
+                  "val[112] = 0x922ecb99 (2452540313)" K_eol
+                  "val[113] = 0x323b2d0f (842738959)" K_eol
+                  "val[114] = 0xb78c2fe9 (3079417833)" K_eol
+                  "val[115] = 0xb43ee2ae (3024020142)" K_eol
+                  "val[116] = 0x3fe5b13d (1072017725)" K_eol
+                  "val[117] = 0x534016b1 (1396709041)" K_eol
+                  "val[118] = 0x862ccd9b (2251083163)" K_eol
+                  "val[119] = 0x33c1912e (868323630)" K_eol
+                  "val[120] = 0xbc8c2545 (3163301189)" K_eol
+                  "val[121] = 0x381d4236 (941441590)" K_eol
+                  "val[122] = 0x1bb38521 (464749857)" K_eol
+                  "val[123] = 0x9ce4f59c (2632250780)" K_eol
+                  "val[124] = 0xe4f5d4a0 (3841316000)" K_eol
+                  "val[125] = 0x34997626 (882472486)" K_eol
+                  "val[126] = 0x3a2c0fdf (975966175)" K_eol
+                  "val[127] = 0xac3be9b5 (2889607605)" K_eol
+                  "val[128] = 0x40e7b23c (1088926268)" K_eol
+                  "val[129] = 0x564117a6 (1447106470)" K_eol
+                  "val[130] = 0x7f29cf9e (2133446558)" K_eol
+                  "val[131] = 0x33c1912e (868323630)" K_eol
+                  "val[132] = 0xbb8c2544 (3146523972)" K_eol
+                  "val[133] = 0x381c4136 (941375798)" K_eol
+                  "val[134] = 0x1b9ce4f5 (463267061)" K_eol
+                  "val[135] = 0xb88a29bf (3096062399)" K_eol
+                  "val[136] = 0x8f2c9ce4 (2402065636)" K_eol
+                  "val[137] = 0xf5dca937 (4124879159)" K_eol
+                  "val[138] = 0x7c60213d (2086674749)" K_eol
+                  "val[139] = 0x2e10c192 (772850066)" K_eol
+                  "val[140] = 0x31fabf41 (838516545)" K_eol
+                  "val[141] = 0x795c1f81 (2036080513)" K_eol
+                  "val[142] = 0x611fd4a0 (1629476000)" K_eol
+                  "val[143] = 0x33bf912d (868192557)" K_eol
+                  "val[144] = 0xba8a2444 (3129615428)" K_eol
+                  "val[145] = 0x371c4134 (924598580)" K_eol
+                  "val[146] = 0x1b9ce4f5 (463267061)" K_eol
+                  "val[147] = 0xb687299c (3062311324)" K_eol
+                  "val[148] = 0xe4f59ce4 (3841301732)" K_eol
+                  "val[149] = 0xf5c79631 (4123498033)" K_eol
+                  "val[150] = 0xdca83893 (3702012051)" K_eol
+                  "val[151] = 0x71263f30 (1898331952)" K_eol
+                  "val[152] = 0x10664d1b (275139867)" K_eol
+                  "val[153] = 0x61491932 (1632180530)" K_eol
+                  "val[154] = 0x260cc897 (638371991)" K_eol
+                  "val[155] = 0x30bd902b (817729579)" K_eol
+                  "val[156] = 0xb7872343 (3079086915)" K_eol
+                  "val[157] = 0x371c4136 (924598582)" K_eol
+                  "val[158] = 0x1b9ce4f5 (463267061)" K_eol
+                  "val[159] = 0xb18322b7 (2978161335)" K_eol
+                  "val[160] = 0x8928bd8d (2301148557)" K_eol
+                  "val[161] = 0x2bc2912d (734171437)" K_eol
+                  "val[162] = 0xc4952fd6 (3298111446)" K_eol
+                  "val[163] = 0xa133c997 (2704525719)" K_eol
+                  "val[164] = 0x308d6a20 (814574112)" K_eol
+                  "val[165] = 0x6a4f1767 (1783568231)" K_eol
+                  "val[166] = 0x4c16b789 (1276557193)" K_eol
+                  "val[167] = 0x28ba8b28 (683313960)" K_eol
+                  "val[168] = 0xb3852142 (3011846466)" K_eol
+                  "val[169] = 0x361b4033 (907755571)" K_eol
+                  "val[170] = 0x18ac7d17 (413957399)" K_eol
+                  "val[171] = 0x9ce4f59c (2632250780)" K_eol
+                  "val[172] = 0xe4f59ce4 (3841301732)" K_eol
+                  "val[173] = 0xf5c6a151 (4123435345)" K_eol
+                  "val[174] = 0xc9a24ec9 (3382857417)" K_eol
+                  "val[175] = 0xa04bcca1 (2689322145)" K_eol
+                  "val[176] = 0x49d2a547 (1238541639)" K_eol
+                  "val[177] = 0xd4a643ce (3567666126)" K_eol
+                  "val[178] = 0x9f3ebc91 (2671688849)" K_eol
+                  "val[179] = 0x36b5892d (917866797)" K_eol
+                  "val[180] = 0xb0811b3f (2961251135)" K_eol
+                  "val[181] = 0x3419322a (874066474)" K_eol
+                  "val[182] = 0x1cbea367 (482255719)" K_eol
+                  "val[183] = 0xdaccacd5 (3670846677)" K_eol
+                  "val[184] = 0xc5a1d5c3 (3315717571)" K_eol
+                  "val[185] = 0x9dd6c399 (2648097689)" K_eol
+                  "val[186] = 0xd7c295d6 (3619853782)" K_eol
+                  "val[187] = 0xc091d6be (3230783166)" K_eol
+                  "val[188] = 0x8cd4bc88 (2362752136)" K_eol
+                  "val[189] = 0xd2b983cf (3535373263)" K_eol
+                  "val[190] = 0xb57ecdb3 (3044986291)" K_eol
+                  "val[191] = 0x78cfb377 (2026877815)" K_eol
+                  "val[192] = 0xb3914632 (3012642354)" K_eol
+                  "val[193] = 0x2a1b0000 (706412544)" K_eol
+                  "val[194] = 0x88898b (8948107)" K_eol
+                  "val[195] = 0x95939096 (2509475990)" K_eol
+                  "val[196] = 0x95919997 (2509347223)" K_eol
+                  "val[197] = 0x949c9995 (2493290901)" K_eol
+                  "val[198] = 0x9e9c96a1 (2661062305)" K_eol
+                  "val[199] = 0x9e97a19e (2660737438)" K_eol
+                  "val[200] = 0x969f9c95 (2527042709)" K_eol
+                  "val[201] = 0x9c989196 (2627244438)" K_eol
+                  "val[202] = 0x948b918e (2492174734)" K_eol
+                  "val[203] = 0x858e8880 (2240710784)" K_eol
+                  "val1 = 0x7573 (30067)" K_eol
+                  "val2 = 0x6e00 (28160)" K_eol
+                  "val3 = 0x0 (0)" K_eol
+                  );
+                  
+    // key="WqA&1XsZ~2CdE\"3VfR'4BgT(" (24 bytes)  value="string{decoder=decoder_aes}  val ;"
+    // value length = 35 (34 + zero end of string)
+    // decrypted length = 48 (3*16)
+    // So 13 padding bytes that must be read
+    interpret_data.add_read_variable("decoder_aes_key", "WqA&1XsZ~2CdE\"3VfR'4BgT(");
+    M_TEST_SIMPLE("2a	61	39	d6	12	4c	04	32	7e	d1	7b	a3	2e	f5	9e	ae"
+                  "02	c9	1e	9e	eb	1a	54	10	31	44	d1	21	b9	71	88	cb"
+                  "f0	c1	7d	61	46	75	7c	db	a7	c7	86	4d	ad	b5	9c	77",
+                  "string{decoder=decoder_aes}  val ;"
+                  "hide raw(13)                 padding16bytes ;",
+                  "val = string{decoder=decoder_aes}  val ;" K_eol);
+
+    // key="WqA&1XsZ~2CdE\"3VfR'4BgT(5NhY-6,;" (32 bytes)  value="string{decoder=decoder_aes}  val ;"
+    // value length = 35 (34 + zero end of string)
+    // decrypted length = 48 (3*16)
+    // So 13 padding bytes that must be read
+    interpret_data.add_read_variable("decoder_aes_key", "WqA&1XsZ~2CdE\"3VfR'4BgT(5NhY-6,;");
+    M_TEST_SIMPLE("f8	68	ea	04	3b	d9	c2	f8	52	05	18	b7	2f	7c	6d	c9"
+                  "7c	ec	50	5a	4c	0e	91	74	c3	c6	82	cb	92	8d	c4	e7"
+                  "53	63	ee	9e	1f	b5	1b	57	80	38	3a	2d	60	ba	b6	0a",
+                  "string{decoder=decoder_aes}  val ;"
+                  "hide raw(13)                 padding16bytes ;",
+                  "val = string{decoder=decoder_aes}  val ;" K_eol);
+
+#if 0
+    // Binary key : NOT implemented
+    // key="00010203040506778899AABBCCDDEEFF101112131415161718191A2B3C4D5E6F" (32 bytes)  value="string{decoder=decoder_aes}  val ;"
+    // value length = 35 (34 + zero end of string)
+    // decrypted length = 48 (3*16)
+    // So 13 padding bytes that must be read
+    interpret_data.add_read_variable("decoder_aes_key", "decoder_aes_key", "00010203040506778899AABBCCDDEEFF101112131415161718191A2B3C4D5E6F");
+    M_TEST_SIMPLE("9c	20	40	56	82	e5	ac	eb	3b	62	dd	39	81	c9	f0	70"
+                  "85	e7	b2	01	a0	42	33	e3	53	09	cb	c6	01	60	9d	45"
+                  "81	69	29	79	ff	19	3a	78	c9	79	9f	d3	0b	70	47	76",
+                  "string{decoder=decoder_aes}  val ;"
+                  "hide raw(13)                 padding16bytes ;",
+                  "val = string{decoder=decoder_aes}  val ;" K_eol);
+#endif
+}
diff --git a/plugins/epan/generic/unitary_test_interpret_simple_decoder_base64.cpp b/plugins/epan/generic/unitary_test_interpret_simple_decoder_base64.cpp
new file mode 100644
index 00000000000..ea3b7dafe77
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_interpret_simple_decoder_base64.cpp
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "unitary_tests_ut_interpret_bytes.h"
+
+#include "T_interpret_data.h"
+
+
+//*****************************************************************************
+// test_interpret_simple_decoder_base64
+//*****************************************************************************
+
+M_TEST_FCT(test_interpret_simple_decoder_base64)
+{
+    T_type_definitions    type_definitions;
+    istringstream         iss("alias stringBase64  string{decoder=decoder_base64};");
+    build_types(iss, type_definitions);
+
+    T_interpret_data      interpret_data;
+
+    interpret_data.set_big_endian();
+
+
+    // 56334E6E 5A413D3D --> V3Nn ZA== --> 0x 57 73 67  64 --> "Wsgd" (if it is a string)
+    M_TEST_SIMPLE("56334E6E5A413D3D", "decoder    decoder_base64;"
+                                      " uint8     val1 ;"
+                                      "uint24     val2 ;"
+                                      "decoder    nil;",
+                                      "val1 = 87" K_eol "val2 = 7563108" K_eol);
+    // Idem, but previous presentation seems better
+    // Here, we can think there are 2 different encoded buffers
+    M_TEST_SIMPLE("56334E6E5A413D3D", " uint8{decoder=decoder_base64}     val1 ;"
+                                      "uint24{decoder=decoder_base64}     val2 ;",
+                                      "val1 = 87" K_eol "val2 = 7563108" K_eol);
+
+    // Specifying a size for string works only if encoded size is the same size
+    M_TEST_SIMPLE("56334E6E5A413D3D", "stringBase64(4)  val  ;", "val = Wsgd" K_eol);
+    // Does not work, the 5th byte is missing
+//	M_TEST_SIMPLE("56334E6E5A413D3D", "stringBase64(5)  val  ;", "val = Wsgd" K_eol);
+    M_TEST_SIMPLE("56334E6E5A41413D", "stringBase64(5)  val  ;", "val = Wsgd" K_eol);
+    // Does not work, the 6th byte is missing
+//	M_TEST_SIMPLE("56334E6E5A41413D", "stringBase64(6)  val  ;", "val = Wsgd" K_eol);
+    M_TEST_SIMPLE("56334E6E5A414141", "stringBase64(6)  val  ;", "val = Wsgd" K_eol);
+    M_TEST_SIMPLE("56334E6E5A414156", "stringBase64(6)  val  ;", "val = Wsgd" K_eol);
+    // It works, even without zero end of string, because there is no more data
+    M_TEST_SIMPLE("56334E6E5A413D3D", "stringBase64     val  ;", "val = Wsgd" K_eol);
+    // In normal case, zero end of string is needed
+    // 56334E6E 5A41413D --> V3Nn ZAA= --> 0x 57 73 67  64 00 --> "wsgd" (if it is a string)
+    M_TEST_SIMPLE("56334E6E5A41413D", "stringBase64     val  ;", "val = Wsgd" K_eol);
+
+
+    // Test complement not preceded by A (zero)
+    // 56334E6E 57673D3D --> V3Nn Wg== --> 0x 57 73 67  5A --> "WsgZ" (if it is a string)
+    M_TEST_SIMPLE("56334E6E57673D3D", "stringBase64(4)  val  ;", "val = WsgZ" K_eol);
+    // 56334E6E 5A466F3D --> V3Nn ZFo= --> 0x 57 73 67  64 5A --> "WsgdZ" (if it is a string)
+    M_TEST_SIMPLE("56334E6E5A466F3D", "stringBase64(5)  val  ;", "val = WsgdZ" K_eol);
+
+
+    // Complement = not at the end.
+    // Not a valid syntax.
+    // Behavior NOT guaranteed.
+    // 56334E6E 57673D3D 56334E6E 5A466F3D --> V3Nn Wg== V3Nn ZFo= --> 0x 57 73 67  5A  57 73 67  64 5A--> "WsgZWsgZ"
+    M_TEST_SIMPLE("56334E6E57673D3D56334E6E5A466F3D", "stringBase64(9)  val  ;", "val = WsgZWsgdZ" K_eol);
+    M_TEST_SIMPLE("56334E6E57673D3D56334E6E5A466F3D", "stringBase64     val  ;", "val = WsgZWsgdZ" K_eol);
+
+    // Idem previous + space, \t, \n, \r
+    // These characters are ignored.
+    // 562033094E0A6E 570D673D3D 56334E6E 5A466F3D --> V 3\tN\nn W\rg== V3Nn ZFo= --> 0x 57 73 67  5A  57 73 67  64 5A--> "WsgZWsgZ"
+    M_TEST_SIMPLE("562033094E0A6E570D673D3D56334E6E5A466F3D", "stringBase64     val  ;", "val = WsgZWsgdZ" K_eol);
+}
diff --git a/plugins/epan/generic/unitary_test_interpret_simple_internal_frame.cpp b/plugins/epan/generic/unitary_test_interpret_simple_internal_frame.cpp
new file mode 100644
index 00000000000..7fbd5bf364c
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_interpret_simple_internal_frame.cpp
@@ -0,0 +1,200 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "unitary_tests_ut_interpret_bytes.h"
+
+#include "T_interpret_data.h"
+
+
+//*****************************************************************************
+// test_interpret_simple_internal_frame
+//*****************************************************************************
+
+M_TEST_FCT(test_interpret_simple_internal_frame)
+{
+    T_type_definitions    type_definitions;
+    build_types ("unitary_tests_basic.fdesc",    // decode_invert_4_bytes
+                 type_definitions);
+
+    T_interpret_data      interpret_data;
+    interpret_data.set_big_endian();
+
+    //*************************************************************************
+    // internal_frame
+    //*************************************************************************
+
+    // No real data, data is read from internal_frame.
+    M_TEST_SIMPLE("",
+                  "call frame_append_hexa_data (internal_frame, \" e2 3f 6a 77 \") ; "
+                  "uint32{d=hex}  val ;",
+                  "val = 0xe23f6a77 (3795806839)" K_eol);
+
+    // First, data is read from internal_frame, then from real data.
+    M_TEST_SIMPLE("de",
+                  "call frame_append_hexa_data (internal_frame, \" e2 3f 6a 77 \") ; "
+                  "uint16{d=hex}  val1 ; "
+                  "uint4{d=hex}   val2 ; "
+                  "uint4{d=hex}   val3 ; "
+                  "uint8{d=hex}   val4 ; "
+                  "uint8{d=hex}   val5 ; ",
+                  "val1 = 0xe23f (57919)" K_eol
+                  "val2 = 0x6 (6)" K_eol
+                  "val3 = 0xa (10)" K_eol
+                  "val4 = 0x77 (119)" K_eol
+                  "val5 = 0xde (222)" K_eol);
+
+    //*************************************************************************
+    // Decoder which append more data than asked.
+    // Data goes into internal_frame.
+    //*************************************************************************
+    interpret_data.set_decode_function("decode_invert_4_bytes");  // read 4 bytes and invert them
+
+    C_ut_interpret_bytes_no_decode_guard  uibndg;
+
+    // Bytes inverted by decoder
+    M_TEST_SIMPLE("776a3fe2",    // e23f6a77
+                  "uint8{d=hex}  val1 ; uint8{d=hex}  val2 ; uint8{d=hex}  val3 ; uint8{d=hex}  val4 ;",
+                  "val1 = 0xe2 (226)" K_eol
+                  "val2 = 0x3f (63)" K_eol
+                  "val3 = 0x6a (106)" K_eol
+                  "val4 = 0x77 (119)" K_eol);
+
+    // Bytes inverted by decoder
+    M_TEST_SIMPLE("776a3fe2", "uint32  val ;", "val = 3795806839" K_eol);
+    M_TEST_SIMPLE("776a3fe2", " int32  val ;", "val = -499160457" K_eol);
+
+    // val2 is over first 4 bytes and second 4 bytes
+    M_TEST_SIMPLE("776a3fe2 01020304",    // e23f6a77 04030201
+                  "uint24{d=hex}  val1 ; uint16{d=hex}  val2 ; uint8{d=hex}  val3 ; uint16{d=hex}  val4 ;",
+                  "val1 = 0xe23f6a (14827370)" K_eol
+                  "val2 = 0x7704 (30468)" K_eol
+                  "val3 = 0x3 (3)" K_eol
+                  "val4 = 0x201 (513)" K_eol);
+
+    // bits
+    M_TEST_SIMPLE("776a3fe2 01020304",    // e23f6a77 04030201
+        "uint16{d=hex}  val1 ; uint4{d=hex}  val2; uint8{d=hex}  val3; uint16{d=hex}  val4 ; uint8{d=hex}  val5 ; uint12{d=hex}  val6 ;",
+                  "val1 = 0xe23f (57919)" K_eol
+                  "val2 = 0x6 (6)" K_eol
+                  "val3 = 0xa7 (167)" K_eol
+                  "val4 = 0x7040 (28736)" K_eol
+                  "val5 = 0x30 (48)" K_eol
+                  "val6 = 0x201 (513)" K_eol);
+
+    // string fixed size
+    M_TEST_SIMPLE("4249472d 52455155 45535453",    // 2d474942 55514552 53545345    -GIB UQER STSE
+                  "string(12)  val ;",
+                  "val = -GIBUQERSTSE" K_eol);  // BIG-REQUESTS if not inverted
+    M_TEST_SIMPLE("4249472d 52455155 45535453",
+                  "string(3)  val1; string(3)  val2; string(3)  val3; string(3)  val4; ",
+                  "val1 = -GI" K_eol
+                  "val2 = BUQ" K_eol
+                  "val3 = ERS" K_eol
+                  "val4 = TSE" K_eol);
+    // string fixed size at bit position
+    M_TEST_SIMPLE("94 74 d4 b2    55 14 55 25    34 45 35 25      56 34 12 5e",  // b 4249472d 52455155 45535453 e ...
+                  "uint4  begin; string(12)  val ; uint4  end; uint24{d=hex}  end2;",
+                  "begin = 11" K_eol
+                  "val = -GIBUQERSTSE" K_eol
+                  "end = 14" K_eol
+                  "end2 = 0x123456 (1193046)" K_eol);
+
+    // string unknow size
+    M_TEST_SIMPLE("4249472d 52455155 45535453",
+                  "string  val ;",
+                  "val = -GIBUQERSTSE" K_eol);  // BIG-REQUESTS if not inverted
+    M_TEST_SIMPLE("4249472d 52455155 45535453",
+                  "string(3)  val1; string  val2; ",
+                  "val1 = -GI" K_eol
+                  "val2 = BUQERSTSE" K_eol);
+    M_TEST_SIMPLE("4249472d 52005155 45535453",
+                  "string(3)  val1; string  val2; string  val3; ",
+                  "val1 = -GI" K_eol
+                  "val2 = BUQ" K_eol
+                  "val3 = RSTSE" K_eol);
+    // string unknow size at bit position
+    M_TEST_SIMPLE("94 74 d4 b2  55 14 55 25  30 45 35 25  56 34 12 0e",  // b2 d4 74 94   25 55 14 55   25 35 45 30  0e 12 34 56
+                  "uint4  begin; string  val ; uint4  end; uint24{d=hex}  end2;",
+                  "begin = 11" K_eol
+                  "val = -GIBUQERSTS" K_eol
+                  "end = 14" K_eol
+                  "end2 = 0x123456 (1193046)" K_eol);
+    M_TEST_SIMPLE("94 74 d4 b2  55 04 50 25  30 45 35 25  56 34 12 0e",  // b2 d4 74 94   25 50 04 55   25 35 45 30  0e 12 34 56
+                  "uint4  begin; string  val1 ; string  val2 ; uint4  end; uint24{d=hex}  end2;",
+                  "begin = 11" K_eol
+                  "val1 = -GIBU" K_eol
+                  "val2 = ERSTS" K_eol
+                  "end = 14" K_eol
+                  "end2 = 0x123456 (1193046)" K_eol);
+
+    // string unknow size at bit position, with :
+    // - zero (end of string) not at the end of a 4 bytes block
+    // - decoder changed just after the block containing the zero
+    //   --> following block must NOT be read by initial decoder
+    M_TEST_SIMPLE("94 74 d4 b2  55 04 50 25  30 45 35 25",  // b2 d4 74 94   25 50 04 55  decoder nil  30 45 35 25
+                  "uint4  begin; string  val1 ; uint4  end; uint8{d=hex}  end2; decoder nil; uint8{d=hex}[4]  not_inverted;",
+                  "begin = 11" K_eol
+                  "val1 = -GIBU" K_eol
+                  "end = 4" K_eol
+                  "end2 = 0x55 (85)" K_eol
+                  "not_inverted[0] = 0x30 (48)" K_eol
+                  "not_inverted[1] = 0x45 (69)" K_eol
+                  "not_inverted[2] = 0x35 (53)" K_eol
+                  "not_inverted[3] = 0x25 (37)" K_eol);
+    M_TEST_EQ(interpret_data.get_decode_function(), "");
+    interpret_data.set_decode_function("decode_invert_4_bytes");  // must set again the decoder (set to nil in previous test)
+
+    // raw fixed size
+    M_TEST_SIMPLE("4249472d 52455155 45535453",
+                  "raw(12)  val ;",
+                  "val = " K_eol
+                  "00000000 : 2d 47 49 42 55 51 45 52 53 54 53 45              - -GIBUQERSTSE    " K_eol);
+    M_TEST_SIMPLE("4249472d 52455155 45535453",
+                  "raw(3)  val1; raw(3)  val2; raw(3)  val3; raw(3)  val4; ",
+                  "val1 = " K_eol
+                  "00000000 : 2d 47 49                                         - -GI             " K_eol
+                  "val2 = " K_eol
+                  "00000000 : 42 55 51                                         - BUQ             " K_eol
+                  "val3 = " K_eol
+                  "00000000 : 45 52 53                                         - ERS             " K_eol
+                  "val4 = " K_eol
+                  "00000000 : 54 53 45                                         - TSE             " K_eol);
+
+    // raw unknow size
+    M_TEST_SIMPLE("4249472d 52455155 45535453",
+                  "raw(*)  val ;",
+                  "val = " K_eol
+                  "00000000 : 2d 47 49 42 55 51 45 52 53 54 53 45              - -GIBUQERSTSE    " K_eol);
+    M_TEST_SIMPLE("4249472d 52455155 45535453",
+                  "raw(3)  val1; raw(*)  val2;",
+                  "val1 = " K_eol
+                  "00000000 : 2d 47 49                                         - -GI             " K_eol
+                  "val2 = " K_eol
+                  "00000000 : 42 55 51 45 52 53 54 53 45                       - BUQERSTSE       " K_eol);
+}
diff --git a/plugins/epan/generic/unitary_test_interpret_simple_position.cpp b/plugins/epan/generic/unitary_test_interpret_simple_position.cpp
new file mode 100644
index 00000000000..991bcdeb179
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_interpret_simple_position.cpp
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "unitary_tests_ut_interpret_bytes.h"
+
+#include "T_interpret_data.h"
+
+
+//*****************************************************************************
+// test_interpret_simple_position
+//*****************************************************************************
+
+M_TEST_FCT(test_interpret_simple_position)
+{
+    T_type_definitions    type_definitions;
+    ut_interpret_bytes_init(type_definitions);
+
+    T_interpret_data      interpret_data;
+
+
+    M_TEST_SIMPLE("0102030405060708090A", "uint8  var_a; hide raw(9) ignore;", "var_a = 1" K_eol);
+
+    // Move position forward
+    M_TEST_SIMPLE("0102030405060708090A", "move_position_bytes 2;                 uint8  var_a; hide raw(7) ignore;", "var_a = 3" K_eol);
+    M_TEST_SIMPLE("0102030405060708090A", "move_position_bits 16;                 uint8  var_a; hide raw(7) ignore;", "var_a = 3" K_eol);
+    M_TEST_SIMPLE("0102030405060708090A", "move_position_bits  7; hide uint9 var; uint8  var_a; hide raw(7) ignore;", "var_a = 3" K_eol);
+
+    // Move position backward
+    M_TEST_SIMPLE("0102030405060708090A", "hide raw(7) ignore; move_position_bytes -2;                 uint8  var_a; hide raw(4) ignore;", "var_a = 6" K_eol);
+    M_TEST_SIMPLE("0102030405060708090A", "hide raw(7) ignore; move_position_bits -16;                 uint8  var_a; hide raw(4) ignore;", "var_a = 6" K_eol);
+    M_TEST_SIMPLE("0102030405060708090A", "hide raw(7) ignore; move_position_bits -25; hide uint9 var; uint8  var_a; hide raw(4) ignore;", "var_a = 6" K_eol);
+
+    // save_position, goto_position
+    M_TEST_SIMPLE("0102030405060708090A",
+                  "hide raw(7) ignore; save_position pos; hide raw(2) ignore; goto_position pos; uint8  var_a; hide raw(2) ignore;",
+                  "var_a = 8" K_eol);
+
+    // save_position, goto_position on bit position
+    M_TEST_SIMPLE("0102030405060708090A",
+        "hide uint17 var; save_position pos; hide uint16 var; goto_position pos; uint8  var_a; hide uint7 var; hide raw(6) ignore;",
+        "var_a = 6" K_eol);  // 6 = 3 << 1
+}
+
+//*****************************************************************************
+// test_interpret_simple_position_decode
+//*****************************************************************************
+
+M_TEST_FCT(test_interpret_simple_position_decode)
+{
+    T_type_definitions    type_definitions;
+    ut_interpret_bytes_init(type_definitions);
+    istringstream         iss(
+        "function void  decode_remove_1_byte (in frame  frame, in uint32   nb_of_bits_needed) "
+        "{ "
+        "    while (nb_of_bits_needed > 0) "
+        "    { "
+        "        hide uint8  byte1; "
+        "        hide uint8  byte2; "
+        "        call frame_append_data (frame, byte2); "
+        "        set nb_of_bits_needed = nb_of_bits_needed - 8; "
+        "    } "
+        "} "
+    );
+    build_types(iss, type_definitions);
+
+    T_interpret_data      interpret_data;
+    interpret_data.set_big_endian();
+
+    // Test du dcodeur
+    M_TEST_SIMPLE("0102030405060708090A", "decoder decode_remove_1_byte; uint8[5]  var_a;",
+        "var_a[0] = 2" K_eol
+        "var_a[1] = 4" K_eol
+        "var_a[2] = 6" K_eol
+        "var_a[3] = 8" K_eol
+        "var_a[4] = 10" K_eol
+    );
+
+    M_TEST_SIMPLE("0102030405060708090A", "decoder decode_remove_1_byte; uint16 var_a; uint8[3] var_b;",
+        "var_a = 516" K_eol  // 516 = 2*256 + 4
+        "var_b[0] = 6" K_eol
+        "var_b[1] = 8" K_eol
+        "var_b[2] = 10" K_eol
+    );
+
+
+    // move_position_..., save_position, goto_position "fails" with decoder
+    // Ie:
+    // - ..._position... do not take care of decoder
+    // - decoder is not aware of ..._position...
+    M_TEST_ERROR_ALREADY_KNOWN__OPEN(0, "..._position... not compatible with decoder")
+        // Here "move_position_bytes 4" moves of 4 physical bytes (instead of 8 using decoder)
+        M_TEST_SIMPLE("0102030405060708090A", "decoder decode_remove_1_byte; move_position_bytes 4; uint8  var_a;", "var_a = 10" K_eol);  // gives 6
+    }
+}
+
+//*****************************************************************************
+// test_interpret_simple_position_internal_frame
+//*****************************************************************************
+
+M_TEST_FCT(test_interpret_simple_position_internal_frame)
+{
+    T_type_definitions    type_definitions;
+    ut_interpret_bytes_init(type_definitions);
+    istringstream         iss(
+        "function void  decode_remove_1_byte (in frame  frame, in uint32   nb_of_bits_needed) "
+        "{ "
+        "    while (nb_of_bits_needed > 0) "
+        "    { "
+        "        hide uint8  byte1; "
+        "        hide uint8  byte2; "
+        "        call frame_append_data (frame, byte2); "
+        "        set nb_of_bits_needed = nb_of_bits_needed - 8; "
+        "    } "
+        "} "
+    );
+    build_types(iss, type_definitions);
+
+    T_interpret_data      interpret_data;
+    interpret_data.set_big_endian();
+
+
+    // internal_frame test
+    // No real data, data is read from internal_frame.
+    M_TEST_SIMPLE("",
+        "call frame_append_hexa_data (internal_frame, \" e2 3f 6a 77 \") ; "
+        "uint32{d=hex}  val ;",
+        "val = 0xe23f6a77 (3795806839)" K_eol);
+
+
+    // move_position_..., save_position, goto_position fails with internal_frame
+    // Ie ..._position... do not take care of internal_frame
+    M_TEST_ERROR_ALREADY_KNOWN__OPEN(0, "..._position... not compatible with internal_frame")
+        M_TEST_SIMPLE("",
+            "call frame_append_hexa_data (internal_frame, \" e2 3f 6a 77 \") ; "
+            "move_position_bytes 4;",
+            "");
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_interpret_simple_trailer.cpp b/plugins/epan/generic/unitary_test_interpret_simple_trailer.cpp
new file mode 100644
index 00000000000..f039be31c5c
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_interpret_simple_trailer.cpp
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "unitary_tests_ut_interpret_bytes.h"
+
+#include "T_interpret_data.h"
+
+
+//*****************************************************************************
+// test_interpret_simple_trailer
+//*****************************************************************************
+
+M_TEST_FCT(test_interpret_simple_trailer)
+{
+    T_type_definitions    type_definitions;
+    ut_interpret_bytes_init(type_definitions);
+
+    T_interpret_data      interpret_data;
+
+	type_definitions.trailer_sizeof_bits = 24;
+#define K_TRAILER_INPUT   "767778"
+#define K_TRAILER_READ    "uint8[3]  trailer ;"
+#define K_TRAILER_OUTPUT  "trailer[0] = 118" K_eol "trailer[1] = 119" K_eol "trailer[2] = 120" K_eol
+
+    {
+        M_TEST_SIMPLE("4249472d5245515545535453" K_TRAILER_INPUT,
+                      "raw(*)  val ;" K_TRAILER_READ,
+                      "val = " K_eol
+                      "00000000 : 42 49 47 2d 52 45 51 55 45 53 54 53              - BIG-REQUESTS    " K_eol
+                      K_TRAILER_OUTPUT);
+        M_TEST_SIMPLE("" K_TRAILER_INPUT,
+                      "raw(*)  val ;" K_TRAILER_READ,
+                      ""
+                      K_TRAILER_OUTPUT);
+    }
+
+    {
+        C_ut_interpret_bytes_no_decode_guard  uibndg;    // [*] & [+] rejected with decode
+        M_TEST_SIMPLE("4249472d5245515545535453" K_TRAILER_INPUT,
+                      "uint8[*]  val ;" K_TRAILER_READ,
+                      "val[0] = 66" K_eol
+                      "val[1] = 73" K_eol
+                      "val[2] = 71" K_eol
+                      "val[3] = 45" K_eol
+                      "val[4] = 82" K_eol
+                      "val[5] = 69" K_eol
+                      "val[6] = 81" K_eol
+                      "val[7] = 85" K_eol
+                      "val[8] = 69" K_eol
+                      "val[9] = 83" K_eol
+                      "val[10] = 84" K_eol
+                      "val[11] = 83" K_eol
+                      K_TRAILER_OUTPUT);
+        M_TEST_SIMPLE("4249472d5245515545535453" K_TRAILER_INPUT,
+                      "uint8[+]  val ;" K_TRAILER_READ,
+                      "val[0] = 66" K_eol
+                      "val[1] = 73" K_eol
+                      "val[2] = 71" K_eol
+                      "val[3] = 45" K_eol
+                      "val[4] = 82" K_eol
+                      "val[5] = 69" K_eol
+                      "val[6] = 81" K_eol
+                      "val[7] = 85" K_eol
+                      "val[8] = 69" K_eol
+                      "val[9] = 83" K_eol
+                      "val[10] = 84" K_eol
+                      "val[11] = 83" K_eol
+                      K_TRAILER_OUTPUT);
+        M_TEST_SIMPLE("" K_TRAILER_INPUT,
+                      "uint8[*]  val ;" K_TRAILER_READ,
+                      ""
+                      K_TRAILER_OUTPUT);
+        M_TEST_SIMPLE("42" K_TRAILER_INPUT,
+                      "uint8[+]  val ;" K_TRAILER_READ,
+                      "val[0] = 66" K_eol
+                      K_TRAILER_OUTPUT);
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_is_existing_field_or_variable.cpp b/plugins/epan/generic/unitary_test_is_existing_field_or_variable.cpp
new file mode 100644
index 00000000000..eb5d3e9e8c2
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_is_existing_field_or_variable.cpp
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "unitary_tests_ut_interpret_bytes.h"
+
+#include "T_interpret_data.h"
+
+
+//*****************************************************************************
+// test_is_existing_field_or_variable
+//*****************************************************************************
+
+M_TEST_FCT(test_is_existing_field_or_variable)
+{
+    T_type_definitions    type_definitions;
+    build_types("unitary_tests_basic.fdesc",
+                type_definitions);
+
+    T_interpret_data      interpret_data;
+
+    M_TEST_SIMPLE("", "T_is_existing_field_or_variable    st;", "st.in_main_struct = 1" K_eol);
+
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_none_begin")->get_bool(), false);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_not_exist_begin")->get_bool(), false);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_in_main_struct_begin")->get_bool(), false);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_in_if_begin")->get_bool(), false);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_in_else_begin")->get_bool(), false);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_in_while_begin")->get_bool(), false);
+
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_none_end")->get_bool(), false);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_not_exist_end")->get_bool(), false);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_in_main_struct_end")->get_bool(), true);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_in_if_end")->get_bool(), true);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_in_else_end")->get_bool(), false);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_in_while_end")->get_bool(), true);
+}
diff --git a/plugins/epan/generic/unitary_test_promote_printf_string_to_64bits.cpp b/plugins/epan/generic/unitary_test_promote_printf_string_to_64bits.cpp
new file mode 100644
index 00000000000..57a54071c87
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_promote_printf_string_to_64bits.cpp
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2021 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+
+#include "C_value.h"
+#include "byte_interpret_parse.h"
+
+
+//*****************************************************************************
+// test_promote_printf_string_to_64bits
+//*****************************************************************************
+
+M_TEST_FCT(test_promote_printf_string_to_64bits)
+{
+    string             format;
+    
+#define M_TEST_OK(FORMAT,RESULT)                                       \
+    format = FORMAT;                                                   \
+    promote_printf_string_to_64bits(format);                           \
+    M_TEST_EQ(format, RESULT)
+
+    // No modifications
+    M_TEST_OK("12345 abcde", "12345 abcde");
+    M_TEST_OK("12345 %%s e", "12345 %%s e");
+    M_TEST_OK("%s 45 %scde", "%s 45 %scde");
+    M_TEST_OK("%c %s %p %n", "%c %s %p %n");
+    M_TEST_OK("%e %E %f %F %g %G %a %A", "%e %E %f %F %g %G %a %A");  // floats
+
+    // Modifications for integers
+#ifdef WIN32
+    M_TEST_OK("%d %i %u %o %x %X", "%I64d %I64i %I64u %I64o %I64x %I64X");
+#else
+    M_TEST_OK("%d %i %u %o %x %X", "%lld %lli %llu %llo %llx %llX");
+#endif
+
+    // Errors
+    M_TEST_CATCH_EXCEPTION(format = "12345 %"; promote_printf_string_to_64bits(format), C_byte_interpret_exception);
+    M_TEST_CATCH_EXCEPTION(format = "%hd"; promote_printf_string_to_64bits(format), C_byte_interpret_exception);
+    M_TEST_CATCH_EXCEPTION(format = "%Ld"; promote_printf_string_to_64bits(format), C_byte_interpret_exception);
+    M_TEST_CATCH_EXCEPTION(format = "%ld"; promote_printf_string_to_64bits(format), C_byte_interpret_exception);
+    M_TEST_CATCH_EXCEPTION(format = "%lld"; promote_printf_string_to_64bits(format), C_byte_interpret_exception);
+
+
+#undef  M_TEST_OK
+}
diff --git a/plugins/epan/generic/unitary_test_read_token.cpp b/plugins/epan/generic/unitary_test_read_token.cpp
new file mode 100644
index 00000000000..9235ef5b98e
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_read_token.cpp
@@ -0,0 +1,193 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret_build_types_read_token.h"
+
+//*****************************************************************************
+// test_read_token
+//*****************************************************************************
+
+M_TEST_FCT(test_read_token)
+{
+    string    str_result;
+
+    // Field with (...)
+    {
+        istringstream  iss(""
+            "  raw(val-3)[val+2]"
+            "  toto ; ");
+
+        str_result = "";
+        M_TEST_EQ(read_token_left_any(iss, str_result), true);
+        M_TEST_EQ(str_result, "raw(val-3)[val+2]");
+
+        str_result = "";
+        M_TEST_EQ(read_token_field_name(iss, str_result), true);
+        M_TEST_EQ(str_result, "toto");
+
+        read_token_end_of_statement(iss);
+
+        str_result = "";
+        iss >> str_result;
+        M_TEST_EQ(str_result, "");
+    }
+
+    // Field with (...) and spaces
+    {
+        istringstream  iss(""
+            "  raw( val - 3 )[ val + 2 ]"
+            "  \"\" ; ");
+
+        str_result = "";
+        M_TEST_EQ(read_token_left_any(iss, str_result), true);
+        M_TEST_EQ(str_result, "raw( val - 3 )[ val + 2 ]");
+
+        str_result = "";
+        M_TEST_EQ(read_token_field_name(iss, str_result), true);
+        M_TEST_EQ(str_result, "");
+
+        read_token_end_of_statement(iss);
+
+        str_result = "";
+        iss >> str_result;
+        M_TEST_EQ(str_result, "");
+    }
+
+    // Field with {...}
+    {
+        istringstream  iss(" hide  var"
+            "  uint13{ns=0}{q=12.2:o=-47.2}{min=-43.2:max=12.3}{d=bin}[val+2]"
+            "  toto; ");
+
+        str_result = "";
+        M_TEST_EQ(read_token_left_any(iss, str_result), true);
+        M_TEST_EQ(str_result, "hide");
+
+        str_result = "";
+        M_TEST_EQ(read_token_left_any(iss, str_result), true);
+        M_TEST_EQ(str_result, "var");
+
+        str_result = "";
+        M_TEST_EQ(read_token_left_any(iss, str_result), true);
+        M_TEST_EQ(str_result, "uint13{ns=0}{q=12.2:o=-47.2}{min=-43.2:max=12.3}{d=bin}[val+2]");
+
+        str_result = "";
+        M_TEST_EQ(read_token_field_name(iss, str_result), true);
+        M_TEST_EQ(str_result, "toto");
+
+        read_token_end_of_statement(iss);
+
+        str_result = "";
+        iss >> str_result;
+        M_TEST_EQ(str_result, "");
+    }
+
+    // Field with {...} and spaces
+    {
+        istringstream  iss(" hide  var"
+            "  uint3{ns=0}{q=.2:o=-.2}{min=-3.2:max=2.3}{de=hello world}[ val + 2 ]"
+            "  toto; ");
+
+        str_result = "";
+        M_TEST_EQ(read_token_left_any(iss, str_result), true);
+        M_TEST_EQ(str_result, "hide");
+
+        str_result = "";
+        M_TEST_EQ(read_token_left_any(iss, str_result), true);
+        M_TEST_EQ(str_result, "var");
+
+        str_result = "";
+        M_TEST_EQ(read_token_left_any(iss, str_result), true);
+        M_TEST_EQ(str_result, "uint3{ns=0}{q=.2:o=-.2}{min=-3.2:max=2.3}{de=hello world}[ val + 2 ]");
+
+        str_result = "";
+        M_TEST_EQ(read_token_field_name(iss, str_result), true);
+        M_TEST_EQ(str_result, "toto");
+
+        read_token_end_of_statement(iss);
+
+        str_result = "";
+        iss >> str_result;
+        M_TEST_EQ(str_result, "");
+    }
+
+    // return  expression
+    {
+        istringstream  iss("	return  var_str_array[var_idx+1] + \" et quelques ...\"; ");
+
+        str_result = "";
+        M_TEST_EQ(read_token_left_any(iss, str_result), true);
+        M_TEST_EQ(str_result, "return");
+
+        str_result = "";
+        M_TEST_EQ(read_token_expression_any(iss, str_result), true);
+        M_TEST_EQ(str_result, "var_str_array[var_idx+1] + \" et quelques ...\"");
+
+        read_token_end_of_statement(iss);
+
+        str_result = "";
+        iss >> str_result;
+        M_TEST_EQ(str_result, "");
+    }
+
+    // return  expression function
+    {
+        istringstream  iss(" return  print (var[var_idx+1] + \" et quelques ...\", 2); ");
+
+        str_result = "";
+        M_TEST_EQ(read_token_left_any(iss, str_result), true);
+        M_TEST_EQ(str_result, "return");
+
+        str_result = "";
+        M_TEST_EQ(read_token_expression_any(iss, str_result), true);
+        M_TEST_EQ(str_result, "print (var[var_idx+1] + \" et quelques ...\", 2)");
+
+        read_token_end_of_statement(iss);
+
+        str_result = "";
+        iss >> str_result;
+        M_TEST_EQ(str_result, "");
+    }
+
+    // return  expression function
+    {
+        istringstream  iss(" print (\"int24[0] = %s\", int24[0]); ");
+
+        str_result = "";
+        M_TEST_EQ(read_token_left_any(iss, str_result), true);
+        M_TEST_EQ(str_result, "print");
+
+        str_result = "";
+        M_TEST_EQ(read_token_expression_any(iss, str_result), true);
+        M_TEST_EQ(str_result, "(\"int24[0] = %s\", int24[0])");
+
+        read_token_end_of_statement(iss);
+
+        str_result = "";
+        iss >> str_result;
+        M_TEST_EQ(str_result, "");
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_read_token_word_cplx.cpp b/plugins/epan/generic/unitary_test_read_token_word_cplx.cpp
new file mode 100644
index 00000000000..c5e6b3fc2b2
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_read_token_word_cplx.cpp
@@ -0,0 +1,226 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+
+
+//*****************************************************************************
+// test_read_token_word_cplx
+//*****************************************************************************
+
+M_TEST_FCT(test_read_token_word_cplx)
+{
+    string    str_result;
+
+    // Words and strings
+    {
+        istringstream  iss("word + string - 1234.45 * 0xdf / -067 % \"a string\" ");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "word");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "+");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "string");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "-");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "1234.45");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "*");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "0xdf");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "/");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "-067");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "%");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "\"a string\"");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), false);
+        M_TEST_EQ(str_result, "");
+
+        str_result = "";
+        iss >> str_result;
+        M_TEST_EQ(str_result, "");
+    }
+
+    // Comments and words with blocks
+    {
+        istringstream  iss("word + # comment \n type( (al) lo ) type[idx - 3] type{d=bin} ");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "word");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "+");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "type( (al) lo )");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "type[idx - 3]");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "type{d=bin}");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), false);
+        M_TEST_EQ(str_result, "");
+
+        str_result = "";
+        iss >> str_result;
+        M_TEST_EQ(str_result, "");
+    }
+
+    // ;
+    {
+        istringstream  iss("word + type( al;lo ) begin;end type[idx ;- 3] type{d=bi;n} ");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "word");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "+");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "type( al;lo )");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "begin");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, ";");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "end");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "type[idx ;- 3]");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_normal), true);
+        M_TEST_EQ(str_result, "type{d=bi;n}");
+
+        str_result = "";
+        iss >> str_result;
+        M_TEST_EQ(str_result, "");
+    }
+
+    // K_parser_cfg_parameters permits to extract function parameters
+    // E.g: <param1> , <param2> , ...
+    {
+        istringstream  iss("wo\"r,d\" + type,( al;lo ) begin,end type[idx ,;- 3] t,ype{d=b,i;n} ");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_parameters), true);
+        M_TEST_EQ(str_result, "wo\"r,d\" + type");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_parameters), true);
+        M_TEST_EQ(str_result, "( al;lo ) begin");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_parameters), true);
+        M_TEST_EQ(str_result, "end type[idx ,;- 3] t");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_parameters), true);
+        M_TEST_EQ(str_result, "ype{d=b,i;n}");
+
+        str_result = "";
+        iss >> str_result;
+        M_TEST_EQ(str_result, "");
+    }
+
+    // K_parser_cfg_expression : expression until ;
+    {
+        istringstream  iss("print (...); lhs + rhs; a_value == 0 ? (((a_value * 2) / a_value) + 2) : 5 ; ");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_expression), true);
+        M_TEST_EQ(str_result, "print (...)");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_expression), true);
+        M_TEST_EQ(str_result, ";");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_expression), true);
+        M_TEST_EQ(str_result, "lhs + rhs");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_expression), true);
+        M_TEST_EQ(str_result, ";");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_expression), true);
+        M_TEST_EQ(str_result, "a_value == 0 ? (((a_value * 2) / a_value) + 2) : 5");
+
+        str_result = "";
+        M_TEST_EQ(read_token_word_cplx(iss, str_result, K_parser_cfg_expression), true);
+        M_TEST_EQ(str_result, ";");
+
+        str_result = "";
+        iss >> str_result;
+        M_TEST_EQ(str_result, "");
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_read_values.cpp b/plugins/epan/generic/unitary_test_read_values.cpp
new file mode 100644
index 00000000000..119c7b4d5fc
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_read_values.cpp
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "T_interpret_read_values.h"
+
+
+//*****************************************************************************
+// test_read_values
+//*****************************************************************************
+
+M_TEST_FCT(test_read_values)
+{
+    T_interpret_read_values    read_values;
+
+    // Tests d'existence et de valeurs
+
+    M_TEST_EQ(read_values.is_read_variable("toto"), false);
+    M_TEST_EQ(read_values.is_read_variable("tata"), false);
+    M_TEST_EQ(read_values.is_read_variable("titi"), false);
+    M_TEST_EQ(read_values.is_read_variable("tutu"), false);
+    M_TEST_EQ(read_values.is_read_variable("titi.tutu"), false);
+
+    read_values.add_read_variable("toto", 11);
+
+    M_TEST_EQ(read_values.is_read_variable("toto"), true);
+    M_TEST_EQ(read_values.is_read_variable("tata"), false);
+    M_TEST_EQ(read_values.is_read_variable("titi"), false);
+    M_TEST_EQ(read_values.is_read_variable("tutu"), false);
+    M_TEST_EQ(read_values.is_read_variable("titi.tutu"), false);
+
+    read_values.add_read_variable("tata", 22);
+
+    M_TEST_EQ(read_values.is_read_variable("toto"), true);
+    M_TEST_EQ(read_values.is_read_variable("tata"), true);
+    M_TEST_EQ(read_values.is_read_variable("titi"), false);
+    M_TEST_EQ(read_values.is_read_variable("tutu"), false);
+    M_TEST_EQ(read_values.is_read_variable("titi.tutu"), false);
+
+    read_values.add_read_variable("titi", 33);
+    read_values.add_read_variable("tutu", 44);
+
+    M_TEST_EQ(read_values.is_read_variable("toto"), true);
+    M_TEST_EQ(read_values.is_read_variable("tata"), true);
+    M_TEST_EQ(read_values.is_read_variable("titi"), true);
+    M_TEST_EQ(read_values.is_read_variable("tutu"), true);
+    M_TEST_EQ(read_values.is_read_variable("titi.tutu"), false);
+
+    M_TEST_EQ(read_values.get_P_value_of_read_variable("toto")->get_int(), 11);
+    M_TEST_EQ(read_values.get_P_value_of_read_variable("tata")->get_int(), 22);
+    M_TEST_EQ(read_values.get_P_value_of_read_variable("titi")->get_int(), 33);
+    M_TEST_EQ(read_values.get_P_value_of_read_variable("tutu")->get_int(), 44);
+
+    read_values.read_variable_group_begin("titi");
+    read_values.add_read_variable("tutu", 55);
+    read_values.add_read_variable("allo", 111);
+    read_values.add_read_variable("bonjour", 222);
+    read_values.add_read_variable("c_est_moi", 333);
+    read_values.add_read_variable("comment_ca_va", 444);
+    read_values.add_read_variable("bien_et_toi", 444);
+    read_values.add_read_variable("ping", "pong");
+
+    M_TEST_EQ(read_values.is_read_variable("titi.tutu"), true);
+    M_TEST_EQ(read_values.get_P_value_of_read_variable("tutu")->get_int(), 55);
+    M_TEST_EQ(read_values.get_P_value_of_read_variable("titi.tutu")->get_int(), 55);
+
+    read_values.read_variable_group_end();
+
+    M_TEST_EQ(read_values.get_P_value_of_read_variable("tutu")->get_int(), 55);     // NAMERULE
+    M_TEST_EQ(read_values.get_P_value_of_read_variable("titi.tutu")->get_int(), 55);
+
+    // Test mulitple values
+    T_interpret_read_values::T_var_name_P_values    name_values;
+
+    name_values.clear();
+    read_values.get_multiple_P_attribute_value_of_read_variable("titi.*", name_values);
+    M_TEST_EQ(name_values.size(), 7);
+
+    name_values.clear();
+    read_values.get_multiple_P_attribute_value_of_read_variable("titi.a*", name_values);
+    M_TEST_EQ(name_values.size(), 1);
+
+    name_values.clear();
+    read_values.get_multiple_P_attribute_value_of_read_variable("titi.c*", name_values);
+    M_TEST_EQ(name_values.size(), 2);
+
+    // Test array
+    read_values.add_read_variable("an_array[0]", 1000);
+    read_values.add_read_variable("an_array[1]", 1001);
+    read_values.add_read_variable("an_array[2]", 1002);
+    read_values.add_read_variable("an_array[3]", 1003);
+
+    M_TEST_EQ(read_values.is_read_variable("an_array[0]"), true);
+    M_TEST_EQ(read_values.is_read_variable("an_array[1]"), true);
+    M_TEST_EQ(read_values.is_read_variable("an_array[2]"), true);
+    M_TEST_EQ(read_values.is_read_variable("an_array[3]"), true);
+    M_TEST_EQ(read_values.is_read_variable("an_array[4]"), false);
+
+    M_TEST_EQ(read_values.get_P_value_of_read_variable("an_array[0]")->get_int(), 1000);
+    M_TEST_EQ(read_values.get_P_value_of_read_variable("an_array[1]")->get_int(), 1001);
+    M_TEST_EQ(read_values.get_P_value_of_read_variable("an_array[2]")->get_int(), 1002);
+    M_TEST_EQ(read_values.get_P_value_of_read_variable("an_array[3]")->get_int(), 1003);
+}
diff --git a/plugins/epan/generic/unitary_test_scoped_copyable_ptr.cpp b/plugins/epan/generic/unitary_test_scoped_copyable_ptr.cpp
new file mode 100644
index 00000000000..2adaa1c4419
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_scoped_copyable_ptr.cpp
@@ -0,0 +1,186 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "scoped_copyable_ptr.h"
+
+
+//*****************************************************************************
+// test_scoped_copyable_ptr
+//*****************************************************************************
+
+class C_scoped_copyable_ptr_object
+{
+    C_scoped_copyable_ptr_object &  operator=(const C_scoped_copyable_ptr_object & rhs);
+
+public:
+    C_scoped_copyable_ptr_object()
+        :id (++id_counter),
+         generation (1)
+    {
+    }
+    C_scoped_copyable_ptr_object(const C_scoped_copyable_ptr_object & rhs)
+        :id (rhs.id),
+         generation (rhs.generation + 1)
+    {
+    }
+    ~C_scoped_copyable_ptr_object()
+    {
+        last_deleted_id = id;
+        last_deleted_generation = generation;
+    }
+
+    static int    id_counter;
+    static int    last_deleted_id;
+    static int    last_deleted_generation;
+    int           id;
+    int           generation;
+};
+int   C_scoped_copyable_ptr_object::id_counter = 0;
+int   C_scoped_copyable_ptr_object::last_deleted_id = 0;
+int   C_scoped_copyable_ptr_object::last_deleted_generation = 0;
+
+M_TEST_FCT(test_scoped_copyable_ptr)
+{
+    // Empty
+    scoped_copyable_ptr<C_scoped_copyable_ptr_object>  scptr_a;
+
+    M_TEST_NULL(scptr_a.get());
+
+    // Empty reset 
+    scptr_a.reset(nullptr);
+    M_TEST_NULL(scptr_a.get());
+
+    // reset initialize
+    scptr_a.reset(new C_scoped_copyable_ptr_object);
+    M_TEST_NOT_NULL(scptr_a.get());
+    M_TEST_EQ(scptr_a->id, 1);
+    M_TEST_EQ((*scptr_a).id, 1);
+    M_TEST_EQ(scptr_a->generation, 1);
+
+    // Create not empty
+    scoped_copyable_ptr<C_scoped_copyable_ptr_object>  scptr_b(new C_scoped_copyable_ptr_object);
+
+    M_TEST_NOT_NULL(scptr_b.get());
+    M_TEST_EQ(scptr_b->id, 2);
+    M_TEST_EQ(scptr_b->generation, 1);
+
+    // Assign
+
+    // Do not compile : forbidden
+//	scoped_copyable_ptr<C_scoped_copyable_ptr_object>  scptr_c = new C_scoped_copyable_ptr_object;
+
+    scoped_copyable_ptr<C_scoped_copyable_ptr_object>  scptr_c(nullptr);
+    M_TEST_NULL(scptr_c.get());
+
+    scptr_c = scptr_a;    // deep copy
+
+    M_TEST_NOT_NULL(scptr_c.get());
+    M_TEST_EQ(scptr_c->id, 1);
+    M_TEST_EQ(scptr_c->generation, 2);    // deep copy
+
+    M_TEST_NOT_NULL(scptr_a.get());
+    M_TEST_EQ(scptr_a->id, 1);
+    M_TEST_EQ(scptr_a->generation, 1);
+
+    // Copy
+    {
+        scoped_copyable_ptr<C_scoped_copyable_ptr_object>  scptr_d(scptr_c);    // deep copy
+
+        M_TEST_NOT_NULL(scptr_d.get());
+        M_TEST_EQ(scptr_d->id, 1);
+        M_TEST_EQ(scptr_d->generation, 3);    // deep copy
+    }
+
+    // Out of scope destruction
+    M_TEST_EQ(C_scoped_copyable_ptr_object::last_deleted_id, 1);
+    M_TEST_EQ(C_scoped_copyable_ptr_object::last_deleted_generation, 3);
+
+    // swap
+    swap(scptr_c, scptr_b);
+
+    M_TEST_NOT_NULL(scptr_b.get());
+    M_TEST_EQ(scptr_b->id, 1);
+    M_TEST_EQ(scptr_b->generation, 2);
+
+    M_TEST_NOT_NULL(scptr_c.get());
+    M_TEST_EQ(scptr_c->id, 2);
+    M_TEST_EQ(scptr_c->generation, 1);
+
+    // swap on itself
+    swap(scptr_c, scptr_c);
+
+    M_TEST_NOT_NULL(scptr_c.get());
+    M_TEST_EQ(scptr_c->id, 2);
+    M_TEST_EQ(scptr_c->generation, 1);
+
+    // Destruction reset 
+    scptr_a.reset(nullptr);
+    M_TEST_NULL(scptr_a.get());
+
+    M_TEST_EQ(C_scoped_copyable_ptr_object::last_deleted_id, 1);
+    M_TEST_EQ(C_scoped_copyable_ptr_object::last_deleted_generation, 1);
+
+    // Destruction reset initialize
+    scptr_a.reset(new C_scoped_copyable_ptr_object);
+
+    M_TEST_NOT_NULL(scptr_a.get());
+    M_TEST_EQ(scptr_a->id, 3);
+    M_TEST_EQ(scptr_a->generation, 1);
+
+    // Really bad idea : NO deep copy here !!! BAD, BAD, BAD
+//	scptr_a.reset(scptr_b.get());
+    scptr_a.reset(new C_scoped_copyable_ptr_object);
+
+    M_TEST_EQ(C_scoped_copyable_ptr_object::last_deleted_id, 3);
+    M_TEST_EQ(C_scoped_copyable_ptr_object::last_deleted_generation, 1);
+
+    M_TEST_NOT_NULL(scptr_a.get());
+    M_TEST_EQ(scptr_a->id, 4);
+    M_TEST_EQ(scptr_a->generation, 1);
+}
+
+M_TEST_FCT(test_scoped_copyable_ptr__equality)
+{
+    {
+        scoped_copyable_ptr<C_scoped_copyable_ptr_object>  scptr_a;
+
+        M_TEST(scptr_a == nullptr);
+        M_TEST(!(scptr_a != nullptr));
+        M_TEST_EQ(scptr_a, nullptr);
+        M_TEST_NULL(scptr_a);
+    }
+    {
+        scoped_copyable_ptr<C_scoped_copyable_ptr_object>  scptr_a(new C_scoped_copyable_ptr_object);
+
+        M_TEST(!(scptr_a == nullptr));
+        M_TEST(scptr_a != nullptr);
+        M_TEST_NE(scptr_a, nullptr);
+        M_TEST_NOT_NULL(scptr_a);
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_static_executor_manager.cpp b/plugins/epan/generic/unitary_test_static_executor_manager.cpp
new file mode 100644
index 00000000000..6ebd7da0cf9
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_static_executor_manager.cpp
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "T_static_executor_manager.h"
+
+
+//*****************************************************************************
+// test_static_executor_manager_filters_empty
+//*****************************************************************************
+
+M_TEST_FCT(test_static_executor_manager_filters_empty)
+{
+    T_static_executor_manager::T_execution_filters  filters = T_static_executor_manager::build_execution_filters(7, nullptr, 7);
+    M_TEST_EQ(filters.filter_file_name_ends.size(), 0);
+    M_TEST_EQ(filters.filter_function_names.size(), 0);
+    M_TEST_EQ(filters.filter_function_name_starts.size(), 0);
+
+    T_static_executor executor(nullptr, "file_name.cpp", "fct_name");
+    M_TEST_EQ(filters.must_execute(executor), true);
+}
+
+//*****************************************************************************
+// test_static_executor_manager_filters_file_name_end
+//*****************************************************************************
+
+M_TEST_FCT(test_static_executor_manager_filters_file_name_end)
+{
+    const char* argv[] = { "ut.exe", "file_name.cpp", "_name3.cpp" };
+    T_static_executor_manager::T_execution_filters  filters = T_static_executor_manager::build_execution_filters(3, argv, 1);
+    M_TEST_EQ(filters.filter_file_name_ends.size(), 2);
+    M_TEST_EQ(filters.filter_file_name_ends[0], "file_name.cpp");
+    M_TEST_EQ(filters.filter_file_name_ends[1], "_name3.cpp");
+    M_TEST_EQ(filters.filter_function_names.size(), 0);
+    M_TEST_EQ(filters.filter_function_name_starts.size(), 0);
+
+    M_TEST_EQ(filters.must_execute(T_static_executor(nullptr, "file_name.cpp", "fct_name")), true);
+    M_TEST_EQ(filters.must_execute(T_static_executor(nullptr, "the_file_name.cpp", "fct_name")), true);
+    M_TEST_EQ(filters.must_execute(T_static_executor(nullptr, "file_name2.cpp", "fct_name")), false);
+    M_TEST_EQ(filters.must_execute(T_static_executor(nullptr, "file_name3.cpp", "fct_name")), true);
+}
+
+//*****************************************************************************
+// test_static_executor_manager_filters_function_name
+//*****************************************************************************
+
+M_TEST_FCT(test_static_executor_manager_filters_function_name)
+{
+    const char* argv[] = { "ut.exe", "fct_name", "fct_name3" };
+    T_static_executor_manager::T_execution_filters  filters = T_static_executor_manager::build_execution_filters(3, argv, 1);
+    M_TEST_EQ(filters.filter_file_name_ends.size(), 0);
+    M_TEST_EQ(filters.filter_function_names.size(), 2);
+    M_TEST_EQ(filters.filter_function_names[0], "fct_name");
+    M_TEST_EQ(filters.filter_function_names[1], "fct_name3");
+    M_TEST_EQ(filters.filter_function_name_starts.size(), 0);
+
+    M_TEST_EQ(filters.must_execute(T_static_executor(nullptr, "file_name.cpp", "fct_name")), true);
+    M_TEST_EQ(filters.must_execute(T_static_executor(nullptr, "file_name2.cpp", "fct_name2")), false);
+    M_TEST_EQ(filters.must_execute(T_static_executor(nullptr, "file_name3.cpp", "fct_name3")), true);
+}
+
+//*****************************************************************************
+// test_static_executor_manager_filters_function_name_start
+//*****************************************************************************
+
+M_TEST_FCT(test_static_executor_manager_filters_function_name_start)
+{
+    const char* argv[] = { "ut.exe", "fct_na*", "fct3_*" };
+    T_static_executor_manager::T_execution_filters  filters = T_static_executor_manager::build_execution_filters(3, argv, 1);
+    M_TEST_EQ(filters.filter_file_name_ends.size(), 0);
+    M_TEST_EQ(filters.filter_function_names.size(), 0);
+    M_TEST_EQ(filters.filter_function_name_starts.size(), 2);
+    M_TEST_EQ(filters.filter_function_name_starts[0], "fct_na");
+    M_TEST_EQ(filters.filter_function_name_starts[1], "fct3_");
+
+    M_TEST_EQ(filters.must_execute(T_static_executor(nullptr, "file_name.cpp", "fct_name")), true);
+    M_TEST_EQ(filters.must_execute(T_static_executor(nullptr, "file_name2.cpp", "fctname2")), false);
+    M_TEST_EQ(filters.must_execute(T_static_executor(nullptr, "file_name3.cpp", "fct3_name3")), true);
+}
diff --git a/plugins/epan/generic/unitary_test_string_to_words.cpp b/plugins/epan/generic/unitary_test_string_to_words.cpp
new file mode 100644
index 00000000000..64ecf8a8951
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_string_to_words.cpp
@@ -0,0 +1,161 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "byte_interpret_parse.h"
+
+void    string_to_words (const string          & str,
+                               vector<string>  & words,
+                         const E_parser_cfg      parser_cfg);
+
+
+//*****************************************************************************
+// test_string_to_words
+//*****************************************************************************
+
+M_TEST_FCT(test_string_to_words)
+{
+    {
+        vector<string>    words;
+        string_to_words("Hello world! \"How are you today ?\" Seems fine.", words);
+
+        M_TEST_EQ(words.size(), 5);
+        M_TEST_EQ(words[0], "Hello");
+        M_TEST_EQ(words[1], "world!");
+        M_TEST_EQ(words[2], "\"How are you today ?\"");
+        M_TEST_EQ(words[3], "Seems");
+        M_TEST_EQ(words[4], "fine.");
+    }
+
+    {
+        vector<string>    words;
+        string_to_words("  string(12)  str;  uint16{q=34.23}{max=1234.68}[number_of_integer]  int ;", words);
+
+        M_TEST_EQ(words.size(), 6);
+        M_TEST_EQ(words[0], "string(12)");
+        M_TEST_EQ(words[1], "str");
+        M_TEST_EQ(words[2], ";");
+        M_TEST_EQ(words[3], "uint16{q=34.23}{max=1234.68}[number_of_integer]");
+        M_TEST_EQ(words[4], "int");
+        M_TEST_EQ(words[5], ";");
+    }
+
+    {
+        vector<string>    words;
+        string_to_words("  while (field < 12*3) { uint12  int ; }", words);
+
+        M_TEST_EQ(words.size(), 7);
+        M_TEST_EQ(words[0], "while");
+        M_TEST_EQ(words[1], "(field < 12*3)");
+        M_TEST_EQ(words[2], "{");
+        M_TEST_EQ(words[3], "uint12");
+        M_TEST_EQ(words[4], "int");
+        M_TEST_EQ(words[5], ";");
+        M_TEST_EQ(words[6], "}");
+    }
+
+    {
+        vector<string>    words;
+        string_to_words("  (field < 12*3)  ", words, K_parser_cfg_C);
+
+        M_TEST_EQ(words.size(), 1);
+        M_TEST_EQ(words[0], "(field < 12*3)");
+    }
+
+    {
+        vector<string>    words;
+        string_to_words("field < 12-3*(3.4 * 345)", words, K_parser_cfg_C);
+
+        M_TEST_EQ(words.size(), 7);
+        M_TEST_EQ(words[0], "field");
+        M_TEST_EQ(words[1], "<");
+        M_TEST_EQ(words[2], "12");
+        M_TEST_EQ(words[3], "-");
+        M_TEST_EQ(words[4], "3");
+        M_TEST_EQ(words[5], "*");
+        M_TEST_EQ(words[6], "(3.4 * 345)");
+    }
+
+    {
+        vector<string>    words;
+        string_to_words("\"Hello \" + \"world!\" == \"Hello world!\"", words, K_parser_cfg_C);
+
+        M_TEST_EQ(words.size(), 5);
+        M_TEST_EQ(words[0], "\"Hello \"");
+        M_TEST_EQ(words[1], "+");
+        M_TEST_EQ(words[2], "\"world!\"");
+        M_TEST_EQ(words[3], "==");
+        M_TEST_EQ(words[4], "\"Hello world!\"");
+    }
+
+    {
+        vector<string>    words;
+        string_to_words("\"Hello \"+\"world!\"==\"Hello world!\"", words, K_parser_cfg_C);
+
+        M_TEST_EQ(words.size(), 5);
+        M_TEST_EQ(words[0], "\"Hello \"");
+        M_TEST_EQ(words[1], "+");
+        M_TEST_EQ(words[2], "\"world!\"");
+        M_TEST_EQ(words[3], "==");
+        M_TEST_EQ(words[4], "\"Hello world!\"");
+    }
+
+    {
+        vector<string>    words;
+        string_to_words("  \"Unknow msg identifier (%d) or %s\",Type1,Type2  ", words, K_parser_cfg_parameters);
+
+        M_TEST_EQ(words.size(), 3);
+        M_TEST_EQ(words[0], "\"Unknow msg identifier (%d) or %s\"");
+        M_TEST_EQ(words[1], "Type1");
+        M_TEST_EQ(words[2], "Type2");
+    }
+
+    {
+        vector<string>    words;
+        string_to_words("  \"Unknow msg identifier (%d) or %s\"  ,  Type1  ,  Type2  ", words, K_parser_cfg_parameters);
+
+        M_TEST_EQ(words.size(), 3);
+        M_TEST_EQ(words[0], "\"Unknow msg identifier (%d) or %s\"");
+        M_TEST_EQ(words[1], "Type1");
+        M_TEST_EQ(words[2], "Type2");
+    }
+
+    {
+        vector<string>    words;
+        string_to_words("  12.3 * 2 + 17.1, \"par2\"  ", words, K_parser_cfg_parameters);
+
+        M_TEST_EQ(words.size(), 2);
+        M_TEST_EQ(words[0], "12.3 * 2 + 17.1");
+        M_TEST_EQ(words[1], "\"par2\"");
+    }
+
+    {
+        vector<string>    words;
+        string_to_words("  12.3 * 2 + 17.1, \"par2\" + \"par1\"  ", words, K_parser_cfg_parameters);
+
+        M_TEST_EQ(words.size(), 2);
+        M_TEST_EQ(words[0], "12.3 * 2 + 17.1");
+        M_TEST_EQ(words[1], "\"par2\" + \"par1\"");
+    }
+}
diff --git a/plugins/epan/generic/unitary_test_value_format.cpp b/plugins/epan/generic/unitary_test_value_format.cpp
new file mode 100644
index 00000000000..f7d0af9c2d3
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_value_format.cpp
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+
+#include "C_value.h"
+#include "byte_interpret_parse.h"
+
+
+//*****************************************************************************
+// test_value_format
+//*****************************************************************************
+
+M_TEST_FCT(test_value_format)
+{
+    C_value            value;
+    string             format;
+    
+#define M_TEST_OK(VALUE,RESULT)                                        \
+    value = C_value(VALUE);                                            \
+    M_TEST_EQ(value.as_string(), RESULT)
+
+    M_TEST_OK( 123456789101112,     "123456789101112");
+    M_TEST_OK( 1234567891011121314, "1234567891011121314");
+    M_TEST_OK( -4427611715, "-4427611715");
+
+
+#undef  M_TEST_OK
+
+#define M_TEST_OK(VALUE,FORMAT,RESULT)                                 \
+    value = C_value(VALUE);                                            \
+    format = FORMAT;                                                   \
+    promote_printf_string_to_64bits(format);                           \
+    value.format(format);                                              \
+    M_TEST_EQ(value.as_string(), RESULT)
+
+
+    M_TEST_OK( 123, "hex", "0x7b");
+    M_TEST_OK( 123, "oct", "0173");
+    M_TEST_OK( 123, "bin", "b1111011");
+
+//	M_TEST_OK(-123, "hex", "-0x7b");     // donne 0xffffff85
+//	M_TEST_OK(-123, "oct", "-0173");     // donne 037777777605
+//	M_TEST_OK(-123, "bin", "-b1111011"); // donne b1111111111111111111111111111111111111111111111111111111110000101
+
+    M_TEST_OK( 123, "augmentation = %d%% (non consolide)", "augmentation = 123% (non consolide)");
+    M_TEST_OK( 123, "augmentation = %s%% (non consolide)", "augmentation = 123% (non consolide)");
+
+    M_TEST_OK( 123456789101112    , "%d", "123456789101112");
+    M_TEST_OK( 1234567891011121314, "%d", "1234567891011121314");
+    M_TEST_OK( -4427611715        , "%d", "-4427611715");
+
+#undef  M_TEST_OK
+}
diff --git a/plugins/epan/generic/unitary_test_value_printf.cpp b/plugins/epan/generic/unitary_test_value_printf.cpp
new file mode 100644
index 00000000000..bd59270cd14
--- /dev/null
+++ b/plugins/epan/generic/unitary_test_value_printf.cpp
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+
+#include "C_value.h"
+#include "byte_interpret_parse.h"
+
+
+//*****************************************************************************
+// test_value_printf
+//*****************************************************************************
+
+M_TEST_FCT(test_value_printf)
+{
+    C_value            value;
+    vector<C_value>    values;
+    string             format;
+
+#define M_TEST_OK(FORMAT,VALUE,RESULT)                                 \
+    values.clear();                                                    \
+    values.push_back(C_value(VALUE));                                  \
+    format = FORMAT;                                                   \
+    promote_printf_string_to_64bits(format);                           \
+    value = C_value::sprintf_values(format,values);                    \
+    M_TEST_EQ(value.as_string(), RESULT)
+
+
+    M_TEST_OK("%d",   123, "123");
+    M_TEST_OK("0x%x", 123, "0x7b");
+    M_TEST_OK("0%o",  123, "0173");
+    M_TEST_OK("%s",   123, "123");
+    M_TEST_OK("%f",   123.0, "123.000000");     // NB: do not care about precise format
+    M_TEST_OK("%e",   123.0, "1.230000e+02");   // NB: do not care about precise format
+
+    M_TEST_OK("%d",   -123, "-123");
+//	M_TEST_OK("0x%x", -123, "-0x7b");     // donne 0xffffff85
+//	M_TEST_OK("0%o",  -123, "-0173");     // donne 037777777605
+
+    M_TEST_OK("%s",   -123, "-123");
+    M_TEST_OK("%f",   -123.0, "-123.000000");     // NB: do not care about precise format
+    M_TEST_OK("%e",   -123.0, "-1.230000e+02");   // NB: do not care about precise format
+
+    M_TEST_OK("augmentation = %d%% (non consolide)", 123, "augmentation = 123% (non consolide)");
+    M_TEST_OK("augmentation = %s%% (non consolide)", 123, "augmentation = 123% (non consolide)");
+
+    M_TEST_OK("%d",  123456789101112    , "123456789101112");
+    M_TEST_OK("%d",  1234567891011121314, "1234567891011121314");
+    M_TEST_OK("%d",  -4427611715        , "-4427611715");
+
+
+
+    M_TEST_OK("%05d", 123, "00123");
+    M_TEST_OK("%05i", 123, "00123");
+    M_TEST_OK("%05u", 123, "00123");
+    M_TEST_OK("0%05o",  123, "000173");
+    M_TEST_OK("0x%05x", 123, "0x0007b");
+    M_TEST_OK("0x%05X", 123, "0x0007B");
+
+
+#undef  M_TEST_OK
+}
diff --git a/plugins/epan/generic/unitary_tests.cpp b/plugins/epan/generic/unitary_tests.cpp
new file mode 100644
index 00000000000..98f86e03317
--- /dev/null
+++ b/plugins/epan/generic/unitary_tests.cpp
@@ -0,0 +1,300 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "unitary_tests_ut_interpret_bytes.h"
+#include "C_perf_chrono.h"
+
+#include "C_value.h"
+#include "T_type_definitions.h"
+#include "T_frame_data.h"
+#include "T_frame_data_write.h"
+#include "T_attribute_value.h"
+#include "T_interpret_data.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret_builder.h"
+#include "byte_interpret_compute_expression.h"
+#include "byte_interpret.h"
+#include "byte_interpret_build_types_read_token.h"
+#include "T_expression.h"
+
+
+//*****************************************************************************
+// test_interpret_simple_int64
+//*****************************************************************************
+
+M_TEST_FCT(test_interpret_simple_int64)
+{
+    T_type_definitions    type_definitions;
+    build_types ("unitary_tests_basic.fdesc",
+                 type_definitions);
+
+    T_interpret_data      interpret_data;
+
+    interpret_data.set_big_endian();
+
+    M_TEST_SIMPLE("e23f6a77cbf367a9", "int64  val ;", "val = -2143877834849687639" K_eol);
+}
+
+//*****************************************************************************
+// test_interpret_simple_uint8_array
+//*****************************************************************************
+
+void    test_interpret_simple_uint8_array(const int  max_iter)
+{
+    T_type_definitions    type_definitions;
+    build_types ("unitary_tests_basic.fdesc",
+                 type_definitions);
+
+    T_interpret_data      interpret_data;
+
+    interpret_data.set_little_endian();
+
+    for (int  idx_tst = 0; idx_tst < max_iter; ++idx_tst)
+    {
+        M_TRACE_WARNING("msg.size=" << interpret_data.DEBUG_get_msg().size());
+        ut_interpret_bytes(type_definitions,
+                           "4249472d5245515545535453" "4249472d5245515545535453"
+                           "4249472d5245515545535453" "4249472d5245515545535453"
+                           "4249472d5245515545535453" "4249472d5245515545535453"
+                           "4249472d5245515545535453" "4249472d5245515545535453"
+                           "4249472d5245515545535453" "4249472d5245515545535453"
+                           "4249472d5245515545535453" "4249472d5245515545535453"
+                           "4249472d5245515545535453" "4249472d5245515545535453"
+                           "4249472d5245515545535453" "4249472d5245515545535453"
+                           "4249472d5245515545535453" "4249472d5245515545535453"
+                           "4249472d5245515545535453" "4249472d5245515545535453",
+                           "uint8[240]  val ;",
+                           interpret_data,
+                           nullptr);
+    }
+}
+
+M_TEST_FCT(test_interpret_simple_uint8_array_1)
+{
+    test_interpret_simple_uint8_array(1);
+}
+
+//*****************************************************************************
+// test_interpret_msg
+//*****************************************************************************
+
+void    test_interpret_msg(int   msg_to_test = -1)
+{
+    // Messages which come from example_with_capture.pcap
+    // The number are the packet's number.
+    T_byte_vector    msg_1_frame;
+    T_byte_vector    msg_2_frame;
+    T_byte_vector    msg_4_frame;
+    T_byte_vector    msg_35_frame;
+    {
+        const char  * msg_1_str = "6c000b000000000000000000";
+        const char  * msg_2_str = "01000b000000f400807468020000a000ffff1f00000000001800ffff01070000202008ff8072470054686520584672656538362050726f6a6563742c20496e630101200000000000040820000000000008082000000000000f102000000000001010200000000000182020000000000020202000000000005700000020000000ffffff000000000000001a0090061a0439026401010001002200000000001807182720005ede020022000000040800010000ff0000ff0000ff000000d2ea020023000000040800010000ff0000ff0000ff000000d2ea020024000000040800010000ff0000ff0000ff000000d2ea020025000000040800010000ff0000ff0000ff000000d2ea020026000000040800010000ff0000ff0000ff000000d2ea020027000000040800010000ff0000ff0000ff000000d2ea020028000000040800010000ff0000ff0000ff000000d2ea020029000000040800010000ff0000ff0000ff000000d2ea02002a000000040800010000ff0000ff0000ff000000d2ea02002b000000040800010000ff0000ff0000ff000000d2ea02002c000000040800010000ff0000ff0000ff000000d2ea02002d000000040800010000ff0000ff0000ff000000d2ea02002e000000040800010000ff0000ff0000ff000000d2ea02002f000000040800010000ff0000ff0000ff000000d2ea020030000000040800010000ff0000ff0000ff000000d2ea020031000000040800010000ff0000ff0000ff000000d2ea020032000000040800010000ff0000ff0000ff000000d2ea020033000000040800010000ff0000ff0000ff000000d2ea020034000000040800010000ff0000ff0000ff000000d2ea020035000000040800010000ff0000ff0000ff000000d2ea020036000000040800010000ff0000ff0000ff000000d2ea020037000000040800010000ff0000ff0000ff000000d2ea020038000000040800010000ff0000ff0000ff000000d2ea020039000000040800010000ff0000ff0000ff000000d2ea02003a000000040800010000ff0000ff0000ff000000d2ea02003b000000040800010000ff0000ff0000ff000000d2ea02003c000000040800010000ff0000ff0000ff000000d2ea02003d000000040800010000ff0000ff0000ff000000d2ea02003e000000040800010000ff0000ff0000ff000000d2ea02003f000000040800010000ff0000ff0000ff000000d2ea020040000000040800010000ff0000ff0000ff000000d2ea020041000000040800010000ff0000ff0000ff000000d2ea0200012700005ede0200042700005ede0200082700005ede02000f2700005ede0200102700005ede0200202700005ede0200";
+        const char  * msg_4_str = "010002000000000001870000000000000000000000000000280000005bc00100";
+        const char  * msg_35_str = "370005000000a0005700000008000000ffffff00620005000c0000004249472d524551554553545387000100";
+        string_hexa_to_frame(msg_1_str, msg_1_frame);
+        string_hexa_to_frame(msg_2_str, msg_2_frame);
+        string_hexa_to_frame(msg_4_str, msg_4_frame);
+        string_hexa_to_frame(msg_35_str, msg_35_frame);
+    }
+
+    T_type_definitions    type_definitions;
+    build_types ("unitary_tests_example_with_capture.fdesc",
+                 type_definitions);
+
+    if ((msg_to_test < 0) || (msg_to_test == 1))
+    {
+        T_interpret_data  interpret_data;
+        interpret_data.global_variable_group_begin();
+        interpret_data.add_read_variable("msg_counter" ,0);
+        interpret_data.global_variable_group_end();
+
+        ut_interpret_bytes(type_definitions,
+                           msg_1_frame,
+                           "T_msg_cs_start         msg_1;",
+                           interpret_data,
+                           "msg_1.Header.Type = cs_start (7077899)" K_eol
+                           "msg_1.Header.Size = 8" K_eol
+                           "msg_1.id = 0" K_eol
+                           "msg_1.acronym = " K_eol);
+    }
+    if ((msg_to_test < 0) || (msg_to_test == 2))
+    {
+        T_interpret_data  interpret_data;
+        interpret_data.global_variable_group_begin();
+        interpret_data.add_read_variable("msg_counter" ,1);
+        interpret_data.global_variable_group_end();
+
+        // 2010/10/15         2013 ms
+        // 2010/10/16  1513 - 1545 ms
+        // 2010/10/29         1190 ms  T_expression var set call
+        // 2010/10/29          655 ms  T_expression condition return
+        // 2010/11/10          675 ms  T_expression pre_compute value & operation
+        // 2014/12/20          172 ms
+        ut_interpret_bytes(type_definitions,
+                           msg_2_frame,
+                           "T_msg_sc_start_ack         msg_2;",
+                           interpret_data);
+    }
+    if ((msg_to_test < 0) || (msg_to_test == 4))
+    {
+        T_interpret_data  interpret_data;
+        interpret_data.global_variable_group_begin();
+        interpret_data.add_read_variable("msg_counter" ,2);
+        interpret_data.global_variable_group_end();
+
+        ut_interpret_bytes(type_definitions,
+                           msg_4_frame,
+                           "T_msg_sc_ctx_data         msg_4;",
+                           interpret_data);
+    }
+    if ((msg_to_test < 0) || (msg_to_test == 35))
+    {
+        T_interpret_data  interpret_data;
+        interpret_data.global_variable_group_begin();
+        interpret_data.add_read_variable("msg_counter" ,3);
+        interpret_data.global_variable_group_end();
+
+        ut_interpret_bytes(type_definitions,
+                           msg_35_frame,
+                           "T_msg_cs_request        msg_35;",
+                           interpret_data);
+    }
+}
+
+M_TEST_FCT(test_interpret_msg_all)
+{
+    test_interpret_msg();
+}
+
+//*****************************************************************************
+// test_library
+//*****************************************************************************
+
+#ifdef BYTE_INTERPRET_USE_LIBRARY_DYNCALL
+M_TEST_FCT(test_library)
+#else
+M_TEST_FCT_IGNORE(test_library)
+#endif
+{
+    T_type_definitions    type_definitions;
+    build_types ("unitary_tests_library.fdesc",
+                 type_definitions);
+
+    T_interpret_data      interpret_data;
+
+    // ascii_strdown_inplace & ascii_strup_inplace
+    M_TEST_SIMPLE("", "var string  original = \"Hello WORLD !\";",          "original = Hello WORLD !" K_eol);
+    M_TEST_SIMPLE("", "var string  before = original;",                       "before = Hello WORLD !" K_eol);
+    M_TEST_SIMPLE("", "var string  ret    = ascii_strdown_inplace (before);",    "ret = hello world !" K_eol);
+    M_TEST_SIMPLE("", "var string  after  = before;",                          "after = hello world !" K_eol);
+    M_TEST_SIMPLE("", "var string  ret    = ascii_strup_inplace (before);",      "ret = HELLO WORLD !" K_eol);
+    M_TEST_SIMPLE("", "var string  after  = before;",                          "after = HELLO WORLD !" K_eol);
+    M_TEST_SIMPLE("", "var string  notmodified = original;",             "notmodified = Hello WORLD !" K_eol);
+
+
+    // crc
+    build_types ("unitary_tests_library_part2.fdesc",
+                 type_definitions);
+
+    // crc32c_calculate_byte
+#define DATA  "6c 00 0b 00 00 00 00 00 00 00 00 00"
+
+#define M_TEST_CRC32(POS,OFFSET,SEED,RESULT)  \
+    M_TEST_SIMPLE(DATA,  \
+        "var uint32  crc32 = crc32c_calculate_byte (" #POS "," #OFFSET "," #SEED "); move_position_bytes 12;",  \
+        "crc32 = " #RESULT)
+
+    M_TEST_CRC32( 0, 0,   0,            0);
+    M_TEST_CRC32( 2, 0, 136,          136);
+    M_TEST_CRC32( 0, 4,   0,   1483871832);
+    M_TEST_CRC32( 4, 4,   0,            0);
+    M_TEST_CRC32( 0, 4, 136,   4010883408);
+    M_TEST_CRC32( 4, 4, 136,   3076730632);
+    M_TEST_CRC32( 8, 4,   0,            0);
+//	M_TEST_CRC32( 9, 4,   0,            0);    // out of bounds
+//	M_TEST_CRC32(12, 4,   0,            0);    // out of bounds
+
+
+    // base64
+    build_types ("unitary_tests_library_part3.fdesc",
+                 type_definitions);
+
+#define M_TEST_BASE64(INPUT,RESULT)  \
+    M_TEST_SIMPLE("",  \
+        "hide var string  input_output = " #INPUT "; "  \
+        "hide var int64   size = ws_base64_decode_inplace (input_output); "  \
+        "print (\"%s\", input_output); ",  \
+        RESULT)
+
+    // Only test with output = string, but output can be anything
+    M_TEST_BASE64("V3NnZA==", "Wsgd" K_eol);
+    M_TEST_BASE64("SSBoYXZlIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5n", "I have a base64 encoded string" K_eol);
+    M_TEST_BASE64("T3V0a2FzdCAvIEhleSBZYQ==", "Outkast / Hey Ya" K_eol);
+}
+
+//*****************************************************************************
+// main
+//*****************************************************************************
+
+int   main(const int           argc,
+           const char * const  argv[])
+{
+    // Traces
+    string      trace_file_name = string(argv[0]) + ".traces.txt";
+    ofstream    ofs(trace_file_name.c_str());
+    set_state_ostream(ofs);
+
+    int   arg_idx = 1;
+
+    if ((arg_idx < argc) && (strcmp(argv[arg_idx], "-debug") == 0))
+    {
+        set_debug(E_debug_status_ON);
+        ++arg_idx;
+    }
+
+    if ((arg_idx < argc) && (strcmp(argv[arg_idx], "-uint8_array") == 0))
+    {
+        test_interpret_simple_uint8_array(1);
+    }
+    else if ((arg_idx < argc) && (strcmp(argv[arg_idx], "-uint8_array_10") == 0))
+    {
+        test_interpret_simple_uint8_array(10);
+    }
+    else if ((arg_idx < argc) && (strcmp(argv[arg_idx], "-msg_2") == 0))
+    {
+        test_interpret_msg(2);
+    }
+    else
+    {
+        T_static_executor_manager::getInstance().execute(argc, argv, arg_idx);
+    }
+
+    C_perf_chrono::end();
+    M_TEST_RETURN_OF_MAIN();
+}
diff --git a/plugins/epan/generic/unitary_tests_functions.cpp b/plugins/epan/generic/unitary_tests_functions.cpp
new file mode 100644
index 00000000000..fb7cb502c6d
--- /dev/null
+++ b/plugins/epan/generic/unitary_tests_functions.cpp
@@ -0,0 +1,312 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+#include "T_expression.h"
+
+
+//*****************************************************************************
+// 
+//*****************************************************************************
+T_type_definitions  * SP_type_definitions = nullptr;
+T_interpret_data    * SP_interpret_data = nullptr;
+
+long long  compute_expression_static_int(
+                const string              & expression_str)
+{
+    T_expression    expression;
+    expression.build_expression(*SP_type_definitions, expression_str);
+
+    C_value    value = expression.compute_expression_static(*SP_type_definitions);
+
+    return  value.get_int();
+}
+long long  compute_expression_no_io_int(
+                const string              & expression_str)
+{
+    T_expression    expression;
+    expression.build_expression(*SP_type_definitions, expression_str);
+
+    C_value    value = expression.compute_expression_no_io(*SP_type_definitions, *SP_interpret_data);
+
+    return  value.get_int();
+}
+
+double  compute_expression_static_flt(
+                const string              & expression_str)
+{
+    T_expression    expression;
+    expression.build_expression(*SP_type_definitions, expression_str);
+
+    C_value    value = expression.compute_expression_static(*SP_type_definitions);
+
+    return  value.get_flt();
+}
+double  compute_expression_no_io_flt(
+                const string              & expression_str)
+{
+    T_expression    expression;
+    expression.build_expression(*SP_type_definitions, expression_str);
+
+    C_value    value = expression.compute_expression_no_io(*SP_type_definitions, *SP_interpret_data);
+
+    return  value.get_flt();
+}
+
+string  compute_expression_static_str(
+                const string              & expression_str)
+{
+    T_expression    expression;
+    expression.build_expression(*SP_type_definitions, expression_str);
+
+    C_value    value = expression.compute_expression_static(*SP_type_definitions);
+
+    return  value.get_str();
+}
+string  compute_expression_no_io_str(
+                const string              & expression_str)
+{
+    T_expression    expression;
+    expression.build_expression(*SP_type_definitions, expression_str);
+
+    C_value    value = expression.compute_expression_no_io(*SP_type_definitions, *SP_interpret_data);
+
+    return  value.get_str();
+}
+
+//*****************************************************************************
+// test_function_call
+//*****************************************************************************
+
+M_TEST_FCT(test_function_call)
+{
+    T_type_definitions    type_definitions;
+    build_types ("unitary_tests_basic.fdesc",
+                 type_definitions);
+    SP_type_definitions = &type_definitions;
+
+    T_interpret_data      interpret_data;
+    SP_interpret_data = &interpret_data;
+
+    M_TEST_EQ(compute_expression_static_int("call_me_maybe_u8 (255)"), 254);
+    M_TEST_EQ(compute_expression_static_int("call_me_maybe_u16(65535)"), 65534);
+    M_TEST_EQ(compute_expression_static_int("call_me_maybe_u24(16777215)"), 16777214);
+    M_TEST_EQ(compute_expression_static_int("call_me_maybe_u32(4294967295)"), 4294967294);
+    M_TEST_EQ(compute_expression_static_int("call_me_maybe_u40(1099511627775)"), 1099511627774);
+    M_TEST_EQ(compute_expression_static_int("call_me_maybe_u48(281474976710655)"), 281474976710654);
+
+    M_TEST_EQ(compute_expression_static_int("call_me_maybe_s8 (-127)"), -126);
+    M_TEST_EQ(compute_expression_static_int("call_me_maybe_s16(-32767)"), -32766);
+    M_TEST_EQ(compute_expression_static_int("call_me_maybe_s24(-8388607)"), -8388606);
+    M_TEST_EQ(compute_expression_static_int("call_me_maybe_s32(-2122317823)"), -2122317822);
+    M_TEST_EQ(compute_expression_static_int("call_me_maybe_s40(-543313362943)"), -543313362942);
+    M_TEST_EQ(compute_expression_static_int("call_me_maybe_s48(-139088220913663)"), -139088220913662);
+    M_TEST_EQ(compute_expression_static_int("call_me_maybe_s64(-35606584553897983)"), -35606584553897982);
+
+    // 1234 gives u8 overflow
+    M_TEST_CATCH_EXCEPTION(compute_expression_static_int("call_me_maybe_u8 (1234)"), C_byte_interpret_exception);
+
+    // Currently, parameter must be an entire byte size
+    M_TEST_EXCEPTION_ALREADY_KNOWN(compute_expression_static_int("call_me_maybe_u30(1234)"));
+    M_TEST_EXCEPTION_ALREADY_KNOWN(compute_expression_static_int("call_me_maybe_u20(1234)"));
+    M_TEST_EXCEPTION_ALREADY_KNOWN(compute_expression_static_int("call_me_maybe_u10( 934)"));
+    M_TEST_EXCEPTION_ALREADY_KNOWN(compute_expression_static_int("call_me_maybe_u2 (   3)"));
+    M_TEST_EXCEPTION_ALREADY_KNOWN(compute_expression_static_int("call_me_maybe_u1 (   1)"));
+}
+
+//*****************************************************************************
+// test_function_in_out
+//*****************************************************************************
+
+M_TEST_FCT(test_function_in_out)
+{
+    T_type_definitions    type_definitions;
+    build_types("unitary_tests_basic.fdesc",
+                type_definitions);
+    SP_type_definitions = &type_definitions;
+
+    T_interpret_data      interpret_data;
+    SP_interpret_data = &interpret_data;
+    interpret_data.add_read_variable("is_value_modified", 1);
+    interpret_data.add_read_variable("sum", -7);
+
+    M_TEST_EQ(compute_expression_no_io_int("test_out_normalize (5, is_value_modified)"), 5);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_value_modified")->get_bool(), false);
+
+    M_TEST_EQ(compute_expression_no_io_int("test_out_normalize (15, is_value_modified)"), 10);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_value_modified")->get_bool(), true);
+
+    M_TEST_EQ(compute_expression_no_io_int("test_out_normalize (-15, is_value_modified)"), -15);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_value_modified")->get_bool(), false);
+
+
+    M_TEST_EQ(compute_expression_no_io_int("test_in_out_normalize_accumulate (5, is_value_modified, sum)"), 5);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_value_modified")->get_bool(), false);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("sum")->get_int(), -2);
+
+    M_TEST_EQ(compute_expression_no_io_int("test_in_out_normalize_accumulate (15, is_value_modified, sum)"), 10);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_value_modified")->get_bool(), true);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("sum")->get_int(), 13);
+
+    M_TEST_EQ(compute_expression_no_io_int("test_in_out_normalize_accumulate (-15, is_value_modified, sum)"), -15);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("is_value_modified")->get_bool(), false);
+    M_TEST_EQ(interpret_data.get_P_value_of_read_variable("sum")->get_int(), -2);
+}
+
+//*****************************************************************************
+// test_builtin_functions
+//*****************************************************************************
+
+M_TEST_FCT(test_builtin_functions)
+{
+    T_type_definitions    type_definitions;
+    build_types ("unitary_tests_basic.fdesc",
+                 type_definitions);
+    SP_type_definitions = &type_definitions;
+
+    T_interpret_data      interpret_data;
+    SP_interpret_data = &interpret_data;
+    interpret_data.add_read_variable("int", 0);
+    interpret_data.add_read_variable("flt", 0.0);
+    interpret_data.add_read_variable("str", "");
+
+    // to_string
+    M_TEST_EQ(compute_expression_static_str("to_string(1234)"), "1234");
+    M_TEST_EQ(compute_expression_static_str("to_string (1234) + \"5\""), "12345");
+    M_TEST_EQ(compute_expression_static_str("to_string (12.34)"), "12.34");
+    interpret_data.set_read_variable("int", -136);
+    interpret_data.set_read_variable("flt", -136.2);
+    M_TEST_EQ(compute_expression_no_io_str("to_string (int+5) + \"5\""), "-1315");
+    M_TEST_EQ(compute_expression_no_io_str("to_string(flt+5)"), "-131.2");
+  
+    // to_numeric
+    M_TEST_EQ(compute_expression_static_int("to_numeric (\"12\" + \"34\")"), 1234);
+    M_TEST_EQ(compute_expression_static_int("to_numeric (\"12\" + \"3\") * 3"), 369);
+    interpret_data.set_read_variable("str", "123");
+    M_TEST_EQ(compute_expression_no_io_int("to_numeric (str + \"3\")"), 1233);
+
+    M_TEST_EQ(compute_expression_static_flt("to_numeric (\"1.2\" + \"34\")"), 1.234);
+    M_TEST_EQ(compute_expression_static_flt("to_numeric (\"1.2\" + \"3\") / 2"), 0.615);
+    interpret_data.set_read_variable("str", "123");
+    M_TEST_EQ(compute_expression_no_io_flt("to_numeric (str + \".2\" + \"3\")"), 123.23);
+
+    // to_integer
+    M_TEST_EQ(compute_expression_static_int("to_integer (\"12\" + \"34\")"), 1234);
+    M_TEST_EQ(compute_expression_static_int("to_integer (\"12\" + \"3\") * 3"), 369);
+    interpret_data.set_read_variable("str", "123");
+    M_TEST_EQ(compute_expression_no_io_int("to_integer (str + \"3\")"), 1233);
+    // to_integer from float (can loose data) inside string or not
+    M_TEST_EQ(compute_expression_static_int("to_integer (\"1.2\" + \"34\")"), 1);   //crash
+    M_TEST_EQ(compute_expression_static_int("to_integer (1.2 + 34)"), 35);
+
+    // to_float
+    M_TEST_EQ(compute_expression_static_flt("to_float (\"1.2\" + \"34\")"), 1.234);
+    M_TEST_EQ(compute_expression_static_flt("to_float (\"1.2\" + \"3\") / 2"), 0.615);
+    interpret_data.set_read_variable("str", "123");
+    M_TEST_EQ(compute_expression_no_io_flt("to_float (str + \".2\" + \"3\")"), 123.23);
+    // to_float from int (can loose precision) inside string or not
+    M_TEST_EQ(compute_expression_static_flt("to_float (\"12\" + \"34\")"), 1234.0);
+    M_TEST_EQ(compute_expression_static_flt("to_float (12 + 34)"), 46.0);
+
+    // getenv
+    compute_expression_static_str("getenv (\"USERNAME\")");
+
+    // string.length
+    M_TEST_EQ(compute_expression_static_int("string.length (\"1234\")"), 4);
+    M_TEST_EQ(compute_expression_static_int("string.length (\"abcde\")"), 5);
+    interpret_data.set_read_variable("str", "123");
+    M_TEST_EQ(compute_expression_no_io_int("string.length (str)"), 3);
+
+    // string.substr
+    M_TEST_EQ(compute_expression_static_str("string.substr (\"12345678\", 2)"), "345678");
+    M_TEST_EQ(compute_expression_static_str("string.substr (\"abcdefgh\", 1, 3)"), "bcd");
+    interpret_data.set_read_variable("str", "abcdefgh");
+    interpret_data.set_read_variable("int", 1);
+    M_TEST_EQ(compute_expression_no_io_str("string.substr (str, int, 3)"), "bcd");
+
+    // string.erase
+    M_TEST_EQ(compute_expression_static_str("string.erase (\"12345678\", 2)"), "12");
+    M_TEST_EQ(compute_expression_static_str("string.erase (\"abcdefgh\", 1, 3)"), "aefgh");
+    interpret_data.set_read_variable("str", "abcdefgh");
+    interpret_data.set_read_variable("int", 1);
+    M_TEST_EQ(compute_expression_no_io_str("string.erase (str, int, 3)"), "aefgh");
+
+    // string.insert
+    M_TEST_EQ(compute_expression_static_str("string.insert (\"12345678\", 2, \"yo\")"), "12yo345678");
+    interpret_data.set_read_variable("str", "yo");
+    interpret_data.set_read_variable("int", 2);
+    M_TEST_EQ(compute_expression_no_io_str("string.insert (\"12345678\", int, str)"), "12yo345678");
+
+    // string.replace
+    M_TEST_EQ(compute_expression_static_str("string.replace (\"abcdefgh\", 1, 3, \"123\")"), "a123efgh");
+    interpret_data.set_read_variable("str", "123");
+    M_TEST_EQ(compute_expression_no_io_str("string.replace (\"abcdefgh\", 1, 3, str)"), "a123efgh");
+
+    // string.replace_all
+    M_TEST_EQ(compute_expression_static_str("string.replace_all (\"abcdefgh - abcdefgh\", \"bc\", \"xyz\")"), "axyzdefgh - axyzdefgh");
+    interpret_data.set_read_variable("str", "abcdefgh - abcdefgh");
+    M_TEST_EQ(compute_expression_no_io_str("string.replace_all (str, \" \", \"\")"), "abcdefgh-abcdefgh");
+
+    // string.find
+    M_TEST_EQ(compute_expression_static_int("string.find (\"12345678\", \"2\")"), 1);
+    M_TEST_EQ(compute_expression_static_int("string.find (\"abcdefgh\", \"ef\")"), 4);
+    M_TEST_EQ(compute_expression_static_int("string_find (\"abcdefgh\", \"ef\")"), 4);
+    M_TEST_EQ(compute_expression_static_int("string_found(\"abcdefgh\", \"ef\")"), true);
+    M_TEST_EQ(compute_expression_static_int("string.find (\"abcdefgh\", \"fe\")"), compute_expression_static_int("string::npos"));
+    M_TEST_EQ(compute_expression_static_int("string_find (\"abcdefgh\", \"fe\")"), compute_expression_static_int("string::npos"));
+    M_TEST_EQ(compute_expression_static_int("string_found(\"abcdefgh\", \"fe\")"), false);
+    interpret_data.set_read_variable("str", "abcdefgh");
+    M_TEST_EQ(compute_expression_no_io_int("string.find (str, \"ef\")"), 4);
+
+
+    // date.get_string_from_days
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012,   0)"), "2012/01/01");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012,   1)"), "2012/01/02");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012,  31)"), "2012/02/01");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012,  59)"), "2012/02/29");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012,  60)"), "2012/03/01");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012,  91)"), "2012/04/01");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012, 121)"), "2012/05/01");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012, 152)"), "2012/06/01");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012, 182)"), "2012/07/01");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012, 213)"), "2012/08/01");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012, 244)"), "2012/09/01");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012, 274)"), "2012/10/01");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012, 305)"), "2012/11/01");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012, 335)"), "2012/12/01");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_days (2012, 366)"), "2013/01/01");
+
+    // date.get_string_from_seconds
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_seconds (1970, 0)"), "1970/01/01 00:00:00");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_seconds (1970, 4133980800)"), "2101/01/01 00:00:00");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_seconds (1970, 4134067199)"), "2101/01/01 23:59:59");
+    M_TEST_EQ(compute_expression_static_str("date.get_string_from_seconds (1970, 13601174399)"), "2401/01/01 23:59:59");
+}
diff --git a/plugins/epan/generic/unitary_tests_misc.cpp b/plugins/epan/generic/unitary_tests_misc.cpp
new file mode 100644
index 00000000000..3811a122065
--- /dev/null
+++ b/plugins/epan/generic/unitary_tests_misc.cpp
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+
+#include "C_value.h"
+#include "T_attribute_value.h"
+#include "T_interpret_value.h"
+
+
+
+//*****************************************************************************
+// test_bitfield_C
+// Not a test, I just want to verify the position of the bits.
+// a) From less significant bit to most significant bit
+// b) take care of byte order
+// Note that there is NO standard about this.
+//*****************************************************************************
+
+M_TEST_FCT(test_bitfield_C)
+{
+    struct {
+          unsigned field1  :4;
+          unsigned field2  :3;
+          unsigned field3  :1;
+          unsigned field4  :6;
+          unsigned field5  :2;
+          unsigned field6  :8;
+          unsigned field7  :8;
+    } full_of_fields;
+
+    memset(&full_of_fields, 0, sizeof(full_of_fields));
+    cout << "bitf = " << hex << *(unsigned *)&full_of_fields << endl;
+
+    full_of_fields.field1 = 3;
+    cout << "bitf = " << hex << *(unsigned *)&full_of_fields << endl;
+
+    full_of_fields.field2 = 4;
+    cout << "bitf = " << hex << *(unsigned *)&full_of_fields << endl;
+
+    full_of_fields.field3 = 1;
+    cout << "bitf = " << hex << *(unsigned *)&full_of_fields << endl;
+
+    full_of_fields.field4 = 3;
+    cout << "bitf = " << hex << *(unsigned *)&full_of_fields << endl;
+
+    full_of_fields.field5 = 3;
+    cout << "bitf = " << hex << *(unsigned *)&full_of_fields << endl;
+
+    full_of_fields.field6 = 85;
+    cout << "bitf = " << hex << *(unsigned *)&full_of_fields << endl;
+
+    full_of_fields.field7 = 255;
+    cout << "bitf = " << hex << *(unsigned *)&full_of_fields << endl;
+
+    cout << dec;
+}
+
+//*****************************************************************************
+// test_size
+// Not a test.
+//*****************************************************************************
+C_value  string_count_cpp_to_fdesc(const string::size_type  cpp_count);
+
+M_TEST_FCT(test_size)
+{
+#define M_OUT_SIZEOF(PARAM)    \
+    cout << "sizeof(" << #PARAM << ") = " << sizeof(PARAM) << endl
+
+    M_OUT_SIZEOF(void*);
+    M_OUT_SIZEOF(int);
+    M_OUT_SIZEOF(long);
+    M_OUT_SIZEOF(long long);
+    M_OUT_SIZEOF(double);
+    M_OUT_SIZEOF(size_t);
+    M_OUT_SIZEOF(string::size_type);
+    M_OUT_SIZEOF(string);
+    M_OUT_SIZEOF(C_value);
+    M_OUT_SIZEOF(T_attribute_value);
+    M_OUT_SIZEOF(T_interpret_value);
+
+#define M_OUT_VAL(PARAM)    \
+    cout << "value(" << #PARAM << ") = " << PARAM << endl
+
+    M_OUT_VAL(string::npos);
+    M_OUT_VAL(string_count_cpp_to_fdesc(string::npos));
+}
+
+//*****************************************************************************
+// test_cast
+// Not a test.
+//*****************************************************************************
+
+M_TEST_FCT_IGNORE(test_cast)
+{
+#define M_OUT_VAL(PARAM)    \
+    cout << "value(" << #PARAM << ") = " << PARAM << endl
+
+    unsigned short  valu  = 40000;
+    short           vals  = (int)valu;
+    unsigned short  valu2 = (unsigned int)vals;
+
+    M_OUT_VAL(valu);
+    M_OUT_VAL(vals);
+    M_OUT_VAL(valu2);
+}
diff --git a/plugins/epan/generic/unitary_tests_tools.cpp b/plugins/epan/generic/unitary_tests_tools.cpp
new file mode 100644
index 00000000000..3f6ebbacaf4
--- /dev/null
+++ b/plugins/epan/generic/unitary_tests_tools.cpp
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <string>
+using namespace std;
+
+int   G_TEST_nb_tests = 0;
+int   G_TEST_nb_errors = 0;
+int   G_TEST_nb_errors_already_known = 0;
+
+bool         G_TEST_is_an_error_already_known = false;
+std::string  G_TEST_error_already_known_explain;
diff --git a/plugins/epan/generic/unitary_tests_tools.h b/plugins/epan/generic/unitary_tests_tools.h
new file mode 100644
index 00000000000..f064f3e2993
--- /dev/null
+++ b/plugins/epan/generic/unitary_tests_tools.h
@@ -0,0 +1,301 @@
+/*
+ * Copyright 2005-2019 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef UNITARY_TEST_TOOLS_H
+#define UNITARY_TEST_TOOLS_H
+
+//*****************************************************************************
+// Includes
+//*****************************************************************************
+
+#include <cassert>
+#include <iostream>
+#include <sstream>
+using namespace std;
+
+#include "byte_interpret_common_utils.h"
+#include "T_static_executor.h"
+#include "T_static_executor_manager.h"
+
+#define wait_for_any_operator_input_if_necessary()
+
+
+//*****************************************************************************
+// Counter of tests done.
+// Counter of errors detected.
+// Counter of errors detected already known (minor errors).
+//*****************************************************************************
+
+extern int   G_TEST_nb_tests;
+extern int   G_TEST_nb_errors;
+extern int   G_TEST_nb_errors_already_known;
+
+
+//*****************************************************************************
+// Declare a function containing test
+// The function will be called automatically
+//*****************************************************************************
+#define M_TEST_FCT(fct_name)                                                  \
+extern void fct_name();                                                       \
+M_static_executor(fct_name);                                                  \
+void fct_name()
+
+
+// The function will NOT be called automatically
+#define M_TEST_FCT_IGNORE(fct_name)                                           \
+void fct_name()
+
+
+//*****************************************************************************
+// Test macro.
+// - increment "Counter of tests done"
+// - verify assertion, if wrong :
+//   - output ERROR trace
+//   - increment "Counter of errors detected"
+//*****************************************************************************
+
+#define M_TEST(ASSERTION)                                                     \
+    ++G_TEST_nb_tests;                                                        \
+    if ((ASSERTION) != true)                                                  \
+    {                                                                         \
+        ++G_TEST_nb_errors;                                                   \
+        cout << "ERROR in test " << #ASSERTION << endl                        \
+             << " at " << __FILE__ << "[" << __LINE__ << "]"                  \
+             << " test# " << G_TEST_nb_tests                                  \
+             << endl;                                                         \
+    }
+
+//*****************************************************************************
+// Test macro which compare 2 values.
+//*****************************************************************************
+
+#define M_TEST_EQ(VAL1,VAL2)    M_TEST_fail_compare(VAL1, !=, VAL2)
+#define M_TEST_NE(VAL1,VAL2)    M_TEST_fail_compare(VAL1, ==, VAL2)
+#define M_TEST_GE(VAL1,VAL2)    M_TEST_fail_compare(VAL1, < , VAL2)
+#define M_TEST_GT(VAL1,VAL2)    M_TEST_fail_compare(VAL1, <=, VAL2)
+#define M_TEST_LE(VAL1,VAL2)    M_TEST_fail_compare(VAL1, > , VAL2)
+#define M_TEST_LT(VAL1,VAL2)    M_TEST_fail_compare(VAL1, >=, VAL2)
+
+#define M_TEST_TRIM_EQ(VAL1,VAL2)                                             \
+    ++G_TEST_nb_tests;                                                        \
+    if (VAL1 != VAL2)                                                         \
+        if (get_trim(VAL1) != get_trim(VAL2))                                 \
+            M_TEST_failure(VAL1, !=, VAL2)
+
+//*****************************************************************************
+// Test macro for pointer
+//*****************************************************************************
+std::ostream& operator << (std::ostream & os, std::nullptr_t);
+
+#define M_TEST_NULL(PTR)        M_TEST_EQ(PTR, nullptr)
+#define M_TEST_NOT_NULL(PTR)    M_TEST_NE(PTR, nullptr)
+
+//*****************************************************************************
+// Test macro.
+// - increment "Counter of tests done"
+// - assert assertion
+//*****************************************************************************
+
+#define M_TEST_assert(ASSERTION)                                              \
+    ++G_TEST_nb_tests;                                                        \
+    assert (ASSERTION)
+
+//*****************************************************************************
+// Test macro.
+// - verify that the specified exception is throwed
+//*****************************************************************************
+
+#define M_TEST_CATCH_EXCEPTION(instruction_that_calls_function,exception)     \
+{                                                                             \
+  bool  is_exception_catched = false;                                         \
+                                                                              \
+  try                                                                         \
+  {                                                                           \
+    instruction_that_calls_function;                                          \
+  }                                                                           \
+  catch (exception&)                                                          \
+  {                                                                           \
+    is_exception_catched = true;                                              \
+  }                                                                           \
+                                                                              \
+  M_TEST_EQ (is_exception_catched, true);                                     \
+}
+
+
+//*****************************************************************************
+// Synthesis macro
+// - output end of main
+// - output synthesis information
+// - return the "Counter of errors detected"
+//*****************************************************************************
+
+#define M_TEST_RETURN_OF_MAIN()                                               \
+    cout << "End of main" << endl;                                            \
+                                                                              \
+    string  TEST_new_label = "";                                              \
+    if (G_TEST_nb_errors_already_known != 0)                                  \
+    {                                                                         \
+        TEST_new_label = " new";                                              \
+        cout << "         " << G_TEST_nb_errors_already_known                 \
+             << " already known errors." << endl;                             \
+    }                                                                         \
+    if (G_TEST_nb_errors == 0)                                                \
+        cout << "    OK : no" << TEST_new_label << " error";                  \
+    else                                                                      \
+        cout << "NOT OK : " << G_TEST_nb_errors << TEST_new_label << " errors";  \
+    cout << " found during " << G_TEST_nb_tests << " tests." << endl;         \
+                                                                              \
+    wait_for_any_operator_input_if_necessary ();                              \
+                                                                              \
+    return  G_TEST_nb_errors
+
+
+//*****************************************************************************
+//*****************************************************************************
+//! IMPLEMENTATION --- Do not read --- IMPLEMENTATION --- Do not read ---
+//! IMPLEMENTATION --- Do not read --- IMPLEMENTATION --- Do not read ---
+//! IMPLEMENTATION --- Do not read --- IMPLEMENTATION --- Do not read ---
+//*****************************************************************************
+//*****************************************************************************
+
+//! The specified comparison must fail for the test be valid.
+#define M_TEST_fail_compare(VAL1,FAIL_COMPARE,VAL2)                           \
+    ++G_TEST_nb_tests;                                                        \
+    if (VAL1 FAIL_COMPARE VAL2)                                               \
+    M_TEST_failure(VAL1,FAIL_COMPARE,VAL2)
+
+//! For float/double comparison.
+//! Could NOT work for little values (like zero).
+#define M_TEST_EQ_APPROX(VAL1,VAL2)                                           \
+    ++G_TEST_nb_tests;                                                        \
+    if (fabs(VAL1 - VAL2) > fabs(VAL1 / 100000.0))                            \
+    M_TEST_failure(VAL1,"NOT approx =",VAL2)
+
+
+
+//*****************************************************************************
+// error_already_known flag 
+//*****************************************************************************
+
+extern bool         G_TEST_is_an_error_already_known;
+extern std::string  G_TEST_error_already_known_explain;
+class C_TEST_error_already_known
+{
+public:
+    C_TEST_error_already_known(long  bug_id, const std::string  & comment)
+        :A_save_G_TEST_nb_errors_already_known(G_TEST_nb_errors_already_known)
+    {
+        G_TEST_is_an_error_already_known = true;
+        G_TEST_error_already_known_explain = "";
+
+        {
+            std::ostringstream  oss;
+            if (bug_id > 0)
+            {
+                oss << "bug=" << bug_id << "  ";
+            }
+            oss << comment;
+            G_TEST_error_already_known_explain += oss.str();
+        }
+    }
+
+    ~C_TEST_error_already_known()
+    {
+        G_TEST_is_an_error_already_known = false;
+        G_TEST_error_already_known_explain = "";
+        if (G_TEST_nb_errors_already_known <= A_save_G_TEST_nb_errors_already_known)
+        {
+            ++G_TEST_nb_errors;
+            cout << "NO MORE ERROR in test" << endl;
+        }
+    }
+
+private:
+    int          A_save_G_TEST_nb_errors_already_known;
+};
+
+#define M_TEST_ERROR_ALREADY_KNOWN__OPEN(BUGID,COMMENT)                       \
+{ C_TEST_error_already_known  TEST_error_already_known(BUGID,COMMENT);
+
+#define M_TEST_EXCEPTION_ALREADY_KNOWN(instruction_that_calls_function)       \
+{                                                                             \
+  bool  is_exception_catched = false;                                         \
+                                                                              \
+  try                                                                         \
+  {                                                                           \
+    instruction_that_calls_function;                                          \
+  }                                                                           \
+  catch (...)                                                                 \
+  {                                                                           \
+    is_exception_catched = true;                                              \
+    ++G_TEST_nb_errors_already_known;                                         \
+    cout << "EXCEPTION (already known: "                                      \
+         << G_TEST_error_already_known_explain << ") "                        \
+         << " at " << __FILE__ << "[" << __LINE__ << "]"                      \
+         << " test# " << G_TEST_nb_tests                                      \
+         << endl;                                                             \
+  }                                                                           \
+                                                                              \
+  M_TEST_EQ (is_exception_catched, true);                                     \
+}
+
+//*****************************************************************************
+// Error management
+//*****************************************************************************
+
+//! The specified fail comparison is valid, so the test is not valid.
+#define M_TEST_failure(VAL1,FAIL_COMPARE,VAL2)                                \
+    {                                                                         \
+        string  TEST_already_known_label = "";                                \
+        if (G_TEST_is_an_error_already_known == true)                         \
+        {                                                                     \
+            ++G_TEST_nb_errors_already_known;                                 \
+            TEST_already_known_label = "(already known: ";                    \
+            TEST_already_known_label += G_TEST_error_already_known_explain;   \
+            TEST_already_known_label += ") ";                                 \
+        }                                                                     \
+        else                                                                  \
+            ++G_TEST_nb_errors;                                               \
+        cout << "ERROR " << TEST_already_known_label << "in test "            \
+             << #VAL1 " (" << VAL1 << ") "                                    \
+             << #FAIL_COMPARE " "                                             \
+             << #VAL2 " (" << VAL2 << ") " << endl                            \
+             << " at " << __FILE__ << "[" << __LINE__ << "]"                  \
+             << " test# " << G_TEST_nb_tests                                  \
+             << endl;                                                         \
+    }
+
+#if 0
+ following test could NOT be added,
+  because it could have many tests and only 1 (or few) fails.
+
+    else if (G_TEST_is_an_error_already_known == true)                        \
+    {                                                                         \
+        ++G_TEST_nb_errors;                                                   \
+        cout << "NO MORE ERROR in test "                                      \
+             << #VAL1 " (" << VAL1 << ") "                                    \
+             << #FAIL_COMPARE " "                                             \
+             << #VAL2 " (" << VAL2 << ") " << endl                            \
+             << " at " << __FILE__ << "[" << __LINE__ << "]"                  \
+             << " test# " << G_TEST_nb_tests                                  \
+             << endl;                                                         \
+    }
+#endif
+
+
+#endif
diff --git a/plugins/epan/generic/unitary_tests_ut_interpret_bytes.cpp b/plugins/epan/generic/unitary_tests_ut_interpret_bytes.cpp
new file mode 100644
index 00000000000..dfae485e137
--- /dev/null
+++ b/plugins/epan/generic/unitary_tests_ut_interpret_bytes.cpp
@@ -0,0 +1,225 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+//*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "unitary_tests_tools.h"
+#include "C_perf_chrono.h"
+
+#include "T_type_definitions.h"
+#include "T_interpret_data.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+#include "byte_interpret_build_types.h"
+#include "unitary_tests_ut_interpret_bytes.h"
+
+
+//*****************************************************************************
+// ut_interpret_bytes_init ****************************************************
+//*****************************************************************************
+
+void ut_interpret_bytes_init(T_type_definitions& type_definitions)
+{
+    if (type_definitions.is_a_function("decode_stream_nothing"))
+    {
+        return;
+    }
+
+    istringstream iss(
+        "    function void  decode_stream_nothing (in frame  frame, in uint32   nb_of_bits_needed)"
+        "    {"
+        "        while (nb_of_bits_needed > 0)"
+        "        {"
+        "            hide uint1  bit1;"
+        "            call frame_append_data (frame, bit1);"
+        "            set nb_of_bits_needed = nb_of_bits_needed - 1;"
+        "        }"
+        "    }");
+
+    build_types(iss, type_definitions);
+}
+
+//*****************************************************************************
+// ut_interpret_bytes_base ****************************************************
+//*****************************************************************************
+
+bool    ut_interpret_bytes_base (const T_type_definitions  & type_definitions,
+                                 const T_byte_vector       & in_byte_vector,
+                                 const string              & in_input_string,
+                                       ostream             & os_out,
+                                       ostream             & os_err,
+                                       T_interpret_data    & interpret_data)
+{
+    string    conditions;
+    if (interpret_data.get_decode_function().empty())
+    {
+        conditions += "      ";
+    }
+    else
+    {
+        conditions += "decode";
+    }
+
+    conditions += " ";
+
+    if (get_debug() == false)
+    {
+        conditions += "     ";
+    }
+    else
+    {
+        conditions += "debug";
+    }
+
+
+    const T_byte    * P_bytes = in_byte_vector.empty() ? nullptr : &in_byte_vector[0];
+    size_t            sizeof_bytes = in_byte_vector.size();
+
+    bool  result = false;
+    M_TRACE_WARNING("enter ut_interpret_bytes_base " << conditions << "  for " << in_input_string);
+    get_state_ostream() << flush;
+    {
+        C_perf_chrono  perf_chrono(interpret_data, in_input_string.c_str(), sizeof_bytes);
+        result = interpret_bytes (type_definitions,
+                                    P_bytes,
+                                    sizeof_bytes,
+                                    in_input_string,
+                                    os_out,
+                                    os_err,
+                                    interpret_data);
+    }
+    M_TRACE_WARNING("leave ut_interpret_bytes_base " << conditions << "  for " << in_input_string);
+
+    M_TEST_EQ(result, true);
+    // Check no remaining input
+    M_TEST_EQ(sizeof_bytes, 0);
+    // Even in internal_frame : this is already tested by interpret_bytes
+    // Fail because decode_stream_frame does NOT exist anymore
+//	M_TEST_EQ(interpret_data.get_decode_stream_frame().frame_data.get_remaining_bits(), 0);
+
+    return  result;
+}
+
+//*****************************************************************************
+// ut_interpret_bytes *********************************************************
+//*****************************************************************************
+
+bool  S_ut_interpret_bytes_decode_nothing = true;
+bool  S_ut_interpret_bytes_debug          = false;
+
+
+C_ut_interpret_bytes_no_decode_guard::C_ut_interpret_bytes_no_decode_guard()
+    : _S_ut_interpret_bytes_decode_nothing_saved(S_ut_interpret_bytes_decode_nothing)
+{
+    S_ut_interpret_bytes_decode_nothing = false;
+}
+C_ut_interpret_bytes_no_decode_guard::~C_ut_interpret_bytes_no_decode_guard()
+{
+    S_ut_interpret_bytes_decode_nothing = _S_ut_interpret_bytes_decode_nothing_saved;
+}
+
+void ut_interpret_bytes (const T_type_definitions  & type_definitions,
+                         const T_byte_vector       & in_byte_vector,
+                         const string              & in_input_string,
+                               T_interpret_data    & interpret_data,
+                         const char                * output_expected)
+{
+    // Save original interpret_data (because of global data).
+    T_interpret_data  interpret_data_save = interpret_data;
+
+    string    output_str_normal;
+
+    for (int  idx_decode = 0; idx_decode <= S_ut_interpret_bytes_decode_nothing; ++idx_decode)
+    for (int  idx_debug  = 0; idx_debug  <= S_ut_interpret_bytes_debug; ++idx_debug)
+    {
+        // Restore original interpret_data (because of global data).
+        interpret_data = interpret_data_save;
+
+        ostringstream   oss;
+        ostream       & os_out = oss;
+        ostream       & os_err = oss;
+
+        if (idx_decode > 0)  { interpret_data.set_decode_function("decode_stream_nothing"); }
+        C_debug_set_temporary  debug_set_temporary((idx_debug == 0) ? E_debug_status_OFF : E_debug_status_ON);
+        bool  result = ut_interpret_bytes_base (type_definitions,
+                                        in_byte_vector,
+                                        in_input_string,
+                                        os_out,
+                                        os_err,
+                                        interpret_data);
+        if (idx_decode > 0)  { interpret_data.set_decode_function(""); }
+        if (result != true)
+        {
+            return;
+        }
+
+        if (idx_decode == 0)
+        {
+            // Without decoder, save output.
+            output_str_normal = oss.str();
+
+            // Compare to expected output.
+            if (output_expected != nullptr)
+            {
+                if (output_str_normal != output_expected)
+                {
+                    string  output_expected_str = output_expected;
+                    string  put_a_breakpoint_here;
+                }
+
+                M_TEST_EQ(output_str_normal, output_expected);
+            }
+        }
+        else
+        {
+            // With decoder
+            string    output_str_decoder = oss.str();
+
+            // Check output is identic to normal output
+            M_TEST_EQ(output_str_decoder, output_str_normal);
+        }
+    }
+}
+
+//*****************************************************************************
+// ut_interpret_bytes *********************************************************
+//*****************************************************************************
+
+void ut_interpret_bytes (const T_type_definitions  & type_definitions,
+                         const char                * in_hexa_str_param,
+                         const string              & in_input_string,
+                               T_interpret_data    & interpret_data,
+                         const char                * output_expected)
+{
+    string           in_hexa_str = in_hexa_str_param;
+    mod_replace_all(in_hexa_str, " ", "");
+    mod_replace_all(in_hexa_str, "	", "");
+
+    T_byte_vector    byte_vector;
+    string_hexa_to_frame(in_hexa_str, byte_vector);
+
+    ut_interpret_bytes (type_definitions, byte_vector, in_input_string, interpret_data, output_expected);
+}
diff --git a/plugins/epan/generic/unitary_tests_ut_interpret_bytes.h b/plugins/epan/generic/unitary_tests_ut_interpret_bytes.h
new file mode 100644
index 00000000000..c348965e2a4
--- /dev/null
+++ b/plugins/epan/generic/unitary_tests_ut_interpret_bytes.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2005-2020 Olivier Aveline <wsgd@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef UNITARY_TEST_UT_INTERPRET_BYTES_H
+#define UNITARY_TEST_UT_INTERPRET_BYTES_H
+
+ //*****************************************************************************
+// Includes.
+//*****************************************************************************
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+
+using namespace std;
+
+#include "T_type_definitions.h"
+#include "T_interpret_data.h"
+#include "byte_interpret_parse.h"
+#include "byte_interpret.h"
+
+
+//*****************************************************************************
+// ut_interpret_bytes_init ****************************************************
+//*****************************************************************************
+
+void ut_interpret_bytes_init(T_type_definitions& type_definitions);
+
+//*****************************************************************************
+// C_ut_interpret_bytes_no_decode_guard ***************************************
+//*****************************************************************************
+
+class C_ut_interpret_bytes_no_decode_guard
+{
+public:
+    C_ut_interpret_bytes_no_decode_guard();
+    ~C_ut_interpret_bytes_no_decode_guard();
+private:
+    bool    _S_ut_interpret_bytes_decode_nothing_saved;
+};
+
+//*****************************************************************************
+// ut_interpret_bytes *********************************************************
+//*****************************************************************************
+
+void ut_interpret_bytes (const T_type_definitions  & type_definitions,
+                         const T_byte_vector       & in_byte_vector,
+                         const string              & in_input_string,
+                               T_interpret_data    & interpret_data,
+                         const char                * output_expected = nullptr);
+
+//*****************************************************************************
+// ut_interpret_bytes *********************************************************
+//*****************************************************************************
+
+void ut_interpret_bytes (const T_type_definitions  & type_definitions,
+                         const char                * in_hexa_str_param,
+                         const string              & in_input_string,
+                               T_interpret_data    & interpret_data,
+                         const char                * output_expected = nullptr);
+
+//*****************************************************************************
+// M_TEST_SIMPLE call ut_interpret_bytes with type_definitions & interpret_data
+//*****************************************************************************
+
+#define K_eol  "\n"
+#define M_TEST_SIMPLE(BIN_DATA,TO_READ,EXPECTED)    \
+    ut_interpret_bytes(type_definitions, BIN_DATA, TO_READ, interpret_data, EXPECTED)
+
+
+
+#endif
diff --git a/plugins/epan/h4bcm/AUTHORS b/plugins/epan/h4bcm/AUTHORS
new file mode 100644
index 00000000000..bde853919bc
--- /dev/null
+++ b/plugins/epan/h4bcm/AUTHORS
@@ -0,0 +1,3 @@
+Authors:
+Jiska Classen / Secure Mobile Networking Lab
+Michael Ossmann <mike@ossmann.com>
diff --git a/plugins/epan/h4bcm/CMakeLists.txt b/plugins/epan/h4bcm/CMakeLists.txt
new file mode 100644
index 00000000000..23bcf609672
--- /dev/null
+++ b/plugins/epan/h4bcm/CMakeLists.txt
@@ -0,0 +1,58 @@
+# CMakeLists.txt
+#
+# Wireshark - Network traffic analyzer By Gerald Combs <gerald@wireshark.org>
+# Copyright 1998 Gerald Combs
+#
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+
+include(WiresharkPlugin)
+include(UseMakePluginReg)
+
+# Plugin name and version info (major minor micro extra)
+set_module_info(h4bcm 1 1 0 0)
+
+set(DISSECTOR_SRC packet-h4bcm.c packet-btbrlmp.c)
+
+set(PLUGIN_FILES plugin.c ${DISSECTOR_SRC})
+
+set_source_files_properties(${PLUGIN_FILES} PROPERTIES COMPILE_FLAGS
+                                                       "${WERROR_COMMON_FLAGS}")
+
+include_directories(${CMAKE_CURRENT_SOURCE_DIR})
+
+register_plugin_files(plugin.c plugin ${DISSECTOR_SRC})
+
+add_wireshark_plugin_library(h4bcm epan)
+
+target_link_libraries(h4bcm epan)
+
+target_compile_options(h4bcm PRIVATE -w)
+
+install_plugin(h4bcm epan)
+
+file(
+  GLOB DISSECTOR_HEADERS
+  RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}"
+  "*.h")
+checkapi(
+  NAME
+  h4bcm
+  SWITCHES
+  -g
+  abort
+  -g
+  termoutput
+  -build
+  SOURCES
+  ${DISSECTOR_SRC}
+  ${DISSECTOR_HEADERS})
+
+#
+# Editor modelines  -  https://www.wireshark.org/tools/modelines.html
+#
+# Local variables: c-basic-offset: 8 tab-width: 8 indent-tabs-mode: t End:
+#
+# vi: set shiftwidth=8 tabstop=8 noexpandtab:
+# :indentSize=8:tabSize=8:noTabs=false:
+#
diff --git a/plugins/epan/h4bcm/COPYING b/plugins/epan/h4bcm/COPYING
new file mode 100644
index 00000000000..aa0aea5b9cb
--- /dev/null
+++ b/plugins/epan/h4bcm/COPYING
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/plugins/epan/h4bcm/README.md b/plugins/epan/h4bcm/README.md
new file mode 100644
index 00000000000..7f920bdf650
--- /dev/null
+++ b/plugins/epan/h4bcm/README.md
@@ -0,0 +1,40 @@
+Bluetooth H4 Broadcom Wireshark plugin from the InternalBlue project
+====================================================================
+
+This dissector contains vendor specific additions to the serial protocol
+H4, which is used by the operating system's driver to interact with
+Bluetooth chips. Broadcom not only supports sending standard messages
+such as HCI commands and events but also has an undocumented
+diagnostic protocol using the H4 serial data type 0x07.
+
+Subprotocols inside Broadcom's diagnostic protocol include the Link Management
+Protocol (LMP) and Bluetooth Baseband (BB). The dissectors for LMP and BB were
+updated to be compatible with Wireshark 3.0. Credit for most of the LMP and BB
+dissector goes to the original authors of libbtbb.
+
+About this repository
+---------------------
+
+This repository contains only the Wireshark dissector without the rest of
+Internalblue. All credit goes to the original authors of InternalBlue. For
+additional information see the original repository:
+
+https://github.com/seemoo-lab/internalblue
+
+Build and Install
+-----------------
+
+To build this on Debian/Ubuntu/BackTrack linux distributions:
+
+    sudo apt-get install wireshark-dev wireshark cmake
+
+    mkdir build
+    cd build
+    cmake ..
+    make
+    make install
+
+This will install to the ~/.local/lib/wireshark/plugins/3.0/epan/ in your home
+directory. To override this set the DESTDIR environment variable when running
+cmake.
+
diff --git a/plugins/epan/h4bcm/packet-btbrlmp.c b/plugins/epan/h4bcm/packet-btbrlmp.c
new file mode 100644
index 00000000000..bd809d9d2c0
--- /dev/null
+++ b/plugins/epan/h4bcm/packet-btbrlmp.c
@@ -0,0 +1,4987 @@
+/* packet-btbrlmp.c
+ * Routines for Bluetooth LMP dissection
+ * Copyright 2009, Michael Ossmann <mike@ossmann.com>
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "config.h"
+
+#include <epan/packet.h>
+#include <epan/prefs.h>
+
+/* LMP opcodes */
+#define LMP_VSC 0
+#define LMP_NAME_REQ 1
+#define LMP_NAME_RES 2
+#define LMP_ACCEPTED 3
+#define LMP_NOT_ACCEPTED 4
+#define LMP_CLKOFFSET_REQ 5
+#define LMP_CLKOFFSET_RES 6
+#define LMP_DETACH 7
+#define LMP_IN_RAND 8
+#define LMP_COMB_KEY 9
+#define LMP_UNIT_KEY 10
+#define LMP_AU_RAND 11
+#define LMP_SRES 12
+#define LMP_TEMP_RAND 13
+#define LMP_TEMP_KEY 14
+#define LMP_ENCRYPTION_MODE_REQ 15
+#define LMP_ENCRYPTION_KEY_SIZE_REQ 16
+#define LMP_START_ENCRYPTION_REQ 17
+#define LMP_STOP_ENCRYPTION_REQ 18
+#define LMP_SWITCH_REQ 19
+#define LMP_HOLD 20
+#define LMP_HOLD_REQ 21
+#define LMP_SNIFF_REQ 23
+#define LMP_UNSNIFF_REQ 24
+#define LMP_PARK_REQ 25
+#define LMP_SET_BROADCAST_SCAN_WINDOW 27
+#define LMP_MODIFY_BEACON 28
+#define LMP_UNPARK_BD_ADDR_REQ 29
+#define LMP_UNPARK_PM_ADDR_REQ 30
+#define LMP_INCR_POWER_REQ 31
+#define LMP_DECR_POWER_REQ 32
+#define LMP_MAX_POWER 33
+#define LMP_MIN_POWER 34
+#define LMP_AUTO_RATE 35
+#define LMP_PREFERRED_RATE 36
+#define LMP_VERSION_REQ 37
+#define LMP_VERSION_RES 38
+#define LMP_FEATURES_REQ 39
+#define LMP_FEATURES_RES 40
+#define LMP_QUALITY_OF_SERVICE 41
+#define LMP_QUALITY_OF_SERVICE_REQ 42
+#define LMP_SCO_LINK_REQ 43
+#define LMP_REMOVE_SCO_LINK_REQ 44
+#define LMP_MAX_SLOT 45
+#define LMP_MAX_SLOT_REQ 46
+#define LMP_TIMING_ACCURACY_REQ 47
+#define LMP_TIMING_ACCURACY_RES 48
+#define LMP_SETUP_COMPLETE 49
+#define LMP_USE_SEMI_PERMANENT_KEY 50
+#define LMP_HOST_CONNECTION_REQ 51
+#define LMP_SLOT_OFFSET 52
+#define LMP_PAGE_MODE_REQ 53
+#define LMP_PAGE_SCAN_MODE_REQ 54
+#define LMP_SUPERVISION_TIMEOUT 55
+#define LMP_TEST_ACTIVATE 56
+#define LMP_TEST_CONTROL 57
+#define LMP_ENCRYPTION_KEY_SIZE_MASK_REQ 58
+#define LMP_ENCRYPTION_KEY_SIZE_MASK_RES 59
+#define LMP_SET_AFH 60
+#define LMP_ENCAPSULATED_HEADER 61
+#define LMP_ENCAPSULATED_PAYLOAD 62
+#define LMP_SIMPLE_PAIRING_CONFIRM 63
+#define LMP_SIMPLE_PAIRING_NUMBER 64
+#define LMP_DHKEY_CHECK 65
+#define LMP_ESCAPE_1 124
+#define LMP_ESCAPE_2 125
+#define LMP_ESCAPE_3 126
+#define LMP_ESCAPE_4 127
+
+/* LMP extended opcodes */
+#define LMP_ACCEPTED_EXT 1
+#define LMP_NOT_ACCEPTED_EXT 2
+#define LMP_FEATURES_REQ_EXT 3
+#define LMP_FEATURES_RES_EXT 4
+#define LMP_PACKET_TYPE_TABLE_REQ 11
+#define LMP_ESCO_LINK_REQ 12
+#define LMP_REMOVE_ESCO_LINK_REQ 13
+#define LMP_CHANNEL_CLASSIFICATION_REQ 16
+#define LMP_CHANNEL_CLASSIFICATION 17
+#define LMP_SNIFF_SUBRATING_REQ 21
+#define LMP_SNIFF_SUBRATING_RES 22
+#define LMP_PAUSE_ENCRYPTION_REQ 23
+#define LMP_RESUME_ENCRYPTION_REQ 24
+#define LMP_IO_CAPABILITY_REQ 25
+#define LMP_IO_CAPABILITY_RES 26
+#define LMP_NUMERIC_COMPARISON_FAILED 27
+#define LMP_PASSKEY_FAILED 28
+#define LMP_OOB_FAILED 29
+#define LMP_KEYPRESS_NOTIFICATION 30
+#define LMP_POWER_CONTROL_REQ 31
+#define LMP_POWER_CONTROL_RES 32
+#define LMP_PING_REQ 33
+#define LMP_PING_RES 34
+
+/* initialize the protocol and registered fields */
+static int proto_btbrlmp = -1;
+static int hf_lmp_accscheme = -1;
+static int hf_lmp_afhchmap = -1;
+static int hf_lmp_afhclass = -1;
+static int hf_lmp_afhinst = -1;
+static int hf_lmp_afhmaxintvl = -1;
+static int hf_lmp_afhminintvl = -1;
+static int hf_lmp_afhmode = -1;
+static int hf_lmp_afhrptmode = -1;
+static int hf_lmp_airmode = -1;
+static int hf_lmp_araddr = -1;
+static int hf_lmp_authreqs = -1;
+static int hf_lmp_authres = -1;
+static int hf_lmp_bdaddr = -1;
+static int hf_lmp_bdaddr1 = -1;
+static int hf_lmp_bdaddr2 = -1;
+static int hf_lmp_bsw = -1;
+static int hf_lmp_clkoffset = -1;
+static int hf_lmp_commit = -1;
+static int hf_lmp_confirm = -1;
+static int hf_lmp_compid = -1;
+static int hf_lmp_cryptmode = -1;
+static int hf_lmp_daccess = -1;
+static int hf_lmp_db = -1;
+static int hf_lmp_dbsleep = -1;
+static int hf_lmp_deltab = -1;
+static int hf_lmp_desco = -1;
+static int hf_lmp_drift = -1;
+static int hf_lmp_dsco = -1;
+static int hf_lmp_dsniff = -1;
+static int hf_lmp_encdata = -1;
+static int hf_lmp_enclen = -1;
+static int hf_lmp_encmaj = -1;
+static int hf_lmp_encmin = -1;
+static int hf_lmp_eop = -1;
+static int hf_lmp_eopinre = -1;
+static int hf_lmp_escolenms = -1;
+static int hf_lmp_escolensm = -1;
+static int hf_lmp_escotypems = -1;
+static int hf_lmp_escotypesm = -1;
+static int hf_lmp_err = -1;
+static int hf_lmp_escohdl = -1;
+static int hf_lmp_escoltaddr = -1;
+static int hf_lmp_features = -1;
+static int hf_lmp_feat_3slot = -1;
+static int hf_lmp_feat_5slot = -1;
+static int hf_lmp_feat_enc = -1;
+static int hf_lmp_feat_slotoff = -1;
+static int hf_lmp_feat_timacc = -1;
+static int hf_lmp_feat_rolesw = -1;
+static int hf_lmp_feat_holdmo = -1;
+static int hf_lmp_feat_sniffmo = -1;
+static int hf_lmp_feat_res0 = -1;
+static int hf_lmp_feat_pwrctlreq = -1;
+static int hf_lmp_feat_cqddr = -1;
+static int hf_lmp_feat_sco = -1;
+static int hf_lmp_feat_hv2 = -1;
+static int hf_lmp_feat_hv3 = -1;
+static int hf_lmp_feat_mulaw = -1;
+static int hf_lmp_feat_alaw = -1;
+static int hf_lmp_feat_cvsd = -1;
+static int hf_lmp_feat_pagneg = -1;
+static int hf_lmp_feat_pwrctl = -1;
+static int hf_lmp_feat_transsync = -1;
+static int hf_lmp_feat_flowctl1 = -1;
+static int hf_lmp_feat_flowctl2 = -1;
+static int hf_lmp_feat_flowctl3 = -1;
+static int hf_lmp_feat_bcenc = -1;
+static int hf_lmp_feat_res1 = -1;
+static int hf_lmp_feat_acl2 = -1;
+static int hf_lmp_feat_acl3 = -1;
+static int hf_lmp_feat_eninq = -1;
+static int hf_lmp_feat_intinq = -1;
+static int hf_lmp_feat_intpag = -1;
+static int hf_lmp_feat_rssiinq = -1;
+static int hf_lmp_feat_ev3 = -1;
+static int hf_lmp_feat_ev4 = -1;
+static int hf_lmp_feat_ev5 = -1;
+static int hf_lmp_feat_res2 = -1;
+static int hf_lmp_feat_afhcapsl = -1;
+static int hf_lmp_feat_afhclasl = -1;
+static int hf_lmp_feat_bredrnotsup = -1;
+static int hf_lmp_feat_lesup = -1;
+static int hf_lmp_feat_3slotenh = -1;
+static int hf_lmp_feat_5slotenh = -1;
+static int hf_lmp_feat_sniffsubr = -1;
+static int hf_lmp_feat_pauseenc = -1;
+static int hf_lmp_feat_afhcapma = -1;
+static int hf_lmp_feat_afhclama = -1;
+static int hf_lmp_feat_esco2 = -1;
+static int hf_lmp_feat_esco3 = -1;
+static int hf_lmp_feat_3slotenhesco = -1;
+static int hf_lmp_feat_extinqres = -1;
+static int hf_lmp_feat_simlebredr = -1;
+static int hf_lmp_feat_res3 = -1;
+static int hf_lmp_feat_ssp = -1;
+static int hf_lmp_feat_enpdu = -1;
+static int hf_lmp_feat_edr = -1;
+static int hf_lmp_feat_nonflush = -1;
+static int hf_lmp_feat_res4 = -1;
+static int hf_lmp_feat_lstimche = -1;
+static int hf_lmp_feat_inqtxpwr = -1;
+static int hf_lmp_feat_enhpwr = -1;
+static int hf_lmp_feat_res5 = -1;
+static int hf_lmp_feat_res6 = -1;
+static int hf_lmp_feat_res7 = -1;
+static int hf_lmp_feat_res8 = -1;
+static int hf_lmp_feat_extfeat = -1;
+static int hf_lmp_featuresext = -1;
+static int hf_lmp_efeat_ssp = -1;
+static int hf_lmp_efeat_lesup = -1;
+static int hf_lmp_efeat_lebredr = -1;
+static int hf_lmp_efeat_sch = -1;
+static int hf_lmp_efeat_csbma = -1;
+static int hf_lmp_efeat_csbsl = -1;
+static int hf_lmp_efeat_syntr = -1;
+static int hf_lmp_efeat_synsc = -1;
+static int hf_lmp_efeat_inqresnote = -1;
+static int hf_lmp_efeat_genintsc = -1;
+static int hf_lmp_efeat_ccadj = -1;
+static int hf_lmp_efeat_res0 = -1;
+static int hf_lmp_efeat_scc = -1;
+static int hf_lmp_efeat_ping = -1;
+static int hf_lmp_efeat_res1 = -1;
+static int hf_lmp_efeat_trnud = -1;
+static int hf_lmp_efeat_sam = -1;
+static int hf_lmp_fpage = -1;
+static int hf_lmp_htime = -1;
+static int hf_lmp_hinst = -1;
+static int hf_lmp_hopmode = -1;
+static int hf_lmp_iocaps = -1;
+static int hf_lmp_jitter = -1;
+static int hf_lmp_key = -1;
+static int hf_lmp_keysz = -1;
+static int hf_lmp_ksmask = -1;
+static int hf_lmp_ltaddr1 = -1;
+static int hf_lmp_ltaddr2 = -1;
+static int hf_lmp_ltaddr3 = -1;
+static int hf_lmp_ltaddr4 = -1;
+static int hf_lmp_ltaddr5 = -1;
+static int hf_lmp_ltaddr6 = -1;
+static int hf_lmp_ltaddr7 = -1;
+static int hf_lmp_maccess = -1;
+static int hf_lmp_maxslots = -1;
+static int hf_lmp_maxsp = -1;
+static int hf_lmp_maxss = -1;
+static int hf_lmp_minsmt = -1;
+static int hf_lmp_naccslots = -1;
+static int hf_lmp_namefrag = -1;
+static int hf_lmp_namelen = -1;
+static int hf_lmp_nameoffset = -1;
+static int hf_lmp_nb = -1;
+static int hf_lmp_nbc = -1;
+static int hf_lmp_nbsleep = -1;
+static int hf_lmp_negstate = -1;
+static int hf_lmp_nonce = -1;
+static int hf_lmp_nottype = -1;
+static int hf_lmp_npoll = -1;
+static int hf_lmp_oobauthdata = -1;
+static int hf_lmp_op = -1;
+static int hf_lmp_opinre = -1;
+static int hf_lmp_pagesch = -1;
+static int hf_lmp_pcmode = -1;
+static int hf_lmp_pkttype = -1;
+static int hf_lmp_pkttypetbl = -1;
+static int hf_lmp_pmaddr = -1;
+static int hf_lmp_pmaddr1 = -1;
+static int hf_lmp_pmaddr2 = -1;
+static int hf_lmp_pmaddr3 = -1;
+static int hf_lmp_pmaddr4 = -1;
+static int hf_lmp_pmaddr5 = -1;
+static int hf_lmp_pmaddr6 = -1;
+static int hf_lmp_pmaddr7 = -1;
+static int hf_lmp_pollintvl = -1;
+static int hf_lmp_pollper = -1;
+static int hf_lmp_pssettings = -1;
+static int hf_lmp_pwradjreq = -1;
+static int hf_lmp_pwradjres = -1;
+static int hf_lmp_pwradj_8dpsk = -1;
+static int hf_lmp_pwradj_dqpsk = -1;
+static int hf_lmp_pwradj_gfsk = -1;
+static int hf_lmp_rand = -1;
+static int hf_lmp_rate = -1;
+static int hf_lmp_rate_fec = -1;
+static int hf_lmp_rate_size = -1;
+static int hf_lmp_rate_type = -1;
+static int hf_lmp_rate_edrsize = -1;
+static int hf_lmp_rxfreq = -1;
+static int hf_lmp_scohdl = -1;
+static int hf_lmp_scopkt = -1;
+static int hf_lmp_slotoffset = -1;
+static int hf_lmp_sniffatt = -1;
+static int hf_lmp_sniffsi = -1;
+static int hf_lmp_sniffto = -1;
+static int hf_lmp_subversnr = -1;
+static int hf_lmp_suptimeout = -1;
+static int hf_lmp_swinst = -1;
+static int hf_lmp_taccess = -1;
+static int hf_lmp_tb = -1;
+static int hf_lmp_tesco = -1;
+static int hf_lmp_testlen = -1;
+static int hf_lmp_testscen = -1;
+static int hf_lmp_tid = -1;
+static int hf_lmp_timectrl = -1;
+static int hf_lmp_time_change = -1;
+static int hf_lmp_time_init = -1;
+static int hf_lmp_time_accwin = -1;
+static int hf_lmp_tsco = -1;
+static int hf_lmp_tsniff = -1;
+static int hf_lmp_txfreq = -1;
+static int hf_lmp_versnr = -1;
+static int hf_lmp_wesco = -1;
+
+/* supported features page 0 (standard p. 528) */
+static const int *features_fields[] = {
+	&hf_lmp_feat_3slot,
+	&hf_lmp_feat_5slot,
+	&hf_lmp_feat_enc,
+	&hf_lmp_feat_slotoff,
+	&hf_lmp_feat_timacc,
+	&hf_lmp_feat_rolesw,
+	&hf_lmp_feat_holdmo,
+	&hf_lmp_feat_sniffmo,
+	&hf_lmp_feat_res0,
+	&hf_lmp_feat_pwrctlreq,
+	&hf_lmp_feat_cqddr,
+	&hf_lmp_feat_sco,
+	&hf_lmp_feat_hv2,
+	&hf_lmp_feat_hv3,
+	&hf_lmp_feat_mulaw,
+	&hf_lmp_feat_alaw,
+	&hf_lmp_feat_cvsd,
+	&hf_lmp_feat_pagneg,
+	&hf_lmp_feat_pwrctl,
+	&hf_lmp_feat_transsync,
+	&hf_lmp_feat_flowctl1,
+	&hf_lmp_feat_flowctl2,
+	&hf_lmp_feat_flowctl3,
+	&hf_lmp_feat_bcenc,
+	&hf_lmp_feat_res1,
+	&hf_lmp_feat_acl2,
+	&hf_lmp_feat_acl3,
+	&hf_lmp_feat_eninq,
+	&hf_lmp_feat_intinq,
+	&hf_lmp_feat_intpag,
+	&hf_lmp_feat_rssiinq,
+	&hf_lmp_feat_ev3,
+	&hf_lmp_feat_ev4,
+	&hf_lmp_feat_ev5,
+	&hf_lmp_feat_res2,
+	&hf_lmp_feat_afhcapsl,
+	&hf_lmp_feat_afhclasl,
+	&hf_lmp_feat_bredrnotsup,
+	&hf_lmp_feat_lesup,
+	&hf_lmp_feat_3slotenh,
+	&hf_lmp_feat_5slotenh,
+	&hf_lmp_feat_sniffsubr,
+	&hf_lmp_feat_pauseenc,
+	&hf_lmp_feat_afhcapma,
+	&hf_lmp_feat_afhclama,
+	&hf_lmp_feat_esco2,
+	&hf_lmp_feat_esco3,
+	&hf_lmp_feat_3slotenhesco,
+	&hf_lmp_feat_extinqres,
+	&hf_lmp_feat_simlebredr,
+	&hf_lmp_feat_res3,
+	&hf_lmp_feat_ssp,
+	&hf_lmp_feat_enpdu,
+	&hf_lmp_feat_edr,
+	&hf_lmp_feat_nonflush,
+	&hf_lmp_feat_res4,
+	&hf_lmp_feat_lstimche,
+	&hf_lmp_feat_inqtxpwr,
+	&hf_lmp_feat_enhpwr,
+	&hf_lmp_feat_res5,
+	&hf_lmp_feat_res6,
+	&hf_lmp_feat_res7,
+	&hf_lmp_feat_res8,
+	&hf_lmp_feat_extfeat,
+	NULL};
+
+/* supported features page 1+2 (standard p. 530) */
+static const int *extfeatures1_fields[] = {
+
+	&hf_lmp_efeat_ssp,
+	&hf_lmp_efeat_lesup,
+	&hf_lmp_efeat_lebredr,
+	&hf_lmp_efeat_sch,
+	NULL};
+
+static const int *extfeatures2_fields[] = {
+	&hf_lmp_efeat_csbma,
+	&hf_lmp_efeat_csbsl,
+	&hf_lmp_efeat_syntr,
+	&hf_lmp_efeat_synsc,
+	&hf_lmp_efeat_inqresnote,
+	&hf_lmp_efeat_genintsc,
+	&hf_lmp_efeat_ccadj,
+	&hf_lmp_efeat_res0,
+	&hf_lmp_efeat_scc,
+	&hf_lmp_efeat_ping,
+	&hf_lmp_efeat_res1,
+	&hf_lmp_efeat_trnud,
+	&hf_lmp_efeat_sam,
+	NULL};
+
+/* timing control flags */
+static const int *timectrl_fields[] = {
+	&hf_lmp_time_change,
+	&hf_lmp_time_init,
+	&hf_lmp_time_accwin,
+	/* bits 3-7 reserved */
+	NULL};
+
+static const true_false_string time_change = {
+	"timing change",
+	"no timing change"};
+
+static const true_false_string time_init = {
+	"use initialization 2",
+	"use initialization 1"};
+
+static const true_false_string time_accwin = {
+	"no access window",
+	"access window"};
+
+static const true_false_string fec = {
+	"do not use FEC",
+	"use FEC"};
+
+static const true_false_string tid = {
+	"transaction initiated by slave",
+	"transaction initiated by master"};
+
+/* short LMP opcodes */
+static const value_string opcode[] = {
+	{LMP_VSC, "LMP_Broadcom_BPCS"},
+	{LMP_NAME_REQ, "LMP_name_req"},
+	{LMP_NAME_RES, "LMP_name_res"},
+	{LMP_ACCEPTED, "LMP_accepted"},
+	{LMP_NOT_ACCEPTED, "LMP_not_accepted"},
+	{LMP_CLKOFFSET_REQ, "LMP_clkoffset_req"},
+	{LMP_CLKOFFSET_RES, "LMP_clkoffset_res"},
+	{LMP_DETACH, "LMP_detach"},
+	{LMP_IN_RAND, "LMP_in_rand"},
+	{LMP_COMB_KEY, "LMP_comb_key"},
+	{LMP_UNIT_KEY, "LMP_unit_key"},
+	{LMP_AU_RAND, "LMP_au_rand"},
+	{LMP_SRES, "LMP_sres"},
+	{LMP_TEMP_RAND, "LMP_temp_rand"},
+	{LMP_TEMP_KEY, "LMP_temp_key"},
+	{LMP_ENCRYPTION_MODE_REQ, "LMP_encryption_mode_req"},
+	{LMP_ENCRYPTION_KEY_SIZE_REQ, "LMP_encryption_key_size_req"},
+	{LMP_START_ENCRYPTION_REQ, "LMP_start_encryption_req"},
+	{LMP_STOP_ENCRYPTION_REQ, "LMP_stop_encryption_req"},
+	{LMP_SWITCH_REQ, "LMP_switch_req"},
+	{LMP_HOLD, "LMP_hold"},
+	{LMP_HOLD_REQ, "LMP_hold_req"},
+	{LMP_SNIFF_REQ, "LMP_sniff_req"},
+	{LMP_UNSNIFF_REQ, "LMP_unsniff_req"},
+	{LMP_PARK_REQ, "LMP_park_req"},
+	{LMP_SET_BROADCAST_SCAN_WINDOW, "LMP_set_broadcast_scan_window"},
+	{LMP_MODIFY_BEACON, "LMP_modify_beacon"},
+	{LMP_UNPARK_BD_ADDR_REQ, "LMP_unpark_BD_ADDR_req"},
+	{LMP_UNPARK_PM_ADDR_REQ, "LMP_unpark_PM_ADDR_req"},
+	{LMP_INCR_POWER_REQ, "LMP_incr_power_req"},
+	{LMP_DECR_POWER_REQ, "LMP_decr_power_req"},
+	{LMP_MAX_POWER, "LMP_max_power"},
+	{LMP_MIN_POWER, "LMP_min_power"},
+	{LMP_AUTO_RATE, "LMP_auto_rate"},
+	{LMP_PREFERRED_RATE, "LMP_preferred_rate"},
+	{LMP_VERSION_REQ, "LMP_version_req"},
+	{LMP_VERSION_RES, "LMP_version_res"},
+	{LMP_FEATURES_REQ, "LMP_features_req"},
+	{LMP_FEATURES_RES, "LMP_features_res"},
+	{LMP_QUALITY_OF_SERVICE, "LMP_quality_of_service"},
+	{LMP_QUALITY_OF_SERVICE_REQ, "LMP_quality_of_service_req"},
+	{LMP_SCO_LINK_REQ, "LMP_SCO_link_req"},
+	{LMP_REMOVE_SCO_LINK_REQ, "LMP_remove_SCO_link_req"},
+	{LMP_MAX_SLOT, "LMP_max_slot"},
+	{LMP_MAX_SLOT_REQ, "LMP_max_slot_req"},
+	{LMP_TIMING_ACCURACY_REQ, "LMP_timing_accuracy_req"},
+	{LMP_TIMING_ACCURACY_RES, "LMP_timing_accuracy_res"},
+	{LMP_SETUP_COMPLETE, "LMP_setup_complete"},
+	{LMP_USE_SEMI_PERMANENT_KEY, "LMP_use_semi_permanent_key"},
+	{LMP_HOST_CONNECTION_REQ, "LMP_host_connection_req"},
+	{LMP_SLOT_OFFSET, "LMP_slot_offset"},
+	{LMP_PAGE_MODE_REQ, "LMP_page_mode_req"},
+	{LMP_PAGE_SCAN_MODE_REQ, "LMP_page_scan_mode_req"},
+	{LMP_SUPERVISION_TIMEOUT, "LMP_supervision_timeout"},
+	{LMP_TEST_ACTIVATE, "LMP_test_activate"},
+	{LMP_TEST_CONTROL, "LMP_test_control"},
+	{LMP_ENCRYPTION_KEY_SIZE_MASK_REQ, "LMP_encryption_key_size_mask_req"},
+	{LMP_ENCRYPTION_KEY_SIZE_MASK_RES, "LMP_encryption_key_size_mask_res"},
+	{LMP_SET_AFH, "LMP_set_AFH"},
+	{LMP_ENCAPSULATED_HEADER, "LMP_encapsulated_header"},
+	{LMP_ENCAPSULATED_PAYLOAD, "LMP_encapsulated_payload"},
+	{LMP_SIMPLE_PAIRING_CONFIRM, "LMP_Simple_Pairing_Confirm"},
+	{LMP_SIMPLE_PAIRING_NUMBER, "LMP_Simple_Pairing_Number"},
+	{LMP_DHKEY_CHECK, "LMP_DHkey_Check"},
+	{LMP_ESCAPE_1, "Escape 1"},
+	{LMP_ESCAPE_2, "Escape 2"},
+	{LMP_ESCAPE_3, "Escape 3"},
+	{LMP_ESCAPE_4, "Escape 4"},
+	{0, NULL}};
+
+/* extended LMP opcodes */
+static const value_string ext_opcode[] = {
+	{LMP_ACCEPTED_EXT, "LMP_accepted_ext"},
+	{LMP_NOT_ACCEPTED_EXT, "LMP_not_accepted_ext"},
+	{LMP_FEATURES_REQ_EXT, "LMP_features_req_ext"},
+	{LMP_FEATURES_RES_EXT, "LMP_features_res_ext"},
+	{LMP_PACKET_TYPE_TABLE_REQ, "LMP_packet_type_table_req"},
+	{LMP_ESCO_LINK_REQ, "LMP_eSCO_link_req"},
+	{LMP_REMOVE_ESCO_LINK_REQ, "LMP_remove_eSCO_link_req"},
+	{LMP_CHANNEL_CLASSIFICATION_REQ, "LMP_channel_classification_req"},
+	{LMP_CHANNEL_CLASSIFICATION, "LMP_channel_classification"},
+	{LMP_SNIFF_SUBRATING_REQ, "LMP_sniff_subrating_req"},
+	{LMP_SNIFF_SUBRATING_RES, "LMP_sniff_subrating_res"},
+	{LMP_PAUSE_ENCRYPTION_REQ, "LMP_pause_encryption_req"},
+	{LMP_RESUME_ENCRYPTION_REQ, "LMP_resume_encryption_req"},
+	{LMP_IO_CAPABILITY_REQ, "LMP_IO_Capability_req"},
+	{LMP_IO_CAPABILITY_RES, "LMP_IO_Capability_res"},
+	{LMP_NUMERIC_COMPARISON_FAILED, "LMP_numeric_comparison_failed"},
+	{LMP_PASSKEY_FAILED, "LMP_passkey_failed"},
+	{LMP_OOB_FAILED, "LMP_oob_failed"},
+	{LMP_KEYPRESS_NOTIFICATION, "LMP_keypress_notification"},
+	{LMP_POWER_CONTROL_REQ, "LMP_power_control_req"},
+	{LMP_POWER_CONTROL_RES, "LMP_power_control_res"},
+	{LMP_PING_REQ, "LMP_ping_req"},
+	{LMP_PING_RES, "LMP_ping_res"},
+	{0, NULL}};
+
+/* LMP error codes */
+static const value_string error_code[] = {
+	{0x00, "Success"},
+	{0x01, "Unknown HCI Command"},
+	{0x02, "Unknown Connection Identifier"},
+	{0x03, "Hardware Failure"},
+	{0x04, "Page Timeout"},
+	{0x05, "Authentication Failure"},
+	{0x06, "PIN or Key Missing"},
+	{0x07, "Memory Capacity Exceeded"},
+	{0x08, "Connection Timeout"},
+	{0x09, "Connection Limit Exceeded"},
+	{0x0A, "Synchronous Connection Limit To A Device Exceeded"},
+	{0x0B, "ACL Connection Already Exists"},
+	{0x0C, "Command Disallowed"},
+	{0x0D, "Connection Rejected due to Limited Resources"},
+	{0x0E, "Connection Rejected Due To Security Reasons"},
+	{0x0F, "Connection Rejected due to Unacceptable BD_ADDR"},
+	{0x10, "Connection Accept Timeout Exceeded"},
+	{0x11, "Unsupported Feature or Parameter Value"},
+	{0x12, "Invalid HCI Command Parameters"},
+	{0x13, "Remote User Terminated Connection"},
+	{0x14, "Remote Device Terminated Connection due to Low Resources"},
+	{0x15, "Remote Device Terminated Connection due to Power Off"},
+	{0x16, "Connection Terminated By Local Host"},
+	{0x17, "Repeated Attempts"},
+	{0x18, "Pairing Not Allowed"},
+	{0x19, "Unknown LMP PDU"},
+	{0x1A, "Unsupported Remote Feature / Unsupported LMP Feature"},
+	{0x1B, "SCO Offset Rejected"},
+	{0x1C, "SCO Interval Rejected"},
+	{0x1D, "SCO Air Mode Rejected"},
+	{0x1E, "Invalid LMP Parameters"},
+	{0x1F, "Unspecified Error"},
+	{0x20, "Unsupported LMP Parameter Value"},
+	{0x21, "Role Change Not Allowed"},
+	{0x22, "LMP Response Timeout"},
+	{0x23, "LMP Error Transaction Collision"},
+	{0x24, "LMP PDU Not Allowed"},
+	{0x25, "Encryption Mode Not Acceptable"},
+	{0x26, "Link Key Can Not be Changed"},
+	{0x27, "Requested QoS Not Supported"},
+	{0x28, "Instant Passed"},
+	{0x29, "Pairing With Unit Key Not Supported"},
+	{0x2A, "Different Transaction Collision"},
+	{0x2B, "Reserved"},
+	{0x2C, "QoS Unacceptable Parameter"},
+	{0x2D, "QoS Rejected"},
+	{0x2E, "Channel Classification Not Supported"},
+	{0x2F, "Insufficient Security"},
+	{0x30, "Parameter Out Of Mandatory Range"},
+	{0x31, "Reserved"},
+	{0x32, "Role Switch Pending"},
+	{0x33, "Reserved"},
+	{0x34, "Reserved Slot Violation"},
+	{0x35, "Role Switch Failed"},
+	{0x36, "Extended Inquiry Response Too Large"},
+	{0x37, "Secure Simple Pairing Not Supported By Host."},
+	{0x38, "Host Busy - Pairing"},
+	{0x39, "Connection Rejected due to No Suitable Channel Found"},
+	{0, NULL}};
+
+static const value_string encryption_mode[] = {
+	{0, "no encryption"},
+	{1, "encryption"},
+	{2, "encryption"},
+	/* 3 - 255 reserved */
+	{0, NULL}};
+
+static const value_string access_scheme[] = {
+	{0, "polling technique"},
+	/* 1 - 15 reserved */
+	{0, NULL}};
+
+static const value_string packet_size[] = {
+	{0, "no packet-size preference available"},
+	{1, "use 1-slot packets"},
+	{2, "use 3-slot packets"},
+	{3, "use 5-slot packets"},
+	{0, NULL}};
+
+static const value_string edr_type[] = {
+	{0, "use DM1 packets"},
+	{1, "use 2 Mbps packets"},
+	{2, "use 3 Mbps packets"},
+	/* 3 reserved */
+	{0, NULL}};
+
+static const value_string versnr[] = {
+	{0, "Bluetooth Core Specification 1.0b"},
+	{1, "Bluetooth Core Specification 1.1"},
+	{2, "Bluetooth Core Specification 1.2"},
+	{3, "Bluetooth Core Specification 2.0 + EDR"},
+	{4, "Bluetooth Core Specification 2.1 + EDR"},
+	{5, "Bluetooth Core Specification 3.0 + HS"},
+	{6, "Bluetooth Core Specification 4.0"},
+	{7, "Bluetooth Core Specification 4.1"},
+	{8, "Bluetooth Core Specification 4.2"},
+	{9, "Bluetooth Core Specification 5.0"},
+	{10, "Bluetooth Core Specification 5.1"},
+	{11, "Bluetooth Core Specification 5.2"},
+	/* 12 - 255 reserved */
+	{0, NULL}};
+
+static const value_string compid[] = {
+	{0, "Ericsson Technology Licensing"},
+	{1, "Nokia Mobile Phones"},
+	{2, "Intel Corp."},
+	{3, "IBM Corp."},
+	{4, "Toshiba Corp."},
+	{5, "3Com"},
+	{6, "Microsoft"},
+	{7, "Lucent"},
+	{8, "Motorola"},
+	{9, "Infineon Technologies AG"},
+	{10, "Cambridge Silicon Radio"},
+	{11, "Silicon Wave"},
+	{12, "Digianswer A/S"},
+	{13, "Texas Instruments Inc."},
+	{14, "Parthus Technologies Inc."},
+	{15, "Broadcom Corporation"},
+	{16, "Mitel Semiconductor"},
+	{17, "Widcomm, Inc."},
+	{18, "Zeevo, Inc."},
+	{19, "Atmel Corporation"},
+	{20, "Mitsubishi Electric Corporation"},
+	{21, "RTX Telecom A/S"},
+	{22, "KC Technology Inc."},
+	{23, "Newlogic"},
+	{24, "Transilica, Inc."},
+	{25, "Rohde & Schwarz GmbH & Co. KG"},
+	{26, "TTPCom Limited"},
+	{27, "Signia Technologies, Inc."},
+	{28, "Conexant Systems Inc."},
+	{29, "Qualcomm"},
+	{30, "Inventel"},
+	{31, "AVM Berlin"},
+	{32, "BandSpeed, Inc."},
+	{33, "Mansella Ltd"},
+	{34, "NEC Corporation"},
+	{35, "WavePlus Technology Co., Ltd."},
+	{36, "Alcatel"},
+	{37, "Philips Semiconductors"},
+	{38, "C Technologies"},
+	{39, "Open Interface"},
+	{40, "R F Micro Devices"},
+	{41, "Hitachi Ltd"},
+	{42, "Symbol Technologies, Inc."},
+	{43, "Tenovis"},
+	{44, "Macronix International Co. Ltd."},
+	{45, "GCT Semiconductor"},
+	{46, "Norwood Systems"},
+	{47, "MewTel Technology Inc."},
+	{48, "ST Microelectronics"},
+	{49, "Synopsys"},
+	{50, "Red-M (Communications) Ltd"},
+	{51, "Commil Ltd"},
+	{52, "Computer Access Technology Corporation (CATC)"},
+	{53, "Eclipse (HQ Espana) S.L."},
+	{54, "Renesas Technology Corp."},
+	{55, "Mobilian Corporation"},
+	{56, "Terax"},
+	{57, "Integrated System Solution Corp."},
+	{58, "Matsushita Electric Industrial Co., Ltd."},
+	{59, "Gennum Corporation"},
+	{60, "Research In Motion"},
+	{61, "IPextreme, Inc."},
+	{62, "Systems and Chips, Inc"},
+	{63, "Bluetooth SIG, Inc"},
+	{64, "Seiko Epson Corporation"},
+	{65, "Integrated Silicon Solution Taiwan, Inc."},
+	{66, "CONWISE Technology Corporation Ltd"},
+	{67, "PARROT SA"},
+	{68, "Socket Mobile"},
+	{69, "Atheros Communications, Inc."},
+	{70, "MediaTek, Inc."},
+	{71, "Bluegiga (tentative)"},
+	{72, "Marvell Technology Group Ltd."},
+	{73, "3DSP Corporation"},
+	{74, "Accel Semiconductor Ltd."},
+	{75, "Continental Automotive Systems"},
+	{76, "Apple, Inc."},
+	{77, "Staccato Communications, Inc."},
+	{78, "Avago Technologies"},
+	{79, "APT Ltd."},
+	{80, "SiRF Technology, Inc."},
+	{81, "Tzero Technologies, Inc."},
+	{82, "J&M Corporation"},
+	{83, "Free2move AB"},
+	{84, "3DiJoyCorporation"},
+	{85, "Plantronics,Inc."},
+	{86, "SonyEricssonMobileCommunications"},
+	{87, "HarmanInternationalIndustries,Inc."},
+	{88, "Vizio,Inc."},
+	{89, "NordicSemiconductorASA"},
+	{90, "EMMicroelectronic-MarinSA"},
+	{91, "RalinkTechnologyCorporation"},
+	{92, "BelkinInternational,Inc."},
+	{93, "RealtekSemiconductorCorporation"},
+	{94, "StonestreetOne,LLC"},
+	{95, "Wicentric,Inc."},
+	{96, "RivieraWavesS.A.S"},
+	{97, "RDAMicroelectronics"},
+	{98, "GibsonGuitars"},
+	{99, "MiCommandInc."},
+	{100, "BandXIInternational,LLC"},
+	{101, "Hewlett-PackardCompany"},
+	{102, "9SolutionsOy"},
+	{103, "GNNetcomA/S"},
+	{104, "GeneralMotors"},
+	{105, "A&DEngineering,Inc."},
+	{106, "MindTreeLtd."},
+	{107, "PolarElectroOY"},
+	{108, "BeautifulEnterpriseCo.,Ltd."},
+	{109, "BriarTek,Inc"},
+	{110, "SummitDataCommunications,Inc."},
+	{111, "SoundID"},
+	{112, "Monster,LLC"},
+	{113, "connectBlueAB"},
+	{114, "ShangHaiSuperSmartElectronicsCo.Ltd."},
+	{115, "GroupSenseLtd."},
+	{116, "Zomm,LLC"},
+	{117, "SamsungElectronicsCo.Ltd."},
+	{118, "CreativeTechnologyLtd."},
+	{119, "LairdTechnologies"},
+	{120, "Nike,Inc."},
+	{121, "lesswireAG"},
+	{122, "MStarSemiconductor,Inc."},
+	{123, "HanlynnTechnologies"},
+	{124, "A&RCambridge"},
+	{125, "SeersTechnologyCo.,Ltd."},
+	{126, "SportsTrackingTechnologiesLtd."},
+	{127, "AutonetMobile"},
+	{128, "DeLormePublishingCompany,Inc."},
+	{129, "WuXiVimicro"},
+	{130, "SennheiserCommunicationsA/S"},
+	{131, "TimeKeepingSystems,Inc."},
+	{132, "LudusHelsinkiLtd."},
+	{133, "BlueRadios,Inc."},
+	{134, "EquinuxAG"},
+	{135, "GarminInternational,Inc."},
+	{136, "Ecotest"},
+	{137, "GNReSoundA/S"},
+	{138, "Jawbone"},
+	{139, "TopconPositioningSystems,LLC"},
+	{140, "GimbalInc.(formerlyQualcommLabs,Inc.andQualcommRetailSolutions,Inc.)"},
+	{141, "ZscanSoftware"},
+	{142, "QuinticCorp"},
+	{143, "TelitWirelessSolutionsGmbH(formerlyStollmannE+VGmbH)"},
+	{144, "FunaiElectricCo.,Ltd."},
+	{145, "AdvancedPANMOBILsystemsGmbH&Co.KG"},
+	{146, "ThinkOptics,Inc."},
+	{147, "UniversalElectronics,Inc."},
+	{148, "AirohaTechnologyCorp."},
+	{149, "NECLighting,Ltd."},
+	{150, "ODMTechnology,Inc."},
+	{151, "ConnecteDeviceLtd."},
+	{152, "zero1.tvGmbH"},
+	{153, "i.TechDynamicGlobalDistributionLtd."},
+	{154, "Alpwise"},
+	{155, "JiangsuToppowerAutomotiveElectronicsCo.,Ltd."},
+	{156, "Colorfy,Inc."},
+	{157, "GeoforceInc."},
+	{158, "BoseCorporation"},
+	{159, "SuuntoOy"},
+	{160, "KensingtonComputerProductsGroup"},
+	{161, "SR-Medizinelektronik"},
+	{162, "VertuCorporationLimited"},
+	{163, "MetaWatchLtd."},
+	{164, "LINAKA/S"},
+	{165, "OTLDynamicsLLC"},
+	{166, "PandaOceanInc."},
+	{167, "VisteonCorporation"},
+	{168, "ARPDevicesLimited"},
+	{169, "MagnetiMarelliS.p.A"},
+	{170, "CAENRFIDsrl"},
+	{171, "Ingenieur-SystemgruppeZahnGmbH"},
+	{172, "GreenThrottleGames"},
+	{173, "PeterSystemtechnikGmbH"},
+	{174, "OmegawaveOy"},
+	{175, "Cinetix"},
+	{176, "PassifSemiconductorCorp"},
+	{177, "SarisCyclingGroup,Inc"},
+	{178, "BekeyA/S"},
+	{179, "ClarinoxTechnologiesPty.Ltd."},
+	{180, "BDETechnologyCo.,Ltd."},
+	{181, "SwirlNetworks"},
+	{182, "Mesointernational"},
+	{183, "TreLabLtd"},
+	{184, "QualcommInnovationCenter,Inc.(QuIC)"},
+	{185, "JohnsonControls,Inc."},
+	{186, "StarkeyLaboratoriesInc."},
+	{187, "S-PowerElectronicsLimited"},
+	{188, "AceSensorInc"},
+	{189, "AplixCorporation"},
+	{190, "AAMPofAmerica"},
+	{191, "StalmartTechnologyLimited"},
+	{192, "AMICCOMElectronicsCorporation"},
+	{193, "ShenzhenExcelsecuDataTechnologyCo.,Ltd"},
+	{194, "GeneqInc."},
+	{195, "adidasAG"},
+	{196, "LGElectronics"},
+	{197, "OnsetComputerCorporation"},
+	{198, "SelflyBV"},
+	{199, "QuuppaOy."},
+	{200, "GeLoInc"},
+	{201, "Evluma"},
+	{202, "MC10"},
+	{203, "BinauricSE"},
+	{204, "BeatsElectronics"},
+	{205, "MicrochipTechnologyInc."},
+	{206, "ElgatoSystemsGmbH"},
+	{207, "ARCHOSSA"},
+	{208, "Dexcom,Inc."},
+	{209, "PolarElectroEuropeB.V."},
+	{210, "DialogSemiconductorB.V."},
+	{211, "TaixingbangTechnology(HK)Co,.LTD."},
+	{212, "Kawantech"},
+	{213, "AustcoCommunicationSystems"},
+	{214, "TimexGroupUSA,Inc."},
+	{215, "QualcommTechnologies,Inc."},
+	{216, "QualcommConnectedExperiences,Inc."},
+	{217, "VoyetraTurtleBeach"},
+	{218, "txtrGmbH"},
+	{219, "Biosentronics"},
+	{220, "Procter&Gamble"},
+	{221, "HosidenCorporation"},
+	{222, "MuzikLLC"},
+	{223, "MisfitWearablesCorp"},
+	{224, "Google"},
+	{225, "DanlersLtd"},
+	{226, "SemilinkInc"},
+	{227, "inMusicBrands,Inc"},
+	{228, "L.S.ResearchInc."},
+	{229, "EdenSoftwareConsultantsLtd."},
+	{230, "Freshtemp"},
+	{231, "KSTechnologies"},
+	{232, "ACTSTechnologies"},
+	{233, "VtrackSystems"},
+	{234, "Nielsen-KellermanCompany"},
+	{235, "ServerTechnologyInc."},
+	{236, "BioResearchAssociates"},
+	{237, "JollyLogic,LLC"},
+	{238, "AboveAverageOutcomes,Inc."},
+	{239, "BitsplittersGmbH"},
+	{240, "PayPal,Inc."},
+	{241, "WitronTechnologyLimited"},
+	{242, "MorseProjectInc."},
+	{243, "KentDisplaysInc."},
+	{244, "NautilusInc."},
+	{245, "SmartifierOy"},
+	{246, "ElcometerLimited"},
+	{247, "VSNTechnologies,Inc."},
+	{248, "AceUniCorp.,Ltd."},
+	{249, "StickNFind"},
+	{250, "CrystalCodeAB"},
+	{251, "KOUKAAMa.s."},
+	{252, "DelphiCorporation"},
+	{253, "ValenceTechLimited"},
+	{254, "StanleyBlackandDecker"},
+	{255, "TypoProducts,LLC"},
+	{256, "TomTomInternationalBV"},
+	{257, "Fugoo,Inc."},
+	{258, "KeiserCorporation"},
+	{259, "Bang&OlufsenA/S"},
+	{260, "PLUSLocationSystemsPtyLtd"},
+	{261, "UbiquitousComputingTechnologyCorporation"},
+	{262, "InnovativeYachtterSolutions"},
+	{263, "WilliamDemantHoldingA/S"},
+	{264, "ChiconyElectronicsCo.,Ltd."},
+	{265, "AtusBV"},
+	{266, "CodegateLtd"},
+	{267, "ERi,Inc"},
+	{268, "TransducersDirect,LLC"},
+	{269, "FujitsuTenLImited"},
+	{270, "AudiAG"},
+	{271, "HiSiliconTechnologiesCol,Ltd."},
+	{272, "NipponSeikiCo.,Ltd."},
+	{273, "SteelseriesApS"},
+	{274, "VisyblInc."},
+	{275, "OpenbrainTechnologies,Co.,Ltd."},
+	{276, "Xensr"},
+	{277, "e.solutions"},
+	{278, "10AKTechnologies"},
+	{279, "WimotoTechnologiesInc"},
+	{280, "RadiusNetworks,Inc."},
+	{281, "WizeTechnologyCo.,Ltd."},
+	{282, "QualcommLabs,Inc."},
+	{283, "HewlettPackardEnterprise"},
+	{284, "Baidu"},
+	{285, "ArendiAG"},
+	{286, "SkodaAutoa.s."},
+	{287, "VolkswagenAG"},
+	{288, "PorscheAG"},
+	{289, "SinoWealthElectronicLtd."},
+	{290, "AirTurn,Inc."},
+	{291, "Kinsa,Inc"},
+	{292, "HIDGlobal"},
+	{293, "SEATes"},
+	{294, "PrometheanLtd."},
+	{295, "SaluticaAlliedSolutions"},
+	{296, "GPSIGroupPtyLtd"},
+	{297, "NimbleDevicesOy"},
+	{298, "ChangzhouYongseInfotechCo.,Ltd."},
+	{299, "SportIQ"},
+	{300, "TEMECInstrumentsB.V."},
+	{301, "SonyCorporation"},
+	{302, "ASSAABLOY"},
+	{303, "ClarionCo.Inc."},
+	{304, "WarehouseInnovations"},
+	{305, "CypressSemiconductor"},
+	{306, "MADSInc"},
+	{307, "BlueMaestroLimited"},
+	{308, "ResolutionProducts,Ltd."},
+	{309, "AirewareLLC"},
+	{310, "Silvair,Inc."},
+	{311, "PrestigioPlazaLtd."},
+	{312, "NTEOInc."},
+	{313, "FocusSystemsCorporation"},
+	{314, "TencentHoldingsLtd."},
+	{315, "Allegion"},
+	{316, "MurataManufacturingCo.,Ltd."},
+	{317, "WirelessWERX"},
+	{318, "Nod,Inc."},
+	{319, "B&BManufacturingCompany"},
+	{320, "AlpineElectronics(China)Co.,Ltd"},
+	{321, "FedExServices"},
+	{322, "GrapeSystemsInc."},
+	{323, "BkonConnect"},
+	{324, "LintechGmbH"},
+	{325, "NovatelWireless"},
+	{326, "Ciright"},
+	{327, "MightyCast,Inc."},
+	{328, "AmbimatElectronics"},
+	{329, "PerytonsLtd."},
+	{330, "TivoliAudio,LLC"},
+	{331, "MasterLock"},
+	{332, "Mesh-NetLtd"},
+	{333, "HUIZHOUDESAYSVAUTOMOTIVECO.,LTD."},
+	{334, "Tangerine,Inc."},
+	{335, "B&WGroupLtd."},
+	{336, "PioneerCorporation"},
+	{337, "OnBeep"},
+	{338, "VernierSoftware&Technology"},
+	{339, "ROLErgo"},
+	{340, "PebbleTechnology"},
+	{341, "NETATMO"},
+	{342, "AccumulateAB"},
+	{343, "AnhuiHuamiInformationTechnologyCo.,Ltd."},
+	{344, "Inmites.r.o."},
+	{345, "ChefSteps,Inc."},
+	{346, "micasAG"},
+	{347, "BiomedicalResearchLtd."},
+	{348, "PitiusTecS.L."},
+	{349, "Estimote,Inc."},
+	{350, "UnikeyTechnologies,Inc."},
+	{351, "TimerCapCo."},
+	{352, "AwoX"},
+	{353, "yikes"},
+	{354, "MADSGlobalNZLtd."},
+	{355, "PCHInternational"},
+	{356, "QingdaoYeelinkInformationTechnologyCo.,Ltd."},
+	{357, "MilwaukeeTool(FormallyMilwaukeeElectricTools)"},
+	{358, "MISHIKPteLtd"},
+	{359, "AscensiaDiabetesCareUSInc."},
+	{360, "SpiceboxLLC"},
+	{361, "emberlight"},
+	{362, "Cooper-AtkinsCorporation"},
+	{363, "Qblinks"},
+	{364, "MYSPHERA"},
+	{365, "LifeScanInc"},
+	{366, "VolanticAB"},
+	{367, "PodoLabs,Inc"},
+	{368, "RocheDiabetesCareAG"},
+	{369, "AmazonFulfillmentService"},
+	{370, "ConnovateTechnologyPrivateLimited"},
+	{371, "Kocomojo,LLC"},
+	{372, "EverykeyInc."},
+	{373, "DynamicControls"},
+	{374, "SentriLock"},
+	{375, "I-SYSTinc."},
+	{376, "CASIOCOMPUTERCO.,LTD."},
+	{377, "LAPISSemiconductorCo.,Ltd."},
+	{378, "Telemonitor,Inc."},
+	{379, "taskitGmbH"},
+	{380, "DaimlerAG"},
+	{381, "BatAndCat"},
+	{382, "BluDotzLtd"},
+	{383, "XTelWirelessApS"},
+	{384, "GigasetCommunicationsGmbH"},
+	{385, "GeckoHealthInnovations,Inc."},
+	{386, "HOPUbiquitous"},
+	{387, "WaltDisney"},
+	{388, "Nectar"},
+	{389, "bel'appsLLC"},
+	{390, "CORELightingLtd"},
+	{391, "SeraphimSenseLtd"},
+	{392, "UnicoRBC"},
+	{393, "PhysicalEnterprisesInc."},
+	{394, "AbleTrendTechnologyLimited"},
+	{395, "KonicaMinolta,Inc."},
+	{396, "WiloSE"},
+	{397, "ExtronDesignServices"},
+	{398, "Fitbit,Inc."},
+	{399, "FirefliesSystems"},
+	{400, "IntellettoTechnologiesInc."},
+	{401, "FDKCORPORATION"},
+	{402, "Cloudleaf,Inc"},
+	{403, "MavericAutomationLLC"},
+	{404, "AcousticStreamCorporation"},
+	{405, "Zuli"},
+	{406, "PaxtonAccessLtd"},
+	{407, "WiSilicaInc."},
+	{408, "VENGITKorlatoltFelelosseguTarsasag"},
+	{409, "SALTOSYSTEMSS.L."},
+	{410, "TRONForum(formerlyT-EngineForum)"},
+	{411, "CUBETECHs.r.o."},
+	{412, "CokiyaIncorporated"},
+	{413, "CVSHealth"},
+	{414, "Ceruus"},
+	{415, "StrainstallLtd"},
+	{416, "ChannelEnterprises(HK)Ltd."},
+	{417, "FIAMM"},
+	{418, "GIGALANE.CO.,LTD"},
+	{419, "EROAD"},
+	{420, "MineSafetyAppliances"},
+	{421, "IconHealthandFitness"},
+	{422, "WilleEngineering(formelyasAsandooGmbH)"},
+	{423, "ENERGOUSCORPORATION"},
+	{424, "Taobao"},
+	{425, "CanonInc."},
+	{426, "GeophysicalTechnologyInc."},
+	{427, "Facebook,Inc."},
+	{428, "TrividiaHealth,Inc."},
+	{429, "FlightSafetyInternational"},
+	{430, "EarlensCorporation"},
+	{431, "SunriseMicroDevices,Inc."},
+	{432, "StarMicronicsCo.,Ltd."},
+	{433, "NetizensSp.zo.o."},
+	{434, "NymiInc."},
+	{435, "Nytec,Inc."},
+	{436, "TrineoSp.zo.o."},
+	{437, "NestLabsInc."},
+	{438, "LMTechnologiesLtd"},
+	{439, "GeneralElectricCompany"},
+	{440, "i+D3S.L."},
+	{441, "HANAMicron"},
+	{442, "StagesCyclingLLC"},
+	{443, "CochlearBoneAnchoredSolutionsAB"},
+	{444, "SenionLabAB"},
+	{445, "SyszoneCo.,Ltd"},
+	{446, "PulsateMobileLtd."},
+	{447, "HongKongHunterSunElectronicLimited"},
+	{448, "pironexGmbH"},
+	{449, "BRADATECHCorp."},
+	{450, "TransenergooilAG"},
+	{451, "Bunch"},
+	{452, "DMEMicroelectronics"},
+	{453, "BitcrazeAB"},
+	{454, "HASWAREInc."},
+	{455, "AbiogenixInc."},
+	{456, "Poly-ControlApS"},
+	{457, "Avi-on"},
+	{458, "LaerdalMedicalAS"},
+	{459, "FetchMyPet"},
+	{460, "SamLabsLtd."},
+	{461, "ChengduSynwingTechnologyLtd"},
+	{462, "HOUWASYSTEMDESIGN,k.k."},
+	{463, "BSH"},
+	{464, "PrimusInterParesLtd"},
+	{465, "AugustHome,Inc"},
+	{466, "GillElectronics"},
+	{467, "SkyWaveDesign"},
+	{468, "NewlabS.r.l."},
+	{469, "ELADsrl"},
+	{470, "G-wearablesinc."},
+	{471, "SquadroneSystemsInc."},
+	{472, "CodeCorporation"},
+	{473, "SavantSystemsLLC"},
+	{474, "LogitechInternationalSA"},
+	{475, "InnblueConsulting"},
+	{476, "iParkingLtd."},
+	{477, "KoninklijkePhilipsElectronicsN.V."},
+	{478, "MinelabElectronicsPtyLimited"},
+	{479, "BisonGroupLtd."},
+	{480, "WidexA/S"},
+	{481, "JollaLtd"},
+	{482, "Lectronix,Inc."},
+	{483, "CaterpillarInc"},
+	{484, "FreedomInnovations"},
+	{485, "DynamicDevicesLtd"},
+	{486, "TechnologySolutions(UK)Ltd"},
+	{487, "IPSGroupInc."},
+	{488, "STIR"},
+	{489, "Sano,Inc."},
+	{490, "AdvancedApplicationDesign,Inc."},
+	{491, "AutoMapLLC"},
+	{492, "SpreadtrumCommunicationsShanghaiLtd"},
+	{493, "CuteCircuitLTD"},
+	{494, "ValeoService"},
+	{495, "FullpowerTechnologies,Inc."},
+	{496, "KloudNation"},
+	{497, "ZebraTechnologiesCorporation"},
+	{498, "Itron,Inc."},
+	{499, "TheUniversityofTokyo"},
+	{500, "UTCFireandSecurity"},
+	{501, "CoolWebthingsLimited"},
+	{502, "DJOGlobal"},
+	{503, "GellinerLimited"},
+	{504, "Anyka(Guangzhou)MicroelectronicsTechnologyCo,LTD"},
+	{505, "MedtronicInc."},
+	{506, "GozioInc."},
+	{507, "FormLifting,LLC"},
+	{508, "WahooFitness,LLC"},
+	{509, "KontaktMicro-LocationSp.zo.o."},
+	{510, "RadioSystemsCorporation"},
+	{511, "FreescaleSemiconductor,Inc."},
+	{512, "VerifoneSystemsPteLtd.TaiwanBranch"},
+	{513, "ARTiming"},
+	{514, "RigadoLLC"},
+	{515, "KemppiOy"},
+	{516, "TapcentiveInc."},
+	{517, "SmartboticsInc."},
+	{518, "OtterProducts,LLC"},
+	{519, "STEMPInc."},
+	{520, "LumiGeekLLC"},
+	{521, "InvisionHeartInc."},
+	{522, "MacnicaInc."},
+	{523, "JaguarLandRoverLimited"},
+	{524, "CoroWareTechnologies,Inc"},
+	{525, "SimploTechnologyCo.,LTD"},
+	{526, "OmronHealthcareCo.,LTD"},
+	{527, "ComoduleGMBH"},
+	{528, "ikeGPS"},
+	{529, "TelinkSemiconductorCo.Ltd"},
+	{530, "InterplanCo.,Ltd"},
+	{531, "WylerAG"},
+	{532, "IKMultimediaProductionsrl"},
+	{533, "LukotonExperienceOy"},
+	{534, "MTILtd"},
+	{535, "Tech4home,Lda"},
+	{536, "HiotechAB"},
+	{537, "DOTTLimited"},
+	{538, "BlueSpeckLabs,LLC"},
+	{539, "CiscoSystems,Inc"},
+	{540, "MobicommInc"},
+	{541, "Edamic"},
+	{542, "Goodnet,Ltd"},
+	{543, "LusterLeafProductsInc"},
+	{544, "ManusMachinaBV"},
+	{545, "MobiquityNetworksInc"},
+	{546, "PraxisDynamics"},
+	{547, "PhilipMorrisProductsS.A."},
+	{548, "ComarchSA"},
+	{549, "NestlNespressoS.A."},
+	{550, "MerliniaA/S"},
+	{551, "LifeBEAMTechnologies"},
+	{552, "TwocanoesLabs,LLC"},
+	{553, "MuovertiLimited"},
+	{554, "StamerMusikanlagenGMBH"},
+	{555, "TeslaMotors"},
+	{556, "PharynksCorporation"},
+	{557, "Lupine"},
+	{558, "SiemensAG"},
+	{559, "Huami(Shanghai)CultureCommunicationCO.,LTD"},
+	{560, "FosterElectricCompany,Ltd"},
+	{561, "ETASA"},
+	{562, "x-SensoSolutionsKft"},
+	{563, "ShenzhenSuLongCommunicationLtd"},
+	{564, "FengFan(BeiJing)TechnologyCo,Ltd"},
+	{565, "QrioInc"},
+	{566, "PitpatpetLtd"},
+	{567, "MSHelis.r.l."},
+	{568, "Trakm8Ltd"},
+	{569, "JINCO,Ltd"},
+	{570, "AlatechTehnology"},
+	{571, "BeijingCarePulseElectronicTechnologyCo,Ltd"},
+	{572, "Awarepoint"},
+	{573, "ViCentraB.V."},
+	{574, "RavenIndustries"},
+	{575, "WaveWareTechnologiesInc."},
+	{576, "ArgenoxTechnologies"},
+	{577, "BragiGmbH"},
+	{578, "16LabInc"},
+	{579, "MasimoCorp"},
+	{580, "IoteraInc"},
+	{581, "Endress+Hauser"},
+	{582, "ACKmeNetworks,Inc."},
+	{583, "FiftyThreeInc."},
+	{584, "ParkerHannifinCorp"},
+	{585, "TranscranialLtd"},
+	{586, "UwatecAG"},
+	{587, "OrlanLLC"},
+	{588, "BlueCloverDevices"},
+	{589, "M-WaySolutionsGmbH"},
+	{590, "MicrotronicsEngineeringGmbH"},
+	{591, "SchneiderSchreibgerteGmbH"},
+	{592, "SapphireCircuitsLLC"},
+	{593, "LumoBodytechInc."},
+	{594, "UKCTechnosolution"},
+	{595, "XicatoInc."},
+	{596, "Playbrush"},
+	{597, "DaiNipponPrintingCo.,Ltd."},
+	{598, "G24PowerLimited"},
+	{599, "AdBabbleLocalCommerceInc."},
+	{600, "DevialetSA"},
+	{601, "ALTYOR"},
+	{602, "UniversityofAppliedSciencesValais/HauteEcoleValaisanne"},
+	{603, "FiveInteractive,LLCdbaZendo"},
+	{604, "NetEaseHangzhouNetworkco.Ltd."},
+	{605, "LexmarkInternationalInc."},
+	{606, "FlukeCorporation"},
+	{607, "YardarmTechnologies"},
+	{608, "SensaRx"},
+	{609, "SECVREGmbH"},
+	{610, "GlacialRidgeTechnologies"},
+	{611, "Identiv,Inc."},
+	{612, "DDS,Inc."},
+	{613, "SMKCorporation"},
+	{614, "SchawbelTechnologiesLLC"},
+	{615, "XMISystemsSA"},
+	{616, "Cerevo"},
+	{617, "TorroxGmbH&CoKG"},
+	{618, "Gemalto"},
+	{619, "DEKAResearch&DevelopmentCorp."},
+	{620, "DomsterTadeuszSzydlowski"},
+	{621, "TechnogymSPA"},
+	{622, "FLEURBAEYBVBA"},
+	{623, "AptcodeSolutions"},
+	{624, "LSIADLTechnology"},
+	{625, "AnimasCorp"},
+	{626, "AlpsElectricCo.,Ltd."},
+	{627, "OCEASOFT"},
+	{628, "MotsaiResearch"},
+	{629, "Geotab"},
+	{630, "E.G.O.Elektro-GertebauGmbH"},
+	{631, "bewhereinc"},
+	{632, "JohnsonOutdoorsInc"},
+	{633, "steuteSchaltgerateGmbH&Co.KG"},
+	{634, "Ekominiinc."},
+	{635, "DEFAAS"},
+	{636, "AseptikaLtd"},
+	{637, "HUAWEITechnologiesCo.,Ltd.()"},
+	{638, "HabitAware,LLC"},
+	{639, "ruwidoaustriagmbh"},
+	{640, "ITECcorporation"},
+	{641, "StoneL"},
+	{642, "SonovaAG"},
+	{643, "MavenMachines,Inc."},
+	{644, "SynapseElectronics"},
+	{645, "StandardInnovationInc."},
+	{646, "RFCode,Inc."},
+	{647, "WallyVenturesS.L."},
+	{648, "WillowbankElectronicsLtd"},
+	{649, "SKTelecom"},
+	{650, "JetroAS"},
+	{651, "CodeGearsLTD"},
+	{652, "NANOLINKAPS"},
+	{653, "IF,LLC"},
+	{654, "RFDigitalCorp"},
+	{655, "Church&DwightCo.,Inc"},
+	{656, "MultibitOy"},
+	{657, "CliniCloudInc"},
+	{658, "SwiftSensors"},
+	{659, "BlueBite"},
+	{660, "ELIASGmbH"},
+	{661, "SivantosGmbH"},
+	{662, "Petzl"},
+	{663, "stormpowerltd"},
+	{664, "EISSTLtd"},
+	{665, "InexessTechnologySimmaKG"},
+	{666, "Currant,Inc."},
+	{667, "C2Development,Inc."},
+	{668, "BlueSkyScientific,LLC"},
+	{669, "ALOTTAZSLABS,LLC"},
+	{670, "Kupsonspol.sr.o."},
+	{671, "AreusEngineeringGmbH"},
+	{672, "ImpossibleCameraGmbH"},
+	{673, "InventureTrackSystems"},
+	{674, "LockedUp"},
+	{675, "Itude"},
+	{676, "PacificLockCompany"},
+	{677, "TendyronCorporation()"},
+	{678, "RobertBoschGmbH"},
+	{679, "IlluxtroninternationalB.V."},
+	{680, "miSportLtd."},
+	{681, "Chargelib"},
+	{682, "DopplerLab"},
+	{683, "BBPOSLimited"},
+	{684, "RTBElektronikGmbH&Co.KG"},
+	{685, "RxNetworks,Inc."},
+	{686, "WeatherFlow,Inc."},
+	{687, "TechnicolorUSAInc."},
+	{688, "Bestechnic(Shanghai),Ltd"},
+	{689, "RadenInc"},
+	{690, "JouZenOy"},
+	{691, "CLABERS.P.A."},
+	{692, "Hyginex,Inc."},
+	{693, "HANSHINELECTRICRAILWAYCO.,LTD."},
+	{694, "SchneiderElectric"},
+	{695, "OortTechnologiesLLC"},
+	{696, "ChronoTherapeutics"},
+	{697, "RinnaiCorporation"},
+	{698, "SwissprimeTechnologiesAG"},
+	{699, "Koha.,Co.Ltd"},
+	{700, "GenevacLtd"},
+	{701, "Chemtronics"},
+	{702, "SeguroTechnologySp.zo.o."},
+	{703, "RedbirdFlightSimulations"},
+	{704, "DashRobotics"},
+	{705, "LINECorporation"},
+	{706, "GuillemotCorporation"},
+	{707, "TechtronicPowerToolsTechnologyLimited"},
+	{708, "WilsonSportingGoods"},
+	{709, "Lenovo(Singapore)PteLtd.()"},
+	{710, "AyatanSensors"},
+	{711, "ElectronicsTomorrowLimited"},
+	{712, "VASCODataSecurityInternational,Inc."},
+	{713, "PayRangeInc."},
+	{714, "ABOVSemiconductor"},
+	{715, "AINA-WirelessInc."},
+	{716, "EijkelkampSoil&Water"},
+	{717, "BMAergonomicsb.v."},
+	{718, "TevaBrandedPharmaceuticalProductsR&D,Inc."},
+	{719, "Anima"},
+	{720, "3M"},
+	{721, "EmpaticaSrl"},
+	{722, "Afero,Inc."},
+	{723, "PowercastCorporation"},
+	{724, "SecuyouApS"},
+	{725, "OMRONCorporation"},
+	{726, "SendSolutions"},
+	{727, "NIPPONSYSTEMWARECO.,LTD."},
+	{728, "Neosfar"},
+	{729, "FlieglAgrartechnikGmbH"},
+	{730, "Gilvader"},
+	{731, "DigiInternationalInc(R)"},
+	{732, "DeWalchTechnologies,Inc."},
+	{733, "FlintRehabilitationDevices,LLC"},
+	{734, "SamsungSDSCo.,Ltd."},
+	{735, "BlurProductDevelopment"},
+	{736, "UniversityofMichigan"},
+	{737, "VictronEnergyBV"},
+	{738, "NTTdocomo"},
+	{739, "CarmanahTechnologiesCorp."},
+	{740, "BytestormLtd."},
+	{741, "EspressifIncorporated(())"},
+	{742, "Unwire"},
+	{743, "ConnectedYard,Inc."},
+	{744, "AmericanMusicEnvironments"},
+	{745, "SensogramTechnologies,Inc."},
+	{746, "FujitsuLimited"},
+	{747, "ArdicTechnology"},
+	{748, "DeltaSystems,Inc"},
+	{749, "HTCCorporation"},
+	{750, "CitizenHoldingsCo.,Ltd."},
+	{751, "SMART-INNOVATION.inc"},
+	{752, "BlackratSoftware"},
+	{753, "TheIdeaCave,LLC"},
+	{754, "GoPro,Inc."},
+	{755, "AuthAir,Inc"},
+	{756, "Vensi,Inc."},
+	{757, "IndagemTechLLC"},
+	{758, "IntemoTechnologies"},
+	{759, "DreamVisionsco.,Ltd."},
+	{760, "RunteqOyLtd"},
+	{761, "IMAGINATIONTECHNOLOGIESLTD"},
+	{762, "CoSTARTEchnologies"},
+	{763, "ClariusMobileHealthCorp."},
+	{764, "ShanghaiFrequenMicroelectronicsCo.,Ltd."},
+	{765, "Uwanna,Inc."},
+	{766, "LierdaScience&TechnologyGroupCo.,Ltd."},
+	{767, "SiliconLaboratories"},
+	{768, "WorldMotoInc."},
+	{769, "GiatecScientificInc."},
+	{770, "LoopDevices,Inc"},
+	{771, "IACAelectronique"},
+	{772, "ProxyTechnologies,Inc."},
+	{773, "SwippApS"},
+	{774, "LifeLaboratoryInc."},
+	{775, "FUJIINDUSTRIALCO.,LTD."},
+	{776, "Surefire,LLC"},
+	{777, "DolbyLabs"},
+	{778, "Ellisys"},
+	{779, "MagnitudeLightingConverters"},
+	{780, "HiltiAG"},
+	{781, "DevdataS.r.l."},
+	{782, "Deviceworx"},
+	{783, "ShortcutLabs"},
+	{784, "SGLItaliaS.r.l."},
+	{785, "PEEQDATA"},
+	{786, "DucereTechnologiesPvtLtd"},
+	{787, "DiveNav,Inc."},
+	{788, "RIIGAISp.zo.o."},
+	{789, "ThermoFisherScientific"},
+	{790, "AGMeasurematicsPvt.Ltd."},
+	{791, "CHUOElectronicsCO.,LTD."},
+	{792, "AspentaInternational"},
+	{793, "EugsterFrismagAG"},
+	{794, "AmberwirelessGmbH"},
+	{795, "HQInc"},
+	{796, "LabSensorSolutions"},
+	{797, "EnterlabApS"},
+	{798, "Eyefi,Inc."},
+	{799, "MetaSystemS.p.A."},
+	{800, "SONOELECTRONICS.CO.,LTD"},
+	{801, "Jewelbots"},
+	{802, "CompumedicsLimited"},
+	{803, "RotorBikeComponents"},
+	{804, "Astro,Inc."},
+	{805, "AmotusSolutions"},
+	{806, "HealthwearTechnologies(Changzhou)Ltd"},
+	{807, "EssexElectronics"},
+	{808, "GrundfosA/S"},
+	{809, "Eargo,Inc."},
+	{810, "ElectronicDesignLab"},
+	{811, "ESYLUX"},
+	{812, "NIPPONSMT.CO.,Ltd"},
+	{813, "BMinnovationsGmbH"},
+	{814, "indoormap"},
+	{815, "OttoQInc"},
+	{816, "NorthPoleEngineering"},
+	{817, "3flaresTechnologiesInc."},
+	{818, "ElectrocompanietA.S."},
+	{819, "Mul-T-Lock"},
+	{820, "CorentiumAS"},
+	{821, "EnlightedInc"},
+	{822, "GISTIC"},
+	{823, "AJP2Holdings,LLC"},
+	{824, "COBIGmbH"},
+	{825, "BlueSkyScientific,LLC"},
+	{826, "Appception,Inc."},
+	{827, "CourtneyThorneLimited"},
+	{828, "Virtuosys"},
+	{829, "TPVTechnologyLimited"},
+	{830, "MonitraSA"},
+	{831, "AutomationComponents,Inc."},
+	{832, "Letsenses.r.l."},
+	{833, "EtesianTechnologiesLLC"},
+	{834, "GERTECBRASILLTDA."},
+	{835, "DrekkerDevelopmentPty.Ltd."},
+	{836, "WhirlInc"},
+	{837, "LocusPositioning"},
+	{838, "AcuityBrandsLighting,Inc"},
+	{839, "PreventBiometrics"},
+	{840, "Arioneo"},
+	{841, "VersaMe"},
+	{842, "Vaddio"},
+	{843, "LibratoneA/S"},
+	{844, "HMElectronics,Inc."},
+	{845, "TASERInternational,Inc."},
+	{846, "SafeTrustInc."},
+	{847, "HeartlandPaymentSystems"},
+	{848, "BitstrataSystemsInc."},
+	{849, "PiepsGmbH"},
+	{850, "iRiding(Xiamen)TechnologyCo.,Ltd."},
+	{851, "AlphaAudiotronics,Inc."},
+	{852, "TOPPANFORMSCO.,LTD."},
+	{853, "SigmaDesigns,Inc."},
+	{854, "SpectrumBrands,Inc."},
+	{855, "PolymapWireless"},
+	{856, "MagniWareLtd."},
+	{857, "NovotecMedicalGmbH"},
+	{858, "MedicomInnovationPartnera/s"},
+	{859, "MatrixInc."},
+	{860, "EatonCorporation"},
+	{861, "KYS"},
+	{862, "NayaHealth,Inc."},
+	{863, "Acromag"},
+	{864, "InsuletCorporation"},
+	{865, "WellinksInc."},
+	{866, "ONSemiconductor"},
+	{867, "FREELAPSA"},
+	{868, "FaveroElectronicsSrl"},
+	{869, "BioMechSensorLLC"},
+	{870, "BOLTTSportstechnologiesPrivatelimited"},
+	{871, "SapheInternational"},
+	{872, "MetormoteAB"},
+	{873, "littleBits"},
+	{874, "SetPointMedical"},
+	{875, "BRControlsProductsBV"},
+	{876, "Zipcar"},
+	{877, "AirBoltPtyLtd"},
+	{878, "KeepTruckinInc"},
+	{879, "Motiv,Inc."},
+	{880, "WazombiLabsO"},
+	{881, "ORBCOMM"},
+	{882, "NixieLabs,Inc."},
+	{883, "AppNearMeLtd"},
+	{884, "HolmanIndustries"},
+	{885, "ExpainAS"},
+	{886, "ElectronicTemperatureInstrumentsLtd"},
+	{887, "PlejdAB"},
+	{888, "PropellerHealth"},
+	{889, "ShenzheniMCOElectronicTechnologyCo.,Ltd"},
+	{890, "Algoria"},
+	{891, "ApptionLabsInc."},
+	{892, "CronologicsCorporation"},
+	{893, "MICRODIALtd."},
+	{894, "lulabytesS.L."},
+	{895, "NestecS.A."},
+	{896, "LLC\"MEGA-Fservice\""},
+	{897, "SharpCorporation"},
+	{898, "PrecisionOutcomesLtd"},
+	{899, "KronosIncorporated"},
+	{900, "OCOSMOSCo.,Ltd."},
+	{901, "EmbeddedElectronicSolutionsLtd.dbae2Solutions"},
+	{902, "AtericaInc."},
+	{903, "BluStorPMC,Inc."},
+	{904, "KapschTrafficComAB"},
+	{905, "ActiveBluCorporation"},
+	{906, "KohlerMiraLimited"},
+	{907, "Noke"},
+	{908, "AppionInc."},
+	{909, "ResmedLtd"},
+	{910, "CrownstoneB.V."},
+	{911, "XiaomiInc."},
+	{912, "INFOTECHs.r.o."},
+	{913, "ThingsquareAB"},
+	{914, "T&D"},
+	{915, "LAVAZZAS.p.A."},
+	{916, "NetclearanceSystems,Inc."},
+	{917, "SDATAWAY"},
+	{918, "BLOKSGmbH"},
+	{919, "LEGOSystemA/S"},
+	{920, "ThetatronicsLtd"},
+	{921, "NikonCorporation"},
+	{922, "NeST"},
+	{923, "SouthSiliconValleyMicroelectronics"},
+	{924, "ALEInternational"},
+	{925, "CareViewCommunications,Inc."},
+	{926, "SchoolBoardLimited"},
+	{927, "MolexCorporation"},
+	{928, "IVTWirelessLimited"},
+	{929, "AlpineLabsLLC"},
+	{930, "CanduraInstruments"},
+	{931, "SmartMovtTechnologyCo.,Ltd"},
+	{932, "TokenZeroLtd"},
+	{933, "ACECADEnterpriseCo.,Ltd.(ACECAD)"},
+	{934, "Medela,Inc"},
+	{935, "AeroScout"},
+	{936, "EsrilleInc."},
+	{937, "THINKERLYSRL"},
+	{938, "ExonSp.zo.o."},
+	{939, "MeizuTechnologyCo.,Ltd."},
+	{940, "SmabloLTD"},
+	{941, "XiQ"},
+	{942, "AllswellInc."},
+	{943, "Comm-N-SenseCorpDBAVerigo"},
+	{944, "VIBRADORMGmbH"},
+	{945, "OtodataWirelessNetworkInc."},
+	{946, "PropagationSystemsLimited"},
+	{947, "MidwestInstruments&Controls"},
+	{948, "AlphaNodus,inc."},
+	{949, "petPOMM,Inc"},
+	{950, "Mattel"},
+	{951, "AirblyInc."},
+	{952, "A-SafeLimited"},
+	{953, "FREDERIQUECONSTANTSA"},
+	{954, "MaxscendMicroelectronicsCompanyLimited"},
+	{955, "AbbottDiabetesCare"},
+	{956, "ASBBankLtd"},
+	{957, "amadas"},
+	{958, "AppliedScience,Inc."},
+	{959, "iLumiSolutionsInc."},
+	{960, "ArchSystemsInc."},
+	{961, "EmberTechnologies,Inc."},
+	{962, "SnapchatInc"},
+	{963, "CasambiTechnologiesOy"},
+	{964, "PicoTechnologyInc."},
+	{965, "St.JudeMedical,Inc."},
+	{966, "Intricon"},
+	{967, "StructuralHealthSystems,Inc."},
+	{968, "AvvelInternational"},
+	{969, "GallagherGroup"},
+	{970, "In2thingsAutomationPvt.Ltd."},
+	{971, "SYSDEVSrl"},
+	{972, "VonkilTechnologiesLtd"},
+	{973, "WyndTechnologies,Inc."},
+	{974, "CONTRINEXS.A."},
+	{975, "MIRA,Inc."},
+	{976, "WatteamLtd"},
+	{977, "DensityInc."},
+	{978, "IOTPotIndiaPrivateLimited"},
+	{979, "SigmaConnectivityAB"},
+	{980, "PEGPEREGOSPA"},
+	{981, "WyzelinkSystemsInc."},
+	{982, "YotaDevicesLTD"},
+	{983, "FINSECUR"},
+	{984, "Zen-MeLabsLtd"},
+	{985, "3IWareCo.,Ltd."},
+	{986, "EnOceanGmbH"},
+	{987, "Instabeat,Inc"},
+	{988, "NimaLabs"},
+	{989, "AndreasStihlAG&Co.KG"},
+	{990, "NathanRhoadesLLC"},
+	{991, "GrobTechnologies,LLC"},
+	{992, "Actions(Zhuhai)TechnologyCo.,Limited"},
+	{993, "SPDDevelopmentCompanyLtd"},
+	{994, "SensoanOy"},
+	{995, "QualcommLifeInc"},
+	{996, "Chip-ingAG"},
+	{997, "ffly4u"},
+	{998, "IoTInstrumentsOy"},
+	{999, "TRUEFitnessTechnology"},
+	{1000, "ReinerKartengeraeteGmbH&Co.KG."},
+	{1001, "SHENZHENLEMONJOYTECHNOLOGYCO.,LTD."},
+	{1002, "HelloInc."},
+	{1003, "EvollveInc."},
+	{1004, "JigowattsInc."},
+	{1005, "BASICMICRO.COM,INC."},
+	{1006, "CUBETECHNOLOGIES"},
+	{1007, "foolographyGmbH"},
+	{1008, "CLINK"},
+	{1009, "HestanSmartCookingInc."},
+	{1010, "WindowMasterA/S"},
+	{1011, "FlowscapeAB"},
+	{1012, "PALTechnologiesLtd"},
+	{1013, "WHERE,Inc."},
+	{1014, "ItonTechnologyCorp."},
+	{1015, "OwlLabsInc."},
+	{1016, "RockfordCorp."},
+	{1017, "BeconTechnologiesCo.,Ltd."},
+	{1018, "VyassoftTechnologiesInc"},
+	{1019, "NoxMedical"},
+	{1020, "Kimberly-Clark"},
+	{1021, "TrimbleNavigationLtd."},
+	{1022, "Littelfuse"},
+	{1023, "Withings"},
+	{1024, "i-developerITBeratungUG"},
+	{1025, ""},
+	{1026, "SearsHoldingsCorporation"},
+	{1027, "GantnerElectronicGmbH"},
+	{1028, "AuthomateInc"},
+	{1029, "VertexInternational,Inc."},
+	{1030, "Airtago"},
+	{1031, "SwissAudioSA"},
+	{1032, "ToGetHomeInc."},
+	{1033, "AXIS"},
+	{1034, "Openmatics"},
+	{1035, "JanaCareInc."},
+	{1036, "SenixCorporation"},
+	{1037, "NorthStarBatteryCompany,LLC"},
+	{1038, "SKF(U.K.)Limited"},
+	{1039, "CO-AXTechnology,Inc."},
+	{1040, "FenderMusicalInstruments"},
+	{1041, "LuidiaInc"},
+	{1042, "SEFAM"},
+	{1043, "WirelessCablesInc"},
+	{1044, "LightningProtectionInternationalPtyLtd"},
+	{1045, "UberTechnologiesInc"},
+	{1046, "SODAGmbH"},
+	{1047, "FatigueScience"},
+	{1048, "AlpineElectronicsInc."},
+	{1049, "NovalogyLTD"},
+	{1050, "FridayLabsLimited"},
+	{1051, "OrthoAccelTechnologies"},
+	{1052, "WaterGuru,Inc."},
+	{1053, "BenningElektrotechnikundElektronikGmbH&Co.KG"},
+	{1054, "DellComputerCorporation"},
+	{1055, "KopinCorporation"},
+	{1056, "TecBakeryGmbH"},
+	{1057, "BackboneLabs,Inc."},
+	{1058, "DELSEYSA"},
+	{1059, "ChargifiLimited"},
+	{1060, "TrainesenseLtd."},
+	{1061, "UnifySoftwareandSolutionsGmbH&Co.KG"},
+	{1062, "HusqvarnaAB"},
+	{1063, "Focusfleetandfuelmanagementinc"},
+	{1064, "SmallLoop,LLC"},
+	{1065, "ProlonInc."},
+	{1066, "BDMedical"},
+	{1067, "iMicroMedIncorporated"},
+	{1068, "TictoN.V."},
+	{1069, "MeshtechAS"},
+	{1070, "MemCachierInc."},
+	{1071, "DanfossA/S"},
+	{1072, "SnapStykInc."},
+	{1073, "AmwayCorporation"},
+	{1074, "SilkLabs,Inc."},
+	{1075, "PillsyInc."},
+	{1076, "HatchBaby,Inc."},
+	{1077, "BlocksWearablesLtd."},
+	{1078, "DraysonTechnologies(Europe)Limited"},
+	{1079, "eBestIOTInc."},
+	{1080, "HelvarLtd"},
+	{1081, "RadianceTechnologies"},
+	{1082, "NuhearaLimited"},
+	{1083, "Appsideco.,ltd."},
+	{1084, "DeLaval"},
+	{1085, "CoilerCorporation"},
+	{1086, "Thermomedics,Inc."},
+	{1087, "TentacleSyncGmbH"},
+	{1088, "Valencell,Inc."},
+	{1089, "iProtoXiOy"},
+	{1090, "SECOMCO.,LTD."},
+	{1091, "TuckerInternationalLLC"},
+	{1092, "MetanateLimited"},
+	{1093, "KobianCanadaInc."},
+	{1094, "NETGEAR,Inc."},
+	{1095, "FabtronicsAustraliaPtyLtd"},
+	{1096, "GrandCentrixGmbH"},
+	{1097, "1UPUSA.comllc"},
+	{1098, "SHIMANOINC."},
+	{1099, "NainInc."},
+	{1100, "LifeStyleLock,LLC"},
+	{1101, "VEGAGrieshaberKG"},
+	{1102, "XtravaInc."},
+	{1103, "TTSTooltechnicSystemsAG&Co.KG"},
+	{1104, "TeenageEngineeringAB"},
+	{1105, "TunstallNordicAB"},
+	{1106, "SvepDesignCenterAB"},
+	{1107, "GreenPeakTechnologiesBV"},
+	{1108, "SphinxElectronicsGmbH&CoKG"},
+	{1109, "Atomation"},
+	{1110, "NemikConsultingInc"},
+	{1111, "RFINNOVATION"},
+	{1112, "MiniSolutionCo.,Ltd."},
+	{1113, "Lumenetix,Inc"},
+	{1114, "2048450OntarioInc"},
+	{1115, "SPACEEKLTD"},
+	{1116, "DeltaTCorporation"},
+	{1117, "BostonScientificCorporation"},
+	{1118, "Nuviz,Inc."},
+	{1119, "RealTimeAutomation,Inc."},
+	{1120, "Kolibree"},
+	{1121, "vhfelektronikGmbH"},
+	{1122, "BonsaiSystemsGmbH"},
+	{1123, "FathomSystemsInc."},
+	{1124, "Bellman&Symfon"},
+	{1125, "InternationalForteGroupLLC"},
+	{1126, "CycleLabsSolutionsinc."},
+	{1127, "CodenexOy"},
+	{1128, "KynesimLtd"},
+	{1129, "PalagoAB"},
+	{1130, "INSIGMAINC."},
+	{1131, "PMDSolutions"},
+	{1132, "QingdaoRealtimeTechnologyCo.,Ltd."},
+	{1133, "BEGAGantenbrink-LeuchtenKG"},
+	{1134, "PamborLtd."},
+	{1135, "DevelcoProductsA/S"},
+	{1136, "iDesigns.r.l."},
+	{1137, "TiVoCorp"},
+	{1138, "Control-JPtyLtd"},
+	{1139, "Steelcase,Inc."},
+	{1140, "iApartmentco.,ltd."},
+	{1141, "Icominc."},
+	{1142, "OxstrenWearableTechnologiesPrivateLimited"},
+	{1143, "BlueSparkTechnologies"},
+	{1144, "FarSiteCommunicationsLimited"},
+	{1145, "mywerksystemGmbH"},
+	{1146, "SinosunTechnologyCo.,Ltd."},
+	{1147, "MIYOSHIELECTRONICSCORPORATION"},
+	{1148, "POWERMATLTD"},
+	{1149, "OcclyLLC"},
+	{1150, "OurHubDevIvS"},
+	{1151, "Pro-Mark,Inc."},
+	{1152, "DynometricsInc."},
+	{1153, "QuintraxLimited"},
+	{1154, "POSTuningUdoVosshenrichGmbH&Co.KG"},
+	{1155, "MultiCareSystemsB.V."},
+	{1156, "RevolTechnologiesInc"},
+	{1157, "SKIDATAAG"},
+	{1158, "DEVTECNOLOGIAINDUSTRIA,COMERCIOEMANUTENCAODEEQUIPAMENTOSLTDA.-ME"},
+	{1159, "CentricaConnectedHome"},
+	{1160, "AutomotiveDataSolutionsInc"},
+	{1161, "IgarashiEngineering"},
+	{1162, "TaelekOy"},
+	{1163, "CPElectronicsLimited"},
+	{1164, "VectronixAG"},
+	{1165, "S-LabsSp.zo.o."},
+	{1166, "CompanionMedical,Inc."},
+	{1167, "BlueKitchenGmbH"},
+	{1168, "MattingAB"},
+	{1169, "SOREX-WirelessSolutionsGmbH"},
+	{1170, "ADCTechnology,Inc."},
+	{1171, "LynxemiPteLtd"},
+	{1172, "SENNHEISERelectronicGmbH&Co.KG"},
+	{1173, "LMTMercerGroup,Inc"},
+	{1174, "PolymorphicLabsLLC"},
+	{1175, "CochlearLimited"},
+	{1176, "METERGroup,Inc.USA"},
+	{1177, "RuuviInnovationsLtd."},
+	{1178, "SituneAS"},
+	{1179, "nVisti,LLC"},
+	{1180, "DyOcean"},
+	{1181, "Uhlmann&ZacherGmbH"},
+	{1182, "AND!XORLLC"},
+	{1183, "tictoteAB"},
+	{1184, "Vypin,LLC"},
+	{1185, "PNISensorCorporation"},
+	{1186, "ovrEngineered,LLC"},
+	{1187, "GT-tronicsHKLtd"},
+	{1188, "HerbertWaldmannGmbH&Co.KG"},
+	{1189, "GuangzhouFiiOElectronicsTechnologyCo.,Ltd"},
+	{1190, "VinetechCo.,Ltd"},
+	{1191, "DallasLogicCorporation"},
+	{1192, "BioTex,Inc."},
+	{1193, "DISCOVERYSOUNDTECHNOLOGY,LLC"},
+	{1194, "LINKIOSAS"},
+	{1195, "Harbortronics,Inc."},
+	{1196, "UndagridB.V."},
+	{1197, "ShureInc"},
+	{1198, "ERMElectronicSystemsLTD"},
+	{1199, "BIOROWERHandelsagenturGmbH"},
+	{1200, "WebaSportundMed.ArtikelGmbH"},
+	{1201, "KartographersTechnologiesPvt.Ltd."},
+	{1202, "TheShadowontheMoon"},
+	{1203, "mobike(HongKong)Limited"},
+	{1204, "InuheatGroupAB"},
+	{1205, "SwiftronixAB"},
+	{1206, "DiagnopticsTechnologies"},
+	{1207, "AnalogDevices,Inc."},
+	{1208, "SoraaInc."},
+	{1209, "CSRBuildingProductsLimited"},
+	{1210, "CrestronElectronics,Inc."},
+	{1211, "NeateboxLtd"},
+	{1212, "DraegerwerkAG&Co.KGaA"},
+	{1213, "AlbynMedical"},
+	{1214, "AverosFZCO"},
+	{1215, "VITInitiative,LLC"},
+	{1216, "StatsportsInternational"},
+	{1217, "Sospitas,s.r.o."},
+	{1218, "DmetProductsCorp."},
+	{1219, "MantracourtElectronicsLimited"},
+	{1220, "TeAMHutchinsAB"},
+	{1221, "SeibertWilliamsGlass,LLC"},
+	{1222, "InstaGmbH"},
+	{1223, "SvantekSp.zo.o."},
+	{1224, "ShanghaiFlycoElectricalApplianceCo.,Ltd."},
+	{1225, "ThornwaveLabsInc"},
+	{1226, "Steiner-OptikGmbH"},
+	{1227, "NovoNordiskA/S"},
+	{1228, "EnfluxInc."},
+	{1229, "SafetechProductsLLC"},
+	{1230, "GOOOLEDS.R.L."},
+	{1231, "DOMSicherheitstechnikGmbH&Co.KG"},
+	{1232, "OlympusCorporation"},
+	{1233, "KTSGmbH"},
+	{1234, "AnloqTechnologiesInc."},
+	{1235, "Queercon,Inc"},
+	{1236, "5thElementLtd"},
+	{1237, "GooeeLimited"},
+	{1238, "LUGLOCLLC"},
+	{1239, "Blincam,Inc."},
+	{1240, "FUJIFILMCorporation"},
+	{1241, "RandMcNally"},
+	{1242, "FranceschiMarinasnc"},
+	{1243, "EngineeredAudio,LLC."},
+	{1244, "IOTTIVE(OPC)PRIVATELIMITED"},
+	{1245, "4MODTechnology"},
+	{1246, "LutronElectronicsCo.,Inc."},
+	{1247, "Emerson"},
+	{1248, "Guardtec,Inc."},
+	{1249, "REACTECLIMITED"},
+	{1250, "EllieGrid"},
+	{1251, "UnderArmour"},
+	{1252, "Woodenshark"},
+	{1253, "AvackOy"},
+	{1254, "SmartSolutionTechnology,Inc."},
+	{1255, "REHABTRONICSINC."},
+	{1256, "STABILOInternational"},
+	{1257, "BuschJaegerElektroGmbH"},
+	{1258, "PacificBioscienceLaboratories,Inc"},
+	{1259, "BirdHomeAutomationGmbH"},
+	{1260, "MotorolaSolutions"},
+	{1261, "R9Technology,Inc."},
+	{1262, "Auxivia"},
+	{1263, "DaisyWorks,Inc"},
+	{1264, "KosiLimited"},
+	{1265, "ThebenAG"},
+	{1266, "InDreamerTechsolPrivateLimited"},
+	{1267, "CerevastMedical"},
+	{1268, "ZanComputeInc."},
+	{1269, "PirelliTyreS.P.A."},
+	{1270, "McLearLimited"},
+	{1271, "ShenzhenHuidingTechnologyCo.,Ltd."},
+	{1272, "ConvergenceSystemsLimited"},
+	{1273, "Interactio"},
+	{1274, "AndrotecGmbH"},
+	{1275, "BenchmarkDrivesGmbH&Co.KG"},
+	{1276, "SwingLyncL.L.C."},
+	{1277, "TapkeyGmbH"},
+	{1278, "WoosimSystemsInc."},
+	{1279, "MicrosemiCorporation"},
+	{1280, "WiliotLTD."},
+	{1281, "PolarisIND"},
+	{1282, "Specifi-KaliLLC"},
+	{1283, "Locoroll,Inc"},
+	{1284, "PHYPLUSInc"},
+	{1285, "InplayTechnologiesLLC"},
+	{1286, "Hager"},
+	{1287, "Yellowcog"},
+	{1288, "AxesSystemsp.zo.o."},
+	{1289, "myLIFTERInc."},
+	{1290, "Shake-onB.V."},
+	{1291, "VibrissaInc."},
+	{1292, "OSRAMGmbH"},
+	{1293, "TRSystemsGmbH"},
+	{1294, "YichipMicroelectronics(Hangzhou)Co.,Ltd."},
+	{1295, "FoundationEngineeringLLC"},
+	{1296, "UNI-ELECTRONICS,INC."},
+	{1297, "BrookfieldEquinoxLLC"},
+	{1298, "SoprodSA"},
+	{1299, "9974091CanadaInc."},
+	{1300, "FIBROGmbH"},
+	{1301, "RBControlsCo.,Ltd."},
+	{1302, "Footmarks"},
+	{1303, "AmtronicSverigeAB(formerlyAmcoreAB)"},
+	{1304, "MAMORIO.inc"},
+	{1305, "TytoLifeLLC"},
+	{1306, "LeicaCameraAG"},
+	{1307, "AngeeTechnologiesLtd."},
+	{1308, "EDPS"},
+	{1309, "OFFLineCo.,Ltd."},
+	{1310, "DetectBlueLimited"},
+	{1311, "SetecPtyLtd"},
+	{1312, "TargetCorporation"},
+	{1313, "IAICorporation"},
+	{1314, "NSTech,Inc."},
+	{1315, "MTGCo.,Ltd."},
+	{1316, "HangzhouiMagicTechnologyCo.,Ltd"},
+	{1317, "HONGKONGNANOICTECHNOLOGIESCO.,LIMITED"},
+	{1318, "HoneywellInternationalInc."},
+	{1319, "AlbrechtJUNG"},
+	{1320, "LuneraLightingInc."},
+	{1321, "LumenUAB"},
+	{1322, "KeynesControlsLtd"},
+	{1323, "NovartisAG"},
+	{1324, "GeosatisSA"},
+	{1325, "EXFO,Inc."},
+	{1326, "LEDVANCEGmbH"},
+	{1327, "CenterIDCorp."},
+	{1328, "Adolene,Inc."},
+	{1329, "D&MHoldingsInc."},
+	{1330, "CRESCOWireless,Inc."},
+	{1331, "NuraOperationsPtyLtd"},
+	{1332, "Frontiergadget,Inc."},
+	{1333, "SmartComponentTechnologiesLimited"},
+	{1334, "ZTRControlSystemsLLC"},
+	{1335, "MetaLogicsCorporation"},
+	{1336, "MedelaAG"},
+	{1337, "OPPLELightingCo.,Ltd"},
+	{1338, "SavitechCorp.,"},
+	{1339, "prodigy"},
+	{1340, "ScreenovateTechnologiesLtd"},
+	{1341, "TESASA"},
+	{1342, "CLIM8LIMITED"},
+	{1343, "SilergyCorp"},
+	{1344, "SilverPlus,Inc"},
+	{1345, "Sharknetsrl"},
+	{1346, "MistSystems,Inc."},
+	{1347, "MIWALOCKCO.,Ltd"},
+	{1348, "OrthoSensor,Inc."},
+	{1349, "CandyHooverGroups.r.l"},
+	{1350, "ApexarTechnologiesS.A."},
+	{1351, "LOGICDATAd.o.o."},
+	{1352, "KnickElektronischeMessgeraeteGmbH&Co.KG"},
+	{1353, "SmartTechnologiesandInvestmentLimited"},
+	{1354, "LinoughInc."},
+	{1355, "AdvancedElectronicDesigns,Inc."},
+	{1356, "CarefreeScottFetzerCoInc"},
+	{1357, "Sensome"},
+	{1358, "FORTRONIKstoritved.o.o."},
+	{1359, "Sinnoz"},
+	{1360, "VersaNetworks,Inc."},
+	{1361, "Sylero"},
+	{1362, "AvempaceSARL"},
+	{1363, "NintendoCo.,Ltd."},
+	{1364, "NationalInstruments"},
+	{1365, "KROHNEMesstechnikGmbH"},
+	{1366, "OtodynamicsLtd"},
+	{1367, "ArwinTechnologyLimited"},
+	{1368, "benegear,inc."},
+	{1369, "NewconOptik"},
+	{1370, "CANDYHOUSE,Inc."},
+	{1371, "FRANKLINTECHNOLOGYINC"},
+	{1372, "Lely"},
+	{1373, "ValveCorporation"},
+	{1374, "HekatronVertriebsGmbH"},
+	{1375, "PROTECHS.A.S.DIGIRARDIANDREA&C."},
+	{1376, "SaritaCareTechAPS(formerlySaritaCareTechIVS)"},
+	{1377, "FinderS.p.A."},
+	{1378, "ThalmicLabsInc."},
+	{1379, "SteinelVertriebGmbH"},
+	{1380, "BeghelliSpa"},
+	{1381, "BeijingSmartspaceTechnologiesInc."},
+	{1382, "CORETRANSPORTTECHNOLOGIESNZLIMITED"},
+	{1383, "XiamenEveresportsGoodsCo.,Ltd"},
+	{1384, "BodyportInc."},
+	{1385, "AudionicsSystem,INC."},
+	{1386, "FlipnaviCo.,Ltd."},
+	{1387, "RionCo.,Ltd."},
+	{1388, "LongRangeSystems,LLC"},
+	{1389, "RedmondIndustrialGroupLLC"},
+	{1390, "VIZPININC."},
+	{1391, "BikeFinderAS"},
+	{1392, "ConsumerSleepSolutionsLLC"},
+	{1393, "PSIKICK,INC."},
+	{1394, "AntTail.com"},
+	{1395, "LightingScienceGroupCorp."},
+	{1396, "AFFORDABLEELECTRONICSINC"},
+	{1397, "IntegralMemroyPlc"},
+	{1398, "Globalstar,Inc."},
+	{1399, "TrueWearables,Inc."},
+	{1400, "WellingtonDriveTechnologiesLtd"},
+	{1401, "EnsembleTechPrivateLimited"},
+	{1402, "OMNIRemotes"},
+	{1403, "DuracellU.S.OperationsInc."},
+	{1404, "ToorTechnologiesLLC"},
+	{1405, "InstinctPerformance"},
+	{1406, "Beco,Inc"},
+	{1407, "ScufGamingInternational,LLC"},
+	{1408, "ARANZMedicalLimited"},
+	{1409, "LYSTECHNOLOGIESLTD"},
+	{1410, "BreakwallAnalytics,LLC"},
+	{1411, "CodeBlueCommunications"},
+	{1412, "GiraGiersiepenGmbH&Co.KG"},
+	{1413, "HearingLabTechnology"},
+	{1414, "LEGRAND"},
+	{1415, "DerichsGmbH"},
+	{1416, "ALT-TEKNIKLLC"},
+	{1417, "StarTechnologies"},
+	{1418, "STARTTODAYCO.,LTD."},
+	{1419, "MaximIntegratedProducts"},
+	{1420, "MERCKKommanditgesellschaftaufAktien"},
+	{1421, "JungheinrichAktiengesellschaft"},
+	{1422, "OculusVR,LLC"},
+	{1423, "HENDONSEMICONDUCTORSPTYLTD"},
+	{1424, "Pur3Ltd"},
+	{1425, "ViasatGroupS.p.A."},
+	{1426, "IZITHERM"},
+	{1427, "SpauldingClinicalResearch"},
+	{1428, "KohlerCompany"},
+	{1429, "InorProcessAB"},
+	{1430, "MySmartBlinds"},
+	{1431, "RadioPulseInc"},
+	{1432, "rapitagGmbH"},
+	{1433, "Lazlo326,LLC."},
+	{1434, "TeledyneLecroy,Inc."},
+	{1435, "DataflowSystemsLimited"},
+	{1436, "MacrogigaElectronics"},
+	{1437, "TandemDiabetesCare"},
+	{1438, "Polycom,Inc."},
+	{1439, "Fisher&PaykelHealthcare"},
+	{1440, "RCPSoftwareOy"},
+	{1441, "ShanghaiXiaoyiTechnologyCo.,Ltd."},
+	{1442, "ADHERIUM(NZ)LIMITED"},
+	{1443, "AxiomwareSystemsIncorporated"},
+	{1444, "O.E.M.Controls,Inc."},
+	{1445, "KiirooBV"},
+	{1446, "TeleconMobileLimited"},
+	{1447, "SonosInc"},
+	{1448, "TomAllebrandiConsulting"},
+	{1449, "Monidor"},
+	{1450, "TramexLimited"},
+	{1451, "NofenceAS"},
+	{1452, "GoerTekDynaudioCo.,Ltd."},
+	{1453, "INIA"},
+	{1454, "CARMATEMFG.CO.,LTD"},
+	{1455, "ONvocal"},
+	{1456, "NewTecGmbH"},
+	{1457, "MedallionInstrumentationSystems"},
+	{1458, "CARELINDUSTRIESS.P.A."},
+	{1459, "ParabitSystems,Inc."},
+	{1460, "WhiteHorseScientificltd"},
+	{1461, "verisilicon"},
+	{1462, "ElecsIndustryCo.,Ltd."},
+	{1463, "BeijingPineconeElectronicsCo.,Ltd."},
+	{1464, "AmbystomaLabsInc."},
+	{1465, "SuzhouPairlinkNetworkTechnology"},
+	{1466, "igloohome"},
+	{1467, "OxfordMetricsplc"},
+	{1468, "LevitonMfg.Co.,Inc."},
+	{1469, "ULCRoboticsInc."},
+	{1470, "RFIDGlobalbySoftworkSrL"},
+	{1471, "Real-World-SystemsCorporation"},
+	{1472, "NaluMedical,Inc."},
+	{1473, "P.I.Engineering"},
+	{1474, "GroteIndustries"},
+	{1475, "Runtime,Inc."},
+	{1476, "Codecoupsp.zo.o.sp.k."},
+	{1477, "SELVEGmbH&Co.KG"},
+	{1478, "SmartAnimalTrainingSystems,LLC"},
+	{1479, "LippertComponents,INC"},
+	{1480, "SOMFYSAS"},
+	{1481, "TBSElectronicsB.V."},
+	{1482, "MHLCustomInc"},
+	{1483, "LucentWearLLC"},
+	{1484, "WATTSELECTRONICS"},
+	{1485, "RJBrandsLLC"},
+	{1486, "V-ZUGLtd"},
+	{1487, "BiowatchSA"},
+	{1488, "AnovaAppliedElectronics"},
+	{1489, "LindabAB"},
+	{1490, "frogblueTECHNOLOGYGmbH"},
+	{1491, "AcurableLimited"},
+	{1492, "LAMPLIGHTCo.,Ltd."},
+	{1493, "TEGAM,Inc."},
+	{1494, "ZhuhaiJielitechnologyCo.,Ltd"},
+	{1495, "modum.ioAG"},
+	{1496, "FarmJennyLLC"},
+	{1497, "ToyoElectronicsCorporation"},
+	{1498, "AppliedNeuralResearchCorp"},
+	{1499, "AvidIdentificationSystems,Inc."},
+	{1500, "PetronicsInc."},
+	{1501, "essentimGmbH"},
+	{1502, "QTMedicalINC."},
+	{1503, "VIRTUALCLINIC.DIRECTLIMITED"},
+	{1504, "ViperDesignLLC"},
+	{1505, "Human,Incorporated"},
+	{1506, "stAPPtronicsGmbH"},
+	{1507, "ElementalMachines,Inc."},
+	{1508, "TaiyoYudenCo.,Ltd"},
+	{1509, "INEOENERGY&SYSTEMS"},
+	{1510, "MotionInstrumentsInc."},
+	{1511, "PressurePro"},
+	{1512, "COWBOY"},
+	{1513, "iconmobileGmbH"},
+	{1514, "ACS-Control-SystemGmbH"},
+	{1515, "BayerischeMotorenWerkeAG"},
+	{1516, "GycomSvenskaAB"},
+	{1517, "FujiXeroxCo.,Ltd"},
+	{1518, "GlideInc."},
+	{1519, "SIKOMAS"},
+	{1520, "beken"},
+	{1521, "TheLinuxFoundation"},
+	{1522, "TryandECO.,LTD."},
+	{1523, "SeeScan"},
+	{1524, "Clearity,LLC"},
+	{1525, "GSTAG"},
+	{1526, "DPTechnics"},
+	{1527, "TRACMO,INC."},
+	{1528, "AnkiInc."},
+	{1529, "HagleitnerHygieneInternationalGmbH"},
+	{1530, "KonamiSportsLifeCo.,Ltd."},
+	{1531, "ArbletInc."},
+	{1532, "MasbandoGmbH"},
+	{1533, "Innoseis"},
+	{1534, "Niko"},
+	{1535, "WellnomicsLtd"},
+	{1536, "iRobotCorporation"},
+	{1537, "SchraderElectronics"},
+	{1538, "GeberitInternationalAG"},
+	{1539, "FourthEvolutionInc"},
+	{1540, "Cell2JackLLC"},
+	{1541, "FMWelectronicFuttereru.Maier-WolfOHG"},
+	{1542, "JohnDeere"},
+	{1543, "RookeryTechnologyLtd"},
+	{1544, "KeySafe-Cloud"},
+	{1545, "BUCHILabortechnikAG"},
+	{1546, "IQAirAG"},
+	{1547, "TriaxTechnologiesInc"},
+	{1548, "VuzixCorporation"},
+	{1549, "TDKCorporation"},
+	{1550, "BlueairAB"},
+	{1551, "SignifyNetherlands"},
+	{1552, "ADHGUARDIANUSALLC"},
+	{1553, "BeurerGmbH"},
+	{1554, "PlayfinityAS"},
+	{1555, "HansDinslageGmbH"},
+	{1556, "OnAssetIntelligence,Inc."},
+	{1557, "INTERACTIONCorporation"},
+	{1558, "OS42UG(haftungsbeschraenkt)"},
+	{1559, "WIZCONNECTEDCOMPANYLIMITED"},
+	{1560, "Audio-TechnicaCorporation"},
+	{1561, "SixGuysLabs,s.r.o."},
+	{1562, "R.W.BeckettCorporation"},
+	{1563, "silextechnology,inc."},
+	{1564, "UnivationsLimited"},
+	{1565, "SENSInnovationApS"},
+	{1566, "DiamondKinetics,Inc."},
+	{1567, "PhrameInc."},
+	{1568, "ForciotOy"},
+	{1569, "Noordungd.o.o."},
+	{1570, "BeamLabs,LLC"},
+	{1571, "PhiladelphiaScientific(U.K.)Limited"},
+	{1572, "BiovotionAG"},
+	{1573, "SquarePanda,Inc."},
+	{1574, "Amplifico"},
+	{1575, "WEGS.A."},
+	{1576, "EnstoOy"},
+	{1577, "PHONEPEPVTLTD"},
+	{1578, "LunaticoAstronomiaSL"},
+	{1579, "MinebeaMitsumiInc."},
+	{1580, "ASPionGmbH"},
+	{1581, "Vossloh-SchwabeDeutschlandGmbH"},
+	{1582, "Procept"},
+	{1583, "ONKYOCorporation"},
+	{1584, "AsthreaD.O.O."},
+	{1585, "FortioriDesignLLC"},
+	{1586, "HugoMullerGmbH&CoKG"},
+	{1587, "WangiLaiPLT"},
+	{1588, "FanstelCorp"},
+	{1589, "Crookwood"},
+	{1590, "ELECTRONICAINTEGRALDESONIDOS.A."},
+	{1591, "GiPInnovationToolsGmbH"},
+	{1592, "LXSOLUTIONSPTYLIMITED"},
+	{1593, "ShenzhenMinewTechnologiesCo.,Ltd."},
+	{1594, "ProlojikLimited"},
+	{1595, "KromekGroupPlc"},
+	{1596, "ContecMedicalSystemsCo.,Ltd."},
+	{1597, "XradioTechnologyCo.,Ltd."},
+	{1598, "TheIndoorLab,LLC"},
+	{1599, "LDLTECHNOLOGY"},
+	{1600, "Parkifi"},
+	{1601, "RevenueCollectionSystemsFRANCESAS"},
+	{1602, "BluetrumTechnologyCo.,Ltd"},
+	{1603, "makitacorporation"},
+	{1604, "ApogeeInstruments"},
+	{1605, "BM3"},
+	{1606, "SGVGroupHoldingGmbH&Co.KG"},
+	{1607, "MED-EL"},
+	{1608, "UltuneTechnologies"},
+	{1609, "RyeexTechnologyCo.,Ltd."},
+	{1610, "OpenResearchInstitute,Inc."},
+	{1611, "Scale-Tec,Ltd"},
+	{1612, "ZumtobelGroupAG"},
+	{1613, "iLOQOy"},
+	{1614, "KRUXWorksTechnologiesPrivateLimited"},
+	{1615, "DigitalMatterPtyLtd"},
+	{1616, "Coravin,Inc."},
+	{1617, "StasisLabs,Inc."},
+	{1618, "ITZInnovations-undTechnologiezentrumGmbH"},
+	{1619, "MeggittSA"},
+	{1620, "LedlenserGmbH&Co.KG"},
+	{1621, "RenishawPLC"},
+	{1622, "ZhuHaiAdvanProTechnologyCompanyLimited"},
+	{1623, "MeshtronixLimited"},
+	{1624, "PayexNorgeAS"},
+	{1625, "UnSeenTechnologiesOy"},
+	{1626, "ZoundIndustriesInternationalAB"},
+	{1627, "SesamSolutionsBV"},
+	{1628, "PixArtImagingInc."},
+	{1629, "PanduitCorp."},
+	{1630, "AloAB"},
+	{1631, "RicohCompanyLtd"},
+	{1632, "RTCIndustries,Inc."},
+	{1633, "ModeLightingLimited"},
+	{1634, "ParticleIndustries,Inc."},
+	{1635, "AdvancedTelemetrySystems,Inc."},
+	{1636, "RHATECHNOLOGIESLTD"},
+	{1637, "PureInternationalLimited"},
+	{1638, "WTOWerkzeug-EinrichtungenGmbH"},
+	{1639, "SparkTechnologyLabsInc."},
+	{1640, "BlebTechnologysrl"},
+	{1641, "LivanovaUSA,Inc."},
+	{1642, "BradyWorldwideInc."},
+	{1643, "DewertOkinGmbH"},
+	{1644, "ZtoveApS"},
+	{1645, "VensoEcoSolutionsAB"},
+	{1646, "EurotronikKranjd.o.o."},
+	{1647, "HugTechnologyLtd"},
+	{1648, "GemaSwitzerlandGmbH"},
+	{1649, "BuzzProductsLtd."},
+	{1650, "Kopi"},
+	{1651, "InnovaIdeasLimited"},
+	{1652, "BeSpoon"},
+	{1653, "DecoEnterprises,Inc."},
+	{1654, "ExpaiSolutionsPrivateLimited"},
+	{1655, "InnovationFirst,Inc."},
+	{1656, "SABIKOffshoreGmbH"},
+	{1657, "4iiiiInnovationsInc."},
+	{1658, "TheEnergyConservatory,Inc."},
+	{1659, "I.FARM,INC."},
+	{1660, "Tile,Inc."},
+	{1661, "FormAthleticaInc."},
+	{1662, "MbientLabInc"},
+	{1663, "NETGRIDS.N.C.DIBISSOLIMATTEO,CAMPOREALESIMONE,TOGNETTIFEDERICO"},
+	{1664, "MannkindCorporation"},
+	{1665, "TradeFIDESa.s."},
+	{1666, "PhotronLimited"},
+	{1667, "EltakoGmbH"},
+	{1668, "Dermalapps,LLC"},
+	{1669, "GreenwaldIndustries"},
+	{1670, "inQsCo.,Ltd."},
+	{1671, "CherryGmbH"},
+	{1672, "AmstedDigitalSolutionsInc."},
+	{1673, "Tacxb.v."},
+	{1674, "RaytacCorporation"},
+	{1675, "JiangsuTeranovoTechCo.,Ltd."},
+	{1676, "ChangzhouSoundDragonElectronicsandAcousticsCo.,Ltd"},
+	{1677, "JetBeepInc."},
+	{1678, "RazerInc."},
+	{1679, "JRMGroupLimited"},
+	{1680, "EccrineSystems,Inc."},
+	{1681, "CuriePointAB"},
+	{1682, "GeorgFischerAG"},
+	{1683, "Hach-Danaher"},
+	{1684, "T&ALaboratoriesLLC"},
+	{1685, "KokiHoldingsCo.,Ltd."},
+	{1686, "GunakarPrivateLimited"},
+	{1687, "StemcoProductsInc"},
+	{1688, "WoodITSecurity,LLC"},
+	{1689, "RandomLabSAS"},
+	{1690, "Adero,Inc.(formerlyasTrackR,Inc.)"},
+	{1691, "DragonchipLimited"},
+	{1692, "NoomiAB"},
+	{1693, "VakarosLLC"},
+	{1694, "DeltaElectronics,Inc."},
+	{1695, "FlowMotionTechnologiesAS"},
+	{1696, "OBIQLocationTechnologyInc."},
+	{1697, "CardoSystems,Ltd"},
+	{1698, "GlobalworxGmbH"},
+	{1699, "Nymbus,LLC"},
+	{1700, "SanyoTechnoSolutionsTottoriCo.,Ltd."},
+	{1701, "TEKZITELPTYLTD"},
+	{1702, "RoambeeCorporation"},
+	{1703, "ChipseaTechnologies(ShenZhen)Corp."},
+	{1704, "GDMideaAir-ConditioningEquipmentCo.,Ltd."},
+	{1705, "SoundmaxElectronicsLimited"},
+	{1706, "ProdualOy"},
+	{1707, "HMSIndustrialNetworksAB"},
+	{1708, "IngchipsTechnologyCo.,Ltd."},
+	{1709, "InnovaSeaSystemsInc."},
+	{1710, "SenseQInc."},
+	{1711, "ShoofTechnologies"},
+	{1712, "BRKBrands,Inc."},
+	{1713, "SimpliSafe,Inc."},
+	{1714, "TussockInnovation2013Limited"},
+	{1715, "TheHablabApS"},
+	{1716, "SencilionOy"},
+	{1717, "WabilogicLtd."},
+	{1718, "SociometricSolutions,Inc."},
+	{1719, "iCOGNIZEGmbH"},
+	{1720, "ShadeCraft,Inc"},
+	{1721, "BeflexInc."},
+	{1722, "BeaconzoneLtd"},
+	{1723, "LeaftronixAnalogicSolutionsPrivateLimited"},
+	{1724, "TWSSrl"},
+	{1725, "ABBOy"},
+	{1726, "HitSeedOy"},
+	{1727, "DelcomProductsInc."},
+	{1728, "CAMES.p.A."},
+	{1729, "Alarm.comHoldings,Inc"},
+	{1730, "MeasurlogicInc."},
+	{1731, "KingIElectronics.Co.,Ltd"},
+	{1732, "DreamLabsGmbH"},
+	{1733, "UrbanCompass,Inc"},
+	{1734, "SimmTronicLimited"},
+	{1735, "SomatixInc"},
+	{1736, "Storz&BickelGmbH&Co.KG"},
+	{1737, "MYLAPSB.V."},
+	{1738, "ShenzhenZhongguangInfotechTechnologyDevelopmentCo.,Ltd"},
+	{1739, "Dyeware,LLC"},
+	{1740, "DongguanSmartActionTechnologyCo.,Ltd."},
+	{1741, "DIGCorporation"},
+	{1742, "FIOR&GENTZ"},
+	{1743, "BelpartsN.V."},
+	{1744, "EtekcityCorporation"},
+	{1745, "MeyerSoundLaboratories,Incorporated"},
+	{1746, "CeoTronicsAG"},
+	{1747, "TriTeqLockandSecurity,LLC"},
+	{1748, "DYNAKODETECHNOLOGYPRIVATELIMITED"},
+	{1749, "SensirionAG"},
+	{1750, "JCTHealthcarePtyLtd"},
+	{1751, "FUBAAutomotiveElectronicsGmbH"},
+	{1752, "AWCompany"},
+	{1753, "ShanghaiMountainViewSiliconCo.,Ltd."},
+	{1754, "ZliideTechnologiesApS"},
+	{1755, "AutomaticLabs,Inc."},
+	{1756, "IndustrialNetworkControls,LLC"},
+	{1757, "IntellithingsLtd."},
+	{1758, "Navcast,Inc."},
+	{1759, "HubbellLighting,Inc."},
+	{1760, "Avaya"},
+	{1761, "MilestoneAVTechnologiesLLC"},
+	{1762, "AlangoTechnologiesLtd"},
+	{1763, "SpinlockLtd"},
+	{1764, "Aluna"},
+	{1765, "OPTEXCO.,LTD."},
+	{1766, "NIHONDENGYOKOUSAKU"},
+	{1767, "VELUXA/S"},
+	{1768, "AlmendoTechnologiesGmbH"},
+	{1769, "ZmartfunElectronics,Inc."},
+	{1770, "SafeLineSwedenAB"},
+	{1771, "HoustonRadarLLC"},
+	{1772, "Sigur"},
+	{1773, "JNeadesLtd"},
+	{1774, "AvantisSystemsLimited"},
+	{1775, "ALCARECo.,Ltd."},
+	{1776, "ChargyTechnologies,SL"},
+	{1777, "ShibutaniCo.,Ltd."},
+	{1778, "TrapperDataAB"},
+	{1779, "AlfredInternationalInc."},
+	{1780, "NearFieldSolutionsLtd"},
+	{1781, "VigilTechnologiesInc."},
+	{1782, "VituloPlusBV"},
+	{1783, "WILKASchliesstechnikGmbH"},
+	{1784, "BodyPlusTechnologyCo.,Ltd"},
+	{1785, "happybrushGmbH"},
+	{1786, "EnequiAB"},
+	{1787, "SartoriusAG"},
+	{1788, "TomCommunicationIndustrialCo.,Ltd."},
+	{1789, "ESSEmbeddedSystemSolutionsInc."},
+	{1790, "MahrGmbH"},
+	{1791, "RedpineSignalsInc"},
+	{1792, "TraqFreqLLC"},
+	{1793, "PAFERSTECH"},
+	{1794, "Akcijusabiedriba\"SAFTEHNIKA\""},
+	{1795, "BeijingJingdongCenturyTradingCo.,Ltd."},
+	{1796, "JBXDesignsInc."},
+	{1797, "ABElectrolux"},
+	{1798, "WernhervonBraunCenterforASdvancedResearch"},
+	{1799, "EssityHygieneandHealthAktiebolag"},
+	{1800, "BeInteractiveCo.,Ltd"},
+	{1801, "CarewearCorp."},
+	{1802, "HufHlsbeck&FrstGmbH&Co.KG"},
+	{1803, "ElementProducts,Inc."},
+	{1804, "BeijingWinnerMicroelectronicsCo.,Ltd"},
+	{1805, "SmartSnuggPtyLtd"},
+	{1806, "FiveCoSarl"},
+	{1807, "CaliforniaThingsInc."},
+	{1808, "AudiodoAB"},
+	{1809, "ABAXAS"},
+	{1810, "BullGroupCompanyLimited"},
+	{1811, "RespiriLimited"},
+	{1812, "MindPeaceSafetyLLC"},
+	{1813, "VgyanSolutions"},
+	{1814, "Altonics"},
+	{1815, "iQsquareBV"},
+	{1816, "IDIBAIXenginneering"},
+	{1817, "ECSG"},
+	{1818, "REVSMARTWEARABLEHKCOLTD"},
+	{1819, "Precor"},
+	{1820, "F5Sports,Inc"},
+	/* 1821 - 65534 reserved */
+	{65535, "test"},
+	{0, NULL}};
+
+static const value_string sco_packet[] = {
+	{0, "HV1"},
+	{1, "HV2"},
+	{2, "HV3"},
+	/* 3 - 255 reserved */
+	{0, NULL}};
+
+static const value_string air_mode[] = {
+	{0, "mu-law log"},
+	{1, "A-law log"},
+	{2, "CVSD"},
+	{3, "transparent data"},
+	/* 4 - 255 reserved */
+	{0, NULL}};
+
+static const value_string paging_scheme[] = {
+	{0, "mandatory scheme"},
+	/* 1 - 255 reserved */
+	{0, NULL}};
+
+static const value_string paging_scheme_settings[] = {
+	/* for mandatory scheme: */
+	{0, "R0"},
+	{1, "R1"},
+	{2, "R2"},
+	/* 3 - 255 reserved */
+	{0, NULL}};
+
+static const value_string afh_mode[] = {
+	{0, "AFH disabled"},
+	{1, "AFH enabled"},
+	/* 2 - 255 reserved */
+	{0, NULL}};
+
+static const value_string features_page[] = {
+	{0, "standard features"},
+	{1, "extended features 64-67"},
+	{2, "extended features 128-140"},
+	/* 3 - 255 other feature pages */
+	{0, NULL}};
+
+static const value_string packet_type_table[] = {
+	{0, "1 Mbps only"},
+	{1, "2/3 Mbps"},
+	/* 2 - 255 reserved */
+	{0, NULL}};
+
+static const value_string negotiation_state[] = {
+	{0, "Initiate negotiation"},
+	{1, "The latest received set of negotiable parameters were possible but these parameters are preferred."},
+	{2, "The latest received set of negotiable parameters would cause a reserved slot violation."},
+	{3, "The latest received set of negotiable parameters would cause a latency violation."},
+	{4, "The latest received set of negotiable parameters are not supported."},
+	/* 5 - 255 reserved */
+	{0, NULL}};
+
+static const value_string afh_reporting_mode[] = {
+	{0, "AFH reporting disabled"},
+	{1, "AFH reporting enabled"},
+	/* 2 - 255 reserved */
+	{0, NULL}};
+
+static const value_string io_capabilities[] = {
+	{0, "Display Only"},
+	{1, "Display Yes/No"},
+	{2, "Keyboard Only"},
+	{3, "No Input/No Output"},
+	/* 4 - 255 reserved */
+	{0, NULL}};
+
+static const value_string oob_auth_data[] = {
+	{0, "No OOB Authentication Data received"},
+	{1, "OOB Authentication Data received"},
+	/* 2 - 255 reserved */
+	{0, NULL}};
+
+static const value_string auth_requirements[] = {
+	{0x00, "MITM Protection Not Required - No Bonding"},
+	{0x01, "MITM Protection Required - No Bonding"},
+	{0x02, "MITM Protection Not Required - Dedicated Bonding"},
+	{0x03, "MITM Protection Required - Dedicated Bonding"},
+	{0x04, "MITM Protection Not Required - General Bonding"},
+	{0x05, "MITM Protection Required - General Bonding"},
+	/* 0x06 - 0xff reserved */
+	{0, NULL}};
+
+static const value_string power_adjust_req[] = {
+	{0, "decrement power one step"},
+	{1, "increment power one step"},
+	{2, "increase to maximum power"},
+	/* 3 - 255 reserved */
+	{0, NULL}};
+
+static const value_string power_adjust_res[] = {
+	{0, "not supported"},
+	{1, "changed one step (not min or max)"},
+	{2, "max power"},
+	{3, "min power"},
+	/* 4 - 255 reserved */
+	{0, NULL}};
+
+static const value_string test_scenario[] = {
+	{0, "Pause Test Mode"},
+	{1, "Transmitter test - 0 pattern"},
+	{2, "Transmitter test - 1 pattern"},
+	{3, "Transmitter test - 1010 pattern"},
+	{4, "Pseudorandom bit sequence"},
+	{5, "Closed Loop Back - ACL packets"},
+	{6, "Closed Loop Back - Synchronous packets"},
+	{7, "ACL Packets without whitening"},
+	{8, "Synchronous Packets without whitening"},
+	{9, "Transmitter test - 1111 0000 pattern"},
+	/* 10 - 254 reserved */
+	{255, "Exit Test Mode"},
+	{0, NULL}};
+
+static const value_string hopping_mode[] = {
+	{0, "RX/TX on single frequency"},
+	{1, "Normal hopping"},
+	/* 2 - 255 reserved */
+	{0, NULL}};
+
+static const value_string power_control_mode[] = {
+	{0, "fixed TX output power"},
+	{1, "adaptive power control"},
+	/* 2 - 255 reserved */
+	{0, NULL}};
+
+static const value_string esco_packet_type[] = {
+	{0x00, "NULL/POLL"},
+	{0x07, "EV3"},
+	{0x0C, "EV4"},
+	{0x0D, "EV5"},
+	{0x26, "2-EV3"},
+	{0x2C, "2-EV5"},
+	{0x37, "3-EV3"},
+	{0x3D, "3-EV5"},
+	/* other values reserved */
+	{0, NULL}};
+
+static const value_string notification_value[] = {
+	{0, "passkey entry started"},
+	{1, "passkey digit entered"},
+	{2, "passkey digit erased"},
+	{3, "passkey cleared"},
+	{4, "passkey entry completed"},
+	/* 5 - 255 reserved */
+	{0, NULL}};
+
+/* initialize the subtree pointers */
+static gint ett_lmp = -1;
+static gint ett_lmp_pwradjres = -1;
+static gint ett_lmp_rate = -1;
+static gint ett_lmp_timectrl = -1;
+static gint ett_lmp_features = -1;
+static gint ett_lmp_featuresext = -1;
+
+/* LMP PDUs with short opcodes */
+void dissect_vsc(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	/* TODO implement Broadcom VSC opcodes here:
+	 * 0: Features Request
+	 * 1: Features Response
+	 * 	0 and 1: Features: 0x%02X%02X%02X%02X
+	 * 2: Not Accept
+	 * 	Rejection BPCS Opcode: 0x%02X
+	 * 	Rejection Error Code: 0x%02X
+	 * 3: BFC Suspend
+	 * 4: BFC Resume Request
+	 * 	if receive direction:
+	 * 		BFC Resume Response (instead)
+	 * 	BFC Link State: 0x%02X
+	 * 	BFC Stack State: 0x%02X
+	 * 	BFC Reserved: 0x%02X\
+	 * 5: BFC Accept
+	 * 	BPCS Accepted Opcode: 0x%02X
+	 *
+	 */
+}
+
+void dissect_name_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	proto_tree_add_item(tree, hf_lmp_nameoffset, tvb, offset, 1, ENC_NA);
+}
+
+void dissect_name_res(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 17);
+
+	proto_tree_add_item(tree, hf_lmp_nameoffset, tvb, offset, 1, ENC_NA);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_namelen, tvb, offset, 1, ENC_NA);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_namefrag, tvb, offset, 14, ENC_ASCII | ENC_NA);
+}
+
+void dissect_accepted(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	proto_tree_add_item(tree, hf_lmp_opinre, tvb, offset, 1, ENC_NA);
+}
+
+void dissect_not_accepted(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 3);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 2);
+
+	proto_tree_add_item(tree, hf_lmp_opinre, tvb, offset, 1, ENC_NA);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_err, tvb, offset, 1, ENC_NA);
+}
+
+void dissect_clkoffset_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 1);
+}
+
+void dissect_clkoffset_res(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 3);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 2);
+
+	proto_tree_add_item(tree, hf_lmp_clkoffset, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_detach(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	proto_tree_add_item(tree, hf_lmp_err, tvb, offset, 1, ENC_NA);
+}
+
+void dissect_in_rand(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 17);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 16);
+
+	proto_tree_add_item(tree, hf_lmp_rand, tvb, offset, 16, ENC_NA);
+}
+
+void dissect_comb_key(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 17);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 16);
+
+	proto_tree_add_item(tree, hf_lmp_rand, tvb, offset, 16, ENC_NA);
+}
+
+void dissect_unit_key(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 17);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 16);
+
+	proto_tree_add_item(tree, hf_lmp_key, tvb, offset, 16, ENC_NA);
+}
+
+void dissect_au_rand(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 17);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 16);
+
+	proto_tree_add_item(tree, hf_lmp_rand, tvb, offset, 16, ENC_NA);
+}
+
+void dissect_sres(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 5);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 4);
+
+	proto_tree_add_item(tree, hf_lmp_authres, tvb, offset, 4, ENC_NA);
+}
+
+void dissect_temp_rand(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 17);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 16);
+
+	proto_tree_add_item(tree, hf_lmp_rand, tvb, offset, 16, ENC_NA);
+}
+
+void dissect_temp_key(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 17);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 16);
+
+	proto_tree_add_item(tree, hf_lmp_key, tvb, offset, 16, ENC_NA);
+}
+
+void dissect_encryption_mode_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	proto_tree_add_item(tree, hf_lmp_cryptmode, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_encryption_key_size_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+    proto_tree_add_item(tree, hf_lmp_keysz, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+    int ret = tvb_get_guint8(tvb, offset);
+    DISSECTOR_ASSERT(ret >= 7);
+}
+
+void dissect_start_encryption_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 17);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 16);
+
+	proto_tree_add_item(tree, hf_lmp_rand, tvb, offset, 16, ENC_NA);
+}
+
+void dissect_stop_encryption_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 1);
+}
+
+void dissect_switch_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 5);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 4);
+
+	proto_tree_add_item(tree, hf_lmp_swinst, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_hold(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 7);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 6);
+
+	proto_tree_add_item(tree, hf_lmp_htime, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_hinst, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_hold_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 7);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 6);
+
+	proto_tree_add_item(tree, hf_lmp_htime, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_hinst, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_sniff_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 10);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 9);
+
+	proto_tree_add_bitmask(tree, tvb, offset, hf_lmp_timectrl,
+						   ett_lmp_timectrl, timectrl_fields, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_dsniff, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_tsniff, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_sniffatt, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_sniffto, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_unsniff_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 1);
+}
+
+void dissect_park_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 17);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 16);
+
+	proto_tree_add_bitmask(tree, tvb, offset, hf_lmp_timectrl,
+						   ett_lmp_timectrl, timectrl_fields, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_db, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_tb, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_nb, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_deltab, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_pmaddr, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_araddr, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_nbsleep, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_dbsleep, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_daccess, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_taccess, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_naccslots, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_npoll, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_maccess, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(tree, hf_lmp_accscheme, tvb, offset, 1, ENC_NA);
+}
+
+void dissect_set_broadcast_scan_window(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	int db_present;
+
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	proto_tree_add_bitmask(tree, tvb, offset, hf_lmp_timectrl,
+						   ett_lmp_timectrl, timectrl_fields, ENC_LITTLE_ENDIAN);
+
+	/* bit0 of timing control flags indicates presence of db */
+	db_present = tvb_get_guint8(tvb, offset) & 0x01;
+	offset += 1;
+
+	if (db_present)
+	{
+		DISSECTOR_ASSERT(len == 6);
+		DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 4);
+
+		proto_tree_add_item(tree, hf_lmp_db, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+		offset += 2;
+	}
+	else
+	{
+		DISSECTOR_ASSERT(len == 4);
+		DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 2);
+	}
+
+	proto_tree_add_item(tree, hf_lmp_bsw, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_modify_beacon(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	int db_present;
+
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	proto_tree_add_bitmask(tree, tvb, offset, hf_lmp_timectrl,
+						   ett_lmp_timectrl, timectrl_fields, ENC_LITTLE_ENDIAN);
+
+	/* bit0 of timing control flags indicates presence of db */
+	db_present = tvb_get_guint8(tvb, offset) & 0x01;
+	offset += 1;
+
+	if (db_present)
+	{
+		DISSECTOR_ASSERT(len == 13);
+		DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 11);
+
+		proto_tree_add_item(tree, hf_lmp_db, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+		offset += 2;
+	}
+	else
+	{
+		DISSECTOR_ASSERT(len == 11);
+		DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 9);
+	}
+
+	proto_tree_add_item(tree, hf_lmp_tb, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_nb, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_deltab, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_daccess, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_taccess, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_naccslots, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_npoll, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_maccess, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(tree, hf_lmp_accscheme, tvb, offset, 1, ENC_NA);
+}
+
+void dissect_unpark_bd_addr_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	int db_present;
+	proto_item;
+
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	proto_tree_add_bitmask(tree, tvb, offset, hf_lmp_timectrl,
+						   ett_lmp_timectrl, timectrl_fields, ENC_LITTLE_ENDIAN);
+
+	/* bit0 of timing control flags indicates presence of db */
+	db_present = tvb_get_guint8(tvb, offset) & 0x01;
+	offset += 1;
+
+	if (db_present)
+	{
+		DISSECTOR_ASSERT(len == 17);
+		DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 15);
+
+		proto_tree_add_item(tree, hf_lmp_db, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+		offset += 2;
+	}
+	else
+	{
+		DISSECTOR_ASSERT(len == 15);
+		DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 13);
+	}
+
+	proto_tree_add_item(tree, hf_lmp_ltaddr1, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(tree, hf_lmp_ltaddr2, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_bdaddr1, tvb, offset, 6, ENC_LITTLE_ENDIAN);
+	offset += 6;
+
+	proto_tree_add_item(tree, hf_lmp_bdaddr2, tvb, offset, 6, ENC_LITTLE_ENDIAN);
+	offset += 6;
+}
+
+void dissect_unpark_pm_addr_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	int db_present;
+
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	proto_tree_add_bitmask(tree, tvb, offset, hf_lmp_timectrl,
+						   ett_lmp_timectrl, timectrl_fields, ENC_LITTLE_ENDIAN);
+
+	/* bit0 of timing control flags indicates presence of db */
+	db_present = tvb_get_guint8(tvb, offset) & 0x01;
+	offset += 1;
+
+	if (db_present)
+	{
+		DISSECTOR_ASSERT(len == 15);
+		DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 13);
+
+		proto_tree_add_item(tree, hf_lmp_db, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+		offset += 2;
+	}
+	else
+	{
+		DISSECTOR_ASSERT(len == 13);
+		DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 11);
+	}
+
+	proto_tree_add_item(tree, hf_lmp_ltaddr1, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(tree, hf_lmp_ltaddr2, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_pmaddr1, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_pmaddr2, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_ltaddr3, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(tree, hf_lmp_ltaddr4, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_pmaddr3, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_pmaddr4, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_ltaddr5, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(tree, hf_lmp_ltaddr6, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_pmaddr5, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_pmaddr6, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_ltaddr7, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_pmaddr7, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_incr_power_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+
+	/* skipping one byte "for future use" */
+}
+
+void dissect_decr_power_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+
+	/* skipping one byte "for future use" */
+}
+
+void dissect_max_power(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 1);
+}
+
+void dissect_min_power(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 1);
+}
+
+void dissect_auto_rate(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 1);
+}
+
+void dissect_preferred_rate(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	proto_item *rate_item;
+	proto_tree *rate_tree;
+
+	DISSECTOR_ASSERT(len == 2);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	rate_item = proto_tree_add_item(tree, hf_lmp_rate, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	rate_tree = proto_item_add_subtree(rate_item, ett_lmp_rate);
+
+	proto_tree_add_item(rate_tree, hf_lmp_rate_fec, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(rate_tree, hf_lmp_rate_size, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(rate_tree, hf_lmp_rate_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(rate_tree, hf_lmp_rate_edrsize, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_version_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 6);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 5);
+
+	proto_tree_add_item(tree, hf_lmp_versnr, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_compid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_subversnr, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_version_res(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 6);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 5);
+
+	proto_tree_add_item(tree, hf_lmp_versnr, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_compid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_subversnr, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_features_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 9);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 8);
+
+	proto_tree_add_bitmask(tree, tvb, offset, hf_lmp_features,
+						   ett_lmp_features, features_fields, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_features_res(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 9);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 8);
+
+	proto_tree_add_bitmask(tree, tvb, offset, hf_lmp_features,
+						   ett_lmp_features, features_fields, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_quality_of_service(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 4);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 3);
+
+	proto_tree_add_item(tree, hf_lmp_pollintvl, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_nbc, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_quality_of_service_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 4);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 3);
+
+	proto_tree_add_item(tree, hf_lmp_pollintvl, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_nbc, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_sco_link_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 7);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 6);
+
+	proto_tree_add_item(tree, hf_lmp_scohdl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_bitmask(tree, tvb, offset, hf_lmp_timectrl,
+						   ett_lmp_timectrl, timectrl_fields, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_dsco, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_tsco, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_scopkt, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_airmode, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_remove_sco_link_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 3);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 2);
+
+	proto_tree_add_item(tree, hf_lmp_scohdl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_err, tvb, offset, 1, ENC_NA);
+}
+
+void dissect_max_slot(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	proto_tree_add_item(tree, hf_lmp_maxslots, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_max_slot_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	proto_tree_add_item(tree, hf_lmp_maxslots, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_timing_accuracy_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 1);
+}
+
+void dissect_timing_accuracy_res(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 3);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 2);
+
+	proto_tree_add_item(tree, hf_lmp_drift, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_jitter, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_setup_complete(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 1);
+}
+
+void dissect_use_semi_permanent_key(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 1);
+}
+
+void dissect_host_connection_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 1);
+}
+
+void dissect_slot_offset(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 9);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 8);
+
+	proto_tree_add_item(tree, hf_lmp_slotoffset, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_bdaddr, tvb, offset, 6, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_page_mode_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 3);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 2);
+
+	proto_tree_add_item(tree, hf_lmp_pagesch, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_pssettings, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_page_scan_mode_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 3);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 2);
+
+	proto_tree_add_item(tree, hf_lmp_pagesch, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_pssettings, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_supervision_timeout(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 3);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 2);
+
+	proto_tree_add_item(tree, hf_lmp_suptimeout, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_test_activate(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 1);
+}
+
+void dissect_test_control(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 10);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 9);
+
+	proto_tree_add_uint(tree, hf_lmp_testscen, tvb, offset, 1, tvb_get_guint8(tvb, offset) ^ 0x55);
+	offset += 1;
+
+	proto_tree_add_uint(tree, hf_lmp_hopmode, tvb, offset, 1, tvb_get_guint8(tvb, offset) ^ 0x55);
+	offset += 1;
+
+	proto_tree_add_uint(tree, hf_lmp_txfreq, tvb, offset, 1, (tvb_get_guint8(tvb, offset) ^ 0x55) + 2402); //MHz
+	offset += 1;
+
+	proto_tree_add_uint(tree, hf_lmp_rxfreq, tvb, offset, 1, (tvb_get_guint8(tvb, offset) ^ 0x55) + 2402);
+	offset += 1;
+
+	proto_tree_add_uint(tree, hf_lmp_pcmode, tvb, offset, 1, tvb_get_guint8(tvb, offset) ^ 0x55);
+	offset += 1;
+
+	proto_tree_add_uint(tree, hf_lmp_pollper, tvb, offset, 1, (tvb_get_guint8(tvb, offset) ^ 0x55) * 1.25); //ms
+	offset += 1;
+
+	proto_tree_add_uint(tree, hf_lmp_pkttype, tvb, offset, 1, tvb_get_guint8(tvb, offset) ^ 0x55);
+	offset += 1;
+
+	proto_tree_add_uint(tree, hf_lmp_testlen, tvb, offset, 2, tvb_get_bits16(tvb, offset * 8, 16, ENC_LITTLE_ENDIAN) ^ 0x5555);
+}
+
+void dissect_encryption_key_size_mask_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 1);
+}
+
+void dissect_encryption_key_size_mask_res(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 3);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 2);
+
+	proto_tree_add_item(tree, hf_lmp_ksmask, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_set_afh(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 16);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 15);
+
+	proto_tree_add_item(tree, hf_lmp_afhinst, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+	offset += 4;
+
+	proto_tree_add_item(tree, hf_lmp_afhmode, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_afhchmap, tvb, offset, 10, ENC_NA);
+}
+
+void dissect_encapsulated_header(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 4);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 3);
+
+	proto_tree_add_item(tree, hf_lmp_encmaj, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_encmin, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_enclen, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_encapsulated_payload(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 17);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 16);
+
+	proto_tree_add_item(tree, hf_lmp_encdata, tvb, offset, 16, ENC_NA);
+}
+
+void dissect_simple_pairing_confirm(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 17);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 16);
+
+	proto_tree_add_item(tree, hf_lmp_commit, tvb, offset, 16, ENC_NA);
+}
+
+void dissect_simple_pairing_number(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 17);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 16);
+
+	proto_tree_add_item(tree, hf_lmp_nonce, tvb, offset, 16, ENC_NA);
+}
+
+void dissect_dhkey_check(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 17);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 16);
+
+	proto_tree_add_item(tree, hf_lmp_confirm, tvb, offset, 16, ENC_NA);
+}
+
+/* LMP PDUs with extended opcodes */
+
+void dissect_accepted_ext(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 4);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 2);
+
+	proto_tree_add_item(tree, hf_lmp_opinre, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_eopinre, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_not_accepted_ext(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 5);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 3);
+
+	proto_tree_add_item(tree, hf_lmp_opinre, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_eopinre, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_err, tvb, offset, 1, ENC_NA);
+}
+
+void dissect_features_req_ext(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	int feat_page = 0;
+
+	DISSECTOR_ASSERT(len == 12);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 10);
+
+	proto_tree_add_item(tree, hf_lmp_fpage, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	feat_page = tvb_get_guint8(tvb, offset);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_maxsp, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	if (feat_page == 1)
+	{
+		proto_tree_add_bitmask(tree, tvb, offset, hf_lmp_featuresext,
+							   ett_lmp_featuresext, extfeatures1_fields, ENC_LITTLE_ENDIAN);
+	}
+	else
+	{
+		proto_tree_add_bitmask(tree, tvb, offset, hf_lmp_featuresext,
+							   ett_lmp_featuresext, extfeatures2_fields, ENC_LITTLE_ENDIAN);
+	}
+}
+
+void dissect_features_res_ext(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	int feat_page = 0;
+	DISSECTOR_ASSERT(len == 12);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 10);
+
+	proto_tree_add_item(tree, hf_lmp_fpage, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	feat_page = tvb_get_guint8(tvb, offset);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_maxsp, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	if (feat_page == 1)
+	{
+		proto_tree_add_bitmask(tree, tvb, offset, hf_lmp_featuresext,
+							   ett_lmp_featuresext, extfeatures1_fields, ENC_LITTLE_ENDIAN);
+	}
+	else
+	{
+		proto_tree_add_bitmask(tree, tvb, offset, hf_lmp_featuresext,
+							   ett_lmp_featuresext, extfeatures2_fields, ENC_LITTLE_ENDIAN);
+	}
+}
+
+void dissect_packet_type_table_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 3);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	proto_tree_add_item(tree, hf_lmp_pkttypetbl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_esco_link_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 16);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 14);
+
+	proto_tree_add_item(tree, hf_lmp_escohdl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_escoltaddr, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_bitmask(tree, tvb, offset, hf_lmp_timectrl,
+						   ett_lmp_timectrl, timectrl_fields, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_desco, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_tesco, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_wesco, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_escotypems, tvb, offset, 1, ENC_NA);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_escotypesm, tvb, offset, 1, ENC_NA);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_escolenms, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_escolensm, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_airmode, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_negstate, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_remove_esco_link_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 4);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 2);
+
+	proto_tree_add_item(tree, hf_lmp_escohdl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_err, tvb, offset, 1, ENC_NA);
+}
+
+void dissect_channel_classification_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 7);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 5);
+
+	proto_tree_add_item(tree, hf_lmp_afhrptmode, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_afhminintvl, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_afhmaxintvl, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_channel_classification(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 12);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 10);
+
+	proto_tree_add_item(tree, hf_lmp_afhclass, tvb, offset, 10, ENC_NA);
+}
+
+void dissect_sniff_subrating_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 9);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 7);
+
+	proto_tree_add_item(tree, hf_lmp_maxss, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_minsmt, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_sniffsi, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_sniff_subrating_res(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 9);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 7);
+
+	proto_tree_add_item(tree, hf_lmp_maxss, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_minsmt, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_lmp_sniffsi, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_pause_encryption_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+}
+
+void dissect_resume_encryption_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+}
+
+void dissect_io_capability_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 5);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 3);
+
+	proto_tree_add_item(tree, hf_lmp_iocaps, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_oobauthdata, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_authreqs, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_io_capability_res(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 5);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 3);
+
+	proto_tree_add_item(tree, hf_lmp_iocaps, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_oobauthdata, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_lmp_authreqs, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_numeric_comparison_failed(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+}
+
+void dissect_passkey_failed(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+}
+
+void dissect_oob_failed(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+}
+
+void dissect_keypress_notification(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 3);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	proto_tree_add_item(tree, hf_lmp_nottype, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_power_control_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 3);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	proto_tree_add_item(tree, hf_lmp_pwradjreq, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_power_control_res(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	proto_item *pa_item;
+	proto_tree *pa_tree;
+
+	DISSECTOR_ASSERT(len == 3);
+	DISSECTOR_ASSERT(tvb_reported_length_remaining(tvb, offset) >= 1);
+
+	pa_item = proto_tree_add_item(tree, hf_lmp_pwradjres, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	pa_tree = proto_item_add_subtree(pa_item, ett_lmp_pwradjres);
+
+	proto_tree_add_item(pa_tree, hf_lmp_pwradj_gfsk, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(pa_tree, hf_lmp_pwradj_dqpsk, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(pa_tree, hf_lmp_pwradj_8dpsk, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+}
+
+void dissect_ping_req(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+}
+
+void dissect_ping_res(proto_tree *tree, tvbuff_t *tvb, int offset, int len)
+{
+	DISSECTOR_ASSERT(len == 2);
+}
+
+/* Link Manager Protocol */
+static int
+dissect_btbrlmp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
+{
+	proto_item *lmp_item;
+	proto_tree *lmp_tree;
+	int offset;
+	int len;
+	int op;	 /* opcode */
+	int eop; /* extended opcode */
+
+	// struct timespec start_time;
+	// struct timespec end_time;
+	// clock_gettime(CLOCK_MONOTONIC, &start_time);
+
+	offset = 0;
+	len = tvb_reported_length(tvb);
+
+	DISSECTOR_ASSERT(len >= 1);
+
+	/* make entries in protocol column and info column on summary display */
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "LMP");
+
+	/* clear the info column first just in case of type fetching failure. */
+	col_clear(pinfo->cinfo, COL_INFO);
+	// printf("pinfo->p2p_dir:%d\n",pinfo->p2p_dir);
+	switch (pinfo->p2p_dir)
+	{
+	case P2P_DIR_SENT:
+		col_set_str(pinfo->cinfo, COL_INFO, "TX --> ");
+		break;
+	case P2P_DIR_RECV:
+		col_set_str(pinfo->cinfo, COL_INFO, "RX <-- ");
+		break;
+	default:
+		break;
+	}
+
+	op = tvb_get_guint8(tvb, offset) >> 1;
+
+	if (op == LMP_ESCAPE_4)
+	{
+		DISSECTOR_ASSERT(len >= 2);
+
+		eop = tvb_get_guint8(tvb, offset + 1);
+
+		col_append_str(pinfo->cinfo, COL_INFO, val_to_str(eop, ext_opcode, "Unknown Extended Opcode (%d)"));
+	}
+	else
+	{
+		col_append_str(pinfo->cinfo, COL_INFO, val_to_str(op, opcode, "Unknown Opcode (%d)"));
+	}
+
+	/* see if we are being asked for details */
+	if (!tree)
+		return tvb_reported_length(tvb);
+
+	lmp_item = proto_tree_add_item(tree, proto_btbrlmp, tvb, offset, -1, ENC_NA);
+	lmp_tree = proto_item_add_subtree(lmp_item, ett_lmp);
+
+	proto_tree_add_item(lmp_tree, hf_lmp_tid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+
+	proto_tree_add_item(lmp_tree, hf_lmp_op, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	switch (op)
+	{
+	case LMP_NAME_REQ:
+		dissect_name_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_NAME_RES:
+		dissect_name_res(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_ACCEPTED:
+		dissect_accepted(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_NOT_ACCEPTED:
+		dissect_not_accepted(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_CLKOFFSET_REQ:
+		dissect_clkoffset_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_CLKOFFSET_RES:
+		dissect_clkoffset_res(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_DETACH:
+		dissect_detach(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_IN_RAND:
+		dissect_in_rand(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_COMB_KEY:
+		dissect_comb_key(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_UNIT_KEY:
+		dissect_unit_key(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_AU_RAND:
+		dissect_au_rand(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_SRES:
+		dissect_sres(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_TEMP_RAND:
+		dissect_temp_rand(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_TEMP_KEY:
+		dissect_temp_key(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_ENCRYPTION_MODE_REQ:
+		dissect_encryption_mode_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_ENCRYPTION_KEY_SIZE_REQ:
+		dissect_encryption_key_size_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_START_ENCRYPTION_REQ:
+		dissect_start_encryption_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_STOP_ENCRYPTION_REQ:
+		dissect_stop_encryption_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_SWITCH_REQ:
+		dissect_switch_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_HOLD:
+		dissect_hold(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_HOLD_REQ:
+		dissect_hold_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_SNIFF_REQ:
+		dissect_sniff_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_UNSNIFF_REQ:
+		dissect_unsniff_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_PARK_REQ:
+		dissect_park_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_SET_BROADCAST_SCAN_WINDOW:
+		dissect_set_broadcast_scan_window(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_MODIFY_BEACON:
+		dissect_modify_beacon(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_UNPARK_BD_ADDR_REQ:
+		dissect_unpark_bd_addr_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_UNPARK_PM_ADDR_REQ:
+		dissect_unpark_pm_addr_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_INCR_POWER_REQ:
+		dissect_incr_power_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_DECR_POWER_REQ:
+		dissect_decr_power_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_MAX_POWER:
+		dissect_max_power(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_MIN_POWER:
+		dissect_min_power(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_AUTO_RATE:
+		dissect_auto_rate(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_PREFERRED_RATE:
+		dissect_preferred_rate(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_VERSION_REQ:
+		dissect_version_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_VERSION_RES:
+		dissect_version_res(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_FEATURES_REQ:
+		dissect_features_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_FEATURES_RES:
+		dissect_features_res(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_QUALITY_OF_SERVICE:
+		dissect_quality_of_service(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_QUALITY_OF_SERVICE_REQ:
+		dissect_quality_of_service_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_SCO_LINK_REQ:
+		dissect_sco_link_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_REMOVE_SCO_LINK_REQ:
+		dissect_remove_sco_link_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_MAX_SLOT:
+		dissect_max_slot(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_MAX_SLOT_REQ:
+		dissect_max_slot_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_TIMING_ACCURACY_REQ:
+		dissect_timing_accuracy_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_TIMING_ACCURACY_RES:
+		dissect_timing_accuracy_res(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_SETUP_COMPLETE:
+		dissect_setup_complete(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_USE_SEMI_PERMANENT_KEY:
+		dissect_use_semi_permanent_key(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_HOST_CONNECTION_REQ:
+		dissect_host_connection_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_SLOT_OFFSET:
+		dissect_slot_offset(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_PAGE_MODE_REQ:
+		dissect_page_mode_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_PAGE_SCAN_MODE_REQ:
+		dissect_page_scan_mode_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_SUPERVISION_TIMEOUT:
+		dissect_supervision_timeout(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_TEST_ACTIVATE:
+		dissect_test_activate(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_TEST_CONTROL:
+		dissect_test_control(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_ENCRYPTION_KEY_SIZE_MASK_REQ:
+		dissect_encryption_key_size_mask_req(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_ENCRYPTION_KEY_SIZE_MASK_RES:
+		dissect_encryption_key_size_mask_res(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_SET_AFH:
+		dissect_set_afh(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_ENCAPSULATED_HEADER:
+		dissect_encapsulated_header(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_ENCAPSULATED_PAYLOAD:
+		dissect_encapsulated_payload(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_SIMPLE_PAIRING_CONFIRM:
+		dissect_simple_pairing_confirm(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_SIMPLE_PAIRING_NUMBER:
+		dissect_simple_pairing_number(lmp_tree, tvb, offset, len);
+		break;
+	case LMP_DHKEY_CHECK:
+		dissect_dhkey_check(lmp_tree, tvb, offset, len);
+		break;
+	/*
+	   If the initial 7 bits
+	   of the opcode have one of the special escape values 124-127 then an
+	   additional byte of opcode is located in the second byte of the payload
+	*/
+	case LMP_ESCAPE_1:
+		break;
+	case LMP_ESCAPE_2:
+		break;
+	case LMP_ESCAPE_3:
+		break;
+	case LMP_ESCAPE_4:
+		/* extended opcode */
+		DISSECTOR_ASSERT(len >= 2);
+		proto_tree_add_item(lmp_tree, hf_lmp_eop, tvb, offset, 1, ENC_NA);
+		offset += 1;
+
+		switch (eop)
+		{
+		case LMP_ACCEPTED_EXT:
+			dissect_accepted_ext(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_NOT_ACCEPTED_EXT:
+			dissect_not_accepted_ext(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_FEATURES_REQ_EXT:
+			dissect_features_req_ext(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_FEATURES_RES_EXT:
+			dissect_features_res_ext(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_PACKET_TYPE_TABLE_REQ:
+			dissect_packet_type_table_req(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_ESCO_LINK_REQ:
+			dissect_esco_link_req(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_REMOVE_ESCO_LINK_REQ:
+			dissect_remove_esco_link_req(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_CHANNEL_CLASSIFICATION_REQ:
+			dissect_channel_classification_req(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_CHANNEL_CLASSIFICATION:
+			dissect_channel_classification(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_SNIFF_SUBRATING_REQ:
+			dissect_sniff_subrating_req(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_SNIFF_SUBRATING_RES:
+			dissect_sniff_subrating_res(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_PAUSE_ENCRYPTION_REQ:
+			dissect_pause_encryption_req(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_RESUME_ENCRYPTION_REQ:
+			dissect_resume_encryption_req(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_IO_CAPABILITY_REQ:
+			dissect_io_capability_req(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_IO_CAPABILITY_RES:
+			dissect_io_capability_res(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_NUMERIC_COMPARISON_FAILED:
+			dissect_numeric_comparison_failed(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_PASSKEY_FAILED:
+			dissect_passkey_failed(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_OOB_FAILED:
+			dissect_oob_failed(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_KEYPRESS_NOTIFICATION:
+			dissect_keypress_notification(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_POWER_CONTROL_REQ:
+			dissect_power_control_req(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_POWER_CONTROL_RES:
+			dissect_power_control_res(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_PING_REQ:
+			dissect_ping_req(lmp_tree, tvb, offset, len);
+			break;
+		case LMP_PING_RES:
+			dissect_ping_res(lmp_tree, tvb, offset, len);
+			break;
+		default:
+			break;
+		}
+	default:
+		break;
+	}
+
+	// clock_gettime(CLOCK_MONOTONIC, &end_time);
+	// long measured_latency_ns = ((end_time.tv_sec - start_time.tv_sec) * 1000000000UL) + (end_time.tv_nsec - start_time.tv_nsec) / 1000;
+	// printf("lmp=%ld\n", measured_latency_ns);
+
+	/* Return the amount of data this dissector was able to dissect */
+	return tvb_reported_length(tvb);
+};
+
+/* register the protocol with Wireshark */
+void proto_register_btbrlmp(void)
+{
+
+	/* list of fields */
+	static hf_register_info hf[] = {
+		{&hf_lmp_accscheme,
+		 {"Access Scheme", "btbrlmp.accscheme",
+		  FT_UINT8, BASE_DEC, VALS(access_scheme), 0xf0,
+		  NULL, HFILL}},
+		{&hf_lmp_afhchmap,
+		 {"AFH Channel Map", "btbrlmp.afhchmap",
+		  /* could break out individual channels but long */
+		  FT_BYTES, BASE_NONE, NULL, 0x0,
+		  "Adaptive Frequency Hopping Channel Map", HFILL}},
+		{&hf_lmp_afhclass,
+		 {"AFH Channel Classification", "btbrlmp.afhclass",
+		  /* could break out individual channels but long */
+		  FT_BYTES, BASE_NONE, NULL, 0x0,
+		  "Adaptive Frequency Hopping Channel Classification", HFILL}},
+		{&hf_lmp_afhinst,
+		 {"AFH Instant", "btbrlmp.afhinst",
+		  FT_UINT32, BASE_HEX, NULL, 0x0,
+		  "Adaptive Frequency Hopping Instant (slot)", HFILL}},
+		{&hf_lmp_afhmaxintvl,
+		 {"AFH Max Interval", "btbrlmp.maxintvl",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Adaptive Maximum Interval in slots", HFILL}},
+		{&hf_lmp_afhminintvl,
+		 {"AFH Min Interval", "btbrlmp.minintvl",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Adaptive Minimum Interval in slots", HFILL}},
+		{&hf_lmp_afhmode,
+		 {"AFH Mode", "btbrlmp.afhmode",
+		  FT_UINT8, BASE_DEC, VALS(afh_mode), 0x0,
+		  "Adaptive Frequency Hopping Mode", HFILL}},
+		{&hf_lmp_afhrptmode,
+		 {"AFH Reporting Mode", "btbrlmp.afhrptmode",
+		  FT_UINT8, BASE_DEC, VALS(afh_reporting_mode), 0x0,
+		  "Adaptive Frequency Hopping Reporting Mode", HFILL}},
+		{&hf_lmp_airmode,
+		 {"Air Mode", "btbrlmp.airmode",
+		  FT_UINT8, BASE_HEX, VALS(air_mode), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_araddr,
+		 {"AR_ADDR", "btbrlmp.araddr",
+		  FT_UINT8, BASE_HEX, NULL, 0xfe,
+		  NULL, HFILL}},
+		{&hf_lmp_authreqs,
+		 {"Authentication Requirements", "btbrlmp.authreqs",
+		  FT_UINT8, BASE_HEX, VALS(auth_requirements), 0x00,
+		  NULL, HFILL}},
+		{&hf_lmp_authres,
+		 {"Authentication Response", "btbrlmp.authres",
+		  FT_BYTES, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_bdaddr,
+		 {"BD_ADDR", "btbrlmp.bdaddr",
+		  FT_UINT64, BASE_HEX, NULL, 0x0000ffffffffffff,
+		  NULL, HFILL}},
+		{&hf_lmp_bdaddr1,
+		 {"BD_ADDR 1", "btbrlmp.bdaddr",
+		  FT_UINT64, BASE_HEX, NULL, 0x0000ffffffffffff,
+		  NULL, HFILL}},
+		{&hf_lmp_bdaddr2,
+		 {"BD_ADDR2", "btbrlmp.bdaddr",
+		  FT_UINT64, BASE_HEX, NULL, 0x0000ffffffffffff,
+		  "BD_ADDR 2", HFILL}},
+		{&hf_lmp_bsw,
+		 {"Broadcast Scan Window", "btbrlmp.bsw",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Broadcast Scan Window in slots", HFILL}},
+		{&hf_lmp_clkoffset,
+		 {"Clock Offset", "btbrlmp.clkoffset",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  "Clock Offset in units of 1.25 ms", HFILL}},
+		{&hf_lmp_commit,
+		 {"Commitment Value", "btbrlmp.commit",
+		  FT_BYTES, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_confirm,
+		 {"Confirmation Value", "btbrlmp.confirm",
+		  FT_BYTES, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_compid,
+		 {"Company ID", "btbrlmp.compid",
+		  FT_UINT16, BASE_DEC, VALS(compid), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_cryptmode,
+		 {"Encryption Mode", "btbrlmp.cryptmode",
+		  FT_UINT8, BASE_DEC, VALS(encryption_mode), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_daccess,
+		 {"Daccess", "btbrlmp.daccess",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  "Daccess in slots", HFILL}},
+		{&hf_lmp_db,
+		 {"Db", "btbrlmp.db",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Db in slots", HFILL}},
+		{&hf_lmp_dbsleep,
+		 {"Dbsleep", "btbrlmp.dbsleep",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_deltab,
+		 {"Deltab", "btbrlmp.deltab",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  "Deltab in slots", HFILL}},
+		{&hf_lmp_desco,
+		 {"Desco", "btbrlmp.desco",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  "Desco in slots", HFILL}},
+		{&hf_lmp_drift,
+		 {"Drift", "btbrlmp.drift",
+		  FT_UINT8, BASE_DEC, NULL, 0x0,
+		  "Drift in ppm", HFILL}},
+		{&hf_lmp_dsco,
+		 {"Dsco", "btbrlmp.dsco",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  "Dsco in slots", HFILL}},
+		{&hf_lmp_dsniff,
+		 {"Dsniff", "btbrlmp.dsniff",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Dsniff in slots", HFILL}},
+		{&hf_lmp_encdata,
+		 {"Encapsulated Data", "btbrlmp.encdata",
+		  FT_BYTES, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_enclen,
+		 {"Encapsulated Length", "btbrlmp.enclen",
+		  FT_UINT8, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_encmaj,
+		 {"Encapsulated Major Type", "btbrlmp.encmaj",
+		  FT_UINT8, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_encmin,
+		 {"Encapsulated Minor Type", "btbrlmp.encmin",
+		  FT_UINT8, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_eop,
+		 {"Extended Opcode", "btbrlmp.eop",
+		  FT_UINT8, BASE_DEC, VALS(ext_opcode), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_eopinre,
+		 {"In Response To", "btbrlmp.eopinre",
+		  FT_UINT8, BASE_DEC, VALS(ext_opcode), 0x0,
+		  "Extended Opcode this is in response to", HFILL}},
+		{&hf_lmp_escolenms,
+		 {"Packet Length M -> S", "btbrlmp.escolenms",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  "Packet Length in bytes Master to Slave", HFILL}},
+		{&hf_lmp_escolensm,
+		 {"Packet Length S -> M", "btbrlmp.escolensm",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  "Packet Length in bytes Slave to Master", HFILL}},
+		{&hf_lmp_escotypems,
+		 {"eSCO Packet Type M -> S", "btbrlmp.escotypems",
+		  FT_UINT8, BASE_HEX, VALS(esco_packet_type), 0x0,
+		  "eSCO Packet Type Master to Slave", HFILL}},
+		{&hf_lmp_escotypesm,
+		 {"eSCO Packet Type S -> M", "btbrlmp.escotypesm",
+		  FT_UINT8, BASE_HEX, VALS(esco_packet_type), 0x0,
+		  "eSCO Packet Type Slave to Master", HFILL}},
+		{&hf_lmp_err,
+		 {"Error Code", "btbrlmp.err",
+		  FT_UINT8, BASE_HEX, VALS(error_code), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_escohdl,
+		 {"eSCO Handle", "btbrlmp.escohdl",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_escoltaddr,
+		 {"eSCO LT_ADDR", "btbrlmp.escoltaddr",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  "eSCO Logical Transport Address", HFILL}},
+		{&hf_lmp_features,
+		 {"Features", "btbrlmp.features",
+		  FT_UINT64, BASE_HEX, NULL, 0x0,
+		  "Feature Mask", HFILL}},
+		{&hf_lmp_feat_3slot,
+		 {"3 slot packets", "btbrlmp.feat.3slot",
+		  FT_BOOLEAN, 64, NULL, 0x1,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_5slot,
+		 {"5 slot packets", "btbrlmp.feat.5slot",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 1,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_enc,
+		 {"Encryption", "btbrlmp.feat.enc",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 2,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_slotoff,
+		 {"Slot offset", "btbrlmp.feat.slotoff",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 3,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_timacc,
+		 {"Timing accuracy", "btbrlmp.feat.timacc",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 4,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_rolesw,
+		 {"Role switch", "btbrlmp.feat.rolesw",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 5,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_holdmo,
+		 {"Hold mode", "btbrlmp.feat.holdmo",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 6,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_sniffmo,
+		 {"Sniff mode", "btbrlmp.feat.sniffmo",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 7,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_res0,
+		 {"Reserved", "btbrlmp.feat.res0",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 8,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_pwrctlreq,
+		 {"Power control requests", "btbrlmp.feat.pwrctlreq",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 9,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_cqddr,
+		 {"Channel quality driven data rate (CQDDR)", "btbrlmp.feat.cqddr",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 10,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_sco,
+		 {"SCO link", "btbrlmp.feat.sco",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 11,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_hv2,
+		 {"HV2 packets", "btbrlmp.feat.hv2",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 12,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_hv3,
+		 {"HV3 packets", "btbrlmp.feat.hv3",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 13,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_mulaw,
+		 {"u-law log synchronous data", "btbrlmp.feat.mulaw",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 14,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_alaw,
+		 {"A-law log synchronous data", "btbrlmp.feat.alaw",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 15,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_cvsd,
+		 {"CVSD synchronous data", "btbrlmp.feat.cvsd",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 16,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_pagneg,
+		 {"Paging parameter negotiation", "btbrlmp.feat.pagneg",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 17,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_pwrctl,
+		 {"Power control", "btbrlmp.feat.pwrctl",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 18,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_transsync,
+		 {"Transparent synchronous data", "btbrlmp.feat.transsync",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 19,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_flowctl1,
+		 {"Flow control lag (least significant bit)", "btbrlmp.feat.flowctl1",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 20,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_flowctl2,
+		 {"Flow control lag (middle bit)", "btbrlmp.feat.flowctl2",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 21,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_flowctl3,
+		 {"Flow control lag (most significant bit)", "btbrlmp.feat.flowctl3",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 22,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_bcenc,
+		 {"Broadcast Encryption", "btbrlmp.feat.bcenc",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 23,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_res1,
+		 {"Reserved for future use", "btbrlmp.feat.res1",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 24,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_acl2,
+		 {"Enhanced Data Rate ACL 2 Mb/s mode", "btbrlmp.feat.acl2",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 25,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_acl3,
+		 {"Enhanced Data Rate ACL 3 Mb/s mode", "btbrlmp.feat.acl3",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 26,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_eninq,
+		 {"Enhanced inquiry scan", "btbrlmp.feat.eninq",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 27,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_intinq,
+		 {"Interlaced inquiry scan", "btbrlmp.feat.intinq",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 28,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_intpag,
+		 {"Interlaced page scan", "btbrlmp.feat.intpag",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 29,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_rssiinq,
+		 {"RSSI with inquiry results", "btbrlmp.feat.rssiinq",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 30,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_ev3,
+		 {"Extended SCO link (EV3 packets)", "btbrlmp.feat.ev3",
+		  FT_BOOLEAN, 64, NULL, 0x80000000,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_ev4,
+		 {"EV4 packets", "btbrlmp.feat.ev4",
+		  FT_BOOLEAN, 64, NULL, 0x100000000,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_ev5,
+		 {"EV5 packets", "btbrlmp.feat.ev5",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 1,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_res2,
+		 {"Reserved", "btbrlmp.feat.res2",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 2,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_afhcapsl,
+		 {"AFH capable slave", "btbrlmp.feat.afhcapsl",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 3,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_afhclasl,
+		 {"AFH classification slave", "btbrlmp.feat.afhclasl",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 4,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_bredrnotsup,
+		 {"BR/EDR Not Supported", "btbrlmp.feat.bredrnotsup",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 5,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_lesup,
+		 {"LE Supported (Controller)", "btbrlmp.feat.lesup",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 6,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_3slotenh,
+		 {"3-slot Enhanced Data Rate ACL packets", "btbrlmp.feat.3slotenh",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 7,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_5slotenh,
+		 {"5-slot Enhanced Data Rate ACL packets", "btbrlmp.feat.5slotenh",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 8,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_sniffsubr,
+		 {"Sniff subrating", "btbrlmp.feat.sniffsubr",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 9,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_pauseenc,
+		 {"Pause encryption", "btbrlmp.feat.pauseenc",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 10,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_afhcapma,
+		 {"AFH capable master", "btbrlmp.feat.afhcapma",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 11,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_afhclama,
+		 {"AFH classification master", "btbrlmp.feat.afhclama",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 12,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_esco2,
+		 {"Enhanced Data Rate eSCO 2 Mb/s mode", "btbrlmp.feat.esco2",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 13,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_esco3,
+		 {"Enhanced Data Rate eSCO 3 Mb/s mode", "btbrlmp.feat.esco3",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 14,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_3slotenhesco,
+		 {"3-slot Enhanced Data Rate eSCO packets", "btbrlmp.feat.3slotenhesco",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 15,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_extinqres,
+		 {"Extended Inquiry Response", "btbrlmp.feat.extinqres",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 16,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_simlebredr,
+		 {"Simultaneous LE and BR/EDR to Same Device Capable (Controller)", "btbrlmp.feat.simlebredr",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 17,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_res3,
+		 {"Reserved", "btbrlmp.feat.res3",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 18,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_ssp,
+		 {"Secure Simple Pairing", "btbrlmp.feat.ssp",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 19,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_enpdu,
+		 {"Encapsulated PDU", "btbrlmp.feat.enpdu",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 20,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_edr,
+		 {"Erroneous Data Reporting", "btbrlmp.feat.edr",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 21,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_nonflush,
+		 {"Non-flushable Packet Boundary Flag", "btbrlmp.feat.nonflush",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 22,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_res4,
+		 {"Reserved", "btbrlmp.feat.res4",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 23,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_lstimche,
+		 {"Link Supervision Timeout Changed Event", "btbrlmp.feat.lstimche",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 24,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_inqtxpwr,
+		 {"Inquiry TX Power Level", "btbrlmp.feat.inqtxpwr",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 25,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_enhpwr,
+		 {"Enhanced Power Control", "btbrlmp.feat.enhpwr",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 26,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_res5,
+		 {"Reserved", "btbrlmp.feat.res5",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 27,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_res6,
+		 {"Reserved", "btbrlmp.feat.res6",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 28,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_res7,
+		 {"Reserved", "btbrlmp.feat.res7",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 29,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_res8,
+		 {"Reserved", "btbrlmp.feat.res8",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 30,
+		  NULL, HFILL}},
+		{&hf_lmp_feat_extfeat,
+		 {"Extended features", "btbrlmp.feat.extfeat",
+		  FT_BOOLEAN, 64, NULL, 0x100000000 << 31,
+		  NULL, HFILL}},
+		{&hf_lmp_featuresext,
+		 {"Extended Features", "btbrlmp.featuresext",
+		  FT_UINT64, BASE_HEX, NULL, 0x0,
+		  "Extended Feature Mask", HFILL}},
+		/* extended features page 1 */
+		{&hf_lmp_efeat_ssp,
+		 {"Secure Simple Pairing (Host Support)", "btbrlmp.efeat.ssp",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 0,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_lesup,
+		 {"LE Supported (Host)", "btbrlmp.efeat.lesup",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 1,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_lebredr,
+		 {"Simultaneous LE and BR/EDR to Same Device Capable (Host)", "btbrlmp.efeat.lebredr",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 2,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_sch,
+		 {"Secure Connections (Host Support)", "btbrlmp.efeat.sch",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 3,
+		  NULL, HFILL}},
+		/* extended features page 2 */
+		{&hf_lmp_efeat_csbma,
+		 {"Connectionless Slave Broadcast - Master Operation", "btbrlmp.efeat.csbma",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 0,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_csbsl,
+		 {"Connectionless Slave Broadcast - Slave Operation", "btbrlmp.efeat.csbsl",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 1,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_syntr,
+		 {"Synchronization Train", "btbrlmp.efeat.syntr",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 2,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_synsc,
+		 {"Synchronization Scan", "btbrlmp.efeat.synsc",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 3,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_inqresnote,
+		 {"Inquiry Response Notification Event", "btbrlmp.efeat.inqresnote",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 4,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_genintsc,
+		 {"Generalized interlaced scan", "btbrlmp.efeat.genintsc",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 5,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_ccadj,
+		 {"Coarse Clock Adjustment", "btbrlmp.efeat.ccadj",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 6,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_res0,
+		 {"Reserved for future use", "btbrlmp.efeat.res0",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 7,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_scc,
+		 {"Secure Connections (Controller Support)", "btbrlmp.efeat.scc",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 8,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_ping,
+		 {"Ping", "btbrlmp.efeat.ping",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 9,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_res1,
+		 {"Reserved for future use", "btbrlmp.efeat.res1",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 10,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_trnud,
+		 {"Train nudging", "btbrlmp.efeat.trnud",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 11,
+		  NULL, HFILL}},
+		{&hf_lmp_efeat_sam,
+		 {"Slot Availability Mask", "btbrlmp.efeat.sam",
+		  FT_BOOLEAN, 64, NULL, 0x1 << 12, //typo in the BT standard defines this as >>10 ...
+		  NULL, HFILL}},
+		{&hf_lmp_fpage,
+		 {"Features Page", "btbrlmp.fpage",
+		  FT_UINT8, BASE_DEC, VALS(features_page), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_htime,
+		 {"Hold Time", "btbrlmp.htime",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Hold Time in slots", HFILL}},
+		{&hf_lmp_hinst,
+		 {"Hold Instant", "btbrlmp.hinst",
+		  FT_UINT32, BASE_HEX, NULL, 0x0,
+		  "Hold Instant (slot)", HFILL}},
+		{&hf_lmp_hopmode,
+		 {"Hopping Mode", "btbrlmp.hopmode",
+		  FT_UINT8, BASE_DEC, VALS(hopping_mode), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_iocaps,
+		 {"IO Capabilities", "btbrlmp.iocaps",
+		  FT_UINT8, BASE_DEC, VALS(io_capabilities), 0x0,
+		  "Input/Output Capabilities", HFILL}},
+		{&hf_lmp_jitter,
+		 {"Jitter", "btbrlmp.jitter",
+		  FT_UINT8, BASE_DEC, NULL, 0x0,
+		  "Jitter in microseconds", HFILL}},
+		{&hf_lmp_key,
+		 {"Key", "btbrlmp.key",
+		  FT_BYTES, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_keysz,
+		 {"Key Size", "btbrlmp.keysz",
+		  FT_UINT8, BASE_DEC, NULL, 0x0,
+		  "Key Size in bytes", HFILL}},
+		{&hf_lmp_ksmask,
+		 {"Key Size Mask", "btbrlmp.ksmask",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_ltaddr1,
+		 {"LT_ADDR 1", "btbrlmp.ltaddr",
+		  FT_UINT8, BASE_HEX, NULL, 0x0f,
+		  "Logical Transport Address 1", HFILL}},
+		{&hf_lmp_ltaddr2,
+		 {"LT_ADDR 2", "btbrlmp.ltaddr",
+		  FT_UINT8, BASE_HEX, NULL, 0xf0,
+		  "Logical Transport Address 2", HFILL}},
+		{&hf_lmp_ltaddr3,
+		 {"LT_ADDR 3", "btbrlmp.ltaddr",
+		  FT_UINT8, BASE_HEX, NULL, 0x0f,
+		  "Logical Transport Address 3", HFILL}},
+		{&hf_lmp_ltaddr4,
+		 {"LT_ADDR 4", "btbrlmp.ltaddr",
+		  FT_UINT8, BASE_HEX, NULL, 0xf0,
+		  "Logical Transport Address 4", HFILL}},
+		{&hf_lmp_ltaddr5,
+		 {"LT_ADDR 5", "btbrlmp.ltaddr",
+		  FT_UINT8, BASE_HEX, NULL, 0x0f,
+		  "Logical Transport Address 5", HFILL}},
+		{&hf_lmp_ltaddr6,
+		 {"LT_ADDR 6", "btbrlmp.ltaddr",
+		  FT_UINT8, BASE_HEX, NULL, 0xf0,
+		  "Logical Transport Address 6", HFILL}},
+		{&hf_lmp_ltaddr7,
+		 {"LT_ADDR 7", "btbrlmp.ltaddr",
+		  FT_UINT8, BASE_HEX, NULL, 0x0f,
+		  "Logical Transport Address 7", HFILL}},
+		{&hf_lmp_maccess,
+		 {"Maccess", "btbrlmp.maccess",
+		  FT_UINT8, BASE_HEX, NULL, 0x0f,
+		  "Number of access windows", HFILL}},
+		{&hf_lmp_maxslots,
+		 {"Max Slots", "btbrlmp.maxslots",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_maxsp,
+		 {"Max Supported Page", "btbrlmp.maxsp",
+		  FT_UINT8, BASE_DEC, NULL, 0x0,
+		  "Highest extended features page with non-zero bit", HFILL}},
+		{&hf_lmp_maxss,
+		 {"Max Sniff Subrate", "btbrlmp.maxss",
+		  FT_UINT8, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_minsmt,
+		 {"Min Sniff Mode Timeout", "btbrlmp.minsmt",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Min Sniff Mode Timeout in slots", HFILL}},
+		{&hf_lmp_naccslots,
+		 {"Nacc-slots", "btbrlmp.naccslots",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_namefrag,
+		 {"Name Fragment", "btbrlmp.namefrag",
+		  FT_STRING, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_namelen,
+		 {"Name Length", "btbrlmp.namelen",
+		  FT_UINT8, BASE_DEC, NULL, 0x0,
+		  "Name Length in bytes", HFILL}},
+		{&hf_lmp_nameoffset,
+		 {"Name Offset", "btbrlmp.nameoffset",
+		  FT_UINT8, BASE_DEC, NULL, 0x0,
+		  "Name Offset in bytes", HFILL}},
+		{&hf_lmp_nb,
+		 {"Nb", "btbrlmp.nb",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_nbc,
+		 {"Nbc", "btbrlmp.nbc",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_nbsleep,
+		 {"Nbsleep", "btbrlmp.nbsleep",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_negstate,
+		 {"Negotiation State", "btbrlmp.negstate",
+		  FT_UINT8, BASE_DEC, VALS(negotiation_state), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_nonce,
+		 {"Nonce Value", "btbrlmp.nonce",
+		  FT_BYTES, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_nottype,
+		 {"Notification Type", "btbrlmp.nottype",
+		  FT_UINT8, BASE_DEC, VALS(notification_value), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_npoll,
+		 {"Npoll", "btbrlmp.npoll",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_oobauthdata,
+		 {"OOB Authentication Data", "btbrlmp.oobauthdata",
+		  FT_UINT8, BASE_DEC, VALS(oob_auth_data), 0x00,
+		  NULL, HFILL}},
+		{&hf_lmp_op,
+		 {"Opcode", "btbrlmp.op",
+		  FT_UINT8, BASE_DEC, VALS(opcode), 0xfe,
+		  NULL, HFILL}},
+		{&hf_lmp_opinre,
+		 {"In Response To", "btbrlmp.opinre",
+		  FT_UINT8, BASE_DEC, VALS(opcode), 0x7f,
+		  "Opcode this is in response to", HFILL}},
+		{&hf_lmp_pagesch,
+		 {"Paging Scheme", "btbrlmp.pagesch",
+		  FT_UINT8, BASE_DEC, VALS(paging_scheme), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_pcmode,
+		 {"Power Control Mode", "btbrlmp.pcmode",
+		  FT_UINT8, BASE_DEC, VALS(power_control_mode), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_pkttype,
+		 {"Packet Type", "btbrlmp.pkttype",
+		  /* FIXME break out further */
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  "Packet Type", HFILL}},
+		{&hf_lmp_pkttypetbl,
+		 {"Packet Type Table", "btbrlmp.pkttypetbl",
+		  FT_UINT8, BASE_DEC, VALS(packet_type_table), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_pmaddr,
+		 {"PM_ADDR", "btbrlmp.pmaddr",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_pmaddr1,
+		 {"PM_ADDR 1", "btbrlmp.pmaddr1",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_pmaddr2,
+		 {"PM_ADDR 2", "btbrlmp.pmaddr2",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_pmaddr3,
+		 {"PM_ADDR 3", "btbrlmp.pmaddr3",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_pmaddr4,
+		 {"PM_ADDR 4", "btbrlmp.pmaddr4",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_pmaddr5,
+		 {"PM_ADDR 5", "btbrlmp.pmaddr5",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_pmaddr6,
+		 {"PM_ADDR 6", "btbrlmp.pmaddr6",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_pmaddr7,
+		 {"PM_ADDR 7", "btbrlmp.pmaddr7",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_pollintvl,
+		 {"Poll Interval", "btbrlmp.pollintvl",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Poll Interval in slots", HFILL}},
+		{&hf_lmp_pollper,
+		 {"Poll Period (ms)", "btbrlmp.pollper",
+		  FT_UINT8, BASE_DEC, NULL, 0x0,
+		  "Poll Period in units of 1.25 ms", HFILL}},
+		{&hf_lmp_pssettings,
+		 {"Paging Scheme Settings", "btbrlmp.pssettings",
+		  FT_UINT8, BASE_DEC, VALS(paging_scheme_settings), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_pwradjreq,
+		 {"Power Adjustment Request", "btbrlmp.pwradjreq",
+		  FT_UINT8, BASE_DEC, VALS(power_adjust_req), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_pwradjres,
+		 {"Power Adjustment Response", "btbrlmp.pwradjres",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_pwradj_8dpsk,
+		 {"8DPSK", "btbrlmp.pwradj_8dpsk",
+		  FT_UINT8, BASE_DEC, VALS(power_adjust_res), 0x30,
+		  "8DPSK Power Adjustment Response", HFILL}},
+		{&hf_lmp_pwradj_dqpsk,
+		 {"DQPSK", "btbrlmp.pwradj_dqpsk",
+		  FT_UINT8, BASE_DEC, VALS(power_adjust_res), 0x0C,
+		  "DQPSK Power Adjustment Response", HFILL}},
+		{&hf_lmp_pwradj_gfsk,
+		 {"GFSK", "btbrlmp.pwradj_gfsk",
+		  FT_UINT8, BASE_DEC, VALS(power_adjust_res), 0x03,
+		  "GFSK Power Adjustment Response", HFILL}},
+		{&hf_lmp_rand,
+		 {"Random Number", "btbrlmp.rand",
+		  FT_BYTES, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_rate,
+		 {"Data Rate", "btbrlmp.rate",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_rate_fec,
+		 {"FEC", "btbrlmp.rate.fec",
+		  FT_BOOLEAN, BASE_DEC, TFS(&fec), 0x01,
+		  "Forward Error Correction", HFILL}},
+		{&hf_lmp_rate_size,
+		 {"Packet Size", "btbrlmp.rate.size",
+		  FT_UINT8, BASE_HEX, VALS(packet_size), 0x06,
+		  "Basic Rate Packet Size", HFILL}},
+		{&hf_lmp_rate_type,
+		 {"EDR Type", "btbrlmp.rate.type",
+		  FT_UINT8, BASE_HEX, VALS(edr_type), 0x18,
+		  "Enhanced Data Rate type", HFILL}},
+		{&hf_lmp_rate_edrsize,
+		 {"EDR Size", "btbrlmp.rate.edrsize",
+		  FT_UINT8, BASE_HEX, VALS(packet_size), 0x60,
+		  "Enhanced Data Rate packet size", HFILL}},
+		{&hf_lmp_rxfreq,
+		 {"RX Frequency (MHz)", "btbrlmp.rxfreq",
+		  FT_UINT8, BASE_DEC, NULL, 0x0,
+		  "Receive Frequency in MHz above 2402", HFILL}},
+		{&hf_lmp_scohdl,
+		 {"SCO Handle", "btbrlmp.scohdl",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_scopkt,
+		 {"SCO Packet", "btbrlmp.scopkt",
+		  FT_UINT8, BASE_DEC, VALS(sco_packet), 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_slotoffset,
+		 {"Slot Offset", "btbrlmp.slotoffset",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  "Slot Offset in microseconds", HFILL}},
+		{&hf_lmp_sniffatt,
+		 {"Sniff Attempt", "btbrlmp.sniffatt",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Number of receive slots", HFILL}},
+		{&hf_lmp_sniffsi,
+		 {"Sniff Subrating Instant", "btbrlmp.sniffsi",
+		  FT_UINT32, BASE_HEX, NULL, 0x0,
+		  "Sniff Subrating Instant (slot)", HFILL}},
+		{&hf_lmp_sniffto,
+		 {"Sniff Timeout", "btbrlmp.sniffto",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Number of receive slots", HFILL}},
+		{&hf_lmp_subversnr,
+		 {"SubVersNr", "btbrlmp.subversnr",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  "SubVersion", HFILL}},
+		{&hf_lmp_suptimeout,
+		 {"Supervision Timeout", "btbrlmp.suptimeout",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Supervision Timeout in slots", HFILL}},
+		{&hf_lmp_swinst,
+		 {"Switch Instant", "btbrlmp.swinst",
+		  FT_UINT32, BASE_HEX, NULL, 0x0,
+		  "Switch Instant (slot)", HFILL}},
+		{&hf_lmp_taccess,
+		 {"Taccess", "btbrlmp.taccess",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  "Taccess in slots", HFILL}},
+		{&hf_lmp_tb,
+		 {"Tb", "btbrlmp.tb",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Tb in slots", HFILL}},
+		{&hf_lmp_tesco,
+		 {"Tesco", "btbrlmp.tesco",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  "Tesco in slots", HFILL}},
+		{&hf_lmp_testlen,
+		 {"Test Length", "btbrlmp.testlen",
+		  FT_UINT16, BASE_DEC, NULL, 0x00,
+		  "Length of test sequence in bytes", HFILL}},
+		{&hf_lmp_testscen,
+		 {"Test Scenario", "btbrlmp.testscen",
+		  FT_UINT8, BASE_DEC, VALS(test_scenario), 0x00,
+		  NULL, HFILL}},
+		{&hf_lmp_tid,
+		 {"TID", "btbrlmp.tid",
+		  FT_BOOLEAN, BASE_DEC, TFS(&tid), 0x01,
+		  "Transaction ID", HFILL}},
+		{&hf_lmp_timectrl,
+		 {"Timing Control Flags", "btbrlmp.timectrl",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_lmp_time_change,
+		 {"Timing Change", "btbrlmp.time.change",
+		  FT_BOOLEAN, 8, TFS(&time_change), 0x01,
+		  NULL, HFILL}},
+		{&hf_lmp_time_init,
+		 {"Initialization", "btbrlmp.time.init",
+		  FT_BOOLEAN, 8, TFS(&time_init), 0x02,
+		  NULL, HFILL}},
+		{&hf_lmp_time_accwin,
+		 {"Access Window", "btbrlmp.time.accwin",
+		  FT_BOOLEAN, 8, TFS(&time_accwin), 0x04,
+		  NULL, HFILL}},
+		{&hf_lmp_tsco,
+		 {"Tsco", "btbrlmp.tsco",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  "Tsco in slots", HFILL}},
+		{&hf_lmp_tsniff,
+		 {"Tsniff", "btbrlmp.tsniff",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Tsniff in slots", HFILL}},
+		{&hf_lmp_txfreq,
+		 {"TX Frequency (MHz)", "btbrlmp.txfreq",
+		  FT_UINT8, BASE_DEC, NULL, 0x0,
+		  "Transmit Frequency in MHz above 2402", HFILL}},
+		{&hf_lmp_versnr,
+		 {"VersNr", "btbrlmp.versnr",
+		  FT_UINT8, BASE_DEC, VALS(versnr), 0x0,
+		  "Version", HFILL}},
+		{&hf_lmp_wesco,
+		 {"Wesco", "btbrlmp.wesco",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  "Number of slots in retransmission window", HFILL}},
+	};
+
+	/* protocol subtree arrays */
+	static gint *ett[] = {
+		&ett_lmp,
+		&ett_lmp_pwradjres,
+		&ett_lmp_rate,
+		&ett_lmp_timectrl,
+		&ett_lmp_features,
+		&ett_lmp_featuresext,
+	};
+
+	/* register the protocol name and description */
+	proto_btbrlmp = proto_register_protocol(
+		"ESP32 Bluetooth Link Manager Protocol", /* full name */
+		"esp32_btlmp",						   /* short name */
+		"esp32_btlmp"							   /* abbreviation (e.g. for filters) */
+	);
+
+	register_dissector("esp32_btlmp", dissect_btbrlmp, proto_btbrlmp);
+
+	/* register the header fields and subtrees used */
+	proto_register_field_array(proto_btbrlmp, hf, array_length(hf));
+	proto_register_subtree_array(ett, array_length(ett));
+}
+
+void proto_reg_handoff_btbrlmp(void)
+{
+}
+
+/*
+ * Editor modelines  -  http://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 4
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=4 tabstop=8 expandtab:
+ * :indentSize=4:tabSize=8:noTabs=true:
+ */
diff --git a/plugins/epan/h4bcm/packet-h4bcm.c b/plugins/epan/h4bcm/packet-h4bcm.c
new file mode 100644
index 00000000000..abe7d338569
--- /dev/null
+++ b/plugins/epan/h4bcm/packet-h4bcm.c
@@ -0,0 +1,1570 @@
+/* packet-h4bcm.c
+ * Routines for Bluetooth H4 Broadcom vendor specific additions
+ * Copyright 2019, Jiska Classen / Secure Mobile Networking Lab
+ *
+ * $Id$
+ *
+ * Wireshark - Network traffic analyzer
+ * By Gerald Combs <gerald@wireshark.org>
+ * Copyright 1998 Gerald Combs
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "config.h"
+
+#include <epan/packet.h>
+#include <epan/prefs.h>
+#include <epan/dissectors/packet-bthci_acl.h>
+#include <string.h>
+#include <stdio.h>
+
+/* type definitions for Broadcom diagnostics */
+#define DIA_LM_SENT 0x00
+#define DIA_LM_RECV 0x01
+#define DIA_MEM_PEEK_RESP 0x03
+#define DIA_MEM_DUMP_RESP 0x04
+#define DIA_TEST_COMPL 0x0a
+#define DIA_MEM_POKE_RESP 0x11
+#define DIA_CPU_LOAD_RESP 0x15
+#define DIA_ACL_BR_RESP 0x16
+#define DIA_ACL_EDR_RESP 0x17
+#define DIA_AUX_RESP 0x18
+#define DIA_ACL_UNKN1_RESP 0x1a
+#define DIA_ACL_UNKN2_RESP 0x1b
+#define DIA_CON_RESP 0x1f
+#define DIA_LE_SENT 0x80
+#define DIA_LE_RECV 0x81
+#define DIA_ACL_BR_RESET 0xb9
+#define DIA_ACL_BR_GET 0xc1
+#define DIA_ACL_EDR_GET 0xc2
+#define DIA_AUX_GET 0xc3
+#define DIA_ACL_UNKN1_GET 0xc5
+#define DIA_ACL_UNKN2_GET 0xc6
+#define DIA_CON_GET 0xcf
+#define DIA_LM_ENABLE 0xf0
+#define DIA_MEM_PEEK_GET 0xf1
+#define DIA_MEM_POKE_GET 0xf2
+#define DIA_MEM_DUMP_GET 0xf3
+#define DIA_PKT_TEST 0xf6
+
+/* function prototypes */
+void proto_reg_handoff_h4bcm(void);
+
+/* initialize the protocol and registered fields */
+static int proto_h4bcm = -1;
+static int hf_h4bcm_type = -1;
+static int hf_h4bcm_clock = -1;
+static int hf_h4bcm_maclow = -1;
+static int hf_h4bcm_pldhdr = -1;
+static int hf_h4bcm_aclhdr = -1;
+static int hf_h4bcm_llid = -1;
+static int hf_h4bcm_llid_acl = -1;
+static int hf_h4bcm_acl_fragment = -1;
+static int hf_h4bcm_pldflow = -1;
+static int hf_h4bcm_pldflow_acl = -1;
+static int hf_h4bcm_length = -1;
+static int hf_h4bcm_length_acl = -1;
+static int hf_h4bcm_rfu = -1;
+static int hf_h4bcm_payload = -1;
+static int hf_h4bcm_lm_toggle = -1;
+static int hf_h4bcm_stats_null_rcvd = -1;
+static int hf_h4bcm_stats_poll_rcvd = -1;
+static int hf_h4bcm_stats_dm1_rcvd = -1;
+static int hf_h4bcm_stats_dh1_rcvd = -1;
+static int hf_h4bcm_stats_dv_rcvd = -1;
+static int hf_h4bcm_stats_aux1_rcvd = -1;
+static int hf_h4bcm_stats_dm3_rcvd = -1;
+static int hf_h4bcm_stats_dh3_rcvd = -1;
+static int hf_h4bcm_stats_dm5_rcvd = -1;
+static int hf_h4bcm_stats_dh5_rcvd = -1;
+static int hf_h4bcm_stats_null_tx = -1;
+static int hf_h4bcm_stats_poll_tx = -1;
+static int hf_h4bcm_stats_dm1_tx = -1;
+static int hf_h4bcm_stats_dh1_tx = -1;
+static int hf_h4bcm_stats_dv_tx = -1;
+static int hf_h4bcm_stats_aux1_tx = -1;
+static int hf_h4bcm_stats_dm3_tx = -1;
+static int hf_h4bcm_stats_dh3_tx = -1;
+static int hf_h4bcm_stats_dm5_tx = -1;
+static int hf_h4bcm_stats_dh5_tx = -1;
+static int hf_h4bcm_stats_acl_rx = -1;
+static int hf_h4bcm_stats_acl_tx = -1;
+static int hf_h4bcm_stats_hec_err = -1;
+static int hf_h4bcm_stats_crc_err = -1;
+static int hf_h4bcm_stats_seqn_rep = -1;
+static int hf_h4bcm_stats_soft_rst = -1;
+static int hf_h4bcm_stats_test_tx = -1;
+
+static int hf_h4bcm_stats_test_rx = -1;
+static int hf_h4bcm_stats_test_err = -1;
+static int hf_h4bcm_stats_2dh1_rcvd = -1;
+static int hf_h4bcm_stats_3dh1_rcvd = -1;
+static int hf_h4bcm_stats_2dh3_rcvd = -1;
+static int hf_h4bcm_stats_3dh3_rcvd = -1;
+static int hf_h4bcm_stats_2dh5_rcvd = -1;
+static int hf_h4bcm_stats_3dh5_rcvd = -1;
+static int hf_h4bcm_stats_2dh1_tx = -1;
+static int hf_h4bcm_stats_3dh1_tx = -1;
+static int hf_h4bcm_stats_2dh3_tx = -1;
+static int hf_h4bcm_stats_3dh3_tx = -1;
+static int hf_h4bcm_stats_2dh5_tx = -1;
+static int hf_h4bcm_stats_3dh5_tx = -1;
+static int hf_h4bcm_le_ether = -1;
+static int hf_h4bcm_le_handle = -1;
+static int hf_h4bcm_le_opcode = -1;
+static int hf_h4bcm_le_opcode_ext = -1;
+static int hf_h4bcm_ll_version_ind_versnr = -1;
+static int hf_h4bcm_ll_version_ind_compid = -1;
+static int hf_h4bcm_ll_version_ind_subversnr = -1;
+// Baseband
+static int hf_btbbd = -1;
+// Baseband Metadata
+static int hf_btbbd_meta = -1;
+static int hf_btbbd_clk = -1;
+static int hf_btbbd_channel = -1;
+static int hf_btbbd_ptt = -1;
+static int hf_btbbd_role = -1;
+static int hf_btbbd_tx_encrypted = -1;
+static int hf_btbbd_rx_encrypted = -1;
+static int hf_btbbd_is_eir = -1;
+// Baseband Packet Header
+static int hf_btbbd_pkthdr = -1;
+static int hf_btbbd_ltaddr = -1;
+static int hf_btbbd_type = -1;
+static int hf_btbbd_type_br = -1;
+static int hf_btbbd_type_edr = -1;
+static int hf_btbbd_flags = -1;
+static int hf_btbbd_flow = -1;
+static int hf_btbbd_arqn = -1;
+static int hf_btbbd_seqn = -1;
+static int hf_btbbd_hec = -1;
+// FHS
+static int hf_btbbd_fhs = -1;
+static int hf_btbbd_fhs_parity = -1;
+static int hf_btbbd_fhs_lap = -1;
+static int hf_btbbd_fhs_eir = -1;
+static int hf_btbbd_fhs_sr = -1;
+static int hf_btbbd_fhs_uap = -1;
+static int hf_btbbd_fhs_nap = -1;
+static int hf_btbbd_fhs_class = -1;
+static int hf_btbbd_fhs_ltaddr = -1;
+static int hf_btbbd_fhs_clk = -1;
+static int hf_btbbd_fhs_psmode = -1;
+
+/* initialize the subtree pointers */
+static gint ett_h4bcm = -1;
+static gint ett_h4bcm_pldhdr = -1;
+static gint ett_h4bcm_aclhdr = -1;
+static gint ett_h4bcm_acl_br_stats = -1;
+static gint ett_h4bcm_acl_edr_stats = -1;
+static gint ett_btbbd = -1;
+static gint ett_btbbd_meta = -1;
+static gint ett_btbbd_pkthdr = -1;
+static gint ett_btbbd_fhs = -1;
+
+/* subdissectors */
+static dissector_handle_t btlmp_handle = NULL;
+static dissector_handle_t btl2cap_handle = NULL;
+static dissector_handle_t packetlogger_handle = NULL;
+
+/* reversed Broadcom diagnostic types */
+static const value_string h4bcm_types[] = {
+	{DIA_LM_SENT, "LM Sent"},
+	{DIA_LM_RECV, "LM Received"},
+	{DIA_MEM_PEEK_RESP, "Memory Access Response to Peek"},
+	{DIA_MEM_DUMP_RESP, "Memory Hex Dump Response"},
+	{DIA_TEST_COMPL, "Reported Completed Test"},
+	{DIA_MEM_POKE_RESP, "Memory Access Response to Poke"},
+	{DIA_CPU_LOAD_RESP, "CPU Load"},
+	{DIA_ACL_BR_RESP, "Basic Rate ACL Stats Data"},
+	{DIA_ACL_EDR_RESP, "EDR ACL Stats Data"},
+	{DIA_AUX_RESP, "Received Aux Response"},
+	{DIA_ACL_UNKN1_RESP, "ACL Stats Data (Type 0x1A)"},
+	{DIA_ACL_UNKN2_RESP, "ACL Stats Data (Type 0x1B)"},
+	{DIA_CON_RESP, "Get Connection Response"},
+	{DIA_LE_SENT, "LE LM Sent"}, // Low Energy LL Control PDU LMP Message
+	{DIA_LE_RECV, "LE LM Received"},
+	{DIA_ACL_BR_RESET, "Reset Basic Rate ACL Stats"}, // memclr(DHM_ACLPktStats)
+	{DIA_ACL_BR_GET, "Get Basic Rate ACL Stats"},
+	{DIA_ACL_EDR_GET, "Get EDR ACL Stats"},
+	{DIA_ACL_UNKN1_GET, "Get ACL Stats (Type 0x1A)"}, // BTMUtil_Send_2045_ACL_Stats(0x1a, cmd)
+	{DIA_ACL_UNKN2_GET, "Get ACL Stats (Type 0x1B)"},
+	{DIA_AUX_GET, "Get Aux Stats"},		   // BTMUtil_SendAuxStats
+	{DIA_CON_GET, "Get Connection Stats"}, // ulp_send_connection_stats(0x1F)
+	{DIA_LM_ENABLE, "Toggle LMP Logging"},
+	{DIA_MEM_PEEK_GET, "Memory Peek"},
+	{DIA_MEM_POKE_GET, "Memory Poke"},
+	{DIA_MEM_DUMP_GET, "Memory Hex Dump"},
+	{DIA_PKT_TEST, "BTMMstr_BBPktTest"},
+};
+
+static const value_string llid_codes[] = {
+	{0x0, "undefined"},
+	{0x1, "Continuation fragment of an L2CAP message (ACL-U)"},
+	{0x2, "Start of an L2CAP message or no fragmentation (ACL-U)"},
+	{0x3, "LMP message (ACL-C)"},
+	{0, NULL}};
+
+/* This table is needed due to Brodcoms wrong LMP length passing... */
+static const int lmp_lengths[] = {
+	0,	/* LMP_VSC */
+	2,	/* LMP_NAME_REQ */
+	17, /* LMP_NAME_RES */
+	2,	/* LMP_ACCEPTED */
+	3,	/* LMP_NOT_ACCEPTED */
+	1,	/* LMP_CLKOFFSET_REQ */
+	3,	/* LMP_CLKOFFSET_RES */
+	2,	/* LMP_DETACH */
+	17, /* LMP_IN_RAND */
+	17, /* LMP_COMB_KEY */
+	17, /* LMP_UNIT_KEY */
+	17, /* LMP_AU_RAND */
+	5,	/* LMP_SRES */
+	17, /* LMP_TEMP_RAND */
+	17, /* LMP_TEMP_KEY */
+	2,	/* LMP_ENCRYPTION_MODE_REQ */
+	2,	/* LMP_ENCRYPTION_KEY_SIZE_REQ */
+	17, /* LMP_START_ENCRYPTION_REQ */
+	1,	/* LMP_STOP_ENCRYPTION_REQ */
+	5,	/* LMP_SWITCH_REQ */
+	7,	/* LMP_HOLD */
+	7,	/* LMP_HOLD_REQ */
+	10, /* LMP_SNIFF_REQ */
+	0,
+	1,	/* LMP_UNSNIFF_REQ */
+	17, /* LMP_PARK_REQ */
+	0,
+	4,	/* LMP_SET_BROADCAST_SCAN_WINDOW */
+	11, /* LMP_MODIFY_BEACON */
+	15, /* LMP_UNPARK_BD_ADDR_REQ */
+	13, /* LMP_UNPARK_PM_ADDR_REQ */
+	2,	/* LMP_INCR_POWER_REQ */
+	2,	/* LMP_DECR_POWER_REQ */
+	1,	/* LMP_MAX_POWER */
+	1,	/* LMP_MIN_POWER */
+	1,	/* LMP_AUTO_RATE */
+	2,	/* LMP_PREFERRED_RATE */
+	6,	/* LMP_VERSION_REQ */
+	6,	/* LMP_VERSION_RES */
+	9,	/* LMP_FEATURES_REQ */
+	9,	/* LMP_FEATURES_RES */
+	4,	/* LMP_QUALITY_OF_SERVICE */
+	4,	/* LMP_QUALITY_OF_SERVICE_REQ */
+	7,	/* LMP_SCO_LINK_REQ */
+	3,	/* LMP_REMOVE_SCO_LINK_REQ */
+	2,	/* LMP_MAX_SLOT */
+	2,	/* LMP_MAX_SLOT_REQ */
+	1,	/* LMP_TIMING_ACCURACY_REQ */
+	3,	/* LMP_TIMING_ACCURACY_RES */
+	1,	/* LMP_SETUP_COMPLETE */
+	1,	/* LMP_USE_SEMI_PERMANENT_KEY */
+	1,	/* LMP_HOST_CONNECTION_REQ */
+	9,	/* LMP_SLOT_OFFSET */
+	3,	/* LMP_PAGE_MODE_REQ */
+	3,	/* LMP_PAGE_SCAN_MODE_REQ */
+	3,	/* LMP_SUPERVISION_TIMEOUT */
+	1,	/* LMP_TEST_ACTIVATE */
+	10, /* LMP_TEST_CONTROL */
+	1,	/* LMP_ENCRYPTION_KEY_SIZE_MASK_REQ */
+	3,	/* LMP_ENCRYPTION_KEY_SIZE_MASK_RES */
+	16, /* LMP_SET_AFH */
+	4,	/* LMP_ENCAPSULATED_HEADER */
+	17, /* LMP_ENCAPSULATED_PAYLOAD */
+	17, /* LMP_SIMPLE_PAIRING_CONFIRM */
+	17, /* LMP_SIMPLE_PAIRING_NUMBER */
+	17, /* LMP_DHKEY_CHECK */
+};
+
+static const int lmp_lengths_ext[] = {
+	0,
+	4,	/* LMP_ACCEPTED_EXT */
+	5,	/* LMP_NOT_ACCEPTED_EXT */
+	12, /* LMP_FEATURES_REQ_EXT */
+	12, /* LMP_FEATURES_RES_EXT */
+	0,
+	0,
+	0,
+	0,
+	0,
+	0,
+	3,	/* LMP_PACKET_TYPE_TABLE_REQ */
+	16, /* LMP_ESCO_LINK_REQ */
+	4,	/* LMP_REMOVE_ESCO_LINK_REQ */
+	0,
+	0,
+	7,	/* LMP_CHANNEL_CLASSIFICATION_REQ */
+	12, /* LMP_CHANNEL_CLASSIFICATION */
+	0,
+	0,
+	0,
+	9, /* LMP_SNIFF_SUBRATING_REQ */
+	9, /* LMP_SNIFF_SUBRATING_RES */
+	2, /* LMP_PAUSE_ENCRYPTION_REQ */
+	2, /* LMP_RESUME_ENCRYPTION_REQ */
+	5, /* LMP_IO_CAPABILITY_REQ */
+	5, /* LMP_IO_CAPABILITY_RES */
+	2, /* LMP_NUMERIC_COMPARISON_FAILED */
+	2, /* LMP_PASSKEY_FAILED */
+	2, /* LMP_OOB_FAILED */
+	3, /* LMP_KEYPRESS_NOTIFICATION */
+	3, /* LMP_POWER_CONTROL_REQ */
+	3, /* LMP_POWER_CONTROL_RES */
+	2, /* LMP_PING_REQ */
+	2, /* LMP_PING_RES */
+};
+
+/* Bluetooth 5.0 specification p. 2589 */
+static const value_string lm_le_opcodes[] = {
+	{0x0, "LE LL Connection Update Request"},
+	{0x1, "LE LL Channel Map Request"},
+	{0x2, "LE LL Terminate Indication"},
+	{0x3, "LE LL Encryption Request"},
+	{0x4, "LE LL Encryption Response"},
+	{0x5, "LE LL Start Encryption Request"},
+	{0x6, "LE LL Start Encryption Response"},
+	{0x7, "LE LL Unknown Response"},
+	{0x8, "LE LL Feature Request"},
+	{0x9, "LE LL Feature Response"},
+	{0xa, "LE LL Pause Encryption Request"},
+	{0xb, "LE LL Pause Encryption Response"},
+	{0xc, "LE LL Version Indication"},
+	{0xd, "LE LL Reject Indication"},
+	{0xe, "LE LL Slave Feture Request"},
+	{0xf, "LE LL Connection Parameter Request"},
+	{0x10, "LE LL Connection Parameter Response"},
+	{0x11, "LE LL Extended Reject Indication"},
+	{0x12, "LE LL Ping Request"},
+	{0x13, "LE LL Ping Response"},
+	{0x14, "LE LL Length Request"},
+	{0x15, "LE LL Length Response"},
+	{0x16, "LE LL Update Indication"},
+	{0x17, "LE LL Physical Layers Request"},
+	{0x18, "LE LL Physical Layers Response"},
+	{0x19, "LE LL Minimum Number of Used Channels Indication"},
+	{0xff, "LE LL Broadcom Vendor Specific"},
+	{0, NULL}};
+
+static const value_string lm_le_opcodes_ext[] = {
+	{0x1, "LE LL Vendor Specific Feature Request"},
+	{0x2, "LE LL Vendor Specific Feature Response"},
+	{0x3, "LE LL Vendor Specific Enable Bcs Timeline"},
+	{0x4, "LE LL Random Address Change"},
+	{0, NULL}};
+
+static const true_false_string lm_toggle = {
+	"true",
+	"false"};
+
+static const true_false_string packet_table_type_bits = {
+	"EDR", // Enhanced Data Rate
+	"BR",  // Basic Rate
+};
+
+static const true_false_string packet_role_bits = {
+	"Slave",
+	"Master",
+};
+
+static const value_string packet_types[] = {
+	/* generic names for unknown logical transport */
+	{0x0, "NULL"},
+	{0x1, "POLL"},
+	{0x2, "FHS"},
+	{0x3, "DM1"},
+	{0x4, "DH1/2-DH1"},
+	{0x5, "HV1"},
+	{0x6, "HV2/2-EV3"},
+	{0x7, "HV3/EV3/3-EV3"},
+	{0x8, "DV/3-DH1"},
+	{0x9, "AUX1"},
+	{0xa, "DM3/2-DH3"},
+	{0xb, "DH3/3-DH3"},
+	{0xc, "EV4/2-EV5"},
+	{0xd, "EV5/3-EV5"},
+	{0xe, "DM5/2-DH5"},
+	{0xf, "DH5/3-DH5"},
+	{0, NULL}};
+
+static const value_string packet_types_br[] = {
+	/* generic names for unknown logical transport */
+	{0x0, "NULL"},
+	{0x1, "POLL"},
+	{0x2, "FHS"},
+	{0x3, "DM1"},
+	{0x4, "DH1"},
+	{0x9, "AUX1"},
+	{0xa, "DM3"},
+	{0xb, "DH3"},
+	{0xe, "DM5"},
+	{0xf, "DH5"},
+	{0, NULL}};
+
+static const value_string packet_types_edr[] = {
+	/* generic names for unknown logical transport */
+	{0x0, "NULL"},
+	{0x1, "POLL"},
+	{0x2, "FHS"},
+	{0x3, "DM1"},
+	{0x4, "2-DH1"},
+	{0x8, "3-DH1"},
+	{0x9, "AUX1"},
+	{0xa, "2-DH3"},
+	{0xb, "3-DH3"},
+	{0xe, "2-DH5"},
+	{0xf, "3-DH5"},
+	{0, NULL}};
+
+static const value_string sr_modes[] = {
+	{0x0, "R0"},
+	{0x1, "R1"},
+	{0x2, "R2"},
+	{0x3, "Reserved"},
+	{0, NULL}};
+
+static const range_string ps_modes[] = {
+	{0x0, 0x0, "Mandatory scan mode"},
+	{0x1, 0x7, "Reserved"},
+	{0, 0, NULL}};
+
+/* one byte payload header */
+static int dissect_payload_header1(proto_tree *tree, tvbuff_t *tvb, int offset)
+{
+	proto_item *hdr_item;
+	proto_tree *hdr_tree;
+
+	hdr_item = proto_tree_add_item(tree, hf_h4bcm_pldhdr, tvb, offset, 1, ENC_NA);
+	hdr_tree = proto_item_add_subtree(hdr_item, ett_h4bcm_pldhdr);
+
+	proto_tree_add_item(hdr_tree, hf_h4bcm_llid, tvb, offset, 1, ENC_NA);
+	proto_tree_add_item(hdr_tree, hf_h4bcm_pldflow, tvb, offset, 1, ENC_NA);
+	proto_tree_add_item(hdr_tree, hf_h4bcm_length, tvb, offset, 1, ENC_NA);
+
+	/* payload length */
+	return tvb_get_guint8(tvb, offset) >> 3;
+}
+
+/* two byte payload header */
+static int dissect_payload_header_acl_edr(proto_tree *tree, tvbuff_t *tvb, int offset)
+{
+	proto_item *hdr_item;
+	proto_tree *hdr_tree;
+
+	hdr_item = proto_tree_add_item(tree, hf_h4bcm_aclhdr, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	hdr_tree = proto_item_add_subtree(hdr_item, ett_h4bcm_aclhdr);
+
+	proto_tree_add_item(hdr_tree, hf_h4bcm_llid_acl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(hdr_tree, hf_h4bcm_pldflow_acl, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(hdr_tree, hf_h4bcm_length_acl, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(hdr_tree, hf_h4bcm_rfu, tvb, offset + 1, 2, ENC_LITTLE_ENDIAN);
+
+	/* payload length */
+	return (tvb_get_guint16(tvb, offset, ENC_LITTLE_ENDIAN) >> 3) & 0x3FF;
+}
+
+/* Dissect common LM and LE LM header */
+static void dissect_lm_header(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int is_sent)
+{
+	guint32 mac;
+	gchar *mac_string = (gchar *)g_malloc(12);
+
+	/* LMP and LCP are only transmitted within full diagnostic reports */
+	DISSECTOR_ASSERT(tvb_reported_length(tvb) == 63);
+
+	/* clock of the BT master */
+	proto_tree_add_item(tree, hf_h4bcm_clock, tvb, offset, 4, ENC_BIG_ENDIAN);
+	offset += 4;
+
+	/* decode and display MAC address in src/dst fields */
+	mac = tvb_get_guint32(tvb, offset, ENC_BIG_ENDIAN);
+	g_snprintf(mac_string, 12,
+			   "%02x:%02x:%02x:%02x",
+			   (mac & 0xff000000) >> 24,
+			   (mac & 0x00ff0000) >> 16,
+			   (mac & 0x0000ff00) >> 8,
+			   (mac & 0x000000ff));
+
+	proto_tree_add_item(tree, hf_h4bcm_maclow, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+
+	if (is_sent == 1)
+	{
+		col_set_str(pinfo->cinfo, COL_RES_DL_SRC, "controller");
+		col_set_str(pinfo->cinfo, COL_RES_DL_DST, mac_string);
+	}
+	else
+	{
+		col_set_str(pinfo->cinfo, COL_RES_DL_SRC, mac_string);
+		col_set_str(pinfo->cinfo, COL_RES_DL_DST, "controller");
+	}
+}
+
+/* Pass LMP handling to existing dissector if available */
+static void dissect_lmp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset)
+{
+	int len;
+	int opcode;
+	int dm1_hdr;
+	tvbuff_t *pld_tvb;
+
+	/* LMP is only transmitted within full diagnostic reports */
+	DISSECTOR_ASSERT(tvb_reported_length(tvb) == 63);
+
+	/* DM1 header is common in both directions */
+	dm1_hdr = tvb_get_guint8(tvb, offset);
+	len = dissect_payload_header1(tree, tvb, offset);
+
+	/* Longest LMP packet is 17 bytes */
+	DISSECTOR_ASSERT(len <= 17);
+
+	offset += 1;
+
+	/* In receive direction, diagnostic LMP always sends a packet length 17,
+	 * which makes failed assertions inside the LMP decoder...
+	 * The fixed length corresponds to a DM1 header of 0x8f in flow direction
+	 * receive, so we can check this directly instead of maybe re-checking
+	 * valid length 17 in sent direction.
+	 * This fix is really ugly, but it makes the LMP decoders assertions pass.
+	 */
+	if (dm1_hdr == 0x8f)
+	{
+		/* Get normal / extended opcode length. Will be 0 if undefined. */
+		len = 0;
+		opcode = tvb_get_guint8(tvb, offset) >> 1;
+		if (opcode <= 65)
+		{
+			len = lmp_lengths[opcode];
+		}
+		else if (opcode == 127)
+		{
+			opcode = tvb_get_guint8(tvb, offset + 1);
+			if (opcode <= 32)
+			{
+				len = lmp_lengths_ext[opcode];
+			}
+		}
+	}
+
+	/* Check that we have a LMP dissector or else just display raw payload */
+	if (btlmp_handle && len != 0)
+	{
+		pld_tvb = tvb_new_subset_length_caplen(tvb, offset, len, len);
+		call_dissector(btlmp_handle, pld_tvb, pinfo, tree);
+	}
+	else
+	{
+		/* Maximum (constant) LMP length is 17 */
+		proto_tree_add_item(tree, hf_h4bcm_payload, tvb, offset, 17, ENC_LITTLE_ENDIAN);
+	}
+}
+
+/* Pass ACL handling to existing dissector if available */
+static int dissect_acl(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
+{
+	tvbuff_t *pld_tvb;
+	int len;
+	int opcode;
+	int offset = 0;
+	int llid;
+
+	// struct timespec start_time;
+	// struct timespec end_time;
+	// clock_gettime(CLOCK_MONOTONIC, &start_time);
+
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "ACL");
+
+	len = dissect_payload_header_acl_edr(tree, tvb, offset);
+	llid = tvb_get_guint8(tvb, offset) & 0x03;
+
+	offset += 2;
+
+	if (len)
+	{
+		pld_tvb = tvb_new_subset_length(tvb, offset, len);
+		switch (llid)
+		{
+		case 1:
+			proto_tree_add_item(tree, hf_h4bcm_acl_fragment, tvb, offset, len, ENC_LITTLE_ENDIAN);
+			switch (pinfo->p2p_dir)
+			{
+			case P2P_DIR_SENT:
+				col_set_str(pinfo->cinfo, COL_INFO, "TX --> Fragment");
+				break;
+			case P2P_DIR_RECV:
+				col_set_str(pinfo->cinfo, COL_INFO, "RX <-- Fragment");
+				break;
+			default:
+				break;
+			}
+			break;
+
+		case 2:
+			call_dissector(btl2cap_handle, pld_tvb, pinfo, tree);
+			break;
+
+		case 3:
+			call_dissector(btlmp_handle, pld_tvb, pinfo, tree);
+			break;
+
+		default:
+			proto_tree_add_item(tree, hf_h4bcm_payload, tvb, offset, len, ENC_LITTLE_ENDIAN);
+			break;
+		}
+	}
+	else
+	{
+		proto_tree_add_item(tree, hf_h4bcm_payload, tvb, offset, len, ENC_LITTLE_ENDIAN);
+	}
+
+	return tvb_reported_length(tvb);
+}
+
+static void dissect_fhs(proto_tree *tree, tvbuff_t *tvb, int offset)
+{
+	proto_item *fhs_item, *psmode_item;
+	proto_tree *fhs_tree;
+	const gchar *description;
+	guint8 psmode;
+
+	fhs_item = proto_tree_add_item(tree, hf_btbbd_fhs, tvb, offset, -1, ENC_NA);
+	fhs_tree = proto_item_add_subtree(fhs_item, ett_btbbd_fhs);
+
+	/* Use proto_tree_add_bits_item() to get around 32bit limit on bitmasks */
+	proto_tree_add_bits_item(fhs_tree, hf_btbbd_fhs_parity, tvb, offset * 8, 34, ENC_LITTLE_ENDIAN);
+	/* proto_tree_add_item(fhs_tree, hf_btbb_fhs_parity, tvb, offset, 5, ENC_LITTLE_ENDIAN); */
+	offset += 4;
+
+	proto_tree_add_item(fhs_tree, hf_btbbd_fhs_lap, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+	offset += 3;
+
+	proto_tree_add_item(fhs_tree, hf_btbbd_fhs_eir, tvb, offset, 1, ENC_NA);
+	/* skipping 1 undefined bit */
+	proto_tree_add_item(fhs_tree, hf_btbbd_fhs_sr, tvb, offset, 1, ENC_NA);
+	/* skipping 2 reserved bits */
+	offset += 1;
+
+	proto_tree_add_item(fhs_tree, hf_btbbd_fhs_uap, tvb, offset, 1, ENC_NA);
+	offset += 1;
+
+	proto_tree_add_item(fhs_tree, hf_btbbd_fhs_nap, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(fhs_tree, hf_btbbd_fhs_class, tvb, offset, 3, ENC_LITTLE_ENDIAN);
+	offset += 3;
+
+	proto_tree_add_item(fhs_tree, hf_btbbd_fhs_ltaddr, tvb, offset, 1, ENC_NA);
+	proto_tree_add_item(fhs_tree, hf_btbbd_fhs_clk, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+	offset += 3;
+
+	psmode = tvb_get_guint8(tvb, offset);
+	description = try_rval_to_str(psmode, ps_modes);
+	psmode_item = proto_tree_add_item(fhs_tree, hf_btbbd_fhs_psmode, tvb, offset, 1, ENC_NA);
+	if (description)
+		proto_item_append_text(psmode_item, " (%s)", description);
+	offset += 1;
+}
+
+static int dissect_bt_baseband(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
+{
+	tvbuff_t *pld_tvb;
+	int offset = 0;
+	int bb_type;
+	int ptt;
+
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "Baseband");
+
+	// // Baseband protocol
+	proto_item *btbb_item = proto_tree_add_item(tree, hf_btbbd, tvb, offset, 11, ENC_LITTLE_ENDIAN);
+	proto_tree *btbb_tree = proto_item_add_subtree(btbb_item, ett_btbbd);
+	// // Baseband Metadata
+	proto_item *btbb_meta_item = proto_tree_add_item(btbb_tree, hf_btbbd_meta, tvb, offset, 5, ENC_LITTLE_ENDIAN);
+	proto_tree *btbb_meta_tree = proto_item_add_subtree(btbb_meta_item, ett_btbbd_meta);
+	proto_tree_add_item(btbb_meta_tree, hf_btbbd_clk, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+	offset += 4;
+	proto_tree_add_item(btbb_meta_tree, hf_btbbd_channel, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+	proto_tree_add_item(btbb_meta_tree, hf_btbbd_ptt, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(btbb_meta_tree, hf_btbbd_role, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(btbb_meta_tree, hf_btbbd_tx_encrypted, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	proto_tree_add_item(btbb_meta_tree, hf_btbbd_rx_encrypted, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+    proto_tree_add_item(btbb_meta_tree, hf_btbbd_is_eir, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	// ptt = tvb_get_guint8(tvb, offset) & 0b1;
+	offset += 1;
+	// Baseband Packet Header
+	proto_item *btbb_pkthdr_item = proto_tree_add_item(btbb_tree, hf_btbbd_pkthdr, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	proto_tree *btbb_pkthdr_tree = proto_item_add_subtree(btbb_pkthdr_item, ett_btbbd_pkthdr);
+	proto_tree_add_item(btbb_pkthdr_tree, hf_btbbd_ltaddr, tvb, offset, 1, ENC_NA);
+	proto_tree_add_item_ret_uint(btbb_pkthdr_tree, hf_btbbd_type, tvb, offset, 1, ENC_NA, &bb_type);
+	// if (!ptt)
+	// 	proto_tree_add_item_ret_uint(btbb_pkthdr_tree, hf_btbbd_type_br, tvb, offset, 1, ENC_NA, &bb_type);
+	// else
+	// 	proto_tree_add_item_ret_uint(btbb_pkthdr_tree, hf_btbbd_type_edr, tvb, offset, 1, ENC_NA, &bb_type);
+	proto_tree_add_item(btbb_pkthdr_tree, hf_btbbd_flow, tvb, offset, 1, ENC_NA);
+    offset += 1;
+	proto_tree_add_item(btbb_pkthdr_tree, hf_btbbd_arqn, tvb, offset, 1, ENC_NA);
+    proto_tree_add_item(btbb_pkthdr_tree, hf_btbbd_seqn, tvb, offset, 1, ENC_NA);
+	proto_tree_add_item(btbb_pkthdr_tree, hf_btbbd_hec, tvb, offset, 1, ENC_NA);
+	offset += 1;
+
+	switch (pinfo->p2p_dir)
+	{
+	case P2P_DIR_SENT:
+		col_set_str(pinfo->cinfo, COL_INFO, "TX --> ");
+		break;
+	case P2P_DIR_RECV:
+		col_set_str(pinfo->cinfo, COL_INFO, "RX <-- ");
+		break;
+	default:
+		break;
+	}
+
+	/* payload */
+	switch (bb_type)
+	{
+	case 0x0: /* NULL */
+		col_append_str(pinfo->cinfo, COL_INFO, "NULL");
+		break;
+	case 0x1: /* POLL */
+		col_append_str(pinfo->cinfo, COL_INFO, "POLL");
+		break;
+	case 0x2: /* FHS */
+		col_append_str(pinfo->cinfo, COL_INFO, "FHS");
+		dissect_fhs(tree, tvb, offset);
+		break;
+	case 0x3: /* DM1 */
+	case 0x4: /* DH1/2-DH1 */
+	case 0x5: /* HV1 */
+	case 0x6: /* HV2/2-EV3 */
+	case 0x7: /* HV3/EV3/3-EV3 */
+	case 0x8: /* DV/3-DH1 */
+	case 0x9: /* AUX1 */
+	case 0xa: /* DM3/2-DH3 */
+	case 0xb: /* DH3/3-DH3 */
+	case 0xc: /* EV4/2-EV5 */
+	case 0xd: /* EV5/3-EV5 */
+	case 0xe: /* DM5/2-DH5 */
+	case 0xf: /* DH5/3-DH5 */
+		pld_tvb = tvb_new_subset_remaining(tvb, offset);
+		dissect_acl(pld_tvb, pinfo, tree, &ptt);
+		break;
+	default:
+		break;
+	}
+
+	return tvb_reported_length(tvb);
+}
+
+/* TODO placeholder for responses we don't know yet */
+static void dissect_unkn_resp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset)
+{
+	DISSECTOR_ASSERT(tvb_reported_length(tvb) == 63);
+
+	proto_tree_add_item(tree, hf_h4bcm_type, tvb, offset - 1, 1, ENC_NA);
+
+	/* Sent from chip to host */
+	col_set_str(pinfo->cinfo, COL_RES_DL_SRC, "controller");
+	col_set_str(pinfo->cinfo, COL_RES_DL_DST, "host");
+}
+
+/* TODO placeholder for commands with arguments that are none or unknown */
+static void dissect_unkn_get(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset)
+{
+	DISSECTOR_ASSERT(tvb_reported_length(tvb) >= 1);
+
+	proto_tree_add_item(tree, hf_h4bcm_type, tvb, offset - 1, 1, ENC_NA);
+
+	/* Sent from host to chip */
+	col_set_str(pinfo->cinfo, COL_RES_DL_SRC, "host");
+	col_set_str(pinfo->cinfo, COL_RES_DL_DST, "controller");
+}
+
+/* ACL BR stats */
+static void dissect_acl_br_stats(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset)
+
+{
+	proto_item *stats_item;
+	proto_tree *stats_tree;
+
+	DISSECTOR_ASSERT(tvb_reported_length(tvb) == 63);
+
+	/* Sent from chip to host */
+	col_set_str(pinfo->cinfo, COL_RES_DL_SRC, "controller");
+	col_set_str(pinfo->cinfo, COL_RES_DL_DST, "host");
+
+	/* Display previous item as tree header */
+	stats_item = proto_tree_add_item(tree, hf_h4bcm_type, tvb, offset - 1, 1, ENC_NA);
+
+	/* Make stats subtree */
+	stats_tree = proto_item_add_subtree(stats_item, ett_h4bcm_acl_br_stats);
+
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_null_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_poll_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dm1_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dh1_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dv_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_aux1_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dm3_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dh3_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dm5_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dh5_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_null_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_poll_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dm1_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dh1_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dv_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_aux1_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dm3_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dh3_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dm5_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dh5_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	/* FIXME within the next 16 bytes, some are 4 bytes long ... not 100% sure which */
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_acl_rx, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+	offset += 4;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_acl_tx, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+	offset += 4;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_hec_err, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_crc_err, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_seqn_rep, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_soft_rst, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_test_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_test_rx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_test_err, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+}
+
+/* ACL EDR stats */
+static void dissect_acl_edr_stats(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset)
+{
+	proto_item *stats_item;
+	proto_tree *stats_tree;
+
+	DISSECTOR_ASSERT(tvb_reported_length(tvb) == 63);
+
+	/* Sent from chip to host */
+	col_set_str(pinfo->cinfo, COL_RES_DL_SRC, "controller");
+	col_set_str(pinfo->cinfo, COL_RES_DL_DST, "host");
+
+	/* Display previous item as tree header */
+	stats_item = proto_tree_add_item(tree, hf_h4bcm_type, tvb, offset - 1, 1, ENC_NA);
+
+	/* Make stats subtree */
+	stats_tree = proto_item_add_subtree(stats_item, ett_h4bcm_acl_edr_stats);
+
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_null_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_poll_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dm1_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_2dh1_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_3dh1_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_2dh3_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_3dh3_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_2dh5_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_3dh5_rcvd, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	offset += 2; /* with this offset, null packets match */
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_null_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_poll_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_dm1_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_2dh1_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_3dh1_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_2dh3_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_3dh3_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_2dh5_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_3dh5_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	offset += 2; /* with this offset, acl bytes are correct */
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_acl_rx, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+	offset += 4;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_acl_tx, tvb, offset, 4, ENC_LITTLE_ENDIAN);
+	offset += 4;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_hec_err, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_crc_err, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_seqn_rep, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_soft_rst, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_test_tx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_test_rx, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+	proto_tree_add_item(stats_tree, hf_h4bcm_stats_test_err, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+}
+
+/* LL_VERSION_IND p. 2594
+ */
+static void dissect_ll_version_ind(proto_tree *tree, tvbuff_t *tvb, int offset)
+{
+	proto_tree_add_item(tree, hf_h4bcm_ll_version_ind_versnr, tvb, offset, 1, ENC_LITTLE_ENDIAN);
+	offset += 1;
+
+	proto_tree_add_item(tree, hf_h4bcm_ll_version_ind_compid, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+	offset += 2;
+
+	proto_tree_add_item(tree, hf_h4bcm_ll_version_ind_subversnr, tvb, offset, 2, ENC_LITTLE_ENDIAN);
+}
+
+/* LM LE
+ * Most of this is already implemented in "btle" in Wireshark...
+ * But somewhat different format :( So we do it here.
+ */
+static void dissect_lm_le(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int is_sent)
+{
+	int opcode;
+	int opcode_ext;
+	guint64 mac;
+	gchar *mac_string = (gchar *)g_malloc(18);
+
+	/* LMP and LCP are only transmitted within full diagnostic reports */
+	DISSECTOR_ASSERT(tvb_reported_length(tvb) == 63);
+
+	/* clock of the BT master */
+	proto_tree_add_item(tree, hf_h4bcm_clock, tvb, offset, 4, ENC_BIG_ENDIAN);
+	offset += 4;
+
+	/* standard MAC address this time */
+	mac = tvb_get_guint64(tvb, offset - 2, ENC_BIG_ENDIAN);
+	g_snprintf(mac_string, 18,
+			   "%02x:%02x:%02x:%02x:%02x:%02x",
+			   (unsigned int)((mac & 0xff0000000000) >> 40),
+			   (unsigned int)((mac & 0x00ff00000000) >> 32),
+			   (unsigned int)((mac & 0x0000ff000000) >> 24),
+			   (unsigned int)((mac & 0x000000ff0000) >> 16),
+			   (unsigned int)((mac & 0x00000000ff00) >> 8),
+			   (unsigned int)((mac & 0x0000000000ff)));
+	proto_tree_add_item(tree, hf_h4bcm_le_ether, tvb, offset, 6, ENC_LITTLE_ENDIAN);
+	offset += 6;
+
+	if (is_sent == 1)
+	{
+		col_set_str(pinfo->cinfo, COL_RES_DL_SRC, "controller");
+		col_set_str(pinfo->cinfo, COL_RES_DL_DST, mac_string);
+	}
+	else
+	{
+		col_set_str(pinfo->cinfo, COL_RES_DL_SRC, mac_string);
+		col_set_str(pinfo->cinfo, COL_RES_DL_DST, "controller");
+	}
+
+	/* Handle (only 1 byte, even though it can be 2 bytes long?!) */
+	proto_tree_add_item(tree, hf_h4bcm_le_handle, tvb, offset, 1, ENC_NA);
+	offset += 1;
+
+	opcode = tvb_get_guint8(tvb, offset);
+	proto_tree_add_item(tree, hf_h4bcm_le_opcode, tvb, offset, 1, ENC_NA);
+	col_add_str(pinfo->cinfo, COL_INFO, val_to_str(opcode, lm_le_opcodes, "LE LL Unknown Opcode (%d)"));
+	offset += 1;
+
+	switch (opcode)
+	{
+	case 0x0c:
+		dissect_ll_version_ind(tree, tvb, offset);
+		break;
+	/* Broadcom vendor specific stuff... */
+	case 0xff:
+		opcode_ext = tvb_get_guint8(tvb, offset);
+		proto_tree_add_item(tree, hf_h4bcm_le_opcode_ext, tvb, offset, 1, ENC_NA);
+		col_add_str(pinfo->cinfo, COL_INFO, val_to_str(opcode_ext, lm_le_opcodes_ext, "LE LL Unknown VSC Opcode (%d)"));
+		offset += 1;
+		break;
+	default:
+		break;
+	}
+}
+
+/* Show if LM + LM LE logging was enabled or disabled */
+static void dissect_lm_toggle(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset)
+{
+	DISSECTOR_ASSERT(tvb_reported_length(tvb) >= 1);
+
+	/* Sent from host UART to chip */
+	col_set_str(pinfo->cinfo, COL_RES_DL_SRC, "host");
+	col_set_str(pinfo->cinfo, COL_RES_DL_DST, "controller");
+
+	/* OFF and ON */
+	proto_tree_add_item(tree, hf_h4bcm_lm_toggle, tvb, offset, 1, ENC_BIG_ENDIAN);
+	offset += 1;
+}
+
+/* dissect a packet */
+static int
+dissect_h4bcm(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
+{
+	proto_item *h4bcm_item;
+	proto_tree *h4bcm_tree;
+	int offset;
+	int h4bcm_type;
+
+	/* sanity check: length */
+	if (tvb_reported_length(tvb) < 1)
+		/* bad length: look for a different dissector */
+		return 0;
+
+	/* fprintf(stderr, "total len %d\n", tvb_reported_length(tvb)); */
+
+	/* make entries in protocol column and info column on summary display */
+	col_set_str(pinfo->cinfo, COL_PROTOCOL, "HCI H4 Broadcom");
+
+	/* create display subtree for the protocol */
+	offset = 0;
+	h4bcm_item = proto_tree_add_item(tree, proto_h4bcm, tvb, offset, -1, ENC_NA);
+	h4bcm_tree = proto_item_add_subtree(h4bcm_item, ett_h4bcm);
+
+	h4bcm_type = tvb_get_guint8(tvb, offset);
+	col_add_str(pinfo->cinfo, COL_INFO, val_to_str(h4bcm_type, h4bcm_types, "Unknown Type (%d)"));
+	offset += 1;
+
+	switch (h4bcm_type)
+	{
+	case DIA_LM_SENT:
+		dissect_lm_header(tvb, pinfo, h4bcm_tree, offset, 1);
+		offset += 8;
+		dissect_lmp(tvb, pinfo, h4bcm_tree, offset);
+		break;
+	case DIA_LM_RECV:
+		dissect_lm_header(tvb, pinfo, h4bcm_tree, offset, 0);
+		offset += 11;
+		dissect_lmp(tvb, pinfo, h4bcm_tree, offset);
+		break;
+	case DIA_ACL_BR_RESP:
+		dissect_acl_br_stats(tvb, pinfo, h4bcm_tree, offset);
+		break;
+	case DIA_ACL_EDR_RESP:
+		dissect_acl_edr_stats(tvb, pinfo, h4bcm_tree, offset);
+		break;
+	case DIA_LE_SENT:
+		dissect_lm_le(tvb, pinfo, h4bcm_tree, offset, 1);
+		break;
+	case DIA_LE_RECV:
+		dissect_lm_le(tvb, pinfo, h4bcm_tree, offset, 0);
+		break;
+	case DIA_LM_ENABLE:
+		dissect_lm_toggle(tvb, pinfo, h4bcm_tree, offset);
+		break;
+	case DIA_MEM_PEEK_RESP:
+	case DIA_MEM_DUMP_RESP:
+	case DIA_TEST_COMPL:
+	case DIA_MEM_POKE_RESP:
+	case DIA_CPU_LOAD_RESP:
+	case DIA_AUX_RESP:
+	case DIA_ACL_UNKN1_RESP:
+	case DIA_ACL_UNKN2_RESP:
+		dissect_unkn_resp(tvb, pinfo, h4bcm_tree, offset);
+		break;
+	case DIA_ACL_BR_RESET:
+	case DIA_ACL_BR_GET:
+	case DIA_ACL_EDR_GET:
+	case DIA_AUX_GET:
+	case DIA_ACL_UNKN1_GET:
+	case DIA_ACL_UNKN2_GET:
+	case DIA_CON_GET:
+	case DIA_MEM_PEEK_GET:
+	case DIA_MEM_POKE_GET:
+	case DIA_MEM_DUMP_GET:
+	case DIA_PKT_TEST:
+		dissect_unkn_get(tvb, pinfo, h4bcm_tree, offset);
+		break;
+	default:
+		break;
+	}
+
+	/* Return the amount of data this dissector was able to dissect */
+	return tvb_reported_length(tvb);
+}
+
+/* register the protocol with Wireshark */
+void proto_register_h4bcm(void)
+{
+	/* list of fields */
+	static hf_register_info hf[] = {
+		{&hf_h4bcm_type,
+		 {"Type", "h4bcm.type",
+		  FT_UINT8, BASE_HEX, VALS(h4bcm_types), 0x0,
+		  "Diagnostic Information Type", HFILL}},
+		{&hf_h4bcm_clock,
+		 {"Clock", "h4bcm.clock",
+		  FT_UINT32, BASE_HEX, NULL, 0x0,
+		  "Bluetooth Master Clock", HFILL}},
+		{&hf_h4bcm_maclow,
+		 {"Remote MAC Address", "h4bcm.maclow",
+		  FT_BYTES, SEP_COLON, NULL, 0x0,
+		  "Lower MAC address part, sufficient for l2ping ff:ff:maclow", HFILL}},
+		{&hf_h4bcm_pldhdr,
+		 {"Payload Header", "h4bcm.pldhdr",
+		  FT_NONE, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_aclhdr,
+		 {"ACL Header", "h4bcm.aclhdr",
+		  FT_NONE, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_llid,
+		 {"LLID", "h4bcm.llid",
+		  FT_UINT8, BASE_HEX, VALS(llid_codes), 0x03,
+		  "Logical Link ID", HFILL}},
+		{&hf_h4bcm_llid_acl,
+		 {"LLID", "h4bcm.llid_acl",
+		  FT_UINT16, BASE_HEX, VALS(llid_codes), 0x03,
+		  "Logical Link ID", HFILL}},
+		{&hf_h4bcm_pldflow_acl,
+		 {"Flow", "h4bcm.flow_acl",
+		  FT_BOOLEAN, 16, NULL, 0x04,
+		  "Payload Flow indication", HFILL}},
+		{&hf_h4bcm_rfu,
+		 {"RFU", "h4bcm.rfu_acl",
+		  FT_UINT16, BASE_HEX, 0, 0xE000,
+		  "RFU", HFILL}},
+		{&hf_h4bcm_pldflow,
+		 {"Flow", "h4bcm.flow",
+		  FT_BOOLEAN, 8, NULL, 0x04,
+		  "Payload Flow indication", HFILL}},
+		{&hf_h4bcm_length,
+		 {"Length", "h4bcm.length",
+		  FT_UINT8, BASE_DEC, NULL, 0xf8,
+		  "Payload Length", HFILL}},
+		{&hf_h4bcm_length_acl,
+		 {"Length", "h4bcm.length_acl",
+		  FT_UINT16, BASE_DEC, NULL, 0x1ff8,
+		  "Payload Length", HFILL}},
+		{&hf_h4bcm_payload,
+		 {"Payload", "h4bcm.payload",
+		  FT_BYTES, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_acl_fragment,
+		 {"Payload", "h4bcm.acl_fragment",
+		  FT_BYTES, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_lm_toggle,
+		 {"LM and LM LE Logging", "h4bcm.logging",
+		  FT_BOOLEAN, 8, TFS(&lm_toggle), 0x01,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_null_rcvd,
+		 {"Null Packets Received", "h4bcm.stats.null_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_poll_rcvd,
+		 {"Poll Packets Received", "h4bcm.stats.poll_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_dm1_rcvd,
+		 {"DM1 Packets Received", "h4bcm.stats.dm1_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_dh1_rcvd,
+		 {"DH1 Packets Received", "h4bcm.stats.dh1_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_dv_rcvd,
+		 {"DV Packets Received", "h4bcm.stats.dv_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_aux1_rcvd,
+		 {"AUX1 Packets Received", "h4bcm.stats.aux1_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_dm3_rcvd,
+		 {"DM3 Packets Received", "h4bcm.stats.dm3_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_dh3_rcvd,
+		 {"DH3 Packets Received", "h4bcm.stats.dh3_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_dm5_rcvd,
+		 {"DM5 Packets Received", "h4bcm.stats.dm5_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_dh5_rcvd,
+		 {"DH5 Packets Received", "h4bcm.stats.dh5_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_null_tx,
+		 {"Null Packets Transmitted", "h4bcm.stats.null_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_poll_tx,
+		 {"Poll Packets Transmitted", "h4bcm.stats.poll_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_dm1_tx,
+		 {"DM1 Packets Transmitted", "h4bcm.stats.dm1_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_dh1_tx,
+		 {"DH1 Packets Transmitted", "h4bcm.stats.dh1_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_dv_tx,
+		 {"DV Packets Transmitted", "h4bcm.stats.dv_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_aux1_tx,
+		 {"AUX1 Packets Transmitted", "h4bcm.stats.aux1_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_dm3_tx,
+		 {"DM3 Packets Transmitted", "h4bcm.stats.dm3_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_dh3_tx,
+		 {"DH3 Packets Transmitted", "h4bcm.stats.dh3_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_dm5_tx,
+		 {"DM5 Packets Transmitted", "h4bcm.stats.dm5_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_dh5_tx,
+		 {"DH5 Packets Transmitted", "h4bcm.stats.dh5_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_acl_rx,
+		 {"Total Received ACL Bytes", "h4bcm.stats.acl_rx",
+		  FT_UINT32, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_acl_tx,
+		 {"Total Transmitted ACL Bytes", "h4bcm.stats.acl_tx",
+		  FT_UINT32, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_hec_err,
+		 {"HEC Errors", "h4bcm.stats.hec_err",
+		  FT_UINT32, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_crc_err,
+		 {"CRC Errors", "h4bcm.stats.crc_err",
+		  FT_UINT32, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_seqn_rep,
+		 {"Seqn Repeat", "h4bcm.stats.seqn_rep",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_soft_rst,
+		 {"Soft Reset", "h4bcm.stats.soft_rst",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_test_tx,
+		 {"TestMode Transmitted Packets", "h4bcm.stats.test_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_test_rx,
+		 {"TestMode Received Packets", "h4bcm.stats.test_rx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_test_err,
+		 {"TestMode Packet Errors", "h4bcm.stats.test_err",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_2dh1_rcvd,
+		 {"2DH1 Packets Received", "h4bcm.stats.2dh1_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_3dh1_rcvd,
+		 {"3DH1 Packets Received", "h4bcm.stats.3dh1_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_2dh3_rcvd,
+		 {"2DH3 Packets Received", "h4bcm.stats.2dh3_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_3dh3_rcvd,
+		 {"3DH3 Packets Received", "h4bcm.stats.3dh3_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_2dh5_rcvd,
+		 {"2DH5 Packets Received", "h4bcm.stats.2dh5_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_3dh5_rcvd,
+		 {"3DH5 Packets Received", "h4bcm.stats.3dh5_rcvd",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_2dh1_tx,
+		 {"2DH1 Packets Transmitted", "h4bcm.stats.2dh1_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_3dh1_tx,
+		 {"3DH1 Packets Transmitted", "h4bcm.stats.3dh1_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_2dh3_tx,
+		 {"2DH3 Packets Transmitted", "h4bcm.stats.2dh3_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_3dh3_tx,
+		 {"3DH3 Packets Transmitted", "h4bcm.stats.3dh3_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_2dh5_tx,
+		 {"2DH5 Packets Transmitted", "h4bcm.stats.2dh5_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_stats_3dh5_tx,
+		 {"3DH5 Packets Transmitted", "h4bcm.stats.3dh5_tx",
+		  FT_UINT16, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_le_ether,
+		 {"Remote MAC Address", "h4bcm.le.address",
+		  FT_BYTES, SEP_COLON, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_le_handle,
+		 {"Handle", "h4bcm.le.handle",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_le_opcode,
+		 {"Opcode", "h4bcm.le.opcode",
+		  FT_UINT8, BASE_HEX, VALS(lm_le_opcodes), 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_le_opcode_ext,
+		 {"Broadcom Specific Opcode", "h4bcm.le.opcodeext",
+		  FT_UINT8, BASE_HEX, VALS(lm_le_opcodes_ext), 0x0,
+		  NULL, HFILL}},
+		{&hf_h4bcm_ll_version_ind_versnr,
+		 {"VersNr", "h4bcm.le.versnr",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  "Version", HFILL}},
+		{&hf_h4bcm_ll_version_ind_subversnr,
+		 {"SubVersNr", "h4bcm.le.subversnr",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Subversion", HFILL}},
+		{&hf_h4bcm_ll_version_ind_compid,
+		 {"CompID", "h4bcm.le.compid",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Company", HFILL}},
+		{&hf_btbbd,
+		 {"Baseband", "btbbd",
+		  FT_NONE, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_btbbd_meta,
+		 {"Meta Data", "btbbd.meta",
+		  FT_NONE, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_btbbd_clk,
+		 {"CLK", "btbbd.clk",
+		  FT_UINT32, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_btbbd_channel,
+		 {"Channel", "btbbd.ch",
+		  FT_UINT32, BASE_DEC, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_btbbd_ptt,
+		 {"Table Type", "btbbd.ptt",
+		  FT_BOOLEAN, 8, TFS(&packet_table_type_bits), 0b00000001,
+		  NULL, HFILL}},
+		{&hf_btbbd_role,
+		 {"Role", "btbbd.role",
+		  FT_BOOLEAN, 8, TFS(&packet_role_bits), 0b00000010,
+		  NULL, HFILL}},
+		{&hf_btbbd_tx_encrypted,
+		 {"TX Enc.", "btbbd.txenc",
+		  FT_BOOLEAN, 8, TFS(&lm_toggle), 0b00100000,
+		  NULL, HFILL}},
+		{&hf_btbbd_rx_encrypted,
+		 {"RX Enc.", "btbbd.rxenc",
+		  FT_BOOLEAN, 8, TFS(&lm_toggle), 0b01000000,
+		  NULL, HFILL}},
+		{&hf_btbbd_is_eir,
+		 {"Is EIR", "btbbd.iseir",
+		  FT_BOOLEAN, 8, TFS(&lm_toggle), 0b10000000,
+		  NULL, HFILL}},
+		{&hf_btbbd_pkthdr,
+		 {"Packet Header", "btbbd.pkthdr",
+		  FT_NONE, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_btbbd_ltaddr,
+		 {"LT_ADDR", "btbbd.lt_addr",
+		  FT_UINT16, BASE_HEX, NULL, 0x07,
+		  NULL, HFILL}},
+		{&hf_btbbd_type,
+		 {"Type", "btbbd.type",
+		  FT_UINT16, BASE_HEX, VALS(packet_types), 0x78,
+		  NULL, HFILL}},
+		{&hf_btbbd_type_br,
+		 {"Type", "btbbd.type_br",
+		  FT_UINT16, BASE_HEX, VALS(packet_types_br), 0x78,
+		  NULL, HFILL}},
+		{&hf_btbbd_type_edr,
+		 {"Type", "btbbd.type_edr",
+		  FT_UINT16, BASE_HEX, VALS(packet_types_edr), 0x78,
+		  NULL, HFILL}},
+		{&hf_btbbd_flow,
+		 {"FLOW", "btbbd.flow",
+		  FT_BOOLEAN, 16, NULL, 0x80,
+		  NULL, HFILL}},
+		{&hf_btbbd_arqn,
+		 {"ARQN", "btbbd.arqn",
+		  FT_BOOLEAN, 8, NULL, 0x1,
+		  NULL, HFILL}},
+		{&hf_btbbd_seqn,
+		 {"SEQN", "btbbd.seqn",
+		  FT_BOOLEAN, 8, NULL, 0x2,
+		  NULL, HFILL}},
+		{&hf_btbbd_hec,
+		 {"HEC", "btbbd.hec",
+		  FT_UINT8, BASE_HEX, NULL, 0xFC,
+		  NULL, HFILL}},
+		{&hf_btbbd_fhs,
+		 {"FHS", "fhs",
+		  FT_NONE, BASE_NONE, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_btbbd_fhs_parity,
+		 {"Parity", "fhs.parity",
+		  /* FIXME this doesn't work because bitmasks can only be 32 bits */
+		  FT_UINT64, BASE_HEX, NULL, /*0x00000003ffffffffULL,*/ 0x0,
+		  "LAP parity", HFILL}},
+		{&hf_btbbd_fhs_lap,
+		 {"LAP", "fhs.lap",
+		  FT_UINT24, BASE_HEX, NULL, 0x03fffffc,
+		  "Lower Address Part", HFILL}},
+		{&hf_btbbd_fhs_eir,
+		 {"EIR", "fhs.eir",
+		  FT_BOOLEAN, 8, NULL, 0x04,
+		  "Extended Inquiry Response packet may follow", HFILL}},
+		{&hf_btbbd_fhs_sr,
+		 {"SR", "fhs.sr",
+		  FT_UINT8, BASE_HEX, VALS(sr_modes), 0x30,
+		  "Scan Repetition", HFILL}},
+		{&hf_btbbd_fhs_uap,
+		 {"UAP", "fhs.uap",
+		  FT_UINT8, BASE_HEX, NULL, 0x0,
+		  "Upper Address Part", HFILL}},
+		{&hf_btbbd_fhs_nap,
+		 {"NAP", "fhs.nap",
+		  FT_UINT16, BASE_HEX, NULL, 0x0,
+		  "Non-Significant Address Part", HFILL}},
+		{&hf_btbbd_fhs_class, /* TODO: More options */
+		 {"Class of Device", "fhs.class",
+		  FT_UINT24, BASE_HEX, NULL, 0x0,
+		  NULL, HFILL}},
+		{&hf_btbbd_fhs_ltaddr,
+		 {"LT_ADDR", "fhs.lt_addr",
+		  FT_UINT8, BASE_HEX, NULL, 0x07,
+		  "Logical Transport Address", HFILL}},
+		{&hf_btbbd_fhs_clk,
+		 {"CLK", "fhs.clk",
+		  FT_UINT32, BASE_HEX, NULL, 0x1ffffff8,
+		  "Clock bits 2 through 27", HFILL}},
+		{&hf_btbbd_fhs_psmode,
+		 {"Page Scan Mode", "fhs.psmode",
+		  FT_UINT8, BASE_HEX, NULL, 0xe0,
+		  NULL, HFILL}},
+	};
+
+	/* protocol subtree arrays */
+	static gint *ett[] = {
+		&ett_h4bcm,
+		&ett_h4bcm_pldhdr,
+		&ett_h4bcm_aclhdr,
+		&ett_h4bcm_acl_br_stats,
+		&ett_h4bcm_acl_edr_stats,
+		&ett_btbbd,
+		&ett_btbbd_meta,
+		&ett_btbbd_pkthdr,
+		&ett_btbbd_fhs,
+	};
+
+	/* register the protocol name and description */
+	proto_h4bcm = proto_register_protocol(
+		"Bluetooth H4 Serial Broadcom Vendor Specific", /* full name */
+		"H4 Broadcom",									/* short name */
+		"h4bcm"											/* abbreviation (e.g. for filters) */
+	);
+
+	register_dissector("btacl", dissect_acl, proto_h4bcm);
+
+	/* register the header fields and subtrees used */
+	proto_register_field_array(proto_h4bcm, hf, array_length(hf));
+	proto_register_subtree_array(ett, array_length(ett));
+}
+
+void proto_reg_handoff_h4bcm(void)
+{
+	dissector_handle_t h4bcm_handle;
+
+    // Original InternalBlue Broadcom dissector
+	h4bcm_handle = create_dissector_handle(dissect_h4bcm, proto_h4bcm);
+	dissector_add_uint("hci_h4.type", 0x07, h4bcm_handle);
+
+	// Bluetooth ACL Header (Payload Header)
+	h4bcm_handle = create_dissector_handle(dissect_acl, proto_h4bcm);
+	dissector_add_uint("hci_h4.type", 0x08, h4bcm_handle);
+
+	// Bluetooth Baseband (Packet Header)
+	h4bcm_handle = create_dissector_handle(dissect_bt_baseband, proto_h4bcm);
+	dissector_add_uint("hci_h4.type", 0x09, h4bcm_handle);
+
+	// PacketLogger
+	packetlogger_handle = find_dissector("packetlogger");
+	dissector_add_uint("hci_h4.type", 0x0A, packetlogger_handle);
+
+	/* LMP dissector from https://github.com/greatscottgadgets/libbtbb */
+	btlmp_handle = find_dissector("esp32_btlmp");
+	btl2cap_handle = find_dissector("btl2cap");
+
+	// dissector_add_uint("wtap_encap", WTAP_ENCAP_ESPRESSIF_BT, h4bcm_handle);
+}
+
+/*
+ * Editor modelines  -  http://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 4
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=4 tabstop=8 expandtab:
+ * :indentSize=4:tabSize=8:noTabs=true:
+ */
diff --git a/plugins/wiretap/usbdump/CMakeLists.txt b/plugins/wiretap/usbdump/CMakeLists.txt
index 14fab19de32..c0e13664620 100644
--- a/plugins/wiretap/usbdump/CMakeLists.txt
+++ b/plugins/wiretap/usbdump/CMakeLists.txt
@@ -34,7 +34,7 @@ register_plugin_files(plugin.c
 
 add_wireshark_plugin_library(usbdump wiretap)
 
-target_include_directories(usbdump PRIVATE ${CMAKE_SOURCE_DIR}/wiretap)
+target_include_directories(usbdump PRIVATE ${PROJECT_SOURCE_DIR}/wiretap)
 
 target_link_libraries(usbdump wiretap)
 
diff --git a/resources/share/wireshark/profiles/Profile_nRF_Sniffer_Bluetooth_LE/preferences b/resources/share/wireshark/profiles/Profile_nRF_Sniffer_Bluetooth_LE/preferences
new file mode 100644
index 00000000000..999d56a3b8e
--- /dev/null
+++ b/resources/share/wireshark/profiles/Profile_nRF_Sniffer_Bluetooth_LE/preferences
@@ -0,0 +1,5729 @@
+# Configuration file for Wireshark 3.6.5.
+#
+# This file is regenerated each time preferences are saved within
+# Wireshark. Making manual changes should be safe, however.
+# Preferences that have been commented out have not been
+# changed from their default value.
+
+####### User Interface ########
+
+# Open a console window (Windows only)
+# One of: NEVER, AUTOMATIC, ALWAYS
+# (case-insensitive).
+#gui.console_open: NEVER
+
+# Restore current display filter after following a stream?
+# TRUE or FALSE (case-insensitive)
+#gui.restore_filter_after_following_stream: FALSE
+
+# Where to start the File Open dialog box
+# One of: LAST_OPENED, SPECIFIED
+# (case-insensitive).
+#gui.fileopen.style: LAST_OPENED
+
+# The max. number of items in the open recent files list
+# A decimal number
+#gui.recent_files_count.max: 10
+
+# The max. number of entries in the display filter list
+# A decimal number
+#gui.recent_display_filter_entries.max: 10
+
+# Directory to start in when opening File Open dialog.
+# A path to a directory
+#gui.fileopen.dir: 
+
+# The preview timeout in the File Open dialog
+# A decimal number
+#gui.fileopen.preview: 3
+
+# Ask to save unsaved capture files?
+# TRUE or FALSE (case-insensitive)
+#gui.ask_unsaved: TRUE
+
+# Display an autocomplete suggestion for display and capture filter controls
+# TRUE or FALSE (case-insensitive)
+#gui.autocomplete_filter: TRUE
+
+# Wrap to beginning/end of file during search?
+# TRUE or FALSE (case-insensitive)
+#gui.find_wrap: TRUE
+
+# Save window position at exit?
+# TRUE or FALSE (case-insensitive)
+#gui.geometry.save.position: TRUE
+
+# Save window size at exit?
+# TRUE or FALSE (case-insensitive)
+#gui.geometry.save.size: TRUE
+
+# Save window maximized state at exit?
+# TRUE or FALSE (case-insensitive)
+#gui.geometry.save.maximized: TRUE
+
+# Main Toolbar style
+# One of: ICONS, TEXT, BOTH
+# (case-insensitive).
+#gui.toolbar_main_style: ICONS
+
+# Check for updates (Windows and macOS only)
+# TRUE or FALSE (case-insensitive)
+#gui.update.enabled: TRUE
+
+# The type of update to fetch. You should probably leave this set to STABLE.
+# One of: DEVELOPMENT, STABLE
+# (case-insensitive).
+#gui.update.channel: STABLE
+
+# How often to check for software updates in seconds
+# A decimal number
+#gui.update.interval: 86400
+
+# Custom window title to be appended to the existing title
+# %F = file path of the capture file
+# %P = profile name
+# %S = a conditional separator (" - ") that only shows when surrounded by variables with values or static text
+# %V = version info
+# A string
+#gui.window_title: 
+
+# Custom window title to be prepended to the existing title
+# %F = file path of the capture file
+# %P = profile name
+# %S = a conditional separator (" - ") that only shows when surrounded by variables with values or static text
+# %V = version info
+# A string
+#gui.prepend_window_title: 
+
+# Custom start page title
+# A string
+#gui.start_title: The World's Most Popular Network Protocol Analyzer
+
+# Show version in the start page and/or main screen's title bar
+# One of: WELCOME, TITLE, BOTH, NEITHER
+# (case-insensitive).
+#gui.version_placement: BOTH
+
+# The maximum number of objects that can be exported
+# A decimal number
+#gui.max_export_objects: 1000
+
+# The maximum number of items that can be added to the dissection tree (Increase with caution)
+# A decimal number
+#gui.max_tree_items: 1000000
+
+# The maximum depth of the dissection tree (Increase with caution)
+# A decimal number
+#gui.max_tree_depth: 500
+
+# The position of "..." in packet list text.
+# One of: LEFT, RIGHT, MIDDLE, NONE
+# (case-insensitive).
+#gui.packet_list_elide_mode: RIGHT
+
+# Sets the count of decimal places for values of type 1.Type 1 values are defined by authors.Value can be in range 2 to 10.
+# A decimal number
+#gui.decimal_places1: 2
+
+# Sets the count of decimal places for values of type 2.Type 2 values are defined by authors.Value can be in range 2 to 10.
+# A decimal number
+#gui.decimal_places2: 4
+
+# Sets the count of decimal places for values of type 3.Type 3 values are defined by authors.Value can be in range 2 to 10.
+# A decimal number
+#gui.decimal_places3: 6
+
+# If set to true, RTP Player saves temporary data to temp files on disk. If not set, it uses memory.Every stream uses one file therefore you might touch OS limit for count of opened files.When ui.rtp_player_use_disk2 is set to true too, it uses  two files per RTP stream together.
+# TRUE or FALSE (case-insensitive)
+#gui.rtp_player_use_disk1: FALSE
+
+# If set to true, RTP Player saves temporary dictionary to temp files on disk. If not set, it uses memory.Every stream uses one file therefore you might touch OS limit for count of opened files.When ui.rtp_player_use_disk1 is set to true too, it uses  two files per RTP stream.
+# TRUE or FALSE (case-insensitive)
+#gui.rtp_player_use_disk2: FALSE
+
+# Show all interfaces, including interfaces marked as hidden
+# TRUE or FALSE (case-insensitive)
+#gui.interfaces_show_hidden: FALSE
+
+# Show remote interfaces in the interface selection
+# TRUE or FALSE (case-insensitive)
+#gui.interfaces_remote_display: TRUE
+
+# Hide the given interface types in the startup list.
+# A comma-separated string of interface type values (e.g. 5,9).
+# 0 = Wired,
+# 1 = AirPCAP,
+# 2 = Pipe,
+# 3 = STDIN,
+# 4 = Bluetooth,
+# 5 = Wireless,
+# 6 = Dial-Up,
+# 7 = USB,
+# 8 = External Capture,
+# 9 = Virtual
+# A string
+#gui.interfaces_hidden_types: 
+
+# Enables automatic updates for IO Graph
+# TRUE or FALSE (case-insensitive)
+#gui.io_graph_automatic_update: TRUE
+
+####### User Interface: Colors ########
+
+# Foreground color for an active selected item
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.active_frame.fg: 000000
+
+# Background color for an active selected item
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.active_frame.bg: cbe8ff
+
+# Color style for an active selected item
+# One of: DEFAULT, FLAT, GRADIENT
+# (case-insensitive).
+#gui.active_frame.style: DEFAULT
+
+# Foreground color for an inactive selected item
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.inactive_frame.fg: 000000
+
+# Background color for an inactive selected item
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.inactive_frame.bg: efefef
+
+# Color style for an inactive selected item
+# One of: DEFAULT, FLAT, GRADIENT
+# (case-insensitive).
+#gui.inactive_frame.style: DEFAULT
+
+# Color preferences for a marked frame
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.marked_frame.fg: ffffff
+
+# Color preferences for a marked frame
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.marked_frame.bg: 00202a
+
+# Color preferences for a ignored frame
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.ignored_frame.fg: 7f7f7f
+
+# Color preferences for a ignored frame
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.ignored_frame.bg: ffffff
+
+# TCP stream window color preference
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.stream.client.fg: 7f0000
+
+# TCP stream window color preference
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.stream.client.bg: fbeded
+
+# TCP stream window color preference
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.stream.server.fg: 00007f
+
+# TCP stream window color preference
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.stream.server.bg: ededfb
+
+# Valid color filter background
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.color_filter_bg.valid: afffaf
+
+# Invalid color filter background
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.color_filter_bg.invalid: ffafaf
+
+# Deprecated color filter background
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.color_filter_bg.deprecated: ffffaf
+
+####### User Interface: Columns ########
+
+# Packet list hidden columns
+# List all columns to hide in the packet list.
+gui.column.hidden: %Cus:nordic_ble.phy:0:R,%Cus:btle.length:0:R
+
+# Packet list column format
+# Each pair of strings consists of a column title and its format
+gui.column.format: 
+	"No.", "%m",
+	"Time", "%t",
+	"Source", "%s",
+	"PHY", "%Cus:nordic_ble.phy:0:R",
+	"Protocol", "%p",
+	"Length", "%Cus:btle.length:0:R",
+	"Delta time (s end to start)", "%Cus:nordic_ble.delta_time:0:R",
+	"Channel Index", "%Cus:nordic_ble.channel:0:R",
+	"SN", "%Cus:btle.data_header.sequence_number:0:R",
+	"NESN", "%Cus:btle.data_header.next_expected_sequence_number:0:R",
+	"More Data", "%Cus:btle.data_header.more_data:0:R",
+	"Event counter", "%Cus:nordic_ble.event_counter:0:R",
+	"Info", "%i"
+
+####### User Interface: Font ########
+
+# Font name for packet list, protocol tree, and hex dump panes. (Qt)
+# A string
+gui.qt.font_name: Liberation Mono,9,-1,5,50,0,0,0,0,0
+
+####### User Interface: Layout ########
+
+# Layout type (1-6)
+# A decimal number
+#gui.layout_type: 1
+
+# Layout content of the pane 1
+# One of: NONE, PLIST, PDETAILS, PBYTES, PDIAGRAM
+# (case-insensitive).
+#gui.layout_content_1: PLIST
+
+# Layout content of the pane 2
+# One of: NONE, PLIST, PDETAILS, PBYTES, PDIAGRAM
+# (case-insensitive).
+#gui.layout_content_2: PDETAILS
+
+# Layout content of the pane 3
+# One of: NONE, PLIST, PDETAILS, PBYTES, PDIAGRAM
+# (case-insensitive).
+#gui.layout_content_3: PBYTES
+
+# Enable Packet List Separator
+# TRUE or FALSE (case-insensitive)
+#gui.packet_list_separator.enabled: FALSE
+
+# Show column definition in packet list header
+# TRUE or FALSE (case-insensitive)
+#gui.packet_header_column_definition.enabled: TRUE
+
+# Enable Packet List mouse-over colorization
+# TRUE or FALSE (case-insensitive)
+#gui.packet_list_hover_style.enabled: TRUE
+
+# Show selected packet in the Status Bar
+# TRUE or FALSE (case-insensitive)
+#gui.show_selected_packet.enabled: FALSE
+
+# Show file load time in the Status Bar
+# TRUE or FALSE (case-insensitive)
+#gui.show_file_load_time.enabled: FALSE
+
+# Show related packet indicators in the first column
+# TRUE or FALSE (case-insensitive)
+#gui.packet_list_show_related: TRUE
+
+# Show the intelligent scroll bar (a minimap of packet list colors in the scrollbar)
+# TRUE or FALSE (case-insensitive)
+#gui.packet_list_show_minimap: TRUE
+
+####### Capture ########
+
+# Default capture device
+# A string
+#capture.device: 
+
+# Interface link-layer header types (Ex: en0(1),en1(143),...)
+# A string
+#capture.devices_linktypes: 
+
+# Interface descriptions (Ex: eth0(eth0 descr),eth1(eth1 descr),...)
+# A string
+#capture.devices_descr: 
+
+# Hide interface? (Ex: eth0,eth3,...)
+# A string
+#capture.devices_hide: 
+
+# By default, capture in monitor mode on interface? (Ex: eth0,eth3,...)
+# A string
+#capture.devices_monitor_mode: 
+
+# Interface buffer size (Ex: en0(1),en1(143),...)
+# A string
+#capture.devices_buffersize: 
+
+# Interface snap length (Ex: en0(65535),en1(1430),...)
+# A string
+#capture.devices_snaplen: 
+
+# Interface promiscuous mode (Ex: en0(0),en1(1),...)
+# A string
+#capture.devices_pmode: 
+
+# Capture in promiscuous mode?
+# TRUE or FALSE (case-insensitive)
+#capture.prom_mode: TRUE
+
+# Interface capture filter (Ex: en0(tcp),en1(udp),...)
+# A string
+#capture.devices_filter: 
+
+# Capture in pcapng format?
+# TRUE or FALSE (case-insensitive)
+#capture.pcap_ng: TRUE
+
+# Update packet list in real time during capture?
+# TRUE or FALSE (case-insensitive)
+#capture.real_time_update: TRUE
+
+# Don't automatically load capture interfaces on startup
+# TRUE or FALSE (case-insensitive)
+#capture.no_interface_load: FALSE
+
+# Disable external capture modules (extcap)
+# TRUE or FALSE (case-insensitive)
+#capture.no_extcap: FALSE
+
+# Scroll packet list during capture?
+# TRUE or FALSE (case-insensitive)
+#capture.auto_scroll: TRUE
+
+# Show capture information dialog while capturing?
+# TRUE or FALSE (case-insensitive)
+#capture.show_info: FALSE
+
+# Column list
+# List of columns to be displayed in the capture options dialog.
+# Possible values: INTERFACE, LINK, PMODE, SNAPLEN, MONITOR, BUFFER, FILTER
+# 
+#capture.columns: 
+#	"INTERFACE", "LINK",
+#	"PMODE", "SNAPLEN",
+#	"MONITOR", "BUFFER",
+#	"FILTER"
+
+####### Console ########
+
+# Look for dissectors that left some bytes undecoded (debug)
+# TRUE or FALSE (case-insensitive)
+#console.incomplete_dissectors_check_debug: FALSE
+
+####### Extcap Utilities ########
+
+# Save arguments on start of capture
+# TRUE or FALSE (case-insensitive)
+#extcap.gui_save_on_start: TRUE
+
+# Listen port
+# A string
+#extcap.udpdump.port: 5555
+
+# Payload type
+# A string
+#extcap.udpdump.payload: data
+
+# Run in debug mode
+# A string
+#extcap.udpdump.debug: false
+
+# Use a file for debug
+# A string
+#extcap.udpdump.debugfile: 
+
+# Starting position
+# A string
+#extcap.sdjournal.startfrom: 
+
+# Run in debug mode
+# A string
+#extcap.sdjournal.debug: false
+
+# Use a file for debug
+# A string
+#extcap.sdjournal.debugfile: 
+
+# Remote SSH server address
+# A string
+#extcap.sshdump.remotehost: 
+
+# Remote SSH server port
+# A string
+#extcap.sshdump.remoteport: 
+
+# Remote SSH server username
+# A string
+#extcap.sshdump.remoteusername: 
+
+# Path to SSH private key
+# A string
+#extcap.sshdump.sshkey: 
+
+# ProxyCommand
+# A string
+#extcap.sshdump.proxycommand: 
+
+# Remote interface
+# A string
+#extcap.sshdump.remoteinterface: 
+
+# Remote capture command
+# A string
+#extcap.sshdump.remotecapturecommand: 
+
+# Use sudo on the remote machine
+# A string
+#extcap.sshdump.remotesudo: 
+
+# No promiscuous mode
+# A string
+#extcap.sshdump.remotenoprom: 
+
+# Remote capture filter
+# A string
+#extcap.sshdump.remotefilter: not ((host fe80::3875:876a:45ed:a223 or host fe80::82fa:5bff:fe81:6162 or host 192.168.132.1 or host 192.168.17.1 or host 172.18.40.143) and port 22)
+
+# Packets to capture
+# A string
+#extcap.sshdump.remotecount: 0
+
+# Run in debug mode
+# A string
+#extcap.sshdump.debug: false
+
+# Use a file for debug
+# A string
+#extcap.sshdump.debugfile: 
+
+# Remote SSH server address
+# A string
+#extcap.ciscodump.remotehost: 
+
+# Remote SSH server port
+# A string
+#extcap.ciscodump.remoteport: 22
+
+# Remote SSH server username
+# A string
+#extcap.ciscodump.remoteusername: root
+
+# Path to SSH private key
+# A string
+#extcap.ciscodump.sshkey: 
+
+# ProxyCommand
+# A string
+#extcap.ciscodump.proxycommand: 
+
+# Remote interface
+# A string
+#extcap.ciscodump.remoteinterface: 
+
+# Remote capture filter
+# A string
+#extcap.ciscodump.remotefilter: deny tcp host fe80::3875:876a:45ed:a223 any eq 0, deny tcp any eq 0 host fe80::3875:876a:45ed:a223, deny tcp host fe80::82fa:5bff:fe81:6162 any eq 0, deny tcp any eq 0 host fe80::82fa:5bff:fe81:6162, deny tcp host 192.168.132.1 any eq 0, deny tcp any eq 0 host 192.168.132.1, deny tcp host 192.168.17.1 any eq 0, deny tcp any eq 0 host 192.168.17.1, deny tcp host 172.18.40.143 any eq 0, deny tcp any eq 0 host 172.18.40.143, permit ip any any
+
+# Packets to capture
+# A string
+#extcap.ciscodump.remotecount: 
+
+# Run in debug mode
+# A string
+#extcap.ciscodump.debug: false
+
+# Use a file for debug
+# A string
+#extcap.ciscodump.debugfile: 
+
+# Max bytes in a packet
+# A string
+#extcap.randpkt.maxbytes: 5000
+
+# Number of packets
+# A string
+#extcap.randpkt.count: 1000
+
+# Packet delay (ms)
+# A string
+#extcap.randpkt.delay: 0
+
+# Random type
+# A string
+#extcap.randpkt.randomtype: false
+
+# All random packets
+# A string
+#extcap.randpkt.allrandom: false
+
+# Type of packet
+# A string
+#extcap.randpkt.type: 
+
+# Run in debug mode
+# A string
+#extcap.randpkt.debug: false
+
+# Use a file for debug
+# A string
+#extcap.randpkt.debugfile: 
+
+# Interface index
+# A string
+#extcap.dpauxmon.interface_id: 0
+
+# Run in debug mode
+# A string
+#extcap.dpauxmon.debug: false
+
+# Use a file for debug
+# A string
+#extcap.dpauxmon.debugfile: 
+
+####### Name Resolution ########
+
+# Resolve Ethernet MAC addresses to host names from the preferences or system's Ethers file, or to a manufacturer based name.
+# TRUE or FALSE (case-insensitive)
+#nameres.mac_name: TRUE
+
+# Resolve TCP/UDP ports into service names
+# TRUE or FALSE (case-insensitive)
+#nameres.transport_name: FALSE
+
+# Resolve IPv4, IPv6, and IPX addresses into host names. The next set of check boxes determines how name resolution should be performed. If no other options are checked name resolution is made from Wireshark's host file and capture file name resolution blocks.
+# TRUE or FALSE (case-insensitive)
+#nameres.network_name: FALSE
+
+# Whether address/name pairs found in captured DNS packets should be used by Wireshark for name resolution.
+# TRUE or FALSE (case-insensitive)
+#nameres.dns_pkt_addr_resolution: TRUE
+
+# Use your system's configured name resolver (usually DNS) to resolve network names. Only applies when network name resolution is enabled.
+# TRUE or FALSE (case-insensitive)
+#nameres.use_external_name_resolver: TRUE
+
+# Uses DNS Servers list to resolve network names if TRUE.  If FALSE, default information is used
+# TRUE or FALSE (case-insensitive)
+#nameres.use_custom_dns_servers: FALSE
+
+# The maximum number of DNS requests that may be active at any time. A large value (many thousands) might overload the network or make your DNS server behave badly.
+# A decimal number
+#nameres.name_resolve_concurrency: 500
+
+# By default "hosts" files will be loaded from multiple sources. Checking this box only loads the "hosts" in the current profile.
+# TRUE or FALSE (case-insensitive)
+#nameres.hosts_file_handling: FALSE
+
+# Resolve VLAN IDs to network names from the preferences "vlans" file. Format of the file is: "ID<Tab>Name". One line per VLAN, e.g.: 1 Management
+# TRUE or FALSE (case-insensitive)
+#nameres.vlan_name: FALSE
+
+# Resolve SS7 Point Codes to node names from the profiles "ss7pcs" file. Format of the file is: "Network_Indicator<Dash>PC_Decimal<Tab>Name". One line per Point Code, e.g.: 2-1234 MyPointCode1
+# TRUE or FALSE (case-insensitive)
+#nameres.ss7_pc_name: FALSE
+
+# Resolve Object IDs to object names from the MIB and PIB modules defined below. You must restart Wireshark for this change to take effect
+# TRUE or FALSE (case-insensitive)
+#nameres.load_smi_modules: FALSE
+
+# While loading MIB or PIB modules errors may be detected, which are reported. Some errors can be ignored. If unsure, set to false.
+# TRUE or FALSE (case-insensitive)
+#nameres.suppress_smi_errors: FALSE
+
+####### Protocols ########
+
+# Display all hidden protocol items in the packet list.
+# TRUE or FALSE (case-insensitive)
+#protocols.display_hidden_proto_items: FALSE
+
+# Display all byte fields with a space character between each byte in the packet list.
+# TRUE or FALSE (case-insensitive)
+#protocols.display_byte_fields_with_spaces: FALSE
+
+# Look for dissectors that left some bytes undecoded.
+# TRUE or FALSE (case-insensitive)
+#protocols.enable_incomplete_dissectors_check: FALSE
+
+# Protocols may use things like VLAN ID or interface ID to narrow the potential for duplicate conversations. Currently ICMP and ICMPv6 use this preference to add VLAN ID to conversation tracking, and IPv4 uses this preference to take VLAN ID into account during reassembly
+# TRUE or FALSE (case-insensitive)
+#protocols.strict_conversation_tracking_heuristics: FALSE
+
+# Use a registered heuristic sub-dissector to decode the data payload
+# TRUE or FALSE (case-insensitive)
+#lbmc.use_heuristic_subdissectors: TRUE
+
+# Reassemble data message fragments
+# TRUE or FALSE (case-insensitive)
+#lbmc.reassemble_fragments: FALSE
+
+# Recognize and dissect payloads containing LBMPDM messages (requires reassembly to be enabled)
+# TRUE or FALSE (case-insensitive)
+#lbmc.dissect_lbmpdm: FALSE
+
+# Set the low end of the TCP port range
+# A decimal number
+#lbmpdm_tcp.port_low: 14371
+
+# Set the high end of the port range
+# A decimal number
+#lbmpdm_tcp.port_high: 14390
+
+# Use table of LBMPDM-TCP tags to decode the packet instead of above values
+# TRUE or FALSE (case-insensitive)
+#lbmpdm_tcp.use_lbmpdm_tcp_domain: FALSE
+
+# Set the UDP port for incoming multicast topic resolution (context resolver_multicast_incoming_port)
+# A decimal number
+#lbmr.mc_incoming_port: 12965
+
+# Set the multicast address for incoming multicast topic resolution (context resolver_multicast_incoming_address)
+# A string
+#lbmr.mc_incoming_address: 224.9.10.11
+
+# Set the UDP port for outgoing multicast topic resolution (context resolver_multicast_outgoing_port)
+# A decimal number
+#lbmr.mc_outgoing_port: 12965
+
+# Set the multicast address for outgoing multicast topic resolution (context resolver_multicast_outgoing_address)
+# A string
+#lbmr.mc_outgoing_address: 224.9.10.11
+
+# Set the low UDP port for unicast topic resolution (context resolver_unicast_port_low)
+# A decimal number
+#lbmr.uc_port_low: 14402
+
+# Set the high UDP port for unicast topic resolution (context resolver_unicast_port_high)
+# A decimal number
+#lbmr.uc_port_high: 14406
+
+# Set the destination port for unicast topic resolution (context resolver_unicast_destination_port)
+# A decimal number
+#lbmr.uc_dest_port: 15380
+
+# Set the address of the unicast resolver daemon (context resolver_unicast_address)
+# A string
+#lbmr.uc_address: 0.0.0.0
+
+# Use table of LBMR tags to decode the packet instead of above values
+# TRUE or FALSE (case-insensitive)
+#lbmr.use_lbmr_domain: FALSE
+
+# Set the LBMSRS IP Address
+# A string
+#lbmsrs.source_ip_address: 127.0.0.1
+
+# Set the source TCP port
+# A decimal number
+#lbmsrs.source_port: 0
+
+# Use table of LBMSRS tags to decode the packet instead of above values
+# TRUE or FALSE (case-insensitive)
+#lbmsrs.use_lbmsrs_domain: FALSE
+
+# Set the low end of the LBT-RM multicast address range (context transport_lbtrm_multicast_address_low)
+# A string
+#lbtrm.mc_address_low: 224.10.10.10
+
+# Set the high end of the LBT-RM multicast address range (context transport_lbtrm_multicast_address_high)
+# A string
+#lbtrm.mc_address_high: 224.10.10.14
+
+# Set the low end of the LBT-RM UDP destination port range (source transport_lbtrm_destination_port)
+# A decimal number
+#lbtrm.dport_low: 14400
+
+# Set the high end of the LBT-RM UDP destination port range (source transport_lbtrm_destination_port)
+# A decimal number
+#lbtrm.dport_high: 14400
+
+# Set the low end of the LBT-RM UDP source port range (context transport_lbtrm_source_port_low)
+# A decimal number
+#lbtrm.sport_low: 14390
+
+# Set the high end of the LBT-RM UDP source port range (context transport_lbtrm_source_port_high)
+# A decimal number
+#lbtrm.sport_high: 14399
+
+# Set the incoming MIM multicast address (context mim_incoming_address)
+# A string
+#lbtrm.mim_incoming_address: 224.10.10.21
+
+# Set the outgoing MIM multicast address (context mim_outgoing_address)
+# A string
+#lbtrm.mim_outgoing_address: 224.10.10.21
+
+# Set the incoming MIM UDP port (context mim_incoming_destination_port)
+# A decimal number
+#lbtrm.mim_incoming_dport: 14401
+
+# Set the outgoing MIM UDP port (context mim_outgoing_destination_port)
+# A decimal number
+#lbtrm.mim_outgoing_dport: 14401
+
+# Separate multiple NAKs from a single packet into distinct Expert Info entries
+# TRUE or FALSE (case-insensitive)
+#lbtrm.expert_separate_naks: FALSE
+
+# Separate multiple NCFs from a single packet into distinct Expert Info entries
+# TRUE or FALSE (case-insensitive)
+#lbtrm.expert_separate_ncfs: FALSE
+
+# Perform analysis on LBT-RM sequence numbers to determine out-of-order, gaps, loss, etc
+# TRUE or FALSE (case-insensitive)
+#lbtrm.sequence_analysis: FALSE
+
+# Use table of LBT-RM tags to decode the packet instead of above values
+# TRUE or FALSE (case-insensitive)
+#lbtrm.use_lbtrm_domain: FALSE
+
+# Set the low end of the LBT-RU source UDP port range (context transport_lbtru_port_low)
+# A decimal number
+#lbtru.source_port_low: 14380
+
+# Set the high end of the LBT-RU source UDP port range (context transport_lbtru_port_high)
+# A decimal number
+#lbtru.source_port_high: 14389
+
+# Set the low end of the LBT-RU receiver UDP port range (receiver transport_lbtru_port_low)
+# A decimal number
+#lbtru.receiver_port_low: 14360
+
+# Set the high end of the LBT-RU receiver UDP port range (receiver transport_lbtru_port_high)
+# A decimal number
+#lbtru.receiver_port_high: 14379
+
+# Separate multiple NAKs from a single packet into distinct Expert Info entries
+# TRUE or FALSE (case-insensitive)
+#lbtru.expert_separate_naks: FALSE
+
+# Separate multiple NCFs from a single packet into distinct Expert Info entries
+# TRUE or FALSE (case-insensitive)
+#lbtru.expert_separate_ncfs: FALSE
+
+# Perform analysis on LBT-RU sequence numbers to determine out-of-order, gaps, loss, etc
+# TRUE or FALSE (case-insensitive)
+#lbtru.sequence_analysis: FALSE
+
+# Use table of LBT-RU tags to decode the packet instead of above values
+# TRUE or FALSE (case-insensitive)
+#lbtru.use_lbtru_domain: FALSE
+
+# Set the low end of the LBT-TCP source TCP port range (context transport_tcp_port_low)
+# A decimal number
+#lbttcp.source_port_low: 14371
+
+# Set the high end of the LBT-TCP source TCP port range (context transport_tcp_port_high)
+# A decimal number
+#lbttcp.source_port_high: 14390
+
+# Set the low end of the LBT-TCP request TCP port range (context request_tcp_port_low)
+# A decimal number
+#lbttcp.request_port_low: 14391
+
+# Set the high end of the LBT-TCP request TCP port range (context request_tcp_port_high)
+# A decimal number
+#lbttcp.request_port_high: 14395
+
+# Set the low end of the LBT-TCP UME Store TCP port range
+# A decimal number
+#lbttcp.store_port_low: 0
+
+# Set the high end of the LBT-TCP UME Store TCP port range
+# A decimal number
+#lbttcp.store_port_high: 0
+
+# Use table of LBT-TCP tags to decode the packet instead of above values
+# TRUE or FALSE (case-insensitive)
+#lbttcp.use_lbttcp_domain: FALSE
+
+# Enable this option to recognise all traffic on RTP dynamic payload type 96 (0x60) as FEC data corresponding to Pro-MPEG Code of Practice #3 release 2
+# TRUE or FALSE (case-insensitive)
+#2dparityfec.enable: FALSE
+
+# Derive IID from a short 16-bit address according to RFC 4944 (using the PAN ID).
+# TRUE or FALSE (case-insensitive)
+#6lowpan.rfc4944_short_address_format: FALSE
+
+# Linux kernels before version 4.12 does toggle the Universal/Local bit.
+# TRUE or FALSE (case-insensitive)
+#6lowpan.iid_has_universal_local_bit: FALSE
+
+# Whether the IPv6 summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#6lowpan.summary_in_tree: TRUE
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context0: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context1: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context2: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context3: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context4: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context5: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context6: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context7: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context8: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context9: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context10: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context11: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context12: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context13: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context14: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context15: 
+
+# Some generators incorrectly indicate long preamble when the preamble was actuallyshort. Always assume short preamble when calculating duration.
+# TRUE or FALSE (case-insensitive)
+#wlan_radio.always_short_preamble: FALSE
+
+# Some generators timestamp the end of the PPDU rather than the start of the (A)MPDU.
+# TRUE or FALSE (case-insensitive)
+#wlan_radio.tsf_at_end: TRUE
+
+# Enables an additional panel for navigating through packets
+# TRUE or FALSE (case-insensitive)
+#wlan_radio.timeline: FALSE
+
+# Radiotap has a bit to indicate whether the FCS is still on the frame or not. Some generators (e.g. AirPcap) use a non-standard radiotap flag 14 to put the FCS into the header.
+# TRUE or FALSE (case-insensitive)
+#radiotap.bit14_fcs_in_header: FALSE
+
+# Some generators use rates with bit 7 set to indicate an MCS, e.g. BSD. others (Linux, AirPcap) do not.
+# TRUE or FALSE (case-insensitive)
+#radiotap.interpret_high_rates_as_mcs: FALSE
+
+# Whether to use the FCS bit, assume the FCS is always present, or assume the FCS is never present.
+# One of: Use the FCS bit, Assume all packets have an FCS at the end, Assume all packets don't have an FCS at the end
+# (case-insensitive).
+#radiotap.fcs_handling: Use the FCS bit
+
+# Use ipaccess nanoBTS specific definitions for OML
+# One of: ETSI/3GPP TS 12.21, Siemens, ip.access, Ericsson OM2000
+# (case-insensitive).
+#gsm_abis_oml.oml_dialect: ETSI/3GPP TS 12.21
+
+# Enable Streaming DMX extension dissector (ANSI BSR E1.31)
+# TRUE or FALSE (case-insensitive)
+#acn.dmx_enable: FALSE
+
+# Display format
+# One of: Hex    , Decimal, Percent
+# (case-insensitive).
+#acn.dmx_display_view: Hex    
+
+# Display zeros instead of dots
+# TRUE or FALSE (case-insensitive)
+#acn.dmx_display_zeros: FALSE
+
+# Display leading zeros on levels
+# TRUE or FALSE (case-insensitive)
+#acn.dmx_display_leading_zeros: FALSE
+
+# Display line format
+# One of: 20 per line, 16 per line
+# (case-insensitive).
+#acn.dmx_display_line_format: 20 per line
+
+# Server Port
+# A decimal number
+#adb_cs.server_port: 5037
+
+# Dissect more detail for framebuffer service
+# TRUE or FALSE (case-insensitive)
+#adb_service.framebuffer_more_details: FALSE
+
+# Specify if the Data sections of packets should be dissected or not
+# TRUE or FALSE (case-insensitive)
+#adwin.dissect_data: TRUE
+
+# Include next/previous frame for channel, stream, and term, and other transport sequence analysis.
+# TRUE or FALSE (case-insensitive)
+#aeron.sequence_analysis: FALSE
+
+# Include stream analysis, tracking publisher and subscriber positions. Requires "Analyze transport sequencing".
+# TRUE or FALSE (case-insensitive)
+#aeron.stream_analysis: FALSE
+
+# Reassemble fragmented data messages. Requires "Analyze transport sequencing" and "Analyze stream sequencing".
+# TRUE or FALSE (case-insensitive)
+#aeron.reassemble_fragments: FALSE
+
+# Use a registered heuristic sub-dissector to decode the payload data. Requires "Analyze transport sequencing", "Analyze stream sequencing", and "Reassemble fragmented data".
+# TRUE or FALSE (case-insensitive)
+#aeron.use_heuristic_subdissectors: FALSE
+
+# Whether fragmented AFS PDUs should be reassembled
+# TRUE or FALSE (case-insensitive)
+#afs.defragment: FALSE
+
+# Whether the AIM dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#aim.desegment: TRUE
+
+# Whether the LCT header Codepoint field should be considered the FEC Encoding ID of carried object
+# TRUE or FALSE (case-insensitive)
+#alc.lct.codepoint_as_fec_id: TRUE
+
+# How to decode LCT header extension 192
+# One of: Don't decode, Decode as FLUTE extension (EXT_FDT)
+# (case-insensitive).
+#alc.lct.ext.192: Decode as FLUTE extension (EXT_FDT)
+
+# How to decode LCT header extension 193
+# One of: Don't decode, Decode as FLUTE extension (EXT_CENC)
+# (case-insensitive).
+#alc.lct.ext.193: Decode as FLUTE extension (EXT_CENC)
+
+# Whether persistent call leg information is to be kept
+# TRUE or FALSE (case-insensitive)
+#alcap.leg_info: TRUE
+
+# Set the TCP port for AMQP over SSL/TLS(if other than the default of 5671)
+# A decimal number
+#amqp.tls.port: 5671
+
+# Dynamic payload types which will be interpreted as AMR; values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#amr.dynamic.payload.type: 
+
+# Dynamic payload types which will be interpreted as AMR-WB; values must be in the range 1-127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#amr.wb.dynamic.payload.type: 
+
+# Type of AMR encoding of the payload
+# One of: RFC 3267 octet aligned, RFC 3267 BW-efficient, AMR IF1, AMR IF2
+# (case-insensitive).
+#amr.encoding.version: RFC 3267 octet aligned
+
+# The AMR mode
+# One of: Narrowband AMR, Wideband AMR
+# (case-insensitive).
+#amr.mode: Narrowband AMR
+
+# (if other than the default of IOS 4.0.1)
+# One of: IS-634 rev. 0, TSB-80, IS-634-A, IOS 2.x, IOS 3.x, IOS 4.0.1, IOS 5.0.1
+# (case-insensitive).
+#ansi_a_bsmap.global_variant: IOS 4.0.1
+
+# Whether the mobile ID and service options are displayed in the INFO column
+# TRUE or FALSE (case-insensitive)
+#ansi_a_bsmap.top_display_mid_so: TRUE
+
+# ANSI MAP SSNs to decode as ANSI MAP
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#ansi_map.map.ssn: 5-14
+
+# Type of matching invoke/response, risk of mismatch if loose matching chosen
+# One of: Transaction ID only, Transaction ID and Source, Transaction ID Source and Destination
+# (case-insensitive).
+#ansi_map.transaction.matchtype: Transaction ID and Source
+
+# Type of matching invoke/response, risk of mismatch if loose matching chosen
+# One of: Transaction ID only, Transaction ID and Source, Transaction ID Source and Destination
+# (case-insensitive).
+#ansi_tcap.transaction.matchtype: Transaction ID only
+
+# Whether the AOL dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#aol.desegment: TRUE
+
+# Attempt to display common APRS protocol violations correctly
+# TRUE or FALSE (case-insensitive)
+#aprs.showaprslax: FALSE
+
+# Attempt to detect excessive rate of ARP requests
+# TRUE or FALSE (case-insensitive)
+#arp.detect_request_storms: FALSE
+
+# Number of requests needed within period to indicate a storm
+# A decimal number
+#arp.detect_storm_number_of_packets: 30
+
+# Period in milliseconds during which a packet storm may be detected
+# A decimal number
+#arp.detect_storm_period: 100
+
+# Attempt to detect duplicate use of IP addresses
+# TRUE or FALSE (case-insensitive)
+#arp.detect_duplicate_ips: TRUE
+
+# Try to resolve physical addresses to host names from ARP requests/responses
+# TRUE or FALSE (case-insensitive)
+#arp.register_network_address_binding: TRUE
+
+# Select the CAT001 version
+# One of: Version 1.2
+# (case-insensitive).
+#asterix.i001_version: Version 1.2
+
+# Select the CAT002 version
+# One of: Version 1.0
+# (case-insensitive).
+#asterix.i002_version: Version 1.0
+
+# Select the CAT004 version
+# One of: Version 1.11
+# (case-insensitive).
+#asterix.i004_version: Version 1.11
+
+# Select the CAT008 version
+# One of: Version 1.1
+# (case-insensitive).
+#asterix.i008_version: Version 1.1
+
+# Select the CAT009 version
+# One of: Version 2.0
+# (case-insensitive).
+#asterix.i009_version: Version 2.0
+
+# Select the CAT010 version
+# One of: Version 1.10
+# (case-insensitive).
+#asterix.i010_version: Version 1.10
+
+# Select the CAT011 version
+# One of: Version 1.20
+# (case-insensitive).
+#asterix.i011_version: Version 1.20
+
+# Select the CAT019 version
+# One of: Version 1.3
+# (case-insensitive).
+#asterix.i019_version: Version 1.3
+
+# Select the CAT020 version
+# One of: Version 1.9
+# (case-insensitive).
+#asterix.i020_version: Version 1.9
+
+# Select the CAT021 version
+# One of: Version 2.3, Version 2.1, Version 0.26, Version 0.23
+# (case-insensitive).
+#asterix.i021_version: Version 2.3
+
+# Select the CAT023 version
+# One of: Version 1.2
+# (case-insensitive).
+#asterix.i023_version: Version 1.2
+
+# Select the CAT025 version
+# One of: Version 1.1
+# (case-insensitive).
+#asterix.i025_version: Version 1.1
+
+# Select the CAT032 version
+# One of: Version 1.0
+# (case-insensitive).
+#asterix.i032_version: Version 1.0
+
+# Select the CAT034 version
+# One of: Version 1.27
+# (case-insensitive).
+#asterix.i034_version: Version 1.27
+
+# Select the CAT048 version
+# One of: Version 1.23, Version 1.21, Version 1.17
+# (case-insensitive).
+#asterix.i048_version: Version 1.23
+
+# Select the CAT062 version
+# One of: Version 1.18, Version 1.17, Version 1.16, Version 0.17
+# (case-insensitive).
+#asterix.i062_version: Version 1.18
+
+# Select the CAT063 version
+# One of: Version 1.4
+# (case-insensitive).
+#asterix.i063_version: Version 1.4
+
+# Select the CAT065 version
+# One of: Version 1.4, Version 1.3
+# (case-insensitive).
+#asterix.i065_version: Version 1.4
+
+# Select the CAT240 version
+# One of: Version 1.3
+# (case-insensitive).
+#asterix.i240_version: Version 1.3
+
+# Force treat packets as DTE (PC) or DCE (Modem) role
+# One of: Off, Sent is DTE, Rcvd is DCE, Sent is DCE, Rcvd is DTE
+# (case-insensitive).
+#at.role: Off
+
+# Autodetection between LANE and SSCOP is hard. As default LANE is preferred
+# TRUE or FALSE (case-insensitive)
+#atm.dissect_lane_as_sscop: FALSE
+
+# Whether the ATP dissector should reassemble messages spanning multiple DDP packets
+# TRUE or FALSE (case-insensitive)
+#atp.desegment: TRUE
+
+# Define the standard version that applies to the CBV field
+# One of: AUTOSAR 3.0 or 3.1, AUTOSAR 3.2, AUTOSAR 4.0, AUTOSAR 4.1 or newer, AUTOSAR 20-11
+# (case-insensitive).
+#autosar-nm.cbv_version: AUTOSAR 4.1 or newer
+
+# Make the NM dissector interpret this byte as Control Bit Vector (CBV)
+# One of: Byte Position 0, Byte Position 1, Turned off
+# (case-insensitive).
+#autosar-nm.cbv_position: Byte Position 0
+
+# Make the NM dissector interpret this byte as Source Node Identifier (SNI)
+# One of: Byte Position 0, Byte Position 1, Turned off
+# (case-insensitive).
+#autosar-nm.sni_position: Byte Position 1
+
+# Identifier that is used to filter packets that should be dissected. Set bit 31 when defining an extended id. (works with the mask defined below)
+# A hexadecimal number
+#autosar-nm.can_id: 0
+
+# Mask applied to CAN identifiers when decoding whether a packet should dissected. Use 0xFFFFFFFF mask to require exact match.
+# A hexadecimal number
+#autosar-nm.can_id_mask: 0xffffffff
+
+# PDU Transport IDs.
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#autosar-nm.pdu_transport.ids: 
+
+# Enable checksum calculation.
+# TRUE or FALSE (case-insensitive)
+#ax25_kiss.showcksum: FALSE
+
+# Enable decoding of the payload as APRS.
+# TRUE or FALSE (case-insensitive)
+#ax25_nol3.showaprs: FALSE
+
+# Enable decoding of the payload as DX cluster info.
+# TRUE or FALSE (case-insensitive)
+#ax25_nol3.showcluster: FALSE
+
+# Ethertype used to indicate B.A.T.M.A.N. packet.
+# A hexadecimal number
+#batadv.batmanadv.ethertype: 0x4305
+
+# Whether the Bazaar dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#bzr.desegment: TRUE
+
+# Specifies that BEEP requires CRLF as a terminator, and not just CR or LF
+# TRUE or FALSE (case-insensitive)
+#beep.strict_header_terminator: TRUE
+
+# Whether the dissector should also display internal ASN.1 BER details such as Identifier and Length fields
+# TRUE or FALSE (case-insensitive)
+#ber.show_internals: FALSE
+
+# Whether the dissector should decode unexpected tags as ASN.1 BER encoded data
+# TRUE or FALSE (case-insensitive)
+#ber.decode_unexpected: FALSE
+
+# Whether the dissector should try decoding OCTET STRINGs as constructed ASN.1 BER encoded data
+# TRUE or FALSE (case-insensitive)
+#ber.decode_octetstring: FALSE
+
+# Whether the dissector should try decoding unknown primitive as constructed ASN.1 BER encoded data
+# TRUE or FALSE (case-insensitive)
+#ber.decode_primitive: FALSE
+
+# Whether the dissector should warn if excessive leading zero (0) bits
+# TRUE or FALSE (case-insensitive)
+#ber.warn_too_many_bytes: FALSE
+
+# Whether the BGP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#bgp.desegment: TRUE
+
+# BGP dissector detect the length of the AS number in AS_PATH attributes automatically or manually (NOTE: Automatic detection is not 100% accurate)
+# One of: Auto-detect, 2 octet, 4 octet
+# (case-insensitive).
+#bgp.asn_len: Auto-detect
+
+# Whether the Bitcoin dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#bitcoin.desegment: TRUE
+
+# Whether the BitTorrent dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#bittorrent.desegment: TRUE
+
+# Enabling this will tell which BitTorrent client that produced the handshake message
+# TRUE or FALSE (case-insensitive)
+#bittorrent.decode_client: FALSE
+
+# The maximum size of the buffer for uncompressed messages. If a message is larger than this, then the packet containing the message, as well as subsequent packets, will fail to decompress
+# A decimal number
+#blip.max_uncompressed_size: 64
+
+# Force decoding stream as A2DP with Content Protection SCMS-T 
+# TRUE or FALSE (case-insensitive)
+#bta2dp.a2dp.content_protection.scms_t: FALSE
+
+# Force decoding stream as A2DP with specified codec
+# One of: Default, SBC, MPEG12 AUDIO, MPEG24 AAC, aptX, aptX HD, LDAC
+# (case-insensitive).
+#bta2dp.a2dp.codec: Default
+
+# Dissecting the top protocols
+# TRUE or FALSE (case-insensitive)
+#btbnep.bnep.top_dissect: TRUE
+
+# If "yes" localhost will be treat as Client, "no" as Server
+# One of: Default, Yes, No
+# (case-insensitive).
+#bthcrp.hcrp.force_client: Default
+
+# L2CAP PSM for Control
+# A decimal number
+#bthcrp.hcrp.control.psm: 0
+
+# L2CAP PSM for Data
+# A decimal number
+#bthcrp.hcrp.data.psm: 0
+
+# L2CAP PSM for Notification
+# A decimal number
+#bthcrp.hcrp.notification.psm: 0
+
+# Force treat packets as AG or HS role
+# One of: Off, Sent is AG, Rcvd is HS, Sent is HS, Rcvd is AG
+# (case-insensitive).
+#bthfp.hfp.hfp_role: Off
+
+# Show what is deprecated in HID 1.1
+# TRUE or FALSE (case-insensitive)
+#bthid.hid.deprecated: FALSE
+
+# Force treat packets as AG or HS role
+# One of: Off, Sent is AG, Rcvd is HS, Sent is HS, Rcvd is AG
+# (case-insensitive).
+#bthsp.hsp.hsp_role: Off
+
+# Detect retransmission based on SN (Sequence Number)
+# TRUE or FALSE (case-insensitive)
+#btle.detect_retransmit: TRUE
+
+# Turn on/off decode by next rules
+# TRUE or FALSE (case-insensitive)
+#btrfcomm.rfcomm.decode_by.enabled: FALSE
+
+# Dissecting the top protocols
+# One of: off, Put higher dissectors under this one, On top
+# (case-insensitive).
+#btsap.sap.top_dissect: Put higher dissectors under this one
+
+# Force decoding stream as VDP with Content Protection SCMS-T 
+# TRUE or FALSE (case-insensitive)
+#btvdp.vdp.content_protection.scms_t: FALSE
+
+# Force decoding stream as VDP with specified codec
+# One of: H263, MPEG4 VSP
+# (case-insensitive).
+#btvdp.vdp.codec: H263
+
+# Whether the ACL dissector should reassemble fragmented PDUs
+# TRUE or FALSE (case-insensitive)
+#bthci_acl.hci_acl_reassembly: TRUE
+
+# Whether the ISO dissector should reassemble fragmented PDUs
+# TRUE or FALSE (case-insensitive)
+#bthci_iso.hci_iso_reassembly: TRUE
+
+# Whether the BMP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#bmp.desegment: TRUE
+
+# If enabled, the blocks will have CRC checks performed.
+# TRUE or FALSE (case-insensitive)
+#bpv7.bp_compute_crc: TRUE
+
+# Whether the dissector should reassemble fragmented bundle payloads.
+# TRUE or FALSE (case-insensitive)
+#bpv7.bp_reassemble_payload: TRUE
+
+# When dissecting block type-specific data and payload and no destination matches, attempt heuristic dissection.
+# TRUE or FALSE (case-insensitive)
+#bpv7.bp_payload_try_heur: FALSE
+
+# For the sake of sub-dissectors registering to accept data from the BSSAP/BSAP dissector, this defines whether it is identified as BSSAP or BSAP.
+# One of: BSSAP, BSAP
+# (case-insensitive).
+#bssap.bsap_or_bssap: BSSAP
+
+# GSM-A is the interface between the BSC and the MSC. Lb is the interface between the BSC and the SMLC.
+# One of: GSM A, Lb
+# (case-insensitive).
+#bssap.gsm_or_lb_interface: GSM A
+
+# Set Subsystem number used for BSSAP+
+# A decimal number
+#bssap_plus.ssn: 98
+
+# Whether the dissector should attempt to dissect packets with the obsolete format (version 0) that predates BEP 29 (22-Jun-2009)
+# TRUE or FALSE (case-insensitive)
+#bt-utp.enable_version0: FALSE
+
+# Maximum receive window size allowed by the dissector. Early clients (and a few modern ones) set this value to 0x380000 (the default), later ones use smaller values like 0x100000 and 0x40000. A higher value can detect nonstandard packets, but at the cost of false positives.
+# A hexadecimal number
+#bt-utp.max_window_size: 0x380000
+
+# Dissect next layer
+# TRUE or FALSE (case-insensitive)
+#btsnoop.dissect_next_layer: FALSE
+
+# Whether the C12.22 dissector should reassemble all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#c1222.desegment: TRUE
+
+# Base object identifier for use in resolving relative object identifiers
+# A string
+#c1222.baseoid: 
+
+# Whether the C12.22 dissector should verify the crypto for all relevant messages
+# TRUE or FALSE (case-insensitive)
+#c1222.decrypt: TRUE
+
+# Whether the C12.22 dissector should interpret procedure numbers as big-endian
+# TRUE or FALSE (case-insensitive)
+#c1222.big_endian: FALSE
+
+# The date format: (DD/MM) or (MM/DD)
+# One of: DD/MM/YYYY, MM/DD/YYYY
+# (case-insensitive).
+#camel.date.format: DD/MM/YYYY
+
+# TCAP Subsystem numbers used for Camel
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#camel.tcap.ssn: 146
+
+# Enable response time analysis
+# TRUE or FALSE (case-insensitive)
+#camel.srt: FALSE
+
+# Statistics for Response Time
+# TRUE or FALSE (case-insensitive)
+#camel.persistentsrt: FALSE
+
+# Whether the CAN ID/flags field should be byte-swapped
+# TRUE or FALSE (case-insensitive)
+#can.byte_swap: FALSE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to "decode as"
+# TRUE or FALSE (case-insensitive)
+#can.try_heuristic_first: FALSE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to "decode as"
+# TRUE or FALSE (case-insensitive)
+#acf-can.try_heuristic_first: FALSE
+
+# Enable support of Cisco Wireless Controller (based on old 8 draft revision).
+# TRUE or FALSE (case-insensitive)
+#capwap.draft_8_cisco: FALSE
+
+# Reassemble fragmented CAPWAP packets.
+# TRUE or FALSE (case-insensitive)
+#capwap.reassemble: TRUE
+
+# Swap frame control bytes (needed for some APs).
+# TRUE or FALSE (case-insensitive)
+#capwap.swap_fc: TRUE
+
+# Whether the CAST dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#cast.reassembly: TRUE
+
+# Whether the checksum of all messages should be validated or not
+# TRUE or FALSE (case-insensitive)
+#cattp.checksum: TRUE
+
+# Specify how the dissector should handle the CCSDS checkword
+# One of: Use header flag, Override header flag to be false, Override header flag to be true
+# (case-insensitive).
+#ccsds.global_pref_checkword: Use header flag
+
+# Whether or not the RTP header is present in the CES payload.
+# TRUE or FALSE (case-insensitive)
+#cesoeth.rtp_header: FALSE
+
+# Heuristically determine if an RTP header is present in the CES payload.
+# TRUE or FALSE (case-insensitive)
+#cesoeth.rtp_header_heuristic: TRUE
+
+# Set the port(s) for NetFlow messages (default: 2055,9996)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#cflow.netflow.ports: 2055,9996
+
+# Set the port(s) for IPFIX messages (default: 4739)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#cflow.ipfix.ports: 4739
+
+# Set the number of fields allowed in a template.  Use 0 (zero) for unlimited.   (default: 60)
+# A decimal number
+#cflow.max_template_fields: 60
+
+# Whether the Netflow/Ipfix dissector should reassemble messages spanning multiple TCP segments.  To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#cflow.desegment: TRUE
+
+# Whether to validate the Frame Check Sequence
+# TRUE or FALSE (case-insensitive)
+#cfp.check_fcs: FALSE
+
+# The type of CHDLC frame checksum (none, 16-bit, 32-bit)
+# One of: None, 16-Bit, 32-Bit
+# (case-insensitive).
+#chdlc.fcs_type: None
+
+# The version of CIGI with which to dissect packets
+# One of: From Packet, CIGI 2, CIGI 3
+# (case-insensitive).
+#cigi.version: From Packet
+
+# The byte order with which to dissect CIGI packets (CIGI3)
+# One of: From Packet, Big-Endian, Little-Endian
+# (case-insensitive).
+#cigi.byte_order: From Packet
+
+# IPv4 address or hostname of the host
+# A string
+#cigi.host: 
+
+# IPv4 address or hostname of the image generator
+# A string
+#cigi.ig: 
+
+# Whether the CIP dissector should display enhanced/verbose data in the Info column for CIP explicit messages
+# TRUE or FALSE (case-insensitive)
+#cip.enhanced_info_column: TRUE
+
+# Whether the CIP Motion dissector always display the full raw attribute data bytes
+# TRUE or FALSE (case-insensitive)
+#cipm.display_full_attribute_data: FALSE
+
+# NSAP selector for Transport Protocol (last byte in hex)
+# A hexadecimal number
+#clnp.tp_nsap_selector: 0x21
+
+# Always try to decode NSDU as transport PDUs
+# TRUE or FALSE (case-insensitive)
+#clnp.always_decode_transport: FALSE
+
+# Whether segmented CLNP datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#clnp.reassemble: TRUE
+
+# Whether ATN security label should be decoded
+# TRUE or FALSE (case-insensitive)
+#clnp.decode_atn_options: FALSE
+
+# Whether the CMP-over-TCP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#cmp.desegment: TRUE
+
+# Decode this TCP port's traffic as CMP-over-HTTP. Set to "0" to disable. Use this if the Content-Type is not set correctly.
+# A decimal number
+#cmp.http_alternate_port: 0
+
+# Decode this TCP port's traffic as TCP-transport-style CMP-over-HTTP. Set to "0" to disable. Use this if the Content-Type is not set correctly.
+# A decimal number
+#cmp.tcp_style_http_alternate_port: 0
+
+# Whether to base64-encode the Community ID hash value
+# TRUE or FALSE (case-insensitive)
+#communityid.do_base64: TRUE
+
+# A 16-bit seed value to add to the hashed data
+# A decimal number
+#communityid.seed: 0
+
+# Whether the COPS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#cops.desegment: TRUE
+
+# Decode the COPS messages using PacketCable clients. (Select port 2126)
+# TRUE or FALSE (case-insensitive)
+#cops.packetcable: TRUE
+
+# Semicolon-separated  list of keys for decryption(e.g. key1;key2;...
+# A string
+#corosync_totemnet.private_keys: 
+
+# Whether segmented COTP datagrams should be reassembled. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#cotp.reassemble: TRUE
+
+# How TSAPs should be displayed
+# One of: As strings if printable, As strings, As bytes
+# (case-insensitive).
+#cotp.tsap_display: As strings if printable
+
+# Whether to decode OSI TPDUs with ATN (Aeronautical Telecommunications Network) extensions. To use this option, you must also enable "Always try to decode NSDU as transport PDUs" in the CLNP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#cotp.decode_atn: FALSE
+
+# Whether the memcache dissector should reassemble PDUs spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#couchbase.desegment_pdus: TRUE
+
+# The port used for communicating with the data service via SSL/TLS
+# A decimal number
+#couchbase.tls.port: 11207
+
+# Whether the SEL Protocol dissector should automatically pre-process Telnet data to remove IAC bytes
+# TRUE or FALSE (case-insensitive)
+#cp2179.telnetclean: TRUE
+
+# Set the port for InstanceToInstance messages (if other than the default of 5001)
+# A decimal number
+#cpfi.udp.port2: 5001
+
+# Control the way the '-->' is displayed. When enabled, keeps the 'lowest valued' endpoint of the src-dest pair on the left, and the arrow moves to distinguish source from dest. When disabled, keeps the arrow pointing right so the source of the frame is always on the left.
+# TRUE or FALSE (case-insensitive)
+#cpfi.arrow_ctl: TRUE
+
+# Show not dissected data on new Packet Bytes pane
+# TRUE or FALSE (case-insensitive)
+#data.datapref.newpane: FALSE
+
+# Try to uncompress zlib compressed data and show as uncompressed if successful
+# TRUE or FALSE (case-insensitive)
+#data.uncompress_data: FALSE
+
+# Show data as text in the Packet Details pane
+# TRUE or FALSE (case-insensitive)
+#data.show_as_text: FALSE
+
+# Whether or not MD5 hashes should be generated and shown for each payload.
+# TRUE or FALSE (case-insensitive)
+#data.md5_hash: FALSE
+
+# Whether the LAN sync dissector should reassemble PDUs spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#db-lsp.desegment_pdus: TRUE
+
+# Try to decode the payload using an heuristic sub-dissector
+# TRUE or FALSE (case-insensitive)
+#db-lsp.try_heuristic: TRUE
+
+# Whether the DCCP summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#dccp.summary_in_tree: TRUE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to a specific port
+# TRUE or FALSE (case-insensitive)
+#dccp.try_heuristic_first: FALSE
+
+# Whether to check the validity of the DCCP checksum
+# TRUE or FALSE (case-insensitive)
+#dccp.check_checksum: TRUE
+
+# Make the DCCP dissector use relative sequence numbers instead of absolute ones.
+# TRUE or FALSE (case-insensitive)
+#dccp.relative_sequence_numbers: TRUE
+
+# Whether the DCE/RPC dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#dcerpc.desegment_dcerpc: TRUE
+
+# Whether the DCE/RPC dissector should reassemble fragmented DCE/RPC PDUs
+# TRUE or FALSE (case-insensitive)
+#dcerpc.reassemble_dcerpc: TRUE
+
+# Display some DCOM unmarshalled fields usually hidden
+# TRUE or FALSE (case-insensitive)
+#dcom.display_unmarshalling_details: FALSE
+
+# If a payload looks like it's embedded in an IP primitive message, and there is a Wireshark dissector matching the DCT2000 protocol name, try parsing the payload using that dissector
+# TRUE or FALSE (case-insensitive)
+#dct2000.ipprim_heuristic: TRUE
+
+# If a payload looks like it's embedded in an SCTP primitive message, and there is a Wireshark dissector matching the DCT2000 protocol name, try parsing the payload using that dissector
+# TRUE or FALSE (case-insensitive)
+#dct2000.sctpprim_heuristic: TRUE
+
+# When set, attempt to decode LTE RRC frames. Note that this won't affect other protocols that also call the LTE RRC dissector
+# TRUE or FALSE (case-insensitive)
+#dct2000.decode_lte_rrc: TRUE
+
+# When set, look for formatted messages indicating specific events.  This may be quite slow, so should be disabled if LTE MAC is not being analysed
+# TRUE or FALSE (case-insensitive)
+#dct2000.decode_mac_lte_oob_messages: TRUE
+
+# When set, look for some older protocol names so thatthey may be matched with wireshark dissectors.
+# TRUE or FALSE (case-insensitive)
+#dct2000.convert_old_protocol_names: FALSE
+
+# When set, if there is a Wireshark dissector matching the protocol name, it will parse the PDU using that dissector. This may be slow, so should be disabled unless you are using this feature.
+# TRUE or FALSE (case-insensitive)
+#dct2000.use_protocol_name_as_dissector_name: FALSE
+
+# Novell Servers option 85 can be configured as a string instead of address
+# TRUE or FALSE (case-insensitive)
+#dhcp.novellserverstring: FALSE
+
+# The PacketCable CCC protocol version
+# One of: PKT-SP-PROV-I05-021127, IETF Draft 5, RFC 3495
+# (case-insensitive).
+#dhcp.pkt.ccc.protocol_version: RFC 3495
+
+# Option Number for PacketCable CableLabs Client Configuration
+# A decimal number
+#dhcp.pkt.ccc.option: 122
+
+# Endianness applied to UUID fields
+# One of: Little Endian, Big Endian
+# (case-insensitive).
+#dhcp.uuid.endian: Little Endian
+
+# Whether the DHCP failover dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#dhcpfo.desegment: TRUE
+
+# Whether Option 18 is dissected as CableLab or RFC 3315
+# TRUE or FALSE (case-insensitive)
+#dhcpv6.cablelabs_interface_id: FALSE
+
+# Whether the Bulk Leasequery dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#dhcpv6.bulk_leasequery.desegment: TRUE
+
+# SCTP ports to be decoded as Diameter (default: 3868)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#diameter.sctp.ports: 3868
+
+# Whether the Diameter dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#diameter.desegment: TRUE
+
+# Create DICOM File Meta Header according to PS 3.10 on export for PDUs. If the captured PDV does not contain a SOP Class UID and SOP Instance UID (e.g. for command PDVs), wireshark specific ones will be created.
+# TRUE or FALSE (case-insensitive)
+#dicom.export_header: TRUE
+
+# Do not show items below this size in the export list. Set it to 0, to see DICOM commands and responses in the list. Set it higher, to just export DICOM IODs (i.e. CT Images, RT Structures).
+# A decimal number
+#dicom.export_minsize: 4096
+
+# Create a node for sequences and items, and show children in a hierarchy. De-select this option, if you prefer a flat display or e.g. when using TShark to create a text output.
+# TRUE or FALSE (case-insensitive)
+#dicom.seq_tree: TRUE
+
+# Create a node for a tag and show tag details as single elements. This can be useful to debug a tag and to allow display filters on these attributes. When using TShark to create a text output, it's better to have it disabled. 
+# TRUE or FALSE (case-insensitive)
+#dicom.tag_tree: FALSE
+
+# Show message ID and number of completed, remaining, warned or failed operations in header and info column.
+# TRUE or FALSE (case-insensitive)
+#dicom.cmd_details: TRUE
+
+# Decode all DICOM tags in the last PDV. This will ensure the proper reassembly. De-select, to troubleshoot PDU length issues, or to understand PDV fragmentation. When not set, the decoding may fail and the exports may become corrupt.
+# TRUE or FALSE (case-insensitive)
+#dicom.pdv_reassemble: TRUE
+
+# Whether the DISTCC dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#distcc.desegment_distcc_over_tcp: TRUE
+
+# Whether DJIUAV should reassemble messages spanning multiple TCP segments (required to get useful results)
+# TRUE or FALSE (case-insensitive)
+#djiuav.desegment: TRUE
+
+# Set the SCTP port for Distributed Lock Manager
+# A decimal number
+#dlm3.sctp.port: 21064
+
+# Select the type of decoding for nationally-defined values
+# One of: None (raw data), As for regular, Thales XOmail
+# (case-insensitive).
+#dmp.national_decode: As for regular
+
+# Select the nation of sending server.  This is used when presenting security classification values in messages with security policy set to National (nation of local server)
+# One of: None, Albania, Armenia, Austria, Azerbaijan, Belarus, Belgium, Bosnia and Hercegowina, Bulgaria, Canada, Croatia, Czech Republic, Denmark, Estonia, Euro-Atlantic Partnership Council (EAPC), European Union (EU), Finland, Former Yugoslav Republic of Macedonia, France, Georgia, Germany, Greece, Hungary, Iceland, International Security Assistance Force (ISAF), Ireland, Italy, Kazakhstan, Kyrgyztan, Latvia, Lithuania, Luxembourg, Malta, Moldova, Montenegro, Netherlands, Norway, Partnership for Peace (PfP), Poland, Portugal, Romania, Russian Federation, Serbia, Slovakia, Slovenia, Spain, Sweden, Switzerland, Tajikistan, Turkey, Turkmenistan, United Kingdom, United States, Ukraine, Uzbekistan, Western European Union (WEU)
+# (case-insensitive).
+#dmp.local_nation: None
+
+# Calculate sequence/acknowledgement analysis
+# TRUE or FALSE (case-insensitive)
+#dmp.seq_ack_analysis: TRUE
+
+# Align identifiers in info list (does not align when retransmission or duplicate acknowledgement indication)
+# TRUE or FALSE (case-insensitive)
+#dmp.align_ids: FALSE
+
+# The way DMX values are displayed
+# One of: Percent, Hexadecimal, Decimal
+# (case-insensitive).
+#dmx_chan.dmx_disp_chan_val_type: Percent
+
+# The way DMX channel numbers are displayed
+# One of: Hexadecimal, Decimal
+# (case-insensitive).
+#dmx_chan.dmx_disp_chan_nr_type: Hexadecimal
+
+# The number of columns for the DMX display
+# One of: 6, 10, 12, 16, 24
+# (case-insensitive).
+#dmx_chan.dmx_disp_col_count: 16
+
+# Whether the DNP3 dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#dnp3.desegment: TRUE
+
+# Whether the DNS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#dns.desegment_dns_messages: TRUE
+
+# Number of seconds allowed between DNS requests with the same transaction ID to consider it a retransmission. Otherwise its considered a new request.
+# A decimal number
+#dns.retransmission_timer: 5
+
+# Whether or not to validate the Header Check Sequence
+# TRUE or FALSE (case-insensitive)
+#docsis.check_fcs: TRUE
+
+# Whether or not to attempt to dissect encrypted DOCSIS payload
+# TRUE or FALSE (case-insensitive)
+#docsis.dissect_encrypted_frames: FALSE
+
+# Specifies that decryption should be attempted on all packets, even if the session initialization wasn't captured.
+# TRUE or FALSE (case-insensitive)
+#dof.custom_dof_decrypt_all: FALSE
+
+# Specifies that operations should be tracked across multiple packets, providing summary lists. This takes time and memory.
+# TRUE or FALSE (case-insensitive)
+#dof.custom_dof_track_operations: FALSE
+
+# Limits the number of operations shown before and after the current operations
+# A decimal number
+#dof.custom_dof_track_operations_window: 5
+
+# Should the dissector hide the names for addresses?
+# TRUE or FALSE (case-insensitive)
+#doip.hide_address_name_entries: TRUE
+
+# Whether the DRDA dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#drda.desegment: TRUE
+
+# Whether the DSI dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#dsi.desegment: TRUE
+
+# redirect dtls debug to file name; leave empty to disable debug, use "-" to redirect output to stderr
+# 
+# A path to a file
+#dtls.debug_file: 
+
+# Default client Connection ID length used when the Client Handshake message is missing
+# A decimal number
+#dtls.client_cid_length: 0
+
+# Default server Connection ID length used when the Server Handshake message is missing
+# A decimal number
+#dtls.server_cid_length: 0
+
+# Pre-Shared Key as HEX string. Should be 0 to 16 bytes.
+# A string
+#dtls.psk: 
+
+# SAC Encryption Key (16 hex bytes)
+# A string
+#dvb-ci.sek: 
+
+# SAC Init Vector (16 hex bytes)
+# A string
+#dvb-ci.siv: 
+
+# Dissect the content of messages transmitted on the Low-Speed Communication resource. This requires a dissector for the protocol and target port contained in the connection descriptor.
+# TRUE or FALSE (case-insensitive)
+#dvb-ci.dissect_lsc_msg: FALSE
+
+# Check this to enable full protocol dissection of data above BBHeader
+# TRUE or FALSE (case-insensitive)
+#dvb-s2_modeadapt.decode_df: FALSE
+
+# Check this to enable full protocol dissection of data above GSE Layer
+# TRUE or FALSE (case-insensitive)
+#dvb-s2_modeadapt.full_decode: FALSE
+
+# The preferred Mode Adaptation Interface in the case of ambiguity
+# One of: L.1 (0 bytes), L.2 (2 bytes including sync), L.3 (4 bytes including sync), L.4 (3 bytes)
+# (case-insensitive).
+#dvb-s2_modeadapt.default_modeadapt: L.3 (4 bytes including sync)
+
+# RTP Dynamic payload types which will be interpreted as DVB-S2; values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#dvb-s2_modeadapt.dynamic.payload.type: 
+
+# defines the RCS protocol version used in table dissection
+# One of: RCS protocol, RCS2 protocol
+# (case-insensitive).
+#dvb-s2_table.rcs_protocol: RCS2 protocol
+
+# Allow only packets with Major=0x03//Minor=0xFF as DVMRP V3 packets
+# TRUE or FALSE (case-insensitive)
+#dvmrp.strict_v3: FALSE
+
+# Set the SCTP port for e2ap messages
+# A decimal number
+#e2ap.sctp.port: 37464
+
+# Decode the Message Types according to eCPRI Specification V1.2
+# TRUE or FALSE (case-insensitive)
+#ecpri.ecpripref.msg.decoding: TRUE
+
+# Whether the eDonkey dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#edonkey.desegment: TRUE
+
+# Whether the EtherNet/IP dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#enip.desegment: TRUE
+
+# Determines whether all I/O connections will assume a 32-bit header in the O->T direction
+# TRUE or FALSE (case-insensitive)
+#enip.o2t_run_idle: TRUE
+
+# Determines whether all I/O connections will assume a 32-bit header in the T->O direction
+# TRUE or FALSE (case-insensitive)
+#enip.t2o_run_idle: FALSE
+
+# The way DMX values are displayed
+# One of: Percent, Hexadecimal, Decimal
+# (case-insensitive).
+#enttec.dmx_disp_chan_val_type: Percent
+
+# The way DMX channel numbers are displayed
+# One of: Hexadecimal, Decimal
+# (case-insensitive).
+#enttec.dmx_disp_chan_nr_type: Hexadecimal
+
+# The number of columns for the DMX display
+# One of: 6, 10, 12, 16, 24
+# (case-insensitive).
+#enttec.dmx_disp_col_count: 16
+
+# If you are capturing in networks with multiplexed or slow nodes, this can be useful
+# TRUE or FALSE (case-insensitive)
+#epl.show_soc_flags: FALSE
+
+# For analysis purposes one might want to show the command layer even if the dissector assumes a duplicated frame
+# TRUE or FALSE (case-insensitive)
+#epl.show_duplicated_command_layer: FALSE
+
+# For analysis purposes one might want to see how long the current mapping has been active for and what OD write caused it
+# TRUE or FALSE (case-insensitive)
+#epl.show_pdo_meta_info: FALSE
+
+# Partition PDOs according to ObjectMappings sent via SDO
+# TRUE or FALSE (case-insensitive)
+#epl.use_sdo_mappings: TRUE
+
+# If you want to parse the defaultValue (XDD) and actualValue (XDC) attributes for ObjectMappings in order to detect default PDO mappings, which may not be sent over SDO 
+# TRUE or FALSE (case-insensitive)
+#epl.use_xdc_mappings: TRUE
+
+# If a data field has untyped data under 8 byte long, interpret it as unsigned little endian integer and show decimal and hexadecimal representation thereof. Otherwise use stock data dissector
+# TRUE or FALSE (case-insensitive)
+#epl.interpret_untyped_as_le: TRUE
+
+# If you have a capture without IdentResponse and many nodes, it's easier to set a default profile here than to add entries for all MAC address or Node IDs
+# A path to a file
+#epl.default_profile: 
+
+# Protocol encapsulated in HDLC records
+# One of: Cisco HDLC, PPP serial, Frame Relay, SS7 MTP2, Attempt to guess
+# (case-insensitive).
+#erf.hdlc_type: Attempt to guess
+
+# Whether raw ATM cells should be treated as the first cell of an AAL5 PDU
+# TRUE or FALSE (case-insensitive)
+#erf.rawcell_first: FALSE
+
+# Protocol encapsulated in ATM AAL5 packets
+# One of: Attempt to guess, LLC multiplexed, Unspecified
+# (case-insensitive).
+#erf.aal5_type: Attempt to guess
+
+# The packets contain the optional Incremental Redundancy (IR) fields
+# TRUE or FALSE (case-insensitive)
+#gsm_abis_pgsl.ir: FALSE
+
+# This is done only if the Decoding is not SET or the packet does not belong to a SA. Assumes a 12 byte auth (HMAC-SHA1-96/HMAC-MD5-96/AES-XCBC-MAC-96) and attempts decode based on the ethertype 13 bytes from packet end
+# TRUE or FALSE (case-insensitive)
+#esp.enable_null_encryption_decode_heuristic: FALSE
+
+# Check that successive frames increase sequence number by 1 within an SPI.  This should work OK when only one host is sending frames on an SPI
+# TRUE or FALSE (case-insensitive)
+#esp.do_esp_sequence_analysis: TRUE
+
+# Attempt to decode based on the SAD described hereafter.
+# TRUE or FALSE (case-insensitive)
+#esp.enable_encryption_decode: FALSE
+
+# Attempt to Check ESP Authentication based on the SAD described hereafter.
+# TRUE or FALSE (case-insensitive)
+#esp.enable_authentication_check: FALSE
+
+# Whether the E-Tag summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#etag.summary_in_tree: TRUE
+
+# Place the hash/symbol files (generated by the Apache Etch compiler) ending with .ewh here
+# A path to a directory
+#etch.file: 
+
+# Some devices add trailing data to frames.  Depending on where this device exists in the network, padding could be added to short frames before the additional trailer.  This option determines how that padding will be detected.
+# 
+# Never - Don't detect any padding.  Any bytes after the ethernet payload will be considered trailer.
+# Zeros (default) - Consecutive bytes of zeros up to the minimum ethernet frame size will be treated as padding.  Additional bytes will be considered trailer.
+# Any - Any bytes after the payload up to the minimum ethernet frame size will be treated as padding.  Additional bytes will be considered trailer.
+# One of: Never, Zeros, Any
+# (case-insensitive).
+#eth.padding: Zeros
+
+# Some TAPs add a fixed length ethernet trailer at the end of the frame, but before the (optional) FCS. Make sure it gets interpreted correctly.
+# A decimal number
+#eth.trailer_length: 0
+
+# Some Ethernet adapters and drivers include the FCS at the end of a packet, others do not.  Some capture file formats and protocols do not indicate whether or not the FCS is included. The Ethernet dissector then attempts to guess whether a captured packet has an FCS, but it cannot always guess correctly.  This option can override that heuristic and assume that the FCS is either never or always present in such cases.
+# One of: According to heuristic, Never, Always
+# (case-insensitive).
+#eth.fcs: According to heuristic
+
+# Whether to validate the Frame Check Sequence
+# TRUE or FALSE (case-insensitive)
+#eth.check_fcs: FALSE
+
+# Whether packets should be interpreted as coming from CheckPoint FireWall-1 monitor file if they look as if they do
+# TRUE or FALSE (case-insensitive)
+#eth.interpret_as_fw1_monitor: FALSE
+
+# When capturing on a Cisco FEX some frames start with an extra destination mac
+# TRUE or FALSE (case-insensitive)
+#eth.deduplicate_dmac: FALSE
+
+# Set the condition that must be true for the CCSDS dissector to be called
+# TRUE or FALSE (case-insensitive)
+#eth.ccsds_heuristic_length: FALSE
+
+# Set the condition that must be true for the CCSDS dissector to be called
+# TRUE or FALSE (case-insensitive)
+#eth.ccsds_heuristic_version: FALSE
+
+# Set the condition that must be true for the CCSDS dissector to be called
+# TRUE or FALSE (case-insensitive)
+#eth.ccsds_heuristic_header: FALSE
+
+# Set the condition that must be true for the CCSDS dissector to be called
+# TRUE or FALSE (case-insensitive)
+#eth.ccsds_heuristic_bit: FALSE
+
+# Whether the EVRC dissector should process payload type 60 as legacy EVRC packets
+# TRUE or FALSE (case-insensitive)
+#evrc.legacy_pt_60: FALSE
+
+# Dynamic payload types which will be interpreted as EVS; values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#evs.dynamic.payload.type: 
+
+# Controls the display of the session's username in the info column.  This is only displayed if the packet containing it was seen during this capture session.
+# TRUE or FALSE (case-insensitive)
+#exec.info_show_username: TRUE
+
+# Controls the display of the command being run on the server by this session in the info column.  This is only displayed if the packet containing it was seen during this capture session.
+# TRUE or FALSE (case-insensitive)
+#exec.info_show_command: FALSE
+
+# In a few cases a short ethernet frame will be padded with non-zerobytes.  If this happens, an f5ethtrailer will not be found.Enabling this will step through each byte of the ethernet trailerto try and find the start of an f5ethtrailer
+# TRUE or FALSE (case-insensitive)
+#f5ethtrailer.pref_walk_trailer: FALSE
+
+# Disable this if you do not want this dissector to populate well-known fields in other dissectors (i.e. ip.addr, ipv6.addr, tcp.port and udp.port).  Enabling this will allow filters that reference those fields to also find data in the trailers but will reduce performance.  After disabling, you should restart Wireshark to get performance back.
+# TRUE or FALSE (case-insensitive)
+#f5ethtrailer.pref_pop_other_fields: FALSE
+
+# Enabling this will perform analysis of the trailer data.  It will enable taps on other protocols and slow down Wireshark.
+# TRUE or FALSE (case-insensitive)
+#f5ethtrailer.perform_analysis: TRUE
+
+# In/out only removes slot/tmm information.  Brief shortens the string to >S/T (for in) or <S/T (for out).  See "Brief in/out characters" below.
+# One of: None, Full, In/out only, Brief, Brief in/out only
+# (case-insensitive).
+#f5ethtrailer.info_type: Full
+
+# A string specifying the characters to use to represent "in" and "out" in the brief summary.  The default is "><" ('>' for in and '<' for out).  If this is not set or is less than two characters, the default is used.  If it is longer than two characters, the extra characters are ignored.
+# A string
+#f5ethtrailer.brief_inout_chars: 
+
+# If the platform in the F5 FILEINFO packet matches the provided regex, slot information will be displayed in the info column; otherwise, it will not.  A reasonable value is "^(A.*|Z101)$".  If the regex is empty or there is no platform information in the capture, slot information is always displayed.
+# A string
+#f5ethtrailer.slots_regex: 
+
+# If present, include the RST cause text from the trailer in the "info" column of the packet list pane.
+# TRUE or FALSE (case-insensitive)
+#f5ethtrailer.rstcause_in_info: TRUE
+
+# If enabled, KEYLOG entries will be added to the TLS decode in the f5ethtrailer protocol tree.  It will populate the f5ethtrailer.tls.keylog field.
+# TRUE or FALSE (case-insensitive)
+#f5ethtrailer.generate_keylog: TRUE
+
+# If enabled, reassembly of multi-frame sequences is done
+# TRUE or FALSE (case-insensitive)
+#fc.reassemble: TRUE
+
+# This is the size of non-last frames in a multi-frame sequence
+# A decimal number
+#fc.max_frame_size: 1024
+
+# Whether the FDDI dissector should add 3-byte padding to all captured FDDI packets (useful with e.g. Tru64 UNIX tcpdump)
+# TRUE or FALSE (case-insensitive)
+#fddi.padding: FALSE
+
+# Whether the FCIP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#fcip.desegment: TRUE
+
+# Port number used for FCIP
+# A decimal number
+#fcip.target_port: 3225
+
+# Dissect next layer
+# TRUE or FALSE (case-insensitive)
+#file-pcap.dissect_next_layer: FALSE
+
+# Dissect next layer
+# TRUE or FALSE (case-insensitive)
+#file-pcapng.dissect_next_layer: FALSE
+
+# Whether the FIX dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#fix.desegment: TRUE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to "decode as"
+# TRUE or FALSE (case-insensitive)
+#flexray.try_heuristic_first: FALSE
+
+# With this option display filters for fmp fhandle a RPC call, even if the actual fhandle is only present in one of the packets
+# TRUE or FALSE (case-insensitive)
+#fmp.fhandle_find_both_reqrep: FALSE
+
+# Decode packets on this sctp port as ForCES
+# A decimal number
+#forces.sctp_high_prio_port: 0
+
+# Decode packets on this sctp port as ForCES
+# A decimal number
+#forces.sctp_med_prio_port: 0
+
+# Decode packets on this sctp port as ForCES
+# A decimal number
+#forces.sctp_low_prio_port: 0
+
+# Show reported release info
+# TRUE or FALSE (case-insensitive)
+#fp.show_release_info: TRUE
+
+# Call MAC dissector for payloads
+# TRUE or FALSE (case-insensitive)
+#fp.call_mac: TRUE
+
+# Validate FP payload checksums
+# TRUE or FALSE (case-insensitive)
+#fp.payload_checksum: TRUE
+
+# Validate FP header checksums
+# TRUE or FALSE (case-insensitive)
+#fp.header_checksum: TRUE
+
+# For each PCH data frame, Try to show the paging indications bitmap found in the previous frame
+# TRUE or FALSE (case-insensitive)
+#fp.track_paging_indications: TRUE
+
+# Whether the UID value should be appended in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#fp_mux.uid_in_tree: TRUE
+
+# Whether to try heuristic FP dissectors for the muxed payloads
+# TRUE or FALSE (case-insensitive)
+#fp_mux.call_heur_fp: TRUE
+
+# Encapsulation
+# One of: FRF 3.2/Cisco HDLC, GPRS Network Service, Raw Ethernet, LAPB (T1.617a-1994 Annex G)
+# (case-insensitive).
+#fr.encap: FRF 3.2/Cisco HDLC
+
+# Show offset of frame in capture file
+# TRUE or FALSE (case-insensitive)
+#frame.show_file_off: FALSE
+
+# Treat all frames as DOCSIS Frames
+# TRUE or FALSE (case-insensitive)
+#frame.force_docsis_encap: FALSE
+
+# Whether or not MD5 hashes should be generated for each frame, useful for finding duplicate frames.
+# TRUE or FALSE (case-insensitive)
+#frame.generate_md5_hash: FALSE
+
+# Whether or not an Epoch time entry should be generated for each frame.
+# TRUE or FALSE (case-insensitive)
+#frame.generate_epoch_time: TRUE
+
+# Whether or not the number of bits in the frame should be shown.
+# TRUE or FALSE (case-insensitive)
+#frame.generate_bits_field: TRUE
+
+# Whether or not 'packet size limited during capture' message in shown in Info column.
+# TRUE or FALSE (case-insensitive)
+#frame.disable_packet_size_limited_in_summary: FALSE
+
+# Whether the FireWall-1 summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#fw1.summary_in_tree: TRUE
+
+# Whether the Firewall-1 monitor file includes UUID information
+# TRUE or FALSE (case-insensitive)
+#fw1.with_uuid: FALSE
+
+# Whether the interface list includes the chain position
+# TRUE or FALSE (case-insensitive)
+#fw1.iflist_with_chain: FALSE
+
+# Whether the Gadu-Gadu dissector should reassemble messages spanning multiple TCP segments.To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#gadu-gadu.desegment: TRUE
+
+# Whether the Gearman dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#gearman.desegment: TRUE
+
+# Whether the GED125 dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#ged125.desegment_body: TRUE
+
+# Whether the GIOP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#giop.desegment_giop_messages: TRUE
+
+# Whether fragmented GIOP messages should be reassembled
+# TRUE or FALSE (case-insensitive)
+#giop.reassemble: TRUE
+
+# Maximum allowed message size in bytes (default=10485760)
+# A decimal number
+#giop.max_message_size: 10485760
+
+# File containing stringified IORs, one per line.
+# A path to a file
+#giop.ior_txt: IOR.txt
+
+# Whether the GIT dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#git.desegment: TRUE
+
+# Whether the Gigamon header summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#gmhdr.summary_in_tree: TRUE
+
+# Whether the Gigamon Trailer summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#gmtrailer.summary_in_tree: TRUE
+
+# Whether the Gigamon trailer containing HW timestamp, source id and original CRC should be decoded
+# TRUE or FALSE (case-insensitive)
+#gmtrailer.decode_trailer_timestamp: TRUE
+
+# Make the GeoNetworking dissector analyze GeoNetworking sequence numbers to find and flag duplicate packet (Annex A)
+# TRUE or FALSE (case-insensitive)
+#gnw.analyze_sequence_numbers: TRUE
+
+# Whether to autodetect the cipher bit (because it might be set on unciphered data)
+# TRUE or FALSE (case-insensitive)
+#llcgprs.autodetect_cipher_bit: FALSE
+
+# Help for debug...
+# TRUE or FALSE (case-insensitive)
+#gquic.debug.quic: FALSE
+
+# Normally application/grpc message is protobuf, but sometime the true message is json. If this option in on, we always check whether the message is JSON (body starts with '{' and ends with '}') regardless of grpc_message_type_subdissector_table settings (which dissect grpc message according to content-type).
+# TRUE or FALSE (case-insensitive)
+#grpc.detect_json_automatically: TRUE
+
+# Embed gRPC messages under HTTP2 protocol tree items.
+# TRUE or FALSE (case-insensitive)
+#grpc.embedded_under_http2: FALSE
+
+# Whether the Gryphon dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#gryphon.desegment: TRUE
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#gsm_ipa.hsl_debug_in_root_tree: FALSE
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#gsm_ipa.hsl_debug_in_info: FALSE
+
+# Whether to decode NRI in TLLI. NRI is not used if length is zero
+# A decimal number
+#gsm_a.rr.nri_length: 0
+
+# Whether the dissector should reassemble SMS spanning multiple packets
+# TRUE or FALSE (case-insensitive)
+#gsm_sms.reassemble: TRUE
+
+# Whether the dissector should take into account info coming from lower layers (like GSM-MAP) to perform SMS reassembly
+# TRUE or FALSE (case-insensitive)
+#gsm_sms.reassemble_with_lower_layers_info: TRUE
+
+# Always decode a GSM Short Message as Connectionless WSP if a Port Number Information Element is present in the SMS User Data Header.
+# TRUE or FALSE (case-insensitive)
+#gsm_sms_ud.port_number_udh_means_wsp: FALSE
+
+# Always try subdissection of the 1st fragment of a fragmented GSM Short Message. If reassembly is possible, the Short Message may be dissected twice (once as a short frame, once in its entirety).
+# TRUE or FALSE (case-insensitive)
+#gsm_sms_ud.try_dissect_1st_fragment: FALSE
+
+# Prevent sub-dissectors from replacing column data with their own. Eg. Prevent WSP dissector overwriting SMPP information.
+# TRUE or FALSE (case-insensitive)
+#gsm_sms_ud.prevent_dissectors_chg_cols: FALSE
+
+# Treat ARFCN 512-810 as DCS 1800 rather than PCS 1900
+# TRUE or FALSE (case-insensitive)
+#gsm_um.dcs1800: TRUE
+
+# Dissect Q.931 User-To-User information
+# TRUE or FALSE (case-insensitive)
+#gsm-r-uus1.dissect_q931_u2u: FALSE
+
+# Dissect GSM-A User-To-User information
+# TRUE or FALSE (case-insensitive)
+#gsm-r-uus1.dissect_gsm_a_u2u: TRUE
+
+# TCAP Subsystem numbers used for GSM MAP
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#gsm_map.tcap.ssn: 6-9,145,148-150
+
+# How to treat Application context
+# One of: Use application context from the trace, Treat as AC 1, Treat as AC 2, Treat as AC 3
+# (case-insensitive).
+#gsm_map.application.context.version: Use application context from the trace
+
+# When enabled, dissector will use the non 3GPP standard extensions from Ericsson (that can override the standard ones)
+# TRUE or FALSE (case-insensitive)
+#gsm_map.ericsson.proprietary.extensions: FALSE
+
+# Whether or not to try reassembling GSSAPI blobs spanning multiple (SMB/SessionSetup) PDUs
+# TRUE or FALSE (case-insensitive)
+#gss-api.gssapi_reassembly: TRUE
+
+# Show GSUP Source/Destination names as text in the Packet Details pane
+# TRUE or FALSE (case-insensitive)
+#gsup.show_name_as_text: TRUE
+
+# GTPv0 and GTP' port (default 3386)
+# A decimal number
+#gtp.v0_port: 3386
+
+# GTPv1 and GTPv2 control plane port (default 2123)
+# A decimal number
+#gtp.v1c_port: 2123
+
+# GTPv1 user plane port (default 2152)
+# A decimal number
+#gtp.v1u_port: 2152
+
+# Dissect T-PDU as
+# One of: None, TPDU Heuristic, PDCP-LTE, PDCP-NR, SYNC, ETHERNET, Custom
+# (case-insensitive).
+#gtp.dissect_tpdu_as: TPDU Heuristic
+
+# Request/reply pair matches only if their timestamps are closer than that value, in ms (default 0, i.e. don't use timestamps)
+# A decimal number
+#gtp.pair_max_interval: 0
+
+# GTP ETSI order
+# TRUE or FALSE (case-insensitive)
+#gtp.check_etsi: FALSE
+
+# Dissect GTP over TCP
+# TRUE or FALSE (case-insensitive)
+#gtp.dissect_gtp_over_tcp: TRUE
+
+# Track GTP session
+# TRUE or FALSE (case-insensitive)
+#gtp.track_gtp_session: FALSE
+
+# Use this setting to decode the Transparent Containers in the SRVCC PS-to-CS messages.
+# This is needed until there's a reliable way to determine the contents of the transparent containers.
+# One of: Don't decode, Assume UTRAN target
+# (case-insensitive).
+#gtpv2.decode_srvcc_p2c_trans_cont_target: Don't decode
+
+# Request/reply pair matches only if their timestamps are closer than that value, in ms (default 0, i.e. don't use timestamps)
+# A decimal number
+#gtpv2.pair_max_interval: 0
+
+# H.225 Server TLS Port
+# A decimal number
+#h225.tls.port: 1300
+
+# Whether the H.225 dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#h225.reassembly: TRUE
+
+# ON - display tunnelled H.245 inside H.225.0 tree, OFF - display tunnelled H.245 in root tree after H.225.0
+# TRUE or FALSE (case-insensitive)
+#h225.h245_in_tree: TRUE
+
+# ON - display tunnelled protocols inside H.225.0 tree, OFF - display tunnelled protocols in root tree after H.225.0
+# TRUE or FALSE (case-insensitive)
+#h225.tp_in_tree: TRUE
+
+# Whether the H.245 dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#h245.reassembly: TRUE
+
+# Whether the dissector should show short names or the long names from the standard
+# TRUE or FALSE (case-insensitive)
+#h245.shorttypes: FALSE
+
+# Whether the dissector should print items of h245 Info column in reversed order
+# TRUE or FALSE (case-insensitive)
+#h245.prepand: FALSE
+
+# Dynamic payload types which will be interpreted as H.263; values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#h263p.dynamic.payload.type: 
+
+# Dynamic payload types which will be interpreted as H.264; values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#h264.dynamic.payload.type: 
+
+# Dynamic payload types which will be interpreted as H.265; values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#h265.dynamic.payload.type: 
+
+# Desegment H.501 messages that span more TCP segments
+# TRUE or FALSE (case-insensitive)
+#h501.desegment: TRUE
+
+# Maintain relationships between transactions and contexts and display an extra tree showing context data
+# TRUE or FALSE (case-insensitive)
+#h248.ctx_info: FALSE
+
+# Desegment H.248 messages that span more TCP segments
+# TRUE or FALSE (case-insensitive)
+#h248.desegment: TRUE
+
+# Whether the HART-IP dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#hart_ip.desegment: TRUE
+
+# Whether the hazel dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#hzlcst.desegment: TRUE
+
+# The ethernet type used for L2 communications
+# A decimal number
+#hcrt.dissector_ethertype: 61522
+
+# Specifies that the raw text of the HL7 message should be displayed in addition to the dissection tree
+# TRUE or FALSE (case-insensitive)
+#hl7.display_raw: FALSE
+
+# Specifies that the LLP session information should be displayed (Start/End Of Block) in addition to the dissection tree
+# TRUE or FALSE (case-insensitive)
+#hl7.display_llp: FALSE
+
+# Set the port for HNBAP messages (Default of 29169)
+# A decimal number
+#hnbap.port: 29169
+
+# Whether the HPFEEDS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#hpfeeds.desegment_hpfeeds_messages: TRUE
+
+# Try to decode the payload using an heuristic sub-dissector
+# TRUE or FALSE (case-insensitive)
+#hpfeeds.try_heuristic: TRUE
+
+# Whether the HTTP dissector should reassemble headers of a request spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#http.desegment_headers: TRUE
+
+# Whether the HTTP dissector should use the "Content-length:" value, if present, to reassemble the body of a request spanning multiple TCP segments, and reassemble chunked data spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#http.desegment_body: TRUE
+
+# Whether to reassemble bodies of entities that are transferred using the "Transfer-Encoding: chunked" method
+# TRUE or FALSE (case-insensitive)
+#http.dechunk_body: TRUE
+
+# Whether to uncompress entity bodies that are compressed using "Content-Encoding: "
+# TRUE or FALSE (case-insensitive)
+#http.decompress_body: TRUE
+
+# SCTP Ports range
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#http.sctp.port: 80
+
+# SSL/TLS Ports range
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#http.tls.port: 443
+
+# The UDP port for RROCE messages (default 4791)
+# A decimal number
+#infiniband.rroce.port: 4791
+
+# Try to decode a packet using an heuristic sub-dissector before using Decode As
+# TRUE or FALSE (case-insensitive)
+#infiniband.try_heuristic_first: TRUE
+
+# Maximum number of batch requests allowed
+# A decimal number
+#icep.max_batch_requests: 64
+
+# Maximum length allowed of an ICEP string
+# A decimal number
+#icep.max_ice_string_len: 512
+
+# Maximum number of context pairs allowed
+# A decimal number
+#icep.max_ice_context_pairs: 64
+
+# Whether the 128th and following bytes of the ICMP payload should be decoded as MPLS extensions or as a portion of the original packet
+# TRUE or FALSE (case-insensitive)
+#icmp.favor_icmp_mpls: FALSE
+
+# Length of the Link Address Field, configurable in '101 and absent in '104
+# One of: 0 octet, 1 octet, 2 octet
+# (case-insensitive).
+#iec60870_101.linkaddr_len: 1 octet
+
+# Length of the Cause of Transmission Field, configurable in '101 and fixed at 2 octets with '104
+# One of: 1 octet, 2 octet
+# (case-insensitive).
+#iec60870_101.cot_len: 1 octet
+
+# Length of the Common ASDU Address Field, configurable in '101 and fixed at 2 octets with '104
+# One of: 1 octet, 2 octet
+# (case-insensitive).
+#iec60870_101.asdu_addr_len: 1 octet
+
+# Length of the Information Object Address Field, configurable in '101 and fixed at 3 octets with '104
+# One of: 1 octet, 2 octet, 3 octet
+# (case-insensitive).
+#iec60870_101.asdu_ioa_len: 2 octet
+
+# Whether fragmented 802.11 datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#wlan.defragment: TRUE
+
+# Don't dissect 802.11n draft HT elements (which might contain duplicate information).
+# TRUE or FALSE (case-insensitive)
+#wlan.ignore_draft_ht: FALSE
+
+# Whether retransmitted 802.11 frames should be subdissected
+# TRUE or FALSE (case-insensitive)
+#wlan.retransmitted: TRUE
+
+# Some 802.11 cards include the FCS at the end of a packet, others do not.
+# TRUE or FALSE (case-insensitive)
+#wlan.check_fcs: FALSE
+
+# Whether to validate the FCS checksum or not.
+# TRUE or FALSE (case-insensitive)
+#wlan.check_checksum: FALSE
+
+# Some 802.11 cards leave the Protection bit set even though the packet is decrypted, and some also leave the IV (initialization vector).
+# One of: No, Yes - without IV, Yes - with IV
+# (case-insensitive).
+#wlan.ignore_wep: No
+
+# Whether to enable MIC Length override or not.
+# TRUE or FALSE (case-insensitive)
+#wlan.wpa_key_mic_len_enable: FALSE
+
+# Some Key MIC lengths are greater than 16 bytes, so set the length you require
+# A decimal number
+#wlan.wpa_key_mic_len: 0
+
+# Treat all WiFi packets as S1G
+# TRUE or FALSE (case-insensitive)
+#wlan.treat_as_s1g: FALSE
+
+# Enable WEP and WPA/WPA2 decryption
+# TRUE or FALSE (case-insensitive)
+#wlan.enable_decryption: TRUE
+
+# (Hexadecimal) Ethertype used to indicate IEEE 802.15.4 frame.
+# A hexadecimal number
+#wpan.802154_ethertype: 0x809a
+
+# The FCS format in the captured payload
+# One of: TI CC24xx metadata, ITU-T CRC-16, ITU-T CRC-32
+# (case-insensitive).
+#wpan.fcs_format: ITU-T CRC-16
+
+# Dissect payload only if FCS is valid.
+# TRUE or FALSE (case-insensitive)
+#wpan.802154_fcs_ok: TRUE
+
+# Match frames with ACK request to ACK packets
+# TRUE or FALSE (case-insensitive)
+#wpan.802154_ack_tracking: FALSE
+
+# Parse assuming 802.15.4e quirks for compatibility
+# TRUE or FALSE (case-insensitive)
+#wpan.802154e_compatibility: FALSE
+
+# Specifies the security suite to use for 802.15.4-2003 secured frames (only supported suites are listed). Option ignored for 802.15.4-2006 and unsecured frames.
+# One of: AES-128 Encryption, 128-bit Integrity Protection, AES-128 Encryption, 64-bit Integrity Protection, AES-128 Encryption, 32-bit Integrity Protection
+# (case-insensitive).
+#wpan.802154_sec_suite: AES-128 Encryption, 64-bit Integrity Protection
+
+# Set if the manufacturer extends the authentication data with the security header. Option ignored for 802.15.4-2006 and unsecured frames.
+# TRUE or FALSE (case-insensitive)
+#wpan.802154_extend_auth: TRUE
+
+# (Hexadecimal) Ethertype used to indicate IEEE 802.1ah tag.
+# A hexadecimal number
+#ieee8021ah.8021ah_ethertype: 0x88e7
+
+# Whether the iFCP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ifcp.desegment: TRUE
+
+# Whether the ILP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ilp.desegment_ilp_messages: TRUE
+
+# Whether to use heuristics for post-STARTTLS detection of encrypted IMAP conversations
+# TRUE or FALSE (case-insensitive)
+#imap.ssl_heuristic: TRUE
+
+# TCAP Subsystem numbers used for INAP
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#inap.ssn: 106,241
+
+# Whether the IPDC dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ipdc.desegment_ipdc_messages: TRUE
+
+# Range of session IDs to be decoded as SAMIS-TYPE-1 records
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#ipdr.sessions.samis_type_1: 
+
+# Dissect IPMB commands
+# TRUE or FALSE (case-insensitive)
+#ipmi.dissect_bus_commands: FALSE
+
+# FRU Language Code is English; strings are ASCII+LATIN1 (vs. Unicode)
+# TRUE or FALSE (case-insensitive)
+#ipmi.fru_langcode_is_english: TRUE
+
+# Do not search for responses coming after this timeout (milliseconds)
+# A decimal number
+#ipmi.response_after_req: 5000
+
+# Allow for responses before requests (milliseconds)
+# A decimal number
+#ipmi.response_before_req: 0
+
+# Format of messages embedded into Send/Get/Forward Message
+# One of: None, IPMB, Session-based (LAN, ...), Use heuristics
+# (case-insensitive).
+#ipmi.msgfmt: Use heuristics
+
+# Selects which OEM format is used for commands that IPMI does not define
+# One of: None, Pigeon Point Systems
+# (case-insensitive).
+#ipmi.selected_oem: None
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#ippusb.attempt_reassembly: TRUE
+
+# Whether the IPv4 type-of-service field should be decoded as a Differentiated Services field (see RFC2474/RFC2475)
+# TRUE or FALSE (case-insensitive)
+#ip.decode_tos_as_diffserv: TRUE
+
+# Whether fragmented IPv4 datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#ip.defragment: TRUE
+
+# Whether the IPv4 summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#ip.summary_in_tree: TRUE
+
+# Whether to validate the IPv4 checksum
+# TRUE or FALSE (case-insensitive)
+#ip.check_checksum: FALSE
+
+# Whether to correct for TSO-enabled (TCP segmentation offload) hardware captures, such as spoofing the IP packet length
+# TRUE or FALSE (case-insensitive)
+#ip.tso_support: TRUE
+
+# Whether to look up IP addresses in each MaxMind database we have loaded
+# TRUE or FALSE (case-insensitive)
+#ip.use_geoip: TRUE
+
+# Whether to interpret the originally reserved flag as security flag
+# TRUE or FALSE (case-insensitive)
+#ip.security_flag: FALSE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to a specific port
+# TRUE or FALSE (case-insensitive)
+#ip.try_heuristic_first: FALSE
+
+# Whether fragmented IPv6 datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#ipv6.defragment: TRUE
+
+# Whether the IPv6 summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#ipv6.summary_in_tree: TRUE
+
+# Whether to look up IPv6 addresses in each MaxMind database we have loaded
+# TRUE or FALSE (case-insensitive)
+#ipv6.use_geoip: TRUE
+
+# Check that all RPL Source Routed packets conform to RFC 6554 and do not visit a node more than once
+# TRUE or FALSE (case-insensitive)
+#ipv6.perform_strict_rpl_srh_rfc_checking: FALSE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to a specific port
+# TRUE or FALSE (case-insensitive)
+#ipv6.try_heuristic_first: FALSE
+
+# Whether to display IPv6 extension headers as a separate protocol or a sub-protocol of the IPv6 packet
+# TRUE or FALSE (case-insensitive)
+#ipv6.exthdr_under_root_protocol_tree: FALSE
+
+# If enabled the Length field in octets will be hidden
+# TRUE or FALSE (case-insensitive)
+#ipv6.exthdr_hide_len_oct_field: FALSE
+
+# Whether to correct for TSO-enabled (TCP segmentation offload) hardware captures, such as spoofing the IPv6 packet length
+# TRUE or FALSE (case-insensitive)
+#ipv6.tso_support: FALSE
+
+# The iSCSI protocol version
+# One of: Draft 08, Draft 09, Draft 11, Draft 12, Draft 13
+# (case-insensitive).
+#iscsi.protocol_version: Draft 13
+
+# Whether the iSCSI dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#iscsi.desegment_iscsi_messages: TRUE
+
+# When enabled, packets that appear bogus are ignored
+# TRUE or FALSE (case-insensitive)
+#iscsi.bogus_pdu_filter: TRUE
+
+# Ignore packets that haven't set the F bit when they should have
+# TRUE or FALSE (case-insensitive)
+#iscsi.demand_good_f_bit: FALSE
+
+# Treat packets whose data segment length is greater than this value as bogus
+# A decimal number
+#iscsi.bogus_pdu_max_data_len: 262144
+
+# Range of iSCSI target ports(default 3260)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#iscsi.target_ports: 3260
+
+# System port number of iSCSI target
+# A decimal number
+#iscsi.target_system_port: 860
+
+# The protocol running on the D channel
+# One of: LAPD, DPNSS
+# (case-insensitive).
+#isdn.dchannel_protocol: LAPD
+
+# Range of iSER target ports(default 3260)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#iser.target_ports: 3260
+
+# Dynamic payload types which will be interpreted as ISMACryp; values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#ismacryp.dynamic.payload.type: 
+
+# ISMACryp version
+# One of: ISMACryp v1.1, ISMACryp v2.0
+# (case-insensitive).
+#ismacryp.version: ISMACryp v1.1
+
+# Indicates whether or not the ISMACryp version deduced from RTP payload type, if present, is used or whether the version above is used
+# TRUE or FALSE (case-insensitive)
+#ismacryp.override_rtp_pt: FALSE
+
+# Set the length of the IV in the ISMACryp AU Header in bytes
+# A decimal number
+#ismacryp.iv_length: 4
+
+# Set the length of the Delta IV in the ISMACryp AU Header in bytes
+# A decimal number
+#ismacryp.delta_iv_length: 0
+
+# Set the length of the Key Indicator in the ISMACryp AU Header in bytes
+# A decimal number
+#ismacryp.key_indicator_length: 0
+
+# Indicates whether or not the Key Indicator is present in all AU Headers (T/F)
+# TRUE or FALSE (case-insensitive)
+#ismacryp.key_indicator_per_au_flag: FALSE
+
+# Indicates whether or not selective encryption is enabled (T/F)
+# TRUE or FALSE (case-insensitive)
+#ismacryp.selective_encryption: TRUE
+
+# Indicates whether or not slice start / end is present (T/F)
+# TRUE or FALSE (case-insensitive)
+#ismacryp.slice_indication: FALSE
+
+# Indicates whether or not padding information is present (T/F)
+# TRUE or FALSE (case-insensitive)
+#ismacryp.padding_indication: FALSE
+
+# RFC3640 mode
+# One of: aac-hbr, mpeg4-video, avc-video
+# (case-insensitive).
+#ismacryp.rfc3640_mode: avc-video
+
+# Indicates use of user mode instead of RFC3640 modes (T/F)
+# TRUE or FALSE (case-insensitive)
+#ismacryp.user_mode: FALSE
+
+# Set the length of the AU size in the AU Header in bits
+# A decimal number
+#ismacryp.au_size_length: 0
+
+# Set the length of the AU index in the AU Header in bits
+# A decimal number
+#ismacryp.au_index_length: 0
+
+# Set the length of the AU delta index in the AU Header in bits
+# A decimal number
+#ismacryp.au_index_delta_length: 0
+
+# Set the length of the CTS delta field in the AU Header in bits
+# A decimal number
+#ismacryp.cts_delta_length: 0
+
+# Set the length of the DTS delta field in the AU Header in bits
+# A decimal number
+#ismacryp.dts_delta_length: 0
+
+# Indicates whether or not the RAP field is present in the AU Header (T/F)
+# TRUE or FALSE (case-insensitive)
+#ismacryp.random_access_indication: FALSE
+
+# Indicates the number of bits on which the stream state field is encoded in the AU Header (bits)
+# A decimal number
+#ismacryp.stream_state_indication: 0
+
+# Whether the iSNS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#isns.desegment: TRUE
+
+# FlexRay IDs (combined) - 4bit Bus-ID (0 any), 4bit Channel, 16bit Frame-ID, 8bit Cycle (0xff any)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#iso10681.flexray.flexrayids: 
+
+# TP frames are spread over multiple cycles. Cycle is ignored for matching.
+# TRUE or FALSE (case-insensitive)
+#iso10681.spread_over_cycles: TRUE
+
+# Addressing of ISO 15765. Normal or Extended
+# One of: Normal addressing, Extended addressing
+# (case-insensitive).
+#iso15765.addressing: Normal addressing
+
+# Window of ISO 15765 fragments
+# A decimal number
+#iso15765.window: 8
+
+# ISO15765 bound standard CAN IDs
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#iso15765.can.ids: 
+
+# ISO15765 bound extended CAN IDs
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#iso15765.can.extended_ids: 
+
+# Handle LIN Diagnostic Frames
+# TRUE or FALSE (case-insensitive)
+#iso15765.lin_diag: TRUE
+
+# Addressing of FlexRay TP. 1 Byte or 2 Byte
+# One of: 1 byte addressing, 2 byte addressing
+# (case-insensitive).
+#iso15765.flexray_addressing: 1 byte addressing
+
+# Segment Size Limit for first and consecutive frames of FlexRay (bytes after addresses)
+# A decimal number
+#iso15765.flexray_segment_size_limit: 0
+
+# Endian of the length field. Big endian or Little endian
+# One of: Big endian, Little endian
+# (case-insensitive).
+#iso8583.len_endian: Little endian
+
+#  charset for numbers
+# One of: Digits represented as ASCII Characters, Digits represented in nibbles
+# (case-insensitive).
+#iso8583.charset: Digits represented as ASCII Characters
+
+#  binary data representation
+# One of: Bin data represented as Hex Ascii characters, Bin data not encoded
+# (case-insensitive).
+#iso8583.binencode: Bin data represented as Hex Ascii characters
+
+# File containing a translation from object ID to string
+# A path to a file
+#isobus.vt.object_ids: 
+
+# Note national variants may not be fully supported
+# One of: ITU Standard, French National Standard, Israeli National Standard, Russian National Standard, Japan National Standard, Japan National Standard (TTC)
+# (case-insensitive).
+#isup.variant: ITU Standard
+
+# Show the CIC value (in addition to the message type) in the Info column
+# TRUE or FALSE (case-insensitive)
+#isup.show_cic_in_info: TRUE
+
+# Whether APM messages datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#isup.defragment_apm: TRUE
+
+# The MPLS label (aka Flow Bundle ID) used by ITDM traffic.
+# A hexadecimal number
+#itdm.mpls_label: 0x99887
+
+# Flow Number used by I-TDM Control Protocol traffic.
+# A decimal number
+#itdm.ctl_flowno: 0
+
+# Support Implementers Guide (version 01)
+# TRUE or FALSE (case-insensitive)
+#iua.support_ig: FALSE
+
+# Use SAPI values as specified in TS 48 056
+# TRUE or FALSE (case-insensitive)
+#iua.use_gsm_sapi_values: TRUE
+
+# Whether IuUP Payload bits should be dissected
+# TRUE or FALSE (case-insensitive)
+#iuup.dissect_payload: FALSE
+
+# The payload contains a two byte pseudoheader indicating direction and circuit_id
+# TRUE or FALSE (case-insensitive)
+#iuup.two_byte_pseudoheader: FALSE
+
+# Dynamic payload types which will be interpreted as IuUP; values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#iuup.dynamic.payload.type: 
+
+# Whether the trailer summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#ixiatrailer.summary_in_tree: TRUE
+
+# Display JSON like in browsers devtool
+# TRUE or FALSE (case-insensitive)
+#json.compact_form: FALSE
+
+# Leading bytes will be ignored until first '[' or '{' is found.
+# TRUE or FALSE (case-insensitive)
+#json.ignore_leading_bytes: FALSE
+
+# Hide extended path based filtering
+# TRUE or FALSE (case-insensitive)
+#json.hide_extended_path_based_filtering: FALSE
+
+# Enable to have correctly typed MIME media dissected as JXTA Messages.
+# TRUE or FALSE (case-insensitive)
+#jxta.msg.mediatype: TRUE
+
+# Whether the JXTA dissector should reassemble messages spanning multiple UDP/TCP/SCTP segments. To use this option you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings  and enable "Reassemble fragmented IP datagrams" in the IP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#jxta.desegment: TRUE
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#kafka.show_string_bytes_lengths: FALSE
+
+# Set the SCTP port for kNet messages
+# A decimal number
+#knet.sctp.port: 2345
+
+# Keyring.XML file (exported from ETS)
+# A path to a file
+#kip.key_file: 
+
+# Keyring password
+# A string
+#kip.key_file_pwd: 
+
+# Output file (- for stdout) for keys extracted from key file
+# A path to a file
+#kip.key_info_file: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_1: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_2: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_3: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_4: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_5: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_6: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_7: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_8: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_9: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_10: 
+
+# Whether the KNX/IP dissector should reassemble messages spanning multiple TCP segments.  To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#kip.desegment: TRUE
+
+# Whether the Kpasswd dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#kpasswd.desegment: TRUE
+
+# Whether the Kerberos dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#kerberos.desegment: TRUE
+
+# Whether the dissector should try to decrypt encrypted Kerberos blobs. This requires that the proper keytab file is installed as well.
+# TRUE or FALSE (case-insensitive)
+#kerberos.decrypt: FALSE
+
+# The keytab file containing all the secrets
+# A path to a file
+#kerberos.file: 
+
+# KT allows binary values in keys and values. Attempt to show an ASCII representation anyway (which might be prematurely terminated by a NULL!
+# TRUE or FALSE (case-insensitive)
+#kt.present_key_val_as_ascii: FALSE
+
+# Whether the L&G 8979 dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#lg8979.desegment: TRUE
+
+# L2TPv3 Cookie Size
+# One of: Detect, None, 4 Byte Cookie, 8 Byte Cookie
+# (case-insensitive).
+#l2tp.cookie_size: Detect
+
+# L2TPv3 L2-Specific Sublayer
+# One of: Detect, None, Default L2-Specific, ATM-Specific, LAPD-Specific, DOCSIS DMPT-Specific
+# (case-insensitive).
+#l2tp.l2_specific: Detect
+
+# Shared secret used for control message digest authentication
+# A string
+#l2tp.shared_secret: 
+
+# Use SAPI values as specified in TS 48 056
+# TRUE or FALSE (case-insensitive)
+#lapd.use_gsm_sapi_values: FALSE
+
+# RTP payload types for embedded LAPD; values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#lapd.rtp_payload_type: 
+
+# SCTP Payload Protocol Identifier for LAPD. It is a 32 bits value from 0 to 4294967295. Set it to 0 to disable.
+# A decimal number
+#lapd.sctp_payload_protocol_identifier: 0
+
+# Whether the dissector should defragment LAPDm messages spanning multiple packets.
+# TRUE or FALSE (case-insensitive)
+#lapdm.reassemble: TRUE
+
+# Whether the Laplink dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#laplink.desegment_laplink_over_tcp: TRUE
+
+# Set the SCTP port for LCSAP messages
+# A decimal number
+#lcsap.sctp.port: 9082
+
+# Whether the LDAP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ldap.desegment_ldap_messages: TRUE
+
+# Set the port for LDAP operations over TLS
+# A decimal number
+#ldap.tls.port: 636
+
+# Whether the LDP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ldp.desegment_ldp_messages: TRUE
+
+# Which Information will be showed at Column Information is decided by the selection
+# One of: Default Column Info, PROFINET Special Column Info
+# (case-insensitive).
+#lldp.column_info_selection: Default Column Info
+
+# Dissect this ethertype as LLT traffic in addition to the default, 0xCAFE.
+# A hexadecimal number
+#llt.alternate_ethertype: 0
+
+# Whether LMP contains a checksum which can be checked
+# TRUE or FALSE (case-insensitive)
+#lmp.checksum: FALSE
+
+# There might be plugins corresponding to different version of the specification If they are present they should be listed here.
+# One of: FD1, Rel8 dec 2008
+# (case-insensitive).
+#log3gpp.rrc_release_version: Rel8 dec 2008
+
+# There might be plugins corresponding to different version of the specification If they are present they should be listed here.
+# One of: FD1, Rel8 dec 2008
+# (case-insensitive).
+#log3gpp.nas_eps_release_version: Rel8 dec 2008
+
+# Use oneline info column by replace all new line characters by spaces
+# TRUE or FALSE (case-insensitive)
+#logcat.oneline_info_column: TRUE
+
+# Whether the NAS PDU should be shown in the root packet details tree
+# TRUE or FALSE (case-insensitive)
+#lte_rrc.nas_in_root_tree: FALSE
+
+# Swap frame control bytes (needed for some APs).
+# TRUE or FALSE (case-insensitive)
+#lwapp.swap_fc: FALSE
+
+# Whether to validate the LWL4 crc when crc bit is not set
+# TRUE or FALSE (case-insensitive)
+#lwl4.check_crc: TRUE
+
+# 128-bit decryption key in hexadecimal format
+# A string
+#lwm.lwmes_key: 
+
+# Version used by Wireshark
+# One of: Internet Draft version 2, Internet Draft version 8, RFC 4165
+# (case-insensitive).
+#m2pa.version: RFC 4165
+
+# Set the port for M2PA messages (default: 3565)
+# A decimal number
+#m2pa.port: 3565
+
+# The value of the parameter tag for protocol data 1
+# One of: 0x000e (Draft 7), 0x0300 (RFC3331)
+# (case-insensitive).
+#m2ua.protocol_data_1_tag: 0x0300 (RFC3331)
+
+# Version used by Wireshark
+# One of: Internet Draft version 5, Internet Draft version 6, Internet Draft version 7, RFC 4666
+# (case-insensitive).
+#m3ua.version: RFC 4666
+
+# TSN size in bits, either 6 or 14 bit
+# One of: 6 bits, 14 bits
+# (case-insensitive).
+#mac.tsn_size: 6 bits
+
+# Number of Re-Transmits before expert warning triggered
+# A decimal number
+#mac-lte.retx_count_warn: 3
+
+# Attempt to decode BCH, PCH and CCCH data using LTE RRC dissector
+# TRUE or FALSE (case-insensitive)
+#mac-lte.attempt_rrc_decode: TRUE
+
+# Attempt to dissect frames that have failed CRC check
+# TRUE or FALSE (case-insensitive)
+#mac-lte.attempt_to_dissect_crc_failures: FALSE
+
+# Will call LTE RLC dissector with standard settings as per RRC spec
+# TRUE or FALSE (case-insensitive)
+#mac-lte.attempt_to_dissect_srb_sdus: TRUE
+
+# Will call LTE RLC dissector for MCH LCID 0
+# TRUE or FALSE (case-insensitive)
+#mac-lte.attempt_to_dissect_mcch: FALSE
+
+# Call RLC dissector MTCH LCIDs
+# TRUE or FALSE (case-insensitive)
+#mac-lte.call_rlc_for_mtch: FALSE
+
+# Set whether LCID -> drb Table is taken from static table (below) or from info learned from control protocol (e.g. RRC)
+# One of: From static table, From configuration protocol
+# (case-insensitive).
+#mac-lte.lcid_to_drb_mapping_source: From static table
+
+# If any BSR report is >= this number, an expert warning will be added
+# A decimal number
+#mac-lte.bsr_warn_threshold: 50
+
+# Track status of SRs, providing links between requests, failure indications and grants
+# TRUE or FALSE (case-insensitive)
+#mac-lte.track_sr: TRUE
+
+# Can show PHY, MAC or RLC layer info in Info column
+# One of: PHY Info, MAC Info, RLC Info
+# (case-insensitive).
+#mac-lte.layer_to_show: RLC Info
+
+# Attempt to decode 6 bytes of Contention Resolution body as an UL CCCH PDU
+# TRUE or FALSE (case-insensitive)
+#mac-lte.decode_cr_body: FALSE
+
+# Apply DRX config and show DRX state within each UE
+# TRUE or FALSE (case-insensitive)
+#mac-lte.show_drx: FALSE
+
+# Add as a generated field the middle of the range indicated by the BSR index
+# TRUE or FALSE (case-insensitive)
+#mac-lte.show_bsr_median: FALSE
+
+# Attempt to decode BCCH, PCCH and CCCH data using NR RRC dissector
+# TRUE or FALSE (case-insensitive)
+#mac-nr.attempt_rrc_decode: TRUE
+
+# Will call NR RLC dissector with standard settings as per RRC spec
+# TRUE or FALSE (case-insensitive)
+#mac-nr.attempt_to_dissect_srb_sdus: TRUE
+
+# Set whether LCID -> drb Table is taken from static table (below) or from info learned from control protocol (i.e. RRC)
+# One of: From static table, From configuration protocol
+# (case-insensitive).
+#mac-nr.lcid_to_drb_mapping_source: From static table
+
+# The name of the file containing the mate module's configuration
+# A path to a file
+#mate.config: 
+
+# Decode control data received on "usb.control" with an unknown interface class as MBIM
+# TRUE or FALSE (case-insensitive)
+#mbim.control_decode_unknown_itf: FALSE
+
+# Format used for SMS PDU decoding
+# One of: Automatic, 3GPP, 3GPP2
+# (case-insensitive).
+#mbim.sms_pdu_format: Automatic
+
+# No description
+# One of: 1.0, 2.0, 3.0
+# (case-insensitive).
+#mbim.extended_version: 1.0
+
+# Set the UDP port for the MCPE Server
+# A decimal number
+#mcpe.udp.port: 19132
+
+# A frame is considered for decoding as MDSHDR if either ethertype is 0xFCFC or zero. Turn this flag off if you don't want ethertype zero to be decoded as MDSHDR. This might be useful to avoid problems with test frames.
+# TRUE or FALSE (case-insensitive)
+#mdshdr.decode_if_etype_zero: FALSE
+
+# Set the SCTP port for MEGACO text messages
+# A decimal number
+#megaco.sctp.txt_port: 2944
+
+# Specifies that the raw text of the MEGACO message should be displayed instead of (or in addition to) the dissection tree
+# TRUE or FALSE (case-insensitive)
+#megaco.display_raw_text: TRUE
+
+# Specifies that the dissection tree of the MEGACO message should be displayed instead of (or in addition to) the raw text
+# TRUE or FALSE (case-insensitive)
+#megaco.display_dissect_tree: TRUE
+
+# Maintain relationships between transactions and contexts and display an extra tree showing context data
+# TRUE or FALSE (case-insensitive)
+#megaco.ctx_info: FALSE
+
+# Whether the MEMCACHE dissector should reassemble headers of a request spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#memcache.desegment_headers: TRUE
+
+# Whether the memcache dissector should reassemble PDUs spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#memcache.desegment_pdus: TRUE
+
+# Set the UDP port for gateway messages (if other than the default of 2427)
+# A decimal number
+#mgcp.tcp.gateway_port: 2427
+
+# Set the TCP port for gateway messages (if other than the default of 2427)
+# A decimal number
+#mgcp.udp.gateway_port: 2427
+
+# Set the TCP port for callagent messages (if other than the default of 2727)
+# A decimal number
+#mgcp.tcp.callagent_port: 2727
+
+# Set the UDP port for callagent messages (if other than the default of 2727)
+# A decimal number
+#mgcp.udp.callagent_port: 2727
+
+# Specifies that the raw text of the MGCP message should be displayed instead of (or in addition to) the dissection tree
+# TRUE or FALSE (case-insensitive)
+#mgcp.display_raw_text: FALSE
+
+# Display the number of MGCP messages found in a packet in the protocol column.
+# TRUE or FALSE (case-insensitive)
+#mgcp.display_mgcp_message_count: FALSE
+
+# Display multipart bodies with no media type dissector as raw text (may cause problems with binary data).
+# TRUE or FALSE (case-insensitive)
+#mime_multipart.display_unknown_body_as_text: FALSE
+
+# Remove any base64 content-transfer encoding from bodies. This supports export of the body and its further dissection.
+# TRUE or FALSE (case-insensitive)
+#mime_multipart.remove_base64_encoding: FALSE
+
+# Uncompress parts which are compressed. GZIP for example. This supports export of the body and its further dissection.
+# TRUE or FALSE (case-insensitive)
+#mime_multipart.uncompress_data: TRUE
+
+# Dissect payload only if MIC is valid.
+# TRUE or FALSE (case-insensitive)
+#mle.meshlink_mic_ok: FALSE
+
+# Register Format
+# One of: UINT16     , INT16      , UINT32     , INT32      , IEEE FLT   , MODICON FLT
+# (case-insensitive).
+#modbus.mbus_register_format: UINT16     
+
+# Whether the Modbus RTU dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#mbrtu.desegment: TRUE
+
+# Whether to validate the CRC
+# TRUE or FALSE (case-insensitive)
+#mbrtu.crc_verification: FALSE
+
+# Whether the Modbus RTU dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#mbtcp.desegment: TRUE
+
+# Dynamic payload types which will be interpreted as MP4V-ES; values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#mp4v-es.dynamic.payload.type: 
+
+# Whether the section dissector should verify the CRC or checksum
+# TRUE or FALSE (case-insensitive)
+#mpeg_dsmcc.verify_crc: FALSE
+
+# Whether the section dissector should verify the CRC
+# TRUE or FALSE (case-insensitive)
+#mpeg_sect.verify_crc: FALSE
+
+# Lowest label is used to segregate flows inside a pseudowire
+# TRUE or FALSE (case-insensitive)
+#mpls.flowlabel_in_mpls_header: FALSE
+
+# Enable to allow non-zero Length in Control Word. This may be needed to correctly decode traffic from some legacy devices which generate non-zero Length even if there is no padding in the packet. Note that Length should have proper value (dissector checks this anyway).
+# 
+# Disable to blame all packets with CW.Length <> 0. This conforms to RFC4717.
+# TRUE or FALSE (case-insensitive)
+#mplspwatmaal5sdu.allow_cw_length_nonzero_aal5: FALSE
+
+# Enable to use reserved bits (8..9) of Control Word as an extension of CW.Length. This may be needed to correctly decode traffic from some legacy devices which uses reserved bits as extension of Length
+# 
+# Disable to blame all packets with CW.Reserved <> 0. This conforms to RFC4717.
+# TRUE or FALSE (case-insensitive)
+#mplspwatmaal5sdu.extend_cw_length_with_rsvd_aal5: FALSE
+
+# Enable to allow non-zero Length in Control Word. This may be needed to correctly decode traffic from some legacy devices which generate non-zero Length even if there is no padding in the packet. Note that Length should have proper value (dissector checks this anyway).
+# 
+# Disable to blame all packets with CW.Length <> 0. This conforms to RFC4717.
+# TRUE or FALSE (case-insensitive)
+#mplspwatmn1cw.allow_cw_length_nonzero: FALSE
+
+# Enable to use reserved bits (8..9) of Control Word as an extension of CW.Length. This may be needed to correctly decode traffic from some legacy devices which uses reserved bits as extension of Length
+# 
+# Disable to blame all packets with CW.Reserved <> 0. This conforms to RFC4717.
+# TRUE or FALSE (case-insensitive)
+#mplspwatmn1cw.extend_cw_length_with_rsvd: FALSE
+
+# To use this option you must also enable "Analyze TCP sequence numbers". 
+# TRUE or FALSE (case-insensitive)
+#mptcp.analyze_mptcp: TRUE
+
+# In case you don't capture the key, it will use the first DSN seen
+# TRUE or FALSE (case-insensitive)
+#mptcp.relative_sequence_numbers: TRUE
+
+# Scales logarithmically with the number of packetsYou need to capture the handshake for this to work."Map TCP subflows to their respective MPTCP connections"
+# TRUE or FALSE (case-insensitive)
+#mptcp.analyze_mappings: FALSE
+
+# (Greedy algorithm: Scales linearly with number of subflows and logarithmic scaling with number of packets)You need to enable DSS mapping analysis for this option to work
+# TRUE or FALSE (case-insensitive)
+#mptcp.intersubflows_retransmission: FALSE
+
+# Whether the MQ dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#mq.desegment: TRUE
+
+# Whether the MQ dissector should reassemble MQ messages spanning multiple TSH segments
+# TRUE or FALSE (case-insensitive)
+#mq.reassembly: TRUE
+
+# When dissecting PCF there can be a lot of parameters. You can limit the number of parameter decoded, before it continue with the next PCF.
+# A decimal number
+#mqpcf.maxprm: 999
+
+# When dissecting a parameter of a PCFm, if it is a StringList, IntegerList or Integer64 List,  You can limit the number of elements displayed, before it continues with the next Parameter.
+# A decimal number
+#mqpcf.maxlst: 20000
+
+# Select the MQTT version to use as protocol version if the CONNECT packet is not captured
+# One of: None, MQTT v3.1, MQTT v3.1.1, MQTT v5.0
+# (case-insensitive).
+#mqtt.default_version: None
+
+# Show Publish Message as text
+# TRUE or FALSE (case-insensitive)
+#mqtt.show_msg_as_text: FALSE
+
+# Specifies that the raw text of the MSRP message should be displayed in addition to the dissection tree
+# TRUE or FALSE (case-insensitive)
+#msrp.display_raw_text: TRUE
+
+# Where available, show which protocol and frame caused this MSRP stream to be created
+# TRUE or FALSE (case-insensitive)
+#msrp.show_setup_info: TRUE
+
+# Whether the MTP2 dissector should use extended sequence numbers as described in Q.703, Annex A as a default.
+# TRUE or FALSE (case-insensitive)
+#mtp2.use_extended_sequence_numbers: FALSE
+
+# Some SS7 capture hardware includes the FCS at the end of the packet, others do not.
+# TRUE or FALSE (case-insensitive)
+#mtp2.capture_contains_frame_check_sequence: FALSE
+
+# Reverse the bit order inside bytes specified in Q.703.
+# TRUE or FALSE (case-insensitive)
+#mtp2.reverse_bit_order_mtp2: FALSE
+
+# RTP payload types for embedded packets in RTP stream; values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#mtp2.rtp_payload_type: 
+
+# This only works for SCCP traffic for now
+# TRUE or FALSE (case-insensitive)
+#mtp3.heuristic_standard: FALSE
+
+# The SS7 standard used in MTP3 packets
+# One of: ITU, ANSI, Chinese ITU, Japan
+# (case-insensitive).
+#mtp3.standard: ITU
+
+# The structure of the pointcodes in ITU networks
+# One of: Unstructured, 3-8-3, 4-3-4-3
+# (case-insensitive).
+#mtp3.itu_pc_structure: Unstructured
+
+# The structure of the pointcodes in Japan networks
+# One of: Unstructured, 7-4-5, 3-4-4-5
+# (case-insensitive).
+#mtp3.japan_pc_structure: Unstructured
+
+# Use 5-bit (instead of 8-bit) SLS in ANSI MTP3 packets
+# TRUE or FALSE (case-insensitive)
+#mtp3.ansi_5_bit_sls: FALSE
+
+# Use 5-bit (instead of 4-bit) SLS in Japan MTP3 packets
+# TRUE or FALSE (case-insensitive)
+#mtp3.japan_5_bit_sls: FALSE
+
+# Format for point code in the address columns
+# One of: Decimal, Hexadecimal, NI-Decimal, NI-Hexadecimal, Dashed
+# (case-insensitive).
+#mtp3.addr_format: Dashed
+
+# Decode the spare bits of the SIO as the MSU priority (a national option in ITU)
+# TRUE or FALSE (case-insensitive)
+#mtp3.itu_priority: FALSE
+
+# Whether the MySQL dissector should reassemble MySQL buffers spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#mysql.desegment_buffers: TRUE
+
+# Whether the MySQL dissector should display the SQL query string in the INFO column.
+# TRUE or FALSE (case-insensitive)
+#mysql.show_sql_query: FALSE
+
+# This should work when the NAS ciphering algorithm is NULL (5G-EEA0)
+# TRUE or FALSE (case-insensitive)
+#nas-5gs.null_decipher: FALSE
+
+# No description
+# One of: None, IP, Non IP, Ethernet
+# (case-insensitive).
+#nas-5gs.decode_user_data_container_as: None
+
+# No description
+# A string
+#nas-5gs.non_ip_data_dissector: 
+
+# Always dissect NAS EPS messages as plain
+# TRUE or FALSE (case-insensitive)
+#nas-eps.dissect_plain: FALSE
+
+# This should work when the NAS ciphering algorithm is NULL (128-EEA0)
+# TRUE or FALSE (case-insensitive)
+#nas-eps.null_decipher: TRUE
+
+# No description
+# One of: None, IP, Non IP, Ethernet
+# (case-insensitive).
+#nas-eps.decode_user_data_container_as: None
+
+# No description
+# A string
+#nas-eps.non_ip_data_dissector: 
+
+# Whether the Nasdaq ITCH dissector should decode Chi X extensions.
+# TRUE or FALSE (case-insensitive)
+#nasdaq_itch.chi_x: TRUE
+
+# Whether the Nasdaq-SoupTCP dissector should reassemble messages spanning multiple TCP segments.
+# TRUE or FALSE (case-insensitive)
+#nasdaq_soup.desegment: TRUE
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch1_content: MAC_CONTENT_DCCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch2_content: MAC_CONTENT_DCCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch3_content: MAC_CONTENT_DCCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch4_content: MAC_CONTENT_DCCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch5_content: MAC_CONTENT_CS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch6_content: MAC_CONTENT_CS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch7_content: MAC_CONTENT_CS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch8_content: MAC_CONTENT_DCCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch9_content: MAC_CONTENT_PS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch10_content: MAC_CONTENT_UNKNOWN
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch11_content: MAC_CONTENT_PS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch12_content: MAC_CONTENT_PS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch13_content: MAC_CONTENT_CS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch14_content: MAC_CONTENT_PS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch15_content: MAC_CONTENT_CCCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch16_content: MAC_CONTENT_DCCH
+
+# Encoding used for the IB-SG-DATA element carrying segments of information blocks
+# One of: Encoding Variant 1 (TS 25.433 Annex D.2), Encoding Variant 2 (TS 25.433 Annex D.3)
+# (case-insensitive).
+#nbap.ib_sg_data_encoding: Encoding Variant 1 (TS 25.433 Annex D.2)
+
+# Whether the NBD dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings
+# TRUE or FALSE (case-insensitive)
+#nbd.desegment_nbd_messages: TRUE
+
+# Whether the NBSS dissector should reassemble packets spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#nbss.desegment_nbss_commands: TRUE
+
+# Whether the NCP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ncp.desegment: TRUE
+
+# Whether the NCP dissector should defragment NDS messages spanning multiple reply packets.
+# TRUE or FALSE (case-insensitive)
+#ncp.defragment_nds: TRUE
+
+# Dissect the NetWare Information Structure as NetWare 5.x or higher or as older NetWare 3.x.
+# TRUE or FALSE (case-insensitive)
+#ncp.newstyle: TRUE
+
+# Whether the NCP dissector should echo the NDS Entry ID to name resolves to the expert table.
+# TRUE or FALSE (case-insensitive)
+#ncp.eid_2_expert: TRUE
+
+# Whether the NCP dissector should echo NCP connection information to the expert table.
+# TRUE or FALSE (case-insensitive)
+#ncp.connection_2_expert: FALSE
+
+# Whether the NCP dissector should echo protocol errors to the expert table.
+# TRUE or FALSE (case-insensitive)
+#ncp.error_2_expert: TRUE
+
+# Whether the NCP dissector should echo server information to the expert table.
+# TRUE or FALSE (case-insensitive)
+#ncp.server_2_expert: TRUE
+
+# Whether the NCP dissector should echo file open/close/oplock information to the expert table.
+# TRUE or FALSE (case-insensitive)
+#ncp.file_2_expert: FALSE
+
+# Version of the NDMP protocol to assume if the version can not be automatically detected from the capture
+# One of: Version 2, Version 3, Version 4, Version 5
+# (case-insensitive).
+#ndmp.default_protocol_version: Version 4
+
+# Whether the NDMP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ndmp.desegment: TRUE
+
+# Whether the dissector should defragment NDMP messages spanning multiple packets.
+# TRUE or FALSE (case-insensitive)
+#ndmp.defragment: TRUE
+
+# Whether the NDPS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ndps.desegment_tcp: TRUE
+
+# Whether the NDPS dissector should reassemble fragmented NDPS messages spanning multiple SPX packets
+# TRUE or FALSE (case-insensitive)
+#ndps.desegment_spx: TRUE
+
+# Whether or not the NDPS dissector should show object id's and other details
+# TRUE or FALSE (case-insensitive)
+#ndps.show_oid: FALSE
+
+# Whether the NetBIOS dissector should defragment messages spanning multiple frames
+# TRUE or FALSE (case-insensitive)
+#netbios.defragment: TRUE
+
+# Whether the Netsync dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#netsync.desegment_netsync_messages: TRUE
+
+# Whether the dissector should snoop the FH to filename mappings by looking inside certain packets
+# TRUE or FALSE (case-insensitive)
+#nfs.file_name_snooping: FALSE
+
+# Whether the dissector should snoop the full pathname for files for matching FH's
+# TRUE or FALSE (case-insensitive)
+#nfs.file_full_name_snooping: FALSE
+
+# With this option display filters for nfs fhandles (nfs.fh.{name|full_name|hash}) will find both the request and response packets for a RPC call, even if the actual fhandle is only present in one of the packets
+# TRUE or FALSE (case-insensitive)
+#nfs.fhandle_find_both_reqrep: FALSE
+
+# When enabled, this option will print the NFSv4 tag (if one exists) in the Info column in the Summary pane
+# TRUE or FALSE (case-insensitive)
+#nfs.display_nfsv4_tag: TRUE
+
+# When enabled, shows only the significant NFSv4 Operations in the info column.  Others (like GETFH, PUTFH, etc) are not displayed
+# TRUE or FALSE (case-insensitive)
+#nfs.display_major_nfsv4_ops: TRUE
+
+# Set the SCTP port for NGAP messages
+# A decimal number
+#ngap.sctp.port: 38412
+
+# Dissect TransparentContainers that are opaque to NGAP
+# TRUE or FALSE (case-insensitive)
+#ngap.dissect_container: TRUE
+
+# Select whether target NG-RAN container should be decoded automatically (based on NG Setup procedure) or manually
+# One of: automatic, gNB, ng-eNB
+# (case-insensitive).
+#ngap.dissect_target_ng_ran_container_as: automatic
+
+# Select whether LTE container should be dissected as NB-IOT or legacy LTE
+# One of: Automatic, Legacy LTE, NB-IoT
+# (case-insensitive).
+#ngap.dissect_lte_container_as: Automatic
+
+# Whether the Authentication Extension data contains the source address. Some Cisco IOS implementations forgo this part of RFC2332.
+# TRUE or FALSE (case-insensitive)
+#nhrp.auth_ext_has_addr: TRUE
+
+# Whether the dissector will track and match MSG and RES calls for asynchronous NLM
+# TRUE or FALSE (case-insensitive)
+#nlm.msg_res_matching: FALSE
+
+# Whether the NAS PDU should be shown in the root packet details tree
+# TRUE or FALSE (case-insensitive)
+#nr-rrc.nas_in_root_tree: FALSE
+
+# NT Password (used to decrypt payloads)
+# A string
+#ntlmssp.nt_password: 
+
+# Range of NVMe Subsystem ports(default 4420)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#nvme-rdma.subsystem_ports: 4420
+
+# Range of NVMe Subsystem ports(default 4420)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#nvme-tcp.subsystem_ports: 4420
+
+# Whether to validate the PDU header digest or not.
+# TRUE or FALSE (case-insensitive)
+#nvme-tcp.check_hdgst: FALSE
+
+# Whether to validate the PDU data digest or not.
+# TRUE or FALSE (case-insensitive)
+#nvme-tcp.check_ddgst: FALSE
+
+# The bit width of a sample in the Uplink
+# A decimal number
+#oran_fh_cus.oran.iq_bitwidth_up: 14
+
+# Uplink User Data Compression
+# One of: No Compression, Block Floating Point Compression, Block Scaling Compression, u-Law Compression, Modulation Compression
+# (case-insensitive).
+#oran_fh_cus.oran.ud_comp_up: Block Floating Point Compression
+
+# The udCompHdr field in U-Plane messages may or may not be present, depending on the configuration of the O-RU. This preference instructs the dissector to expect this field to be present in uplink messages.
+# TRUE or FALSE (case-insensitive)
+#oran_fh_cus.oran.ud_comp_hdr_up: FALSE
+
+# The bit width of a sample in the Downlink
+# A decimal number
+#oran_fh_cus.oran.iq_bitwidth_down: 14
+
+# Downlink User Data Compression
+# One of: No Compression, Block Floating Point Compression, Block Scaling Compression, u-Law Compression, Modulation Compression
+# (case-insensitive).
+#oran_fh_cus.oran.ud_comp_down: Block Floating Point Compression
+
+# The udCompHdr field in U-Plane messages may or may not be present, depending on the configuration of the O-RU. This preference instructs the dissector to expect this field to be present in downlink messages.
+# TRUE or FALSE (case-insensitive)
+#oran_fh_cus.oran.ud_comp_hdr_down: FALSE
+
+# This is used if numPrbu is signalled as 0
+# A decimal number
+#oran_fh_cus.oran.rbs_in_uplane_section: 273
+
+# Used in decoding of section extension type 11 (Flexible BF weights)
+# A decimal number
+#oran_fh_cus.oran.num_weights_per_bundle: 32
+
+# Number of BF Antennas (used for C section type 6)
+# A decimal number
+#oran_fh_cus.oran.num_bf_antennas: 32
+
+# Whether the dissector should put the internal OER data in the tree or if it should hide it
+# TRUE or FALSE (case-insensitive)
+#oer.display_internal_oer_fields: FALSE
+
+# Dissect custom olsr.org message types (compatible with rfc routing agents)
+# TRUE or FALSE (case-insensitive)
+#olsr.ff_olsrorg: TRUE
+
+# Dissect custom nrlolsr tc message (incompatible with rfc routing agents)
+# TRUE or FALSE (case-insensitive)
+#olsr.nrlolsr: TRUE
+
+# SSL/TLS Ports range
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#opa.fe.tls.port: 3249-3252
+
+# Attempt to parse mad payload even when MAD.Status is non-zero
+# TRUE or FALSE (case-insensitive)
+#opa.mad.parse_mad_error: FALSE
+
+# Attempt to reassemble the mad payload of RMPP segments
+# TRUE or FALSE (case-insensitive)
+#opa.mad.reassemble_rmpp: TRUE
+
+# Whether the OpenFlow dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#openflow.desegment: TRUE
+
+# To be able to fully dissect SSDO and SPDO packages, a valid UDID for the SCM has to be provided
+# A string
+#opensafety.scm_udid: 00:00:00:00:00:00
+
+# Automatically assign a detected SCM UDID (by reading SNMT->SNTM_assign_UDID_SCM) and set it for the file
+# TRUE or FALSE (case-insensitive)
+#opensafety.scm_udid_autoset: TRUE
+
+# A comma-separated list of nodes to be filtered during dissection
+# A string
+#opensafety.filter_nodes: 
+
+# If set to true, only nodes in the list will be shown, otherwise they will be hidden
+# TRUE or FALSE (case-insensitive)
+#opensafety.filter_show_nodes_in_filterlist: TRUE
+
+# Port used by any UDP demo implementation to transport data
+# A decimal number
+#opensafety.network_udp_port: 9877
+
+# UDP port used by SercosIII to transport data
+# A decimal number
+#opensafety.network_udp_port_sercosiii: 8755
+
+# In an SercosIII/UDP transport stream, openSAFETY frame 2 will be expected before frame 1
+# TRUE or FALSE (case-insensitive)
+#opensafety.network_udp_frame_first_sercosiii: FALSE
+
+# In the transport stream, openSAFETY frame 2 will be expected before frame 1
+# TRUE or FALSE (case-insensitive)
+#opensafety.network_udp_frame_first: FALSE
+
+# Modbus/TCP words can be transcoded either big- or little endian. Default will be little endian
+# TRUE or FALSE (case-insensitive)
+#opensafety.mbtcp_big_endian: FALSE
+
+# Enables additional information in the dissection for better debugging an openSAFETY trace
+# TRUE or FALSE (case-insensitive)
+#opensafety.debug_verbose: FALSE
+
+# Enable heuristic dissection for openSAFETY over UDP encoded traffic
+# TRUE or FALSE (case-insensitive)
+#opensafety.enable_udp: TRUE
+
+# Enable heuristic dissection for Modbus/TCP
+# TRUE or FALSE (case-insensitive)
+#opensafety.enable_mbtcp: TRUE
+
+# Display the data between openSAFETY packets
+# TRUE or FALSE (case-insensitive)
+#opensafety.display_intergap_data: FALSE
+
+# SPDOs may only be found in cyclic data, SSDOs/SNMTS only in acyclic data
+# TRUE or FALSE (case-insensitive)
+#opensafety.classify_transport: TRUE
+
+# Port used by the openSAFETY over UDP data transport
+# A decimal number
+#opensafety_udp.network_udp_port: 9877
+
+# If tls-auth detection fails, you can choose to override detection and set tls-auth yourself
+# TRUE or FALSE (case-insensitive)
+#openvpn.tls_auth_detection_override: FALSE
+
+# If the parameter --tls-auth is used, the following preferences must also be defined.
+# TRUE or FALSE (case-insensitive)
+#openvpn.tls_auth: FALSE
+
+# If the parameter --tls-auth is used, a HMAC header is being inserted.
+# The default HMAC algorithm is SHA-1 which generates a 160 bit HMAC, therefore 20 bytes should be ok.
+# The value must be between 20 (160 bits) and 64 (512 bits).
+# A decimal number
+#openvpn.tls_auth_hmac_size: 20
+
+# If the parameter --tls-auth is used, an additional packet-id for replay protection is inserted after the HMAC signature. This field can either be 4 bytes or 8 bytes including an optional time_t timestamp long.
+#  This option is only evaluated if tls_auth_hmac_size > 0.
+#  The default value is TRUE.
+# TRUE or FALSE (case-insensitive)
+#openvpn.long_format: TRUE
+
+# Whether the Openwire dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#openwire.desegment: TRUE
+
+# Whether verbose type and length information are displayed in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#openwire.verbose_type: FALSE
+
+# Whether the OPSI dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#opsi.desegment_opsi_messages: TRUE
+
+# Dynamic payload types which will be interpreted as OPUS; Values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#opus.dynamic.payload.type: 
+
+# Whether segmented TPKT datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#osi.tpkt_reassemble: FALSE
+
+# Whether segmented RTSE datagrams should be reassembled. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#rtse.reassemble: TRUE
+
+# Whether the IDMP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#idmp.desegment_idmp_messages: TRUE
+
+# Whether segmented IDMP datagrams should be reassembled. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#idmp.reassemble: TRUE
+
+# Reassemble fragmented P_Mul packets
+# TRUE or FALSE (case-insensitive)
+#p_mul.reassemble: TRUE
+
+# Make the P_Mul dissector use relative message id number instead of absolute ones
+# TRUE or FALSE (case-insensitive)
+#p_mul.relative_msgid: TRUE
+
+# Calculate sequence/acknowledgement analysis
+# TRUE or FALSE (case-insensitive)
+#p_mul.seq_ack_analysis: TRUE
+
+# Type of content in Data_PDU
+# One of: No decoding, BER encoded ASN.1, Compressed Data Type
+# (case-insensitive).
+#p_mul.decode: No decoding
+
+# Attempt to decode parts of the message that aren't fully understood yet
+# TRUE or FALSE (case-insensitive)
+#papi.experimental_decode: FALSE
+
+# SCCP (and SUA) SSNs to decode as PCAP
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#pcap.ssn: 
+
+# Whether the PCLI summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#pcli.summary_in_tree: TRUE
+
+# Show uncompressed User-Plane data as IP
+# TRUE or FALSE (case-insensitive)
+#pdcp-lte.show_user_plane_as_ip: TRUE
+
+# Show unciphered Signalling-Plane data as RRC
+# TRUE or FALSE (case-insensitive)
+#pdcp-lte.show_signalling_plane_as_rrc: TRUE
+
+# Do sequence number analysis
+# One of: No-Analysis, Only-RLC-frames, Only-PDCP-frames
+# (case-insensitive).
+#pdcp-lte.check_sequence_numbers: Only-RLC-frames
+
+# Attempt to decode ROHC data
+# TRUE or FALSE (case-insensitive)
+#pdcp-lte.dissect_rohc: FALSE
+
+# Can show RLC, PDCP or Traffic layer info in Info column
+# One of: RLC Info, PDCP Info, Traffic Info
+# (case-insensitive).
+#pdcp-lte.layer_to_show: RLC Info
+
+# If RRC Security Info not seen, e.g. in Handover
+# One of: EEA0 (NULL), EEA1 (SNOW3G), EEA2 (AES), EEA3 (ZUC)
+# (case-insensitive).
+#pdcp-lte.default_ciphering_algorithm: EEA0 (NULL)
+
+# If RRC Security Info not seen, e.g. in Handover
+# One of: EIA0 (NULL), EIA1 (SNOW3G), EIA2 (AES), EIA3 (ZUC)
+# (case-insensitive).
+#pdcp-lte.default_integrity_algorithm: EIA0 (NULL)
+
+# N.B. only possible if build with algorithm support, and have key available and configured
+# TRUE or FALSE (case-insensitive)
+#pdcp-lte.decipher_signalling: TRUE
+
+# N.B. only possible if build with algorithm support, and have key available and configured
+# TRUE or FALSE (case-insensitive)
+#pdcp-lte.decipher_userplane: FALSE
+
+# N.B. only possible if build with algorithm support, and have key available and configured
+# TRUE or FALSE (case-insensitive)
+#pdcp-lte.verify_integrity: TRUE
+
+# Ignore the LTE RRC security algorithm configuration, to be used when PDCP is already deciphered in the capture
+# TRUE or FALSE (case-insensitive)
+#pdcp-lte.ignore_rrc_sec_params: FALSE
+
+# Show uncompressed User-Plane data as IP
+# TRUE or FALSE (case-insensitive)
+#pdcp-nr.show_user_plane_as_ip: TRUE
+
+# Show unciphered Signalling-Plane data as RRC
+# TRUE or FALSE (case-insensitive)
+#pdcp-nr.show_signalling_plane_as_rrc: TRUE
+
+# Do sequence number analysis
+# One of: No-Analysis, Only-RLC-frames, Only-PDCP-frames
+# (case-insensitive).
+#pdcp-nr.check_sequence_numbers: Only-RLC-frames
+
+# Attempt to decode ROHC data
+# TRUE or FALSE (case-insensitive)
+#pdcp-nr.dissect_rohc: FALSE
+
+# Can show RLC, PDCP or Traffic layer info in Info column
+# One of: RLC Info, PDCP Info, Traffic Info
+# (case-insensitive).
+#pdcp-nr.layer_to_show: RLC Info
+
+# If RRC Security Info not seen, e.g. in Handover
+# One of: NEA0 (NULL), NEA1 (SNOW3G), NEA2 (AES), NEA3 (ZUC)
+# (case-insensitive).
+#pdcp-nr.default_ciphering_algorithm: NEA0 (NULL)
+
+# If RRC Security Info not seen, e.g. in Handover
+# One of: NIA0 (NULL), NIA1 (SNOW3G), NIA2 (AES), NIA3 (ZUC)
+# (case-insensitive).
+#pdcp-nr.default_integrity_algorithm: NIA0 (NULL)
+
+# N.B. only possible if build with algorithm support, and have key available and configured
+# TRUE or FALSE (case-insensitive)
+#pdcp-nr.decipher_signalling: TRUE
+
+# N.B. only possible if build with algorithm support, and have key available and configured
+# TRUE or FALSE (case-insensitive)
+#pdcp-nr.decipher_userplane: FALSE
+
+# N.B. only possible if build with algorithm support, and have key available and configured
+# TRUE or FALSE (case-insensitive)
+#pdcp-nr.verify_integrity: TRUE
+
+# Ignore the NR RRC security algorithm configuration, to be used when PDCP is already deciphered in the capture
+# TRUE or FALSE (case-insensitive)
+#pdcp-nr.ignore_rrc_sec_params: FALSE
+
+# Port Ranges UDP.
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#pdu_transport.ports.udp: 
+
+# Port Ranges TCP.
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#pdu_transport.ports.tcp: 
+
+# Whether the dissector should put the internal PER data in the tree or if it should hide it
+# TRUE or FALSE (case-insensitive)
+#per.display_internal_per_fields: FALSE
+
+# PFCP port (default 8805)
+# A decimal number
+#pfcp.port_pfcp: 8805
+
+# Track PFCP session
+# TRUE or FALSE (case-insensitive)
+#pfcp.track_pfcp_session: FALSE
+
+# Whether or not UID and PID fields are dissected in big or little endian
+# TRUE or FALSE (case-insensitive)
+#pflog.uid_endian: TRUE
+
+# Whether to check the validity of the PGM checksum
+# TRUE or FALSE (case-insensitive)
+#pgm.check_checksum: TRUE
+
+# Whether the PIM payload is shown off of the main tree or encapsulated within the PIM options
+# TRUE or FALSE (case-insensitive)
+#pim.payload_tree: TRUE
+
+# The password to used to decrypt the encrypted elements within the PKCS#12 file
+# A string
+#pkcs12.password: 
+
+# Whether to try and decrypt the encrypted data within the PKCS#12 with a NULL password
+# TRUE or FALSE (case-insensitive)
+#pkcs12.try_null_password: FALSE
+
+# Whether the PN-RT summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#pn_rt.summary_in_tree: TRUE
+
+# Reassemble PNIO Fragments and get them decoded
+# TRUE or FALSE (case-insensitive)
+#pn_rt.desegment: TRUE
+
+# Protocol payload type
+# One of: Data, Sony FeliCa, NXP MiFare, ISO 7816
+# (case-insensitive).
+#pn532.prtype532: Data
+
+# Whether the PNIO dissector is allowed to use detailed PROFIsafe dissection of cyclic data frames
+# TRUE or FALSE (case-insensitive)
+#pn_io.pnio_ps_selection: TRUE
+
+# Select your Networkpath to your GSD-Files.
+# A path to a directory
+#pn_io.pnio_ps_networkpath: 
+
+# Whether the POP dissector should reassemble RETR and TOP responses and spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#pop.desegment_data: TRUE
+
+# Whether fragmented 802.11 aggregated MPDUs should be reassembled
+# TRUE or FALSE (case-insensitive)
+#ppi.reassemble: TRUE
+
+# The type of PPP frame checksum (none, 16-bit, 32-bit)
+# One of: None, 16-Bit, 32-Bit
+# (case-insensitive).
+#ppp.fcs_type: None
+
+# Default Protocol ID to be used for PPPMuxCP
+# A hexadecimal number
+#ppp.default_proto_id: 0
+
+# Whether PPP Multilink frames use 12-bit sequence numbers
+# TRUE or FALSE (case-insensitive)
+#mp.short_seqno: FALSE
+
+# Maximum number of PPP Multilink fragments to try to reassemble into one frame
+# A decimal number
+#mp.max_fragments: 6
+
+# Age off unreassembled fragments after this many packets
+# A decimal number
+#mp.fragment_aging: 4000
+
+# Show values of tags and lengths of data fields
+# TRUE or FALSE (case-insensitive)
+#pppoed.show_tags_and_lengths: FALSE
+
+# Load .proto files when Wireshark starts. By default, the .proto files are loaded only when the Protobuf dissector is called for the first time.
+# TRUE or FALSE (case-insensitive)
+#protobuf.preload_protos: FALSE
+
+# If Protobuf messages and fields are defined in loaded .proto files, they will be dissected as wireshark fields if this option is turned on. The names of all these wireshark fields will be prefixed with "pbf." (for fields) or "pbm." (for messages) followed by their full names in the .proto files.
+# TRUE or FALSE (case-insensitive)
+#protobuf.pbf_as_hf: FALSE
+
+# Show the names of message, field, enum and enum_value. Show the wire type and field number format of field. Show value nodes of field and enum_value.
+# TRUE or FALSE (case-insensitive)
+#protobuf.show_details: FALSE
+
+# Show all fields of bytes type as string. For example ETCD string
+# TRUE or FALSE (case-insensitive)
+#protobuf.bytes_as_string: FALSE
+
+# Make Protobuf fields that are not serialized on the wire to be displayed with default values.
+# The default value will be one of the following: 
+#   1) The value of the 'default' option of an optional field defined in 'proto2' file. (explicitly-declared)
+#   2) False for bools.
+#   3) First defined enum value for enums.
+#   4) Zero for numeric types.
+# There are no default values for fields 'repeated' or 'bytes' and 'string' without default value declared.
+# If the missing field is 'required' in a 'proto2' file, a warning item will be added to the tree.
+# One of: None, Only Explicitly-Declared (proto2), Explicitly-Declared, ENUM and BOOL, All
+# (case-insensitive).
+#protobuf.add_default_value: None
+
+# Try to dissect all undefined length-delimited fields as string.
+# TRUE or FALSE (case-insensitive)
+#protobuf.try_dissect_as_string: FALSE
+
+# Try to show all possible field types for each undefined field according to wire type.
+# TRUE or FALSE (case-insensitive)
+#protobuf.show_all_types: FALSE
+
+# Properly translates vendor specific opcodes
+# One of: Unknown vendor, Eastman Kodak, Canon, Nikon, Casio EX-F1, Microsoft / MTP, Olympus E series
+# (case-insensitive).
+#ptpip.vendor: Unknown vendor
+
+# Whether the PVFS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#pvfs.desegment: TRUE
+
+# Whether the Q.931 dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#q931.desegment_h323_messages: TRUE
+
+# Reassemble segmented Q.931 messages (Q.931 - Annex H)
+# TRUE or FALSE (case-insensitive)
+#q931.reassembly: TRUE
+
+# Decode ISO/IEC cause coding standard as ITU-T
+# TRUE or FALSE (case-insensitive)
+#q931.iso_iec_cause_coding: FALSE
+
+# Type of Facility encoding
+# One of: Dissect facility as QSIG, Dissect facility as ETSI
+# (case-insensitive).
+#q932.facility_encoding: Dissect facility as QSIG
+
+# Set the UDP base port for the Quake III Arena Server
+# A decimal number
+#quake3.udp.arena_port: 27960
+
+# Set the UDP base port for the Quake III Arena Master Server
+# A decimal number
+#quake3.udp.master_port: 27950
+
+# Shared secret used to decode User Passwords and validate Accounting Request and Response Authenticators
+# A string
+#radius.shared_secret: 
+
+# Whether to check or not if Accounting Request and Response Authenticator are correct. You need to define shared secret for this to work.
+# TRUE or FALSE (case-insensitive)
+#radius.validate_authenticator: FALSE
+
+# Whether to add or not to the tree the AVP's payload length
+# TRUE or FALSE (case-insensitive)
+#radius.show_length: FALSE
+
+# Whether to interpret 241-246 as extended attributes according to RFC 6929
+# TRUE or FALSE (case-insensitive)
+#radius.disable_extended_attributes: FALSE
+
+# The SCCP SubSystem Number for RANAP (default 142)
+# A decimal number
+#ranap.sccp_ssn: 142
+
+# Attempt to dissect RRC message embedded in RRC-Container IE
+# TRUE or FALSE (case-insensitive)
+#ranap.dissect_rrc_container: FALSE
+
+# Where available, show which protocol and frame caused this RDT stream to be created
+# TRUE or FALSE (case-insensitive)
+#rdt.show_setup_info: TRUE
+
+# Whether fragmented RELOAD datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#reload.defragment: TRUE
+
+# Length of the NodeId as defined in the overlay.
+# A decimal number
+#reload.nodeid_length: 16
+
+# topology plugin defined in the overlay
+# A string
+#reload.topology_plugin: CHORD-RELOAD
+
+# Display the third and forth bytes of the RIPv2 header as the Routing Domain field (introduced in RFC 1388 [January 1993] and obsolete as of RFC 1723 [November 1994])
+# TRUE or FALSE (case-insensitive)
+#rip.display_routing_domain: FALSE
+
+# When enabled, try to reassemble SDUs from the various PDUs received
+# TRUE or FALSE (case-insensitive)
+#rlc.perform_reassembly: TRUE
+
+# When enabled, if data is not present, don't report as an error, but instead add expert info to indicate that headers were omitted
+# TRUE or FALSE (case-insensitive)
+#rlc.header_only_mode: FALSE
+
+# When enabled, RLC will ignore sequence numbers reported in 'Security Mode Command'/'Security Mode Complete' (RRC) messages when checking if frames are ciphered
+# TRUE or FALSE (case-insensitive)
+#rlc.ignore_rrc_cipher_indication: FALSE
+
+# When enabled, RLC will assume all payloads in RLC frames are ciphered
+# TRUE or FALSE (case-insensitive)
+#rlc.ciphered_data: FALSE
+
+# LI size in bits, either 7 or 15 bit
+# One of: 7 bits, 15 bits, Let upper layers decide
+# (case-insensitive).
+#rlc.li_size: Let upper layers decide
+
+# Attempt to keep track of PDUs for AM channels, and point out problems
+# One of: No-Analysis, Only-MAC-frames, Only-RLC-frames
+# (case-insensitive).
+#rlc-lte.do_sequence_analysis_am: Only-MAC-frames
+
+# Attempt to keep track of PDUs for UM channels, and point out problems
+# One of: No-Analysis, Only-MAC-frames, Only-RLC-frames
+# (case-insensitive).
+#rlc-lte.do_sequence_analysis: Only-MAC-frames
+
+# Call PDCP dissector for signalling PDUs.  Note that without reassembly, it canonly be called for complete PDUs (i.e. not segmented over RLC)
+# TRUE or FALSE (case-insensitive)
+#rlc-lte.call_pdcp_for_srb: TRUE
+
+# Call PDCP dissector for user-plane PDUs.  Note that without reassembly, it canonly be called for complete PDUs (i.e. not segmented over RLC)
+# One of: Off, 7-bit SN, 12-bit SN, 15-bit SN, 18-bit SN, Use signalled value
+# (case-insensitive).
+#rlc-lte.call_pdcp_for_drb: Use signalled value
+
+# Call RRC dissector for CCCH PDUs
+# TRUE or FALSE (case-insensitive)
+#rlc-lte.call_rrc_for_ccch: TRUE
+
+# Call RRC dissector for MCCH PDUs  Note that without reassembly, it canonly be called for complete PDUs (i.e. not segmented over RLC)
+# TRUE or FALSE (case-insensitive)
+#rlc-lte.call_rrc_for_mcch: FALSE
+
+# Call ip dissector for MTCH PDUs  Note that without reassembly, it canonly be called for complete PDUs (i.e. not segmented over RLC)
+# TRUE or FALSE (case-insensitive)
+#rlc-lte.call_ip_for_mtch: FALSE
+
+# When enabled, if data is not present, don't report as an error, but instead add expert info to indicate that headers were omitted
+# TRUE or FALSE (case-insensitive)
+#rlc-lte.header_only_mode: FALSE
+
+# When enabled, attempts to re-assemble upper-layer SDUs that are split over more than one RLC PDU.  Note: does not currently support out-of-order or re-segmentation. N.B. sequence analysis must also be turned on in order for reassembly to work
+# TRUE or FALSE (case-insensitive)
+#rlc-lte.reassembly: TRUE
+
+# Call PDCP dissector for signalling PDUs.  Note that without reassembly, it canonly be called for complete PDUs (i.e. not segmented over RLC)
+# TRUE or FALSE (case-insensitive)
+#rlc-nr.call_pdcp_for_srb: TRUE
+
+# Call PDCP dissector for UL user-plane PDUs.  Note that without reassembly, it canonly be called for complete PDUs (i.e. not segmented over RLC)
+# One of: Off, 12-bit SN, 18-bit SN, Use signalled value
+# (case-insensitive).
+#rlc-nr.call_pdcp_for_ul_drb: Off
+
+# Call PDCP dissector for DL user-plane PDUs.  Note that without reassembly, it canonly be called for complete PDUs (i.e. not segmented over RLC)
+# One of: Off, 12-bit SN, 18-bit SN, Use signalled value
+# (case-insensitive).
+#rlc-nr.call_pdcp_for_dl_drb: Off
+
+# Call RRC dissector for CCCH PDUs
+# TRUE or FALSE (case-insensitive)
+#rlc-nr.call_rrc_for_ccch: TRUE
+
+# When enabled, if data is not present, don't report as an error, but instead add expert info to indicate that headers were omitted
+# TRUE or FALSE (case-insensitive)
+#rlc-nr.header_only_mode: FALSE
+
+# N.B. This should be considered experimental/incomplete, in that it doesn't try to discard reassembled state when reestablishment happens, or in certain packet-loss cases
+# TRUE or FALSE (case-insensitive)
+#rlc-nr.reassemble_am_frames: TRUE
+
+# N.B. This should be considered experimental/incomplete, in that it doesn't try to discard reassembled state when reestablishment happens, or in certain packet-loss cases
+# TRUE or FALSE (case-insensitive)
+#rlc-nr.reassemble_um_frames: FALSE
+
+# Whether the RPC dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#rpc.desegment_rpc_over_tcp: TRUE
+
+# Whether the RPC dissector should defragment RPC-over-TCP messages.
+# TRUE or FALSE (case-insensitive)
+#rpc.defragment_rpc_over_tcp: TRUE
+
+# Set the maximum size of RPCoverTCP PDUs.  If the size field of the record marker is larger than this value it will not be considered a valid RPC PDU.
+# A decimal number
+#rpc.max_tcp_pdu_size: 4194304
+
+# Whether the RPC dissector should attempt to dissect RPC PDUs containing programs that are not known to Wireshark. This will make the heuristics significantly weaker and elevate the risk for falsely identifying and misdissecting packets significantly.
+# TRUE or FALSE (case-insensitive)
+#rpc.dissect_unknown_programs: FALSE
+
+# Whether the RPC dissector should attempt to locate RPC PDU boundaries when initial fragment alignment is not known.  This may cause false positives, or slow operation.
+# TRUE or FALSE (case-insensitive)
+#rpc.find_fragment_start: FALSE
+
+# Whether the RPCAP dissector should reassemble PDUs spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#rpcap.desegment_pdus: TRUE
+
+# Whether the packets should be decoded according to the link-layer type.
+# TRUE or FALSE (case-insensitive)
+#rpcap.decode_content: TRUE
+
+# Default link-layer type to use if an Open Reply packet has not been captured.
+# A decimal number
+#rpcap.linktype: 4294967295
+
+# RPKI-Router Protocol TCP TLS port if other than the default
+# A decimal number
+#rpkirtr.tcp.rpkirtr_tls.port: 324
+
+# Whether the NAS PDU should be shown in the root packet details tree
+# TRUE or FALSE (case-insensitive)
+#rrc.nas_in_root_tree: FALSE
+
+# Controls the display of the session's client username in the info column.  This is only displayed if the packet containing it was seen during this capture session.
+# TRUE or FALSE (case-insensitive)
+#rsh.info_show_client_username: FALSE
+
+# Controls the display of the session's server username in the info column.  This is only displayed if the packet containing it was seen during this capture session.
+# TRUE or FALSE (case-insensitive)
+#rsh.info_show_server_username: TRUE
+
+# Controls the display of the command being run on the server by this session in the info column.  This is only displayed if the packet containing it was seen during this capture session.
+# TRUE or FALSE (case-insensitive)
+#rsh.info_show_command: FALSE
+
+# Use ipaccess nanoBTS specific definitions for RSL
+# TRUE or FALSE (case-insensitive)
+#gsm_abis_rsl.use_ipaccess_rsl: FALSE
+
+# Use Osmocom specific definitions for RSL
+# TRUE or FALSE (case-insensitive)
+#gsm_abis_rsl.use_osmocom_rsl: FALSE
+
+# The Physical Context Information field is not specified This information should be not be analysed by BSC, but merely forwarded from one TRX/channel to another.
+# TRUE or FALSE (case-insensitive)
+#gsm_abis_rsl.dissect_phy_ctx_inf: TRUE
+
+# Specifies whether Wireshark should decode and display sub-messages within BUNDLE messages
+# TRUE or FALSE (case-insensitive)
+#rsvp.process_bundle: TRUE
+
+# Specifies how Wireshark should dissect generalized labels
+# One of: data (no interpretation), SONET/SDH ("S, U, K, L, M" scheme), Wavelength Label (fixed or flexi grid), ODUk Label
+# (case-insensitive).
+#rsvp.generalized_label_options: data (no interpretation)
+
+# Set the TCP port for RSYNC messages
+# A decimal number
+#rsync.tcp_port: 873
+
+# Whether the RSYNC dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#rsync.desegment: TRUE
+
+# RTCDC SCTP PPID if other than the default
+# A decimal number
+#rtcdc.sctp.ppi: 50
+
+# Where available, show which protocol and frame caused this RTCP stream to be created
+# TRUE or FALSE (case-insensitive)
+#rtcp.show_setup_info: TRUE
+
+# Try to work out network delay by comparing time between packets as captured and delays as seen by endpoint
+# TRUE or FALSE (case-insensitive)
+#rtcp.show_roundtrip_calculation: FALSE
+
+# Minimum (absolute) calculated roundtrip delay time in milliseconds that should be reported
+# A decimal number
+#rtcp.roundtrip_min_threshhold: 10
+
+# Whether the RTMPT dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#rtmpt.desegment: TRUE
+
+# The largest acceptable packet size for reassembly
+# A decimal number
+#rtmpt.max_packet_size: 32768
+
+# Where available, show which protocol and frame caused this RTP stream to be created
+# TRUE or FALSE (case-insensitive)
+#rtp.show_setup_info: TRUE
+
+# Whether subdissector can request RTP streams to be reassembled
+# TRUE or FALSE (case-insensitive)
+#rtp.desegment_rtp_streams: TRUE
+
+# If an RTP version 0 packet is encountered, it can be treated as an invalid or ZRTP packet, a CLASSIC-STUN packet, or a T.38 packet
+# One of: Invalid or ZRTP packets, STUN packets, CLASSIC-STUN packets, T.38 packets, SPRT packets
+# (case-insensitive).
+#rtp.version0_type: Invalid or ZRTP packets
+
+# Payload Types for RFC2198 Redundant Audio Data; values must be in the range 1-127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#rtp.rfc2198_payload_type: 99
+
+# Payload Types for RFC2833 RTP Events; values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#rtpevent.event_payload_type_value: 101
+
+# Payload Types for Cisco Named Signaling Events; values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#rtpevent.cisco_nse_payload_type_value: 100
+
+# Dynamic payload types which will be interpreted as RTP-MIDI; values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#rtpmidi.midi_payload_type_value: 
+
+# Specifies that RTP/RTCP/T.38/MSRP/etc streams are decoded based upon port numbers found in RTPproxy answers
+# TRUE or FALSE (case-insensitive)
+#rtpproxy.establish_conversation: TRUE
+
+# Maximum timeout value in waiting for reply from RTPProxy (in milliseconds).
+# A decimal number
+#rtpproxy.reply.timeout: 1000
+
+# Specifies the maximum number of samples dissected in a DATA_BATCH submessage. Increasing this value may affect performances if the trace has a lot of big batched samples.
+# A decimal number
+#rtps.max_batch_samples_dissected: 16
+
+# Enabling this option may affect performance if the trace has messages with large Data Types.
+# TRUE or FALSE (case-insensitive)
+#rtps.enable_max_dissection_info_elements: TRUE
+
+# Specifies the maximum number of Data Type elements dissected. Increasing this value may affect performance if the trace has messages with large Data Types.
+# A decimal number
+#rtps.max_dissection_info_elements: 100
+
+# Disabling this option may affect performance if the trace has messages with large arrays or sequences.
+# TRUE or FALSE (case-insensitive)
+#rtps.enable_max_dissection_array_elements: TRUE
+
+# Specifies the maximum number of Data Type elements dissected in arrays or sequences. Increasing this value may affect performance if the trace has messages with large Data Types.
+# A decimal number
+#rtps.max_dissection_array_elements: 100
+
+# Shows the Topic Name and Type Name of the samples. Note: this can considerably increase the dissection time
+# TRUE or FALSE (case-insensitive)
+#rtps.enable_topic_info: TRUE
+
+# Dissects the user data if the Type Object is propagated in Discovery.
+# TRUE or FALSE (case-insensitive)
+#rtps.enable_user_data_dissection: FALSE
+
+# Enables the reassembly of DATA_FRAG submessages.
+# TRUE or FALSE (case-insensitive)
+#rtps.enable_rtps_reassembly: FALSE
+
+# Whether the RTSP dissector should reassemble headers of a request spanning multiple TCP segments.  To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#rtsp.desegment_headers: TRUE
+
+# Whether the RTSP dissector should use the "Content-length:" value to desegment the body of a request spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#rtsp.desegment_body: TRUE
+
+# Set the port for RUA messages (Default of 29169)
+# A decimal number
+#rua.port: 29169
+
+# S101 TCP port if other than the default
+# A decimal number
+#s101.tcp.port: 9000
+
+# Set the SCTP port for S1AP messages
+# A decimal number
+#s1ap.sctp.port: 36412
+
+# Dissect TransparentContainers that are opaque to S1AP
+# TRUE or FALSE (case-insensitive)
+#s1ap.dissect_container: TRUE
+
+# Select whether LTE TransparentContainer should be dissected as NB-IOT or legacy LTE
+# One of: Automatic, Legacy LTE, NB-IoT
+# (case-insensitive).
+#s1ap.dissect_lte_container_as: Automatic
+
+# Show length of text field
+# TRUE or FALSE (case-insensitive)
+#sametime.show_length: FALSE
+
+# reassemble packets
+# TRUE or FALSE (case-insensitive)
+#sametime.reassemble: TRUE
+
+# Whether the SASP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#sasp.desegment_sasp_messages: TRUE
+
+# The source point code (usually MSC) (to determine whether message is uplink or downlink)
+# A hexadecimal number
+#sccp.source_pc: 0
+
+# Show parameter length in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#sccp.show_length: FALSE
+
+# Whether SCCP messages should be reassembled
+# TRUE or FALSE (case-insensitive)
+#sccp.defragment_xudt: TRUE
+
+# Whether to keep information about messages and their associations
+# TRUE or FALSE (case-insensitive)
+#sccp.trace_sccp: FALSE
+
+# Show SLR, DLR, and CAUSE Parameters in the Information Column of the Summary
+# TRUE or FALSE (case-insensitive)
+#sccp.show_more_info: FALSE
+
+# Set the source and destination addresses to the GT digits (if present).  This may affect TCAP's ability to recognize which messages belong to which TCAP session.
+# TRUE or FALSE (case-insensitive)
+#sccp.set_addresses: FALSE
+
+# The protocol which should be used to dissect the payload if nothing else has claimed it
+# A string
+#sccp.default_payload: 
+
+# Use all bytes for data payload. Overcome 255 bytes limit of SCCP stadard.  (Some tracing tool save information without DT1 segmentation of 255 bytes)
+# TRUE or FALSE (case-insensitive)
+#sccp.dt1_ignore_length: FALSE
+
+# When Target Cannot Be Identified, Decode SCSI Messages As
+# One of: Block Device, Sequential Device, Object Based Storage Device, Medium Changer Device, Multimedia Device
+# (case-insensitive).
+#scsi.decode_scsi_messages_as: Block Device
+
+# Whether fragmented SCSI DATA IN/OUT transfers should be reassembled
+# TRUE or FALSE (case-insensitive)
+#scsi.defragment: FALSE
+
+# Show source and destination port numbers in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#sctp.show_port_numbers_in_tree: TRUE
+
+# Use relative TSNs instead of absolute ones
+# TRUE or FALSE (case-insensitive)
+#sctp.relative_tsns: TRUE
+
+# The type of checksum used in SCTP packets
+# One of: None, Adler 32, CRC 32c, Automatic
+# (case-insensitive).
+#sctp.checksum: None
+
+# Show always SCTP control chunks in the Info column
+# TRUE or FALSE (case-insensitive)
+#sctp.show_always_control_chunks: TRUE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to a specific port or PPI
+# TRUE or FALSE (case-insensitive)
+#sctp.try_heuristic_first: FALSE
+
+# Whether fragmented SCTP user messages should be reassembled
+# TRUE or FALSE (case-insensitive)
+#sctp.reassembly: TRUE
+
+# Match TSNs and their SACKs
+# TRUE or FALSE (case-insensitive)
+#sctp.tsn_analysis: TRUE
+
+# Match verification tags (CPU intense)
+# TRUE or FALSE (case-insensitive)
+#sctp.association_index: FALSE
+
+# Dissect upper layer protocols
+# TRUE or FALSE (case-insensitive)
+#sctp.ulp_dissection: TRUE
+
+# Whether Scylla dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#scylla.desegment: TRUE
+
+# Data rate
+# One of: Attempt to guess, OC-3, OC-12, OC-24, OC-48
+# (case-insensitive).
+#sdh.data.rate: OC-3
+
+# Specifies that RTP/RTCP/T.38/MSRP/etc streams are decoded based upon port numbers found in SDP payload
+# TRUE or FALSE (case-insensitive)
+#sdp.establish_conversation: TRUE
+
+# Whether the SEL Protocol dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#selfm.desegment: TRUE
+
+# Whether the SEL Protocol dissector should automatically pre-process Telnet data to remove duplicate 0xFF IAC bytes
+# TRUE or FALSE (case-insensitive)
+#selfm.telnetclean: TRUE
+
+# Perform CRC16 validation on Fast Messages
+# TRUE or FALSE (case-insensitive)
+#selfm.crc_verification: FALSE
+
+# List of word bits contained in SER equations (Comma-separated, no Quotes or Checksums)
+# A string
+#selfm.ser_list: 
+
+# Whether the session dissector should reassemble messages spanning multiple SES segments
+# TRUE or FALSE (case-insensitive)
+#ses.desegment: TRUE
+
+# Enabling dissection makes it easy to view protocol details in each of the sampled headers.  Disabling dissection may reduce noise caused when display filters match the contents of any sampled header(s).
+# TRUE or FALSE (case-insensitive)
+#sflow.enable_dissection: TRUE
+
+# This option only makes sense if dissection of sampled headers is enabled and probably not even then.
+# TRUE or FALSE (case-insensitive)
+#sflow.enable_analysis: FALSE
+
+# Port numbers used for SGsAP traffic (default 29118)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#sgsap.sctp_ports: 29118
+
+# Preference whether to Dissect the UDVM code or not
+# TRUE or FALSE (case-insensitive)
+#sigcomp.display.udvm.code: FALSE
+
+# preference whether to display the bytecode in UDVM operands or not
+# TRUE or FALSE (case-insensitive)
+#sigcomp.display.bytecode: FALSE
+
+# preference whether to decompress message or not
+# TRUE or FALSE (case-insensitive)
+#sigcomp.decomp.msg: FALSE
+
+# preference whether to display the decompressed message as raw text or not
+# TRUE or FALSE (case-insensitive)
+#sigcomp.display.decomp.msg.as.txt: FALSE
+
+# 'No-Printout' = UDVM executes silently, then increasing detail about execution of UDVM instructions; Warning! CPU intense at high detail
+# One of: No-Printout, Low-detail, Medium-detail, High-detail
+# (case-insensitive).
+#sigcomp.show.udvm.execution: No-Printout
+
+# Should the payload dissector be active?
+# TRUE or FALSE (case-insensitive)
+#signal_pdu.payload_dissector_activated: FALSE
+
+# Should the payload dissector show entries marked as hidden in the configuration?
+# TRUE or FALSE (case-insensitive)
+#signal_pdu.payload_dissector_show_hidden: FALSE
+
+# Should the payload dissector hide raw values?
+# TRUE or FALSE (case-insensitive)
+#signal_pdu.payload_dissector_hide_raw_values: TRUE
+
+# Set the CA_system_ID used to decode ECM datagram as MIKEY
+# A hexadecimal number
+#simulcrypt.ca_system_id_mikey: 0x9999
+
+# SIP Server TLS Port
+# A decimal number
+#sip.tls.port: 5061
+
+# Specifies that the raw text of the SIP message should be displayed in addition to the dissection tree
+# TRUE or FALSE (case-insensitive)
+#sip.display_raw_text: FALSE
+
+# If the raw text of the SIP message is displayed, the trailing carriage return and line feed are not shown
+# TRUE or FALSE (case-insensitive)
+#sip.display_raw_text_without_crlf: FALSE
+
+# If enabled, only SIP/2.0 traffic will be dissected as SIP. Disable it to allow SIP traffic with a different version to be dissected as SIP.
+# TRUE or FALSE (case-insensitive)
+#sip.strict_sip_version: TRUE
+
+# Whether the SIP dissector should reassemble headers of a request spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#sip.desegment_headers: TRUE
+
+# Whether the SIP dissector should use the "Content-length:" value, if present, to reassemble the body of a request spanning multiple TCP segments, and reassemble chunked data spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#sip.desegment_body: TRUE
+
+# Whether retransmissions are detected coming from the same source port only.
+# TRUE or FALSE (case-insensitive)
+#sip.retrans_the_same_sport: TRUE
+
+# Whether SIP should delay tracking the media (e.g., RTP/RTCP) until an SDP offer is answered. If enabled, mid-dialog changes to SDP and media state only take effect if and when an SDP offer is successfully answered; however enabling this prevents tracking media in early-media call scenarios
+# TRUE or FALSE (case-insensitive)
+#sip.delay_sdp_changes: FALSE
+
+# Whether the generated call id should be hidden(not displayed) in the tree or not.
+# TRUE or FALSE (case-insensitive)
+#sip.hide_generatd_call_id: FALSE
+
+# Validate SIP authorizations with known credentials
+# TRUE or FALSE (case-insensitive)
+#sip.validate_authorization: FALSE
+
+# Whether the SKINNY dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#skinny.desegment: TRUE
+
+# Whether the dissector should reassemble the payload of SMB Transaction commands spanning multiple SMB PDUs
+# TRUE or FALSE (case-insensitive)
+#smb.trans_reassembly: TRUE
+
+# Whether the dissector should reassemble DCERPC over SMB commands
+# TRUE or FALSE (case-insensitive)
+#smb.dcerpc_reassembly: TRUE
+
+# Whether the dissector should snoop SMB and related CIFS protocols to discover and display Names associated with SIDs
+# TRUE or FALSE (case-insensitive)
+#smb.sid_name_snooping: FALSE
+
+# Whether the dissector should display SIDs and RIDs in hexadecimal rather than decimal
+# TRUE or FALSE (case-insensitive)
+#smb.sid_display_hex: FALSE
+
+# Whether the export object functionality will take the full path file name as file identifier
+# TRUE or FALSE (case-insensitive)
+#smb.eosmb_take_name_as_fid: FALSE
+
+# Whether the export object functionality will take the full path file name as file identifier
+# TRUE or FALSE (case-insensitive)
+#smb2.eosmb2_take_name_as_fid: FALSE
+
+# Whether the dissector should reassemble Named Pipes over SMB2 commands
+# TRUE or FALSE (case-insensitive)
+#smb2.pipe_reassembly: TRUE
+
+# Whether the dissector should try to verify SMB2 signatures
+# TRUE or FALSE (case-insensitive)
+#smb2.verify_signatures: FALSE
+
+# Whether the SMB Direct dissector should reassemble fragmented payloads
+# TRUE or FALSE (case-insensitive)
+#smb_direct.reassemble_smb_direct: TRUE
+
+# Enable reassembling (default is enabled)
+# TRUE or FALSE (case-insensitive)
+#sml.reassemble: TRUE
+
+# Enable crc (default is disabled)
+# TRUE or FALSE (case-insensitive)
+#sml.crc: FALSE
+
+# Whether the SMP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#smp.desegment: TRUE
+
+# Whether the SMPP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#smpp.reassemble_smpp_over_tcp: TRUE
+
+# Whether to decode the SMS contents when DCS is equal to 0 (zero).
+# One of: None, ASCII, GSM 7-bit, GSM 7-bit (packed), ISO-8859-1, ISO-8859-5, ISO-8859-8, UCS2
+# (case-insensitive).
+#smpp.decode_sms_over_smpp: None
+
+# Whether the SMTP dissector should reassemble command and response lines spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#smtp.desegment_lines: TRUE
+
+# Whether the SMTP dissector should reassemble DATA command and lines spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#smtp.desegment_data: TRUE
+
+# Whether the SMTP dissector should decode Base64 encoded AUTH parameters
+# TRUE or FALSE (case-insensitive)
+#smtp.decryption: FALSE
+
+# Whether fragmented BIUs should be reassembled
+# TRUE or FALSE (case-insensitive)
+#sna.defragment: TRUE
+
+# Whether the SNMP OID should be shown in the info column
+# TRUE or FALSE (case-insensitive)
+#snmp.display_oid: TRUE
+
+# Whether the SNMP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#snmp.desegment: TRUE
+
+# ON - display dissected variables inside SNMP tree, OFF - display dissected variables in root tree after SNMP
+# TRUE or FALSE (case-insensitive)
+#snmp.var_in_tree: TRUE
+
+# Set whether dissector should run Snort and pass frames into it, or read alerts from user packet comments
+# One of: Not looking for Snort alerts, From running Snort, From user packet comments
+# (case-insensitive).
+#snort.alerts_source: Not looking for Snort alerts
+
+# The name of the snort binary file to run
+# A path to a file
+#snort.binary: /usr/sbin/snort
+
+# The name of the file containing the snort IDS configuration.  Typically snort.conf
+# A path to a file
+#snort.config: /etc/snort/snort.conf
+
+# Whether or not information about the rule set and detected alerts should be shown in the tree of every snort PDU tree
+# TRUE or FALSE (case-insensitive)
+#snort.show_rule_set_stats: FALSE
+
+# Whether or not expert info should be used to highlight fired alerts
+# TRUE or FALSE (case-insensitive)
+#snort.show_alert_expert_info: FALSE
+
+# Attempt to show alert in reassembled frame where possible.  Note that this won't work during live capture
+# TRUE or FALSE (case-insensitive)
+#snort.show_alert_in_reassembled_frame: FALSE
+
+# When enabled, will run Snort with '-k none'
+# TRUE or FALSE (case-insensitive)
+#snort.ignore_checksum_errors: TRUE
+
+# Show unidentified fields ("padding") in packet dissections
+# TRUE or FALSE (case-insensitive)
+#solaredge.unknown: TRUE
+
+# Inverter system encryption key
+# A string
+#solaredge.system_encryption_key: 
+
+# SOME/IP Port Ranges UDP.
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#someip.ports.udp: 
+
+# SOME/IP Port Ranges TCP.
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#someip.ports.tcp: 
+
+# Reassemble SOME/IP-TP segments
+# TRUE or FALSE (case-insensitive)
+#someip.reassemble_tp: TRUE
+
+# Should the SOME/IP Dissector use the payload dissector?
+# TRUE or FALSE (case-insensitive)
+#someip.payload_dissector_activated: FALSE
+
+# Should the SOME/IP Dissector use the payload dissector with the experimental WTLV encoding for unconfigured messages?
+# TRUE or FALSE (case-insensitive)
+#someip.payload_dissector_wtlv_default: FALSE
+
+# SOME/IP Ignore Port Ranges UDP. These ports are not automatically added by the SOME/IP-SD.
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#someipsd.ports.udp.ignore: 
+
+# SOME/IP Ignore Port Ranges TCP. These ports are not automatically added by the SOME/IP-SD.
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#someipsd.ports.tcp.ignore: 
+
+# Whether the SoulSeek dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#slsk.desegment: TRUE
+
+# Whether the SoulSeek dissector should decompress all zlib compressed packets inside messages
+# TRUE or FALSE (case-insensitive)
+#slsk.decompress: TRUE
+
+# Whether the SoupBinTCP dissector should reassemble messages spanning multiple TCP segments.
+# TRUE or FALSE (case-insensitive)
+#soupbintcp.desegment: TRUE
+
+# Whether the SPDY dissector should reassemble multiple data frames into an entity body.
+# TRUE or FALSE (case-insensitive)
+#spdy.assemble_data_frames: TRUE
+
+# Whether to uncompress SPDY headers.
+# TRUE or FALSE (case-insensitive)
+#spdy.decompress_headers: TRUE
+
+# Whether to uncompress entity bodies that are compressed using "Content-Encoding: "
+# TRUE or FALSE (case-insensitive)
+#spdy.decompress_body: TRUE
+
+# Where available, show which protocol and frame caused this SPRT stream to be created
+# TRUE or FALSE (case-insensitive)
+#sprt.show_setup_info: TRUE
+
+# Show the DLCI field in I_OCTET messages as well as the frame that enabled/disabled the DLCI
+# TRUE or FALSE (case-insensitive)
+#sprt.show_dlci_info: TRUE
+
+# Whether the SRVLOC dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#srvloc.desegment_tcp: TRUE
+
+# SSCOP payload (dissector to call on SSCOP payload)
+# One of: Data (no further dissection), Q.2931, SSCF-NNI (MTP3-b), ALCAP, NBAP
+# (case-insensitive).
+#sscop.payload: Q.2931
+
+# Whether the SSH dissector should reassemble SSH buffers spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ssh.desegment_buffers: TRUE
+
+# The path to the file which contains a list of key exchange secrets in the following format:
+# "<key-type> <hex-encoded-key>" (without quotes or leading spaces).
+# <key-type> is one of: curve25519. 
+# A path to a file
+#ssh.keylog_file: 
+
+# MOSH_KEY AES key (from mosh-{client,server} environment variable)
+# A string
+#ssyncp.key: 
+
+# Whether the STANAG 5066 DTS Layer dissector should reassemble DPDUs spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#s5066dts.proto_desegment: TRUE
+
+# Whether the S5066 SIS dissector should reassemble PDUs spanning multiple TCP segments. The default is to use reassembly.
+# TRUE or FALSE (case-insensitive)
+#s5066sis.desegment_pdus: TRUE
+
+# Whether the S5066 SIS dissector should dissect this edition of the STANAG. This edition was never formally approved and is very rare. The common edition is edition 1.2.
+# TRUE or FALSE (case-insensitive)
+#s5066sis.edition_one: FALSE
+
+# Whether the StarTeam dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#starteam.desegment: TRUE
+
+#  Steam IHS Discovery UDP port if other than the default
+# A decimal number
+#steam_ihs_discovery.udp.port: 27036
+
+# Whether the BPDU dissector should use 802.1t System ID Extensions when dissecting the Bridge Identifier
+# TRUE or FALSE (case-insensitive)
+#stp.use_system_id_extension: TRUE
+
+# Reassembles greater than MTU sized STT packets broken into segments on transmit
+# TRUE or FALSE (case-insensitive)
+#stt.reassemble: TRUE
+
+# Whether to validate the STT checksum or not.
+# TRUE or FALSE (case-insensitive)
+#stt.check_checksum: FALSE
+
+# Stun Version on the Network
+# One of: Auto, MS-TURN, RFC3489 and earlier, RFC5389 and later
+# (case-insensitive).
+#stun.stunversion: RFC5389 and later
+
+# Version used by Wireshark
+# One of: Internet Draft version 08, RFC 3868
+# (case-insensitive).
+#sua.version: RFC 3868
+
+# Set the source and destination addresses to the PC or GT digits, depending on the routing indicator.  This may affect TCAP's ability to recognize which messages belong to which TCAP session.
+# TRUE or FALSE (case-insensitive)
+#sua.set_addresses: FALSE
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#sv.decode_data_as_phsmeas: FALSE
+
+# Whether the T.38 dissector should decode using the Pre-Corrigendum T.38 ASN.1 specification (1998).
+# TRUE or FALSE (case-insensitive)
+#t38.use_pre_corrigendum_asn1_specification: TRUE
+
+# Whether a UDP packet that looks like RTP version 2 packet will be dissected as RTP packet or T.38 packet. If enabled there is a risk that T.38 UDPTL packets with sequence number higher than 32767 may be dissected as RTP.
+# TRUE or FALSE (case-insensitive)
+#t38.dissect_possible_rtpv2_packets_as_rtp: FALSE
+
+# Whether the dissector should reassemble T.38 PDUs spanning multiple TCP segments when TPKT is used over TCP. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#t38.reassembly: TRUE
+
+# Whether T.38 is used with TPKT for TCP
+# One of: Never, Always, Maybe
+# (case-insensitive).
+#t38.tpkt_usage: Maybe
+
+# Where available, show which protocol and frame caused this T.38 stream to be created
+# TRUE or FALSE (case-insensitive)
+#t38.show_setup_info: TRUE
+
+# Whether the TACACS+ dissector should reassemble messages spanning multiple TCP segments.  To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tacplus.desegment: TRUE
+
+# TACACS+ Encryption Key
+# A string
+#tacplus.key: 
+
+# Whether the TALI dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tali.reassemble: TRUE
+
+# SCCP (and SUA) SSNs to decode as TCAP
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#tcap.ssn: 
+
+# Activate the analyse for Response Time
+# TRUE or FALSE (case-insensitive)
+#tcap.srt: FALSE
+
+# Statistics for Response Time
+# TRUE or FALSE (case-insensitive)
+#tcap.persistentsrt: FALSE
+
+# Maximal delay for message repetition
+# A decimal number
+#tcap.repetitiontimeout: 10
+
+# Maximal delay for message lost
+# A decimal number
+#tcap.losttimeout: 30
+
+# Whether the TCP summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#tcp.summary_in_tree: TRUE
+
+# Whether to validate the TCP checksum or not.  (Invalid checksums will cause reassembly, if enabled, to fail.)
+# TRUE or FALSE (case-insensitive)
+#tcp.check_checksum: FALSE
+
+# Whether subdissector can request TCP streams to be reassembled
+# TRUE or FALSE (case-insensitive)
+#tcp.desegment_tcp_streams: TRUE
+
+# Whether out-of-order segments should be buffered and reordered before passing it to a subdissector. To use this option you must also enable "Allow subdissector to reassemble TCP streams".
+# TRUE or FALSE (case-insensitive)
+#tcp.reassemble_out_of_order: FALSE
+
+# Make the TCP dissector analyze TCP sequence numbers to find and flag segment retransmissions, missing segments and RTT
+# TRUE or FALSE (case-insensitive)
+#tcp.analyze_sequence_numbers: TRUE
+
+# Make the TCP dissector use relative sequence numbers instead of absolute ones. To use this option you must also enable "Analyze TCP sequence numbers". 
+# TRUE or FALSE (case-insensitive)
+#tcp.relative_sequence_numbers: TRUE
+
+# Make the TCP dissector use this scaling factor for streams where the signalled scaling factor is not visible in the capture
+# One of: Not known, 0 (no scaling), 1 (multiply by 2), 2 (multiply by 4), 3 (multiply by 8), 4 (multiply by 16), 5 (multiply by 32), 6 (multiply by 64), 7 (multiply by 128), 8 (multiply by 256), 9 (multiply by 512), 10 (multiply by 1024), 11 (multiply by 2048), 12 (multiply by 4096), 13 (multiply by 8192), 14 (multiply by 16384)
+# (case-insensitive).
+#tcp.default_window_scaling: Not known
+
+# Make the TCP dissector track the number on un-ACKed bytes of data are in flight per packet. To use this option you must also enable "Analyze TCP sequence numbers". This takes a lot of memory but allows you to track how much data are in flight at a time and graphing it in io-graphs
+# TRUE or FALSE (case-insensitive)
+#tcp.track_bytes_in_flight: TRUE
+
+# Evaluate BiF on actual sequence numbers or use the historical method based on payloads (default). This option has no effect if not used with "Track number of bytes in flight". 
+# TRUE or FALSE (case-insensitive)
+#tcp.bif_seq_based: FALSE
+
+# Calculate timestamps relative to the first frame and the previous frame in the tcp conversation
+# TRUE or FALSE (case-insensitive)
+#tcp.calculate_timestamps: TRUE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to a specific port
+# TRUE or FALSE (case-insensitive)
+#tcp.try_heuristic_first: FALSE
+
+# Do not place the TCP Timestamps in the summary line
+# TRUE or FALSE (case-insensitive)
+#tcp.ignore_tcp_timestamps: FALSE
+
+# When interpreting ambiguous packets, give precedence to Fast Retransmission or OOO 
+# TRUE or FALSE (case-insensitive)
+#tcp.fastrt_supersedes_ooo: TRUE
+
+# Do not call any subdissectors for Retransmitted or OutOfOrder segments
+# TRUE or FALSE (case-insensitive)
+#tcp.no_subdissector_on_error: TRUE
+
+# Assume TCP Experimental Options (253, 254) have a Magic Number and use it for dissection
+# TRUE or FALSE (case-insensitive)
+#tcp.dissect_experimental_options_with_magic: TRUE
+
+# Collect and store process information retrieved from IPFIX dissector
+# TRUE or FALSE (case-insensitive)
+#tcp.display_process_info_from_ipfix: FALSE
+
+# Whether the TCPROS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tcpros.desegment_tcpros_messages: TRUE
+
+# The TDMoE channel that contains the D-Channel.
+# A decimal number
+#tdmoe.d_channel: 24
+
+# The TDMoD channel that contains the D-Channel.
+# A decimal number
+#tdmop.d_channel: 16
+
+# The bitmask of channels in uncompressed TDMoP frame
+# A hexadecimal number
+#tdmop.ts_mask: 0xffffffff
+
+# The ethertype assigned to TDMoP (without IP/UDP) stream
+# A hexadecimal number
+#tdmop.ethertype: 0
+
+# Whether the TDS dissector should reassemble TDS buffers spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tds.desegment_buffers: TRUE
+
+# Whether the TDS dissector should defragment messages spanning multiple Netlib buffers
+# TRUE or FALSE (case-insensitive)
+#tds.defragment: TRUE
+
+# Hint as to version of TDS protocol being decoded
+# One of: Not Specified, TDS 4.x, TDS 5.0, TDS 7.0, TDS 7.1, TDS 7.2, TDS 7.3, TDS 7.3A, TDS 7.3B, TDS 7.4
+# (case-insensitive).
+#tds.protocol_type: Not Specified
+
+# Hint as to whether to decode TDS protocol as little-endian or big-endian. (TDS7/8 always decoded as little-endian)
+# One of: Little Endian, Big Endian
+# (case-insensitive).
+#tds.endian_type: Little Endian
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to "decode as"
+# TRUE or FALSE (case-insensitive)
+#tecmp.try_heuristic_first: FALSE
+
+# Whether the captured data include carrier number
+# TRUE or FALSE (case-insensitive)
+#tetra.include_carrier_number: TRUE
+
+# Whether fragmented TFTP files should be reassembled
+# TRUE or FALSE (case-insensitive)
+#tftp.defragment: FALSE
+
+# 32-bit sequence counter for hash
+# A string
+#thread.thr_seq_ctr: 
+
+# Set if the PAN ID should be used as the first two octets of the master key (PAN ID LSB), (PAN ID MSB), Key[2]...
+# TRUE or FALSE (case-insensitive)
+#thread.thr_use_pan_id_in_key: FALSE
+
+# Set if the Thread sequence counter should be automatically acquired from Key ID mode 2 MLE messages.
+# TRUE or FALSE (case-insensitive)
+#thread.thr_auto_acq_thr_seq_ctr: TRUE
+
+# How the binary should be decoded
+# One of: UTF-8 if printable, Binary (hexadecimal string), ASCII String, UTF-8 String, UTF-16 Big Endian, UTF-16 Little Endian, UTF-32 Big Endian, UTF-32 Little Endian
+# (case-insensitive).
+#thrift.decode_binary: UTF-8 if printable
+
+# Thrift TLS port
+# A decimal number
+#thrift.tls.port: 0
+
+# Whether the Thrift dissector should display Thrift internal fields for sub-dissectors.
+# TRUE or FALSE (case-insensitive)
+#thrift.show_internal: FALSE
+
+# Whether the Thrift dissector should try to dissect the data if the sub-dissector failed. This option can be useful if the data is well-formed but the sub-dissector is expecting different type/content.
+# TRUE or FALSE (case-insensitive)
+#thrift.fallback_on_generic: FALSE
+
+# Maximum expected depth of nested types in the Thrift structures and containers. A Thrift-based protocol using no parameter and void return types only uses a depth of 0. A Thrift-based protocol using only simple types as parameters or return values uses a depth of 1.
+# A decimal number
+#thrift.nested_type_depth: 25
+
+# Whether the Thrift dissector should reassemble framed messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#thrift.desegment_framed: TRUE
+
+# Try the default RSA key in use by nearly all Open Tibia servers
+# TRUE or FALSE (case-insensitive)
+#tibia.try_otserv_key: TRUE
+
+# Shows active character for every packet
+# TRUE or FALSE (case-insensitive)
+#tibia.show_char_name: TRUE
+
+# Shows account name/password or session key for every packet
+# TRUE or FALSE (case-insensitive)
+#tibia.show_acc_info: TRUE
+
+# Shows which XTEA key was applied for a packet
+# TRUE or FALSE (case-insensitive)
+#tibia.show_xtea_key: FALSE
+
+# Only decrypt packets and dissect login packets. Pass game commands to the data dissector
+# TRUE or FALSE (case-insensitive)
+#tibia.dissect_game_commands: FALSE
+
+# Whether the Tibia dissector should reassemble packets spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tibia.reassemble_tcp_segments: TRUE
+
+# Time display type
+# One of: UTC, Local
+# (case-insensitive).
+#time.display_time_type: Local
+
+# Whether TIPCv1 SEGMENTATION_MANAGER datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#tipc.defragment: TRUE
+
+# Whether to try to dissect TIPC data or not
+# TRUE or FALSE (case-insensitive)
+#tipc.dissect_tipc_data: TRUE
+
+# Try to decode a TIPCv2 packet using an heuristic sub-dissector before using a registered sub-dissector
+# TRUE or FALSE (case-insensitive)
+#tipc.try_heuristic_first: FALSE
+
+# TIPC 1.7 removes/adds fields (not) available in TIPC 1.5/1.6 while keeping the version number 2 in the packages. "ALL" shows all fields that were ever used in both versions.
+# One of: ALL, TIPC 1.5/1.6, TIPC 1.7
+# (case-insensitive).
+#tipc.handle_v2_as: ALL
+
+# Whether the TIPC-over-TCP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tipc.desegment: TRUE
+
+# Redirect TLS debug to the file specified. Leave empty to disable debugging or use "-" to redirect output to stderr.
+# A path to a file
+#tls.debug_file: 
+
+# Whether the TLS dissector should reassemble TLS records spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tls.desegment_ssl_records: TRUE
+
+# Whether the TLS dissector should reassemble TLS Application Data spanning multiple TLS records. 
+# TRUE or FALSE (case-insensitive)
+#tls.desegment_ssl_application_data: TRUE
+
+# For troubleshooting ignore the mac check result and decrypt also if the Message Authentication Code (MAC) fails.
+# TRUE or FALSE (case-insensitive)
+#tls.ignore_ssl_mac_failed: FALSE
+
+# Pre-Shared Key as HEX string. Should be 0 to 16 bytes.
+# A string
+#tls.psk: 
+
+# The name of a file which contains a list of 
+# (pre-)master secrets in one of the following formats:
+# 
+# RSA <EPMS> <PMS>
+# RSA Session-ID:<SSLID> Master-Key:<MS>
+# CLIENT_RANDOM <CRAND> <MS>
+# PMS_CLIENT_RANDOM <CRAND> <PMS>
+# 
+# Where:
+# <EPMS> = First 8 bytes of the Encrypted PMS
+# <PMS> = The Pre-Master-Secret (PMS) used to derive the MS
+# <SSLID> = The SSL Session ID
+# <MS> = The Master-Secret (MS)
+# <CRAND> = The Client's random number from the ClientHello message
+# 
+# (All fields are in hex notation)
+# A path to a file
+#tls.keylog_file: 
+
+# Whether the TNS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tns.desegment_tns_messages: TRUE
+
+# Whether Linux mangling of the link-layer header should be checked for and worked around
+# TRUE or FALSE (case-insensitive)
+#tr.fix_linux_botches: FALSE
+
+# Whether the TPKT dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tpkt.desegment: TRUE
+
+# TCP ports to be decoded as TPKT (default: 102)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#tpkt.tcp.ports: 102
+
+# Whether to load the Database or not; not loading the DB disables the protocol; Wireshark has to be restarted for the setting to take effect.
+# TRUE or FALSE (case-insensitive)
+#tpncp.load_db: FALSE
+
+# Position of the capture unit that produced this trace.  This setting affects the way TRANSUM handles TCP Retransmissions.  See the manual for details.
+# One of: Client, Intermediate, Service
+# (case-insensitive).
+#transum.capture_position: Client
+
+# Set this to match to the TCP subdissector reassembly setting
+# TRUE or FALSE (case-insensitive)
+#transum.reassembly: TRUE
+
+# Add and remove ports numbers separated by commas
+# Ranges are supported e.g. 25,80,2000-3000,5432
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#transum.tcp_port_ranges: 25,80,443,1433
+
+# Add and remove ports numbers separated by commas
+# Ranges are supported e.g. 123,137-139,520-521,2049
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#transum.udp_port_ranges: 137-139
+
+# Set this to discard any packet in the direction client to service,
+# with a 1-byte payload of 0x00 and the ACK flag set
+# TRUE or FALSE (case-insensitive)
+#transum.orphan_ka_discard: FALSE
+
+# RTE data will be added to the first request packet
+# TRUE or FALSE (case-insensitive)
+#transum.rte_on_first_req: FALSE
+
+# RTE data will be added to the last request packet
+# TRUE or FALSE (case-insensitive)
+#transum.rte_on_last_req: TRUE
+
+# RTE data will be added to the first response packet
+# TRUE or FALSE (case-insensitive)
+#transum.rte_on_first_rsp: FALSE
+
+# RTE data will be added to the last response packet
+# TRUE or FALSE (case-insensitive)
+#transum.rte_on_last_rsp: FALSE
+
+# Set this only to troubleshoot problems
+# TRUE or FALSE (case-insensitive)
+#transum.debug_enabled: FALSE
+
+# Critical Traffic Mask (base hex)
+# A hexadecimal number
+#tte.ct_mask_value: 0
+
+# Critical Traffic Marker (base hex)
+# A hexadecimal number
+#tte.ct_marker_value: 0xffffffff
+
+# Setup RTP/RTCP conversations when parsing Start/Record RTP messages
+# TRUE or FALSE (case-insensitive)
+#ua3g.setup_conversations: TRUE
+
+# NOE SIP Protocol
+# TRUE or FALSE (case-insensitive)
+#uasip.noesip: FALSE
+
+# IPv4 address of the proxy (Invalid values will be ignored)
+# A string
+#uasip.proxy_ipaddr: 
+
+# IPv4 (or IPv6) address of the call server. (Used only in case of identical source and destination ports)
+# A string
+#uaudp.system_ip: 
+
+# Whether the UCP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ucp.desegment_ucp_messages: TRUE
+
+# Whether the UDP summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#udp.summary_in_tree: TRUE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to a specific port
+# TRUE or FALSE (case-insensitive)
+#udp.try_heuristic_first: FALSE
+
+# Whether to validate the UDP checksum
+# TRUE or FALSE (case-insensitive)
+#udp.check_checksum: FALSE
+
+# Whether to ignore zero-value UDP checksums over IPv6
+# TRUE or FALSE (case-insensitive)
+#udp.ignore_ipv6_zero_checksum: FALSE
+
+# Collect process flow information from IPFIX
+# TRUE or FALSE (case-insensitive)
+#udp.process_info: FALSE
+
+# Calculate timestamps relative to the first frame and the previous frame in the udp conversation
+# TRUE or FALSE (case-insensitive)
+#udp.calculate_timestamps: TRUE
+
+# Ignore an invalid checksum coverage field and continue dissection
+# TRUE or FALSE (case-insensitive)
+#udplite.ignore_checksum_coverage: TRUE
+
+# Whether to validate the UDP-Lite checksum
+# TRUE or FALSE (case-insensitive)
+#udplite.check_checksum: FALSE
+
+# Calculate timestamps relative to the first frame and the previous frame in the udp-lite conversation
+# TRUE or FALSE (case-insensitive)
+#udplite.calculate_timestamps: TRUE
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#udpcp.attempt_reassembly: TRUE
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#udpcp.attempt_xml_decode: TRUE
+
+# Whether the ULP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ulp.desegment_ulp_messages: TRUE
+
+# Whether the UMA dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#uma.desegment_ucp_messages: TRUE
+
+# Try to decode a packet using a heuristic sub-dissector before attempting to dissect the packet using the "usb.bulk", "usb.interrupt" or "usb.control" dissector tables.
+# TRUE or FALSE (case-insensitive)
+#usb.try_heuristics: TRUE
+
+# Activate workaround for weird Ettus UHD header offset on data packets
+# TRUE or FALSE (case-insensitive)
+#vrt.ettus_uhd_header_format: FALSE
+
+# Whether the vlan summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#vlan.summary_in_tree: TRUE
+
+# The (hexadecimal) Ethertype used to indicate 802.1QinQ VLAN in VLAN tunneling.
+# A hexadecimal number
+#vlan.qinq_ethertype: 0x9100
+
+# IEEE 802.1Q specification version used (802.1Q-1998 uses 802.1D-2004 for PRI values)
+# One of: IEEE 802.1Q-1998, IEEE 802.1Q-2005, IEEE 802.1Q-2011
+# (case-insensitive).
+#vlan.version: IEEE 802.1Q-2011
+
+# Number of priorities supported, and number of those drop eligible (not used for 802.1Q-1998)
+# One of: 8 Priorities, 0 Drop Eligible, 7 Priorities, 1 Drop Eligible, 6 Priorities, 2 Drop Eligible, 5 Priorities, 3 Drop Eligible
+# (case-insensitive).
+#vlan.priority_drop: 8 Priorities, 0 Drop Eligible
+
+# Whether the VNC dissector should reassemble messages spanning multiple TCP segments.  To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#vnc.desegment: TRUE
+
+# Dynamic payload types which will be interpreted as vp8; Values must be in the range 1 - 127
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#vp8.dynamic.payload.type: 
+
+# There is some ambiguity on how to calculate V3 checksumsAs in V3 will use a pseudo header(which may only be implemented for IPv6 by some manufacturers)
+# TRUE or FALSE (case-insensitive)
+#vrrp.v3_checksum_as_in_v2: FALSE
+
+# Whether the VSS Monitoring dissector should attempt to dissect trailers with no timestamp, only port stamping.  Note that this can result in a large number of false positives.
+# TRUE or FALSE (case-insensitive)
+#vssmonitoring.dissect_portstamping_only: FALSE
+
+# Whether the VSS Monitoring dissector should assume that the port stamp is two bytes, instead of the standard one byte.
+# TRUE or FALSE (case-insensitive)
+#vssmonitoring.two_byte_portstamps: FALSE
+
+# Enable this preference if you want to view the WBXML tokens without the representation in a media type (e.g., WML). Tokens will show up as Tag_0x12, attrStart_0x08 or attrValue_0x0B for example.
+# TRUE or FALSE (case-insensitive)
+#wbxml.skip_wbxml_token_mapping: FALSE
+
+# Enable this preference if you want to skip the parsing of the WBXML tokens that constitute the body of the WBXML document. Only the WBXML header will be dissected (and visualized) then.
+# TRUE or FALSE (case-insensitive)
+#wbxml.disable_wbxml_token_parsing: FALSE
+
+# Select dissector for websocket text
+# One of: No subdissection, Line based text, As json, As SIP
+# (case-insensitive).
+#websocket.text_type: No subdissection
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#websocket.decompress: TRUE
+
+# The TCP port DPP over TCP uses
+# A decimal number
+#dpp.tcp.port: 7871
+
+# Set the maximum Basic CID used in the Wimax decoder (if other than the default of 320).  Note: The maximum Primary CID is double the maximum Basic CID.
+# A decimal number
+#wmx.basic_cid_max: 320
+
+# Set to TRUE to use the Corrigendum 2 version of Wimax message decoding. Set to FALSE to use the 802.16e-2005  version.
+# TRUE or FALSE (case-insensitive)
+#wmx.corrigendum_2_version: FALSE
+
+# Show transaction ID direction bit separately from the rest of the transaction ID field.
+# TRUE or FALSE (case-insensitive)
+#wimaxasncp.show_transaction_id_d_bit: FALSE
+
+# Print debug output to the console.
+# TRUE or FALSE (case-insensitive)
+#wimaxasncp.debug_enabled: FALSE
+
+# Version of the NWG that the R6 protocol complies with
+# One of: R1.0 v1.0.0, R1.0 v1.2.0, R1.0 v1.2.1
+# (case-insensitive).
+#wimaxasncp.nwg_version: R1.0 v1.2.1
+
+# Whether the WINS-Replication dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#winsrepl.reassemble: TRUE
+
+# Whether the IP dissector should dissect decrypted transport data.
+# TRUE or FALSE (case-insensitive)
+#wg.dissect_packet: TRUE
+
+# The path to the file which contains a list of secrets in the following format:
+# "<key-type> = <base64-encoded-key>" (without quotes, leading spaces and spaces around '=' are ignored).
+# <key-type> is one of: LOCAL_STATIC_PRIVATE_KEY, REMOTE_STATIC_PUBLIC_KEY, LOCAL_EPHEMERAL_PRIVATE_KEY or PRESHARED_KEY.
+# A path to a file
+#wg.keylog_file: 
+
+# Whether the wow dissector should reassemble messages spanning multiple TCP segments.  To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#wow.desegment: TRUE
+
+# If CALL REQUEST not seen or didn't specify protocol, dissect as QLLC/SNA
+# TRUE or FALSE (case-insensitive)
+#x25.payload_is_qllc_sna: FALSE
+
+# If CALL REQUEST has no data, assume the protocol handled is COTP
+# TRUE or FALSE (case-insensitive)
+#x25.call_request_nodata_is_cotp: FALSE
+
+# If CALL REQUEST not seen or didn't specify protocol, check user data before checking heuristic dissectors
+# TRUE or FALSE (case-insensitive)
+#x25.payload_check_data: FALSE
+
+# Reassemble fragmented X.25 packets
+# TRUE or FALSE (case-insensitive)
+#x25.reassemble: TRUE
+
+# Whether the X11 dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#x11.desegment: TRUE
+
+# Set the SCTP port for X2AP messages
+# A decimal number
+#x2ap.sctp.port: 36422
+
+# Select whether RRC Context should be dissected as legacy LTE or NB-IOT
+# One of: LTE, NB-IoT
+# (case-insensitive).
+#x2ap.dissect_rrc_context_as: LTE
+
+# Try to recognize XML encoded in Unicode (UCS-2BE)
+# TRUE or FALSE (case-insensitive)
+#xml.heuristic_unicode: FALSE
+
+# Whether the XMPP dissector should reassemble messages. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings
+# TRUE or FALSE (case-insensitive)
+#xmpp.desegment: TRUE
+
+# Set the SCTP port for XnAP messages
+# A decimal number
+#xnap.sctp.port: 38422
+
+# Select whether target NG-RAN container should be decoded automatically (based on Xn Setup procedure) or manually
+# One of: automatic, gNB, ng-eNB
+# (case-insensitive).
+#xnap.dissect_target_ng_ran_container_as: automatic
+
+# Select whether LTE RRC Context should be dissected as legacy LTE or NB-IOT
+# One of: LTE, NB-IoT
+# (case-insensitive).
+#xnap.dissect_lte_rrc_context_as: LTE
+
+# Whether the X.25-over-TCP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings
+# TRUE or FALSE (case-insensitive)
+#xot.desegment: TRUE
+
+# Whether the X.25-over-TCP dissector should reassemble all X.25 packets before calling the X25 dissector. If the TCP packets arrive out-of-order, the X.25 reassembly can otherwise fail. To use this option, you should also enable "Reassemble X.25-over-TCP messages spanning multiple TCP segments", "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings and "Reassemble fragmented X.25 packets" in the X.25 protocol settings.
+# TRUE or FALSE (case-insensitive)
+#xot.x25_desegment: FALSE
+
+# Whether the YAMI dissector should reassemble messages spanning multiple TCP segments.To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#yami.desegment: TRUE
+
+# Whether the YMSG dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ymsg.desegment: TRUE
+
+# Whether the Z39.50 dissector should reassemble TDS buffers spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#z3950.desegment_buffers: TRUE
+
+# Specifies the security level to use in the
+# decryption process. This value is ignored
+# for ZigBee 2004 and unsecured networks.
+# One of: No Security, No Encryption, 32-bit Integrity Protection, No Encryption, 64-bit Integrity Protection, No Encryption, 128-bit Integrity Protection, AES-128 Encryption, No Integrity Protection, AES-128 Encryption, 32-bit Integrity Protection, AES-128 Encryption, 64-bit Integrity Protection, AES-128 Encryption, 128-bit Integrity Protection
+# (case-insensitive).
+#zbee_nwk.seclevel: AES-128 Encryption, 32-bit Integrity Protection
+
+# Specifies the ZigBee Smart Energy version used when dissecting ZigBee APS messages within the Smart Energy Profile
+# One of: SE 1.1b, SE 1.2, SE 1.2a, SE 1.2b, SE 1.4
+# (case-insensitive).
+#zbee_aps.zbeeseversion: SE 1.4
+
+####### Statistics ########
+
+# Determines time between tap updates
+# A decimal number
+#statistics.update_interval: 3000
+
+# If enabled burst rates will be calculated for statistics that use the stats_tree system. Burst rates are calculated over a much shorter time interval than the rate column.
+# TRUE or FALSE (case-insensitive)
+#statistics.st_enable_burstinfo: TRUE
+
+# If selected the stats_tree statistics nodes will show the count of events within the burst window instead of a burst rate. Burst rate is calculated as number of events within burst window divided by the burst windown length.
+# TRUE or FALSE (case-insensitive)
+#statistics.st_burst_showcount: FALSE
+
+# Sets the duration of the time interval into which events are grouped when calculating the burst rate. Higher resolution (smaller number) increases processing overhead.
+# A decimal number
+#statistics.st_burst_resolution: 5
+
+# Sets the duration of the sliding window during which the burst rate is measured. Longer window relative to burst rate resolution increases processing overhead. Will be truncated to a multiple of burst resolution.
+# A decimal number
+#statistics.st_burst_windowlen: 100
+
+# Sets the default column by which stats based on the stats_tree system is sorted.
+# One of: Node name (topic/item), Item count, Average value of the node, Minimum value of the node, Maximum value of the node, Burst rate of the node
+# (case-insensitive).
+#statistics.st_sort_defcolflag: Item count
+
+# When selected, statistics based on the stats_tree system will by default be sorted in descending order.
+# TRUE or FALSE (case-insensitive)
+#statistics.st_sort_defdescending: TRUE
+
+# When selected, the item/node names of statistics based on the stats_tree system will be sorted taking case into account. Else the case of the name will be ignored.
+# TRUE or FALSE (case-insensitive)
+#statistics.st_sort_casesensitve: TRUE
+
+# When selected, the stats_tree nodes representing a range of values (0-49, 50-100, etc.) will always be sorted by name (the range of the node). Else range nodes are sorted by the same column as the rest of  the tree.
+# TRUE or FALSE (case-insensitive)
+#statistics.st_sort_rng_nameonly: TRUE
+
+# When selected, the stats_tree nodes representing a range of values (0-49, 50-100, etc.) will always be sorted ascending; else it follows the sort direction of the tree. Only effective if "Always sort 'range' nodes by name" is also selected.
+# TRUE or FALSE (case-insensitive)
+#statistics.st_sort_rng_fixorder: TRUE
+
+# When selected, the full name (including menu path) of the stats_tree plug-in is show in windows. If cleared the plug-in name is shown without menu path (only the part of the name after last '/' character.)
+# TRUE or FALSE (case-insensitive)
+#statistics.st_sort_showfullname: FALSE
diff --git a/resources/share/wireshark/profiles/Profile_nRF_Sniffer_Bluetooth_LE/recent b/resources/share/wireshark/profiles/Profile_nRF_Sniffer_Bluetooth_LE/recent
new file mode 100644
index 00000000000..035079a4ed3
--- /dev/null
+++ b/resources/share/wireshark/profiles/Profile_nRF_Sniffer_Bluetooth_LE/recent
@@ -0,0 +1,129 @@
+# Recent settings file for Wireshark 3.6.5.
+#
+# This file is regenerated each time Wireshark is quit
+# and when changing configuration profile.
+# So be careful, if you want to make manual changes here.
+
+
+# Main Toolbar show (hide).
+# TRUE or FALSE (case-insensitive).
+gui.toolbar_main_show: TRUE
+
+# Filter Toolbar show (hide).
+# TRUE or FALSE (case-insensitive).
+gui.filter_toolbar_show: TRUE
+
+# Wireless Settings Toolbar show (hide).
+# TRUE or FALSE (case-insensitive).
+gui.wireless_toolbar_show: FALSE
+
+# Packet list show (hide).
+# TRUE or FALSE (case-insensitive).
+gui.packet_list_show: TRUE
+
+# Tree view show (hide).
+# TRUE or FALSE (case-insensitive).
+gui.tree_view_show: TRUE
+
+# Byte view show (hide).
+# TRUE or FALSE (case-insensitive).
+gui.byte_view_show: TRUE
+
+# Packet diagram show (hide).
+# TRUE or FALSE (case-insensitive).
+gui.packet_diagram_show: TRUE
+
+# Statusbar show (hide).
+# TRUE or FALSE (case-insensitive).
+gui.statusbar_show: TRUE
+
+# Packet list colorize (hide).
+# TRUE or FALSE (case-insensitive).
+gui.packet_list_colorize: TRUE
+
+# Timestamp display format.
+# One of: RELATIVE, ABSOLUTE, ABSOLUTE_WITH_YMD, ABSOLUTE_WITH_YDOY, ABSOLUTE_WITH_DATE, DELTA, DELTA_DIS, EPOCH, UTC, UTC_WITH_YMD, UTC_WITH_YDOY, UTC_WITH_DATE
+gui.time_format: RELATIVE
+
+# Timestamp display precision.
+# One of: AUTO, SEC, DSEC, CSEC, MSEC, USEC, NSEC
+gui.time_precision: MSEC
+
+# Seconds display format.
+# One of: SECONDS, HOUR_MIN_SEC
+gui.seconds_format: SECONDS
+
+# Zoom level.
+# A decimal number.
+gui.zoom_level: 0
+
+# Bytes view display type.
+# One of: HEX, BITS
+gui.bytes_view: HEX
+
+# Bytes view text encoding.
+# One of: FROM_PACKET, ASCII, EBCDIC
+gui.bytes_encoding: FROM_PACKET
+
+# Packet diagram field values show (hide).
+# TRUE or FALSE (case-insensitive).
+gui.packet_diagram_field_values: FALSE
+
+# Allow hover selection in byte view.
+# TRUE or FALSE (case-insensitive).
+gui.allow_hover_selection: TRUE
+
+# Main window upper (or leftmost) pane size.
+# Decimal number.
+gui.geometry_main_upper_pane: 491
+
+# Main window middle pane size.
+# Decimal number.
+gui.geometry_main_lower_pane: 285
+
+# Packet list column pixel widths.
+# Each pair of strings consists of a column format and its pixel width.
+column.width:
+        %m, 69,
+        %t, 62,
+        %s, 159,
+        "%Cus:nordic_ble.phy", 0,
+        %p, 88,
+        "%Cus:btle.length", 0,
+        "%Cus:nordic_ble.delta_time", 213,
+        "%Cus:nordic_ble.channel", 99:C,
+        "%Cus:btle.data_header.sequence_number", 47,
+        "%Cus:btle.data_header.next_expected_sequence_number", 53,
+        "%Cus:btle.data_header.more_data", 84,
+        "%Cus:nordic_ble.event_counter", 102:C,
+        %i, 2407
+
+# Open conversation dialog tabs.
+# List of conversation names, e.g. "TCP", "IPv6".
+gui.conversation_tabs: 
+	"Ethernet", "IPv4",
+	"IPv6", "TCP",
+	"UDP"
+
+# Open endpoint dialog tabs.
+# List of endpoint names, e.g. "TCP", "IPv6".
+gui.endpoint_tabs: 
+	"Ethernet", "IPv4",
+	"IPv6", "TCP",
+	"UDP", "USB"
+
+# For RLC stats, whether to use RLC PDUs found inside MAC frames.
+# TRUE or FALSE (case-insensitive).
+gui.rlc_pdus_from_mac_frames: FALSE
+
+# Last directory navigated to in File Open dialog.
+gui.fileopen_remembered_dir: /home/matheus/github/wdissector/updates/telit/logs/
+
+# Additional Toolbars shown
+# List of additional toolbars to show.
+gui.additional_toolbar_show: 
+
+# Interface Toolbars show.
+# List of interface toolbars to show.
+gui.interface_toolbar_show: 
+	"nRF Sniffer for Bluetooth LE"
diff --git a/resources/share/wireshark/profiles/WDissector/80211_keys b/resources/share/wireshark/profiles/WDissector/80211_keys
new file mode 100644
index 00000000000..facc707fcc2
--- /dev/null
+++ b/resources/share/wireshark/profiles/WDissector/80211_keys
@@ -0,0 +1,2 @@
+# This file is automatically generated, DO NOT MODIFY.
+"wpa-pwd","testtest:TEST_KRA"
diff --git a/resources/share/wireshark/profiles/WDissector/colorfilters b/resources/share/wireshark/profiles/WDissector/colorfilters
new file mode 100644
index 00000000000..5dda7c62f78
--- /dev/null
+++ b/resources/share/wireshark/profiles/WDissector/colorfilters
@@ -0,0 +1,24 @@
+# DO NOT EDIT THIS FILE!  It was created by Wireshark
+@Duplicated Packet@frame.comment  contains "Duplicated"@[65535,65535,32639][0,0,0]
+@Fuzzed Packet@(frame.comment == "Fuzzed from previous") || (frame.comment == "Fuzzed ")@[51143,38807,65535][0,0,0]
+@Log Error@packetlogger.type == 0xfa@[42148,0,0][65535,64764,40092]
+@Bad TCP@tcp.analysis.flags && !tcp.analysis.window_update && !tcp.analysis.keep_alive && !tcp.analysis.keep_alive_ack@[4626,10023,11822][63479,34695,34695]
+@HSRP State Change@hsrp.state != 8 && hsrp.state != 16@[4626,10023,11822][65535,64764,40092]
+@Spanning Tree Topology  Change@stp.type == 0x80@[4626,10023,11822][65535,64764,40092]
+@OSPF State Change@ospf.msg != 1@[4626,10023,11822][65535,64764,40092]
+@ICMP errors@icmp.type eq 3 || icmp.type eq 4 || icmp.type eq 5 || icmp.type eq 11 || icmpv6.type eq 1 || icmpv6.type eq 2 || icmpv6.type eq 3 || icmpv6.type eq 4@[4626,10023,11822][47031,63479,29812]
+@ARP@arp@[64250,61680,55255][4626,10023,11822]
+@ICMP@icmp || icmpv6@[64764,57568,65535][4626,10023,11822]
+@TCP RST@tcp.flags.reset eq 1@[42148,0,0][65535,64764,40092]
+@SCTP ABORT@sctp.chunk_type eq ABORT@[42148,0,0][65535,64764,40092]
+@TTL low or unexpected@( ! ip.dst == 224.0.0.0/4 && ip.ttl < 5 && !pim && !ospf) || (ip.dst == 224.0.0.0/24 && ip.dst != 224.0.0.251 && ip.ttl != 1 && !(vrrp || carp))@[42148,0,0][60652,61680,60395]
+@Checksum Errors@eth.fcs.status=="Bad" || ip.checksum.status=="Bad" || tcp.checksum.status=="Bad" || udp.checksum.status=="Bad" || sctp.checksum.status=="Bad" || mstp.checksum.status=="Bad" || cdp.checksum.status=="Bad" || edp.checksum.status=="Bad" || wlan.fcs.status=="Bad" || stt.checksum.status=="Bad"@[4626,10023,11822][63479,34695,34695]
+@SMB@smb || nbss || nbns || netbios@[65278,65535,53456][4626,10023,11822]
+@HTTP@http || tcp.port == 80 || http2@[58596,65535,51143][4626,10023,11822]
+@DCERPC@dcerpc@[51143,38807,65535][4626,10023,11822]
+@Routing@hsrp || eigrp || ospf || bgp || cdp || vrrp || carp || gvrp || igmp || ismp@[65535,62451,54998][4626,10023,11822]
+@TCP SYN/FIN@tcp.flags & 0x02 || tcp.flags.fin == 1@[41120,41120,41120][4626,10023,11822]
+@TCP@tcp@[59367,59110,65535][4626,10023,11822]
+@UDP@udp@[56026,61166,65535][4626,10023,11822]
+@Broadcast@eth[0] & 1@[65535,65535,65535][47802,48573,46774]
+@System Event@systemd_journal || sysdig@[59110,59110,59110][11565,28527,39578]
diff --git a/resources/share/wireshark/profiles/WDissector/decode_as_entries b/resources/share/wireshark/profiles/WDissector/decode_as_entries
new file mode 100644
index 00000000000..237ce135c34
--- /dev/null
+++ b/resources/share/wireshark/profiles/WDissector/decode_as_entries
@@ -0,0 +1,23 @@
+# "Decode As" entries file for Wireshark 4.1.0.
+#
+# This file is regenerated each time "Decode As" preferences
+# are saved within Wireshark. Making manual changes should be safe,
+# however.
+decode_as_entry: btl2cap.cid,65,(none),BT SDP
+decode_as_entry: btl2cap.cid,66,(none),BT SDP
+decode_as_entry: btl2cap.cid,67,(none),BT SDP
+decode_as_entry: btl2cap.cid,68,(none),BT SDP
+decode_as_entry: btl2cap.cid,69,(none),BT SDP
+decode_as_entry: btl2cap.cid,70,(none),BT SDP
+decode_as_entry: btl2cap.cid,71,(none),BT SDP
+decode_as_entry: btl2cap.cid,72,(none),BT SDP
+decode_as_entry: btl2cap.cid,73,(none),BT SDP
+decode_as_entry: btl2cap.cid,74,(none),BT SDP
+decode_as_entry: btl2cap.cid,75,(none),BT SDP
+decode_as_entry: btl2cap.cid,76,(none),BT SDP
+decode_as_entry: btl2cap.cid,77,(none),BT SDP
+decode_as_entry: btl2cap.cid,78,(none),BT SDP
+decode_as_entry: btl2cap.cid,79,(none),BT SDP
+decode_as_entry: btl2cap.cid,80,(none),BT SDP
+decode_as_entry: btl2cap.cid,81,(none),BT SDP
+decode_as_entry: ethertype,34997,(none),IEEE1722
diff --git a/resources/share/wireshark/profiles/WDissector/dfilter_buttons b/resources/share/wireshark/profiles/WDissector/dfilter_buttons
new file mode 100644
index 00000000000..1bca6e370a0
--- /dev/null
+++ b/resources/share/wireshark/profiles/WDissector/dfilter_buttons
@@ -0,0 +1,5 @@
+# This file is automatically generated, DO NOT MODIFY.
+"FALSE","Clean 802.11","((!( wlan.fc.type == 0 && wlan.fc.subtype == 8) &&!(wlan.fc.type == 2 && wlan.fc.subtype == 12)) && !(wlan.fc.type_subtype == 0x0004)) && !(wlan.fc.type_subtype == 0x0005)",""
+"TRUE","Crashes","packetlogger.type == 0xfa",""
+"TRUE","Fuzzed","frame.comment contains \x22Fuzzed \x22",""
+"TRUE","Duplicated","frame.comment contains \x22Duplicated\x22",""
diff --git a/resources/share/wireshark/profiles/WDissector/disabled_protos b/resources/share/wireshark/profiles/WDissector/disabled_protos
new file mode 100644
index 00000000000..23da2481b00
--- /dev/null
+++ b/resources/share/wireshark/profiles/WDissector/disabled_protos
@@ -0,0 +1,3 @@
+prp
+stcsig
+transum
diff --git a/resources/share/wireshark/profiles/WDissector/drb_logchans b/resources/share/wireshark/profiles/WDissector/drb_logchans
new file mode 100644
index 00000000000..aab294658a1
--- /dev/null
+++ b/resources/share/wireshark/profiles/WDissector/drb_logchans
@@ -0,0 +1 @@
+# This file is automatically generated, DO NOT MODIFY.
diff --git a/resources/share/wireshark/profiles/WDissector/enabled_protos b/resources/share/wireshark/profiles/WDissector/enabled_protos
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/resources/share/wireshark/profiles/WDissector/heuristic_protos b/resources/share/wireshark/profiles/WDissector/heuristic_protos
new file mode 100644
index 00000000000..516f3a25497
--- /dev/null
+++ b/resources/share/wireshark/profiles/WDissector/heuristic_protos
@@ -0,0 +1,348 @@
+6lowpan_wlan,1
+a615a,1
+acn,0
+adwin_config_tcp,1
+adwin_config_udp,1
+aerohive_info_dhcp,1
+aeron_udp,0
+aim_tls,0
+alcatel_lucent_dhcp,1
+apple_bsdp_dhcp,1
+apple_bsdp_info_dhcp,1
+applemidi_udp,1
+ar_drone_udp,1
+artnet_udp,1
+aruba_ap_dhcp,1
+aruba_instant_ap_dhcp,1
+asphodel_inquiry,1
+at_usb_bulk,1
+at_usb_control,1
+atn-cm-ulcs,1
+atn-cpdlc-ulcs,1
+atn-ucls_cotp,1
+autosar_nm_can_heur,1
+bfcp_tcp,0
+bfcp_udp,0
+bitcoin_tcp,1
+bittorrent_dht_udp,0
+bittorrent_tcp,1
+blf_wtap,1
+bssap_sccp,1
+bssap_sua,1
+bt_utp_udp,0
+btsnoop_wtap,1
+cablelabs_dhcp,1
+caneth_udp,1
+carp_ip,1
+cattp_udp,0
+cco_cip,1
+ceph_tcp,1
+cigi_udp,1
+cimd_tcp,1
+cisco_info_dhcp,1
+classicstun_tcp,1
+classicstun_udp,1
+clique_rm_udp,1
+clses_cotp,1
+cltp_udp,1
+credssp_tls,1
+credssp_tpkt,1
+ctdb_tcp,1
+dcc_udp,1
+dcerpc_http,1
+dcerpc_netbios,1
+dcerpc_smb2,1
+dcerpc_smb_transact,1
+dcerpc_tcp,1
+dcerpc_udp,1
+dcp_etsi_udp,1
+dicom_tcp,1
+dnp3_tcp,0
+dnp3_udp,0
+dns_udp,1
+dplay_tcp,1
+dplay_udp,1
+drbd_tcp,1
+drda_tcp,1
+dtls_classicstun,0
+dtls_stun,0
+dtls_udp,1
+dvb_s2_udp,0
+e100_udp,1
+elf_wtap,1
+esl_eth,0
+etch_tcp,1
+eth_over_ib,1
+exablaze_eth,0
+f5ethtrailer,1
+f5fileinfo,1
+fb_zero,1
+fc_infiniband,1
+fcip_tcp,1
+fix_tcp,1
+fix_tls,1
+fmtp_tcp,1
+fortinet_sso,1
+fp_eth,1
+fp_fp_mux,1
+fp_mux_udp,0
+fp_udp,0
+gbcs_zbee_zcl_se.tun,1
+gelf_udp,0
+gif_http,1
+gif_wtap,1
+giop_tcp,1
+giop_udp,1
+gmhdr_eth,1
+gmtrailer_eth,1
+gquic,1
+gvsp_udp,0
+hdcp2_tcp,0
+hi3cclinkdata,1
+hi_cotp,1
+hi_cotp_is,1
+hi_tcp,1
+hipercontracer_icmp,1
+hipercontracer_icmpv6,1
+hislip_tcp,0
+hl7_tcp,1
+http2_tcp,1
+http2_tls,1
+http_tcp,1
+http_tls,1
+icep_tcp,1
+icep_udp,1
+ifcp_tcp,1
+interlink_udp,1
+ip_tipc,1
+ip_zbee_zcl_se.tun,1
+ipsec_tcp,1
+iscsi_tcp,1
+iser_ib_private,1
+iser_infiniband,1
+iwarp_mpa_tcp,1
+ixiatrailer_eth,1
+jfif_http,1
+jfif_wtap,1
+json_acdr,1
+json_db_lsp,1
+json_hpfeeds,1
+jxta_sctp,1
+jxta_tcp,1
+jxta_udp,1
+lanforge_tcp,1
+lanforge_udp,1
+lbmpdm_tcp,1
+lbmr_udp,1
+lbmsrs_tcp,1
+lbtrm_udp,1
+lbtru_udp,1
+lbttcp_tcp,1
+li5g_tls,1
+lnet_ib,1
+lnet_ib_cm_private,1
+lsd_udp,1
+lwm_wlan,1
+mac_lte_udp,1
+mac_nr_udp,1
+mbim_usb_bulk,1
+mcpe_raknet,1
+mellanox_eoib,1
+metamako_eth,0
+miop_udp,1
+mms_cotp,1
+mms_cotp_is,1
+mmse_wsp,1
+mndp_udp,0
+mojito_udp,1
+mp2t_udp,1
+mp2t_usb_bulk,1
+mpeg_audio,1
+mpeg_pes,1
+mq_http,1
+mq_netbios,1
+mq_tcp,1
+mq_tls,1
+mqpcf_mq,1
+ms_usb_bulk,1
+msrp_tcp,1
+nano-tcp,0
+nano-udp,0
+nas_eps_udp,1
+nbap_sctp,1
+nbd_tcp,1
+ndmp_tcp,1
+netperfmeter_dccp,1
+netperfmeter_tcp,1
+netperfmeter_udp,1
+njack_tcp,0
+njack_udp,1
+nsrpc,0
+nvme_rdma,1
+nvme_rdma_cm_private,1
+obd-ii_can_heur,0
+openflow_tcp,1
+opensafety_epl_data,1
+opensafety_pn_io,0
+opensafety_sercosiii,1
+openwire_tcp,1
+osc_udp,0
+ouch_soupbintcp,1
+packetcable_cm_dhcp,1
+packetcable_mta_dhcp,1
+paltalk_tcp,1
+pana_udp,1
+pathport_udp,1
+pcap_wtap,1
+pcapng_wtap,1
+pdcp_lte_udp,0
+pdcp_nr_udp,0
+peekremote_udp,1
+pktgen_udp,1
+pn_cba_pn_rt,1
+pn_csf_sdu_pn_rt,1
+pn_dcp_pn_rt,1
+pn_frag_pn_rt,1
+pn_io_pn_rt,1
+pn_mrrt_pn_rt,1
+pn_ptcp_pn_rt,1
+png_http,1
+png_wtap,1
+ppp_usb_bulk,0
+proxy_tcp,1
+proxy_udp,1
+pvfs_tcp,1
+pxeclient_dhcp,1
+q931_tcp,1
+quic,1
+raknet_udp,1
+ranap_sccp,1
+ranap_sua,1
+rdmnet_tcp,0
+rdmnet_udp,0
+rdp_cc,1
+rdp_cr,1
+rdp_fastpath,1
+rdpmt_dtls,1
+rdpmt_tls_,1
+redbackli_udp,1
+reload_framing_dtls,1
+reload_framing_tcp,1
+reload_framing_udp,1
+reload_tcp,1
+reload_udp,1
+rfc7468_wtap,1
+rftap,1
+rgoose_cltp,1
+rlc_lte_udp,0
+rlc_nr_udp,1
+rlc_udp,0
+rlm_udp,1
+rmt_norm_udp,0
+rnsap_sccp,1
+rpc_tcp,1
+rpc_udp,1
+rpcap_tcp,1
+rpcap_udp,1
+rpcrdma_infiniband,1
+rpcrdma_iwarp,1
+rtcp_stun,1
+rtcp_udp,1
+rtitcp,1
+rtmpt_tcp,0
+rtp_classicstun,0
+rtp_rtsp,0
+rtp_stun,0
+rtp_udp,0
+rtps_rtitcp,1
+rtps_tcp,1
+rtps_udp,1
+s7comm_cotp,1
+s7comm_cotp_is,1
+s_validator_cip,1
+sdp_ib_private,1
+sdp_infiniband,1
+ses_cotp,1
+ses_cotp_is,1
+signal_pdu_can_heur,1
+signal_pdu_flexray_heur,1
+sip_sctp,1
+sip_stun,1
+sip_tcp,1
+sip_udp,1
+skype_udp,0
+smb1_wsp,1
+smb2_netbios,1
+smb2_smb_direct,1
+smb2_wsp,1
+smb_cotp,1
+smb_direct_infiniband,1
+smb_direct_iwarp,1
+smb_netbios,1
+smb_smb_direct,1
+smb_vines,1
+smc_tcp,1
+smcr_infiniband,1
+smpp_tcp,1
+smpp_x25,1
+someip_tcp_heur,0
+someip_udp_heur,0
+sparkplugb_mqtt,1
+spdy_tcp,0
+spice_tcp,1
+sprt_udp,1
+srt_udp,1
+starteam_tcp,1
+stt_ip,1
+stun_classicstun,0
+stun_tcp,1
+stun_turn,0
+stun_udp,1
+t124_t125,1
+t125_cotp,1
+t125_cotp_is,1
+t38_acdr,1
+tali_tcp,1
+tapa_ip,1
+tcpros_tcp,0
+tds_tcp,1
+teredo_udp,0
+tfp_usb_bulk,1
+tftp,1
+tftp_stun,1
+thread_wlan_beacon,1
+thrift_tcp,1
+thrift_udp,1
+thrift_usb_bulk,1
+tiff_wtap,1
+tls_tcp,1
+tte_eth,1
+turnchannel_stun,1
+tuxedo_tcp,1
+u3v,1
+ucp_tcp,1
+udt_dtls,1
+udt_udp,1
+usb_bulk_isi,0
+vnc_tcp,1
+vssmonitoring_eth,1
+wassp_udp,0
+waveagent_udp,1
+websocket_tcp,0
+wg,1
+wol_udp,1
+xcsl_tcp,1
+xmcp_tcp,1
+xml_http,0
+xml_media,0
+xml_sip,0
+xml_tcp,0
+xml_udp,0
+xml_wtap,1
+yhoo_tcp,1
+ymsg_tcp,1
+zbee_nwk_gp_wlan,1
+zbee_nwk_wpan,1
+zbee_wpan_beacon,1
+zbip_wpan_beacon,1
+ziop_tcp,1
diff --git a/resources/share/wireshark/profiles/WDissector/io_graphs b/resources/share/wireshark/profiles/WDissector/io_graphs
new file mode 100644
index 00000000000..9358ee51655
--- /dev/null
+++ b/resources/share/wireshark/profiles/WDissector/io_graphs
@@ -0,0 +1,3 @@
+# This file is automatically generated, DO NOT MODIFY.
+"Enabled","All packets","","#2E3436","Line","Packets","","None"
+"Enabled","TCP errors","tcp.analysis.flags","#204A87","Bar","Packets","","None"
diff --git a/resources/share/wireshark/profiles/WDissector/pdcp_lte_ue_keys b/resources/share/wireshark/profiles/WDissector/pdcp_lte_ue_keys
new file mode 100644
index 00000000000..aab294658a1
--- /dev/null
+++ b/resources/share/wireshark/profiles/WDissector/pdcp_lte_ue_keys
@@ -0,0 +1 @@
+# This file is automatically generated, DO NOT MODIFY.
diff --git a/resources/share/wireshark/profiles/WDissector/preferences b/resources/share/wireshark/profiles/WDissector/preferences
new file mode 100644
index 00000000000..dfc74f4480e
--- /dev/null
+++ b/resources/share/wireshark/profiles/WDissector/preferences
@@ -0,0 +1,5555 @@
+# Configuration file for Wireshark 4.1.0.
+#
+# This file is regenerated each time preferences are saved within
+# Wireshark. Making manual changes should be safe, however.
+# Preferences that have been commented out have not been
+# changed from their default value.
+
+####### User Interface ########
+
+# Open a console window (Windows only)
+# One of: NEVER, AUTOMATIC, ALWAYS
+# (case-insensitive).
+gui.console_open: ALWAYS
+
+# Restore current display filter after following a stream?
+# TRUE or FALSE (case-insensitive)
+#gui.restore_filter_after_following_stream: FALSE
+
+# Where to start the File Open dialog box
+# One of: LAST_OPENED, SPECIFIED
+# (case-insensitive).
+#gui.fileopen.style: LAST_OPENED
+
+# The max. number of items in the open recent files list
+# A decimal number
+#gui.recent_files_count.max: 10
+
+# The max. number of entries in the display filter list
+# A decimal number
+#gui.recent_display_filter_entries.max: 10
+
+# Directory to start in when opening File Open dialog.
+# A path to a directory
+#gui.fileopen.dir: 
+
+# The preview timeout in the File Open dialog
+# A decimal number
+#gui.fileopen.preview: 3
+
+# Ask to save unsaved capture files?
+# TRUE or FALSE (case-insensitive)
+#gui.ask_unsaved: TRUE
+
+# Display an autocomplete suggestion for display and capture filter controls
+# TRUE or FALSE (case-insensitive)
+#gui.autocomplete_filter: TRUE
+
+# Wrap to beginning/end of file during search?
+# TRUE or FALSE (case-insensitive)
+#gui.find_wrap: TRUE
+
+# Save window position at exit?
+# TRUE or FALSE (case-insensitive)
+#gui.geometry.save.position: TRUE
+
+# Save window size at exit?
+# TRUE or FALSE (case-insensitive)
+#gui.geometry.save.size: TRUE
+
+# Save window maximized state at exit?
+# TRUE or FALSE (case-insensitive)
+#gui.geometry.save.maximized: TRUE
+
+# Main Toolbar style
+# One of: ICONS, TEXT, BOTH
+# (case-insensitive).
+#gui.toolbar_main_style: ICONS
+
+# Check for updates (Windows and macOS only)
+# TRUE or FALSE (case-insensitive)
+#gui.update.enabled: TRUE
+
+# The type of update to fetch. You should probably leave this set to STABLE.
+# One of: DEVELOPMENT, STABLE
+# (case-insensitive).
+#gui.update.channel: STABLE
+
+# How often to check for software updates in seconds
+# A decimal number
+#gui.update.interval: 86400
+
+# Custom window title to be appended to the existing title
+# %F = file path of the capture file
+# %P = profile name
+# %S = a conditional separator (" - ") that only shows when surrounded by variables with values or static text
+# %V = version info
+# A string
+#gui.window_title: 
+
+# Custom window title to be prepended to the existing title
+# %F = file path of the capture file
+# %P = profile name
+# %S = a conditional separator (" - ") that only shows when surrounded by variables with values or static text
+# %V = version info
+# A string
+#gui.prepend_window_title: 
+
+# Custom start page title
+# A string
+#gui.start_title: The World's Most Popular Network Protocol Analyzer
+
+# Show version in the start page and/or main screen's title bar
+# One of: WELCOME, TITLE, BOTH, NEITHER
+# (case-insensitive).
+#gui.version_placement: BOTH
+
+# The maximum number of objects that can be exported
+# A decimal number
+#gui.max_export_objects: 1000
+
+# The maximum number of items that can be added to the dissection tree (Increase with caution)
+# A decimal number
+#gui.max_tree_items: 1000000
+
+# The maximum depth of the dissection tree (Increase with caution)
+# A decimal number
+#gui.max_tree_depth: 500
+
+# The position of "..." in packet list text.
+# One of: LEFT, RIGHT, MIDDLE, NONE
+# (case-insensitive).
+#gui.packet_list_elide_mode: RIGHT
+
+# Sets the count of decimal places for values of type 1.Type 1 values are defined by authors.Value can be in range 2 to 10.
+# A decimal number
+#gui.decimal_places1: 2
+
+# Sets the count of decimal places for values of type 2.Type 2 values are defined by authors.Value can be in range 2 to 10.
+# A decimal number
+#gui.decimal_places2: 4
+
+# Sets the count of decimal places for values of type 3.Type 3 values are defined by authors.Value can be in range 2 to 10.
+# A decimal number
+#gui.decimal_places3: 6
+
+# If set to true, RTP Player saves temporary data to temp files on disk. If not set, it uses memory.Every stream uses one file therefore you might touch OS limit for count of opened files.When ui.rtp_player_use_disk2 is set to true too, it uses  two files per RTP stream together.
+# TRUE or FALSE (case-insensitive)
+#gui.rtp_player_use_disk1: FALSE
+
+# If set to true, RTP Player saves temporary dictionary to temp files on disk. If not set, it uses memory.Every stream uses one file therefore you might touch OS limit for count of opened files.When ui.rtp_player_use_disk1 is set to true too, it uses  two files per RTP stream.
+# TRUE or FALSE (case-insensitive)
+#gui.rtp_player_use_disk2: FALSE
+
+# To prevent sorting by mistake (which can take some time to calculate), it can be disabled
+# TRUE or FALSE (case-insensitive)
+#gui.packet_list_is_sortable: TRUE
+
+# Show all interfaces, including interfaces marked as hidden
+# TRUE or FALSE (case-insensitive)
+#gui.interfaces_show_hidden: FALSE
+
+# Show remote interfaces in the interface selection
+# TRUE or FALSE (case-insensitive)
+#gui.interfaces_remote_display: TRUE
+
+# Hide the given interface types in the startup list.
+# A comma-separated string of interface type values (e.g. 5,9).
+# 0 = Wired,
+# 1 = AirPCAP,
+# 2 = Pipe,
+# 3 = STDIN,
+# 4 = Bluetooth,
+# 5 = Wireless,
+# 6 = Dial-Up,
+# 7 = USB,
+# 8 = External Capture,
+# 9 = Virtual
+# A string
+#gui.interfaces_hidden_types: 
+
+# Enables automatic updates for IO Graph
+# TRUE or FALSE (case-insensitive)
+#gui.io_graph_automatic_update: TRUE
+
+# Show the byte view in the packet details dialog
+# TRUE or FALSE (case-insensitive)
+#gui.show_byteview_in_dialog: TRUE
+
+####### User Interface: Colors ########
+
+# Foreground color for an active selected item
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.active_frame.fg: 000000
+
+# Background color for an active selected item
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.active_frame.bg: cbe8ff
+
+# Color style for an active selected item
+# One of: DEFAULT, FLAT, GRADIENT
+# (case-insensitive).
+#gui.active_frame.style: DEFAULT
+
+# Foreground color for an inactive selected item
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.inactive_frame.fg: 000000
+
+# Background color for an inactive selected item
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.inactive_frame.bg: efefef
+
+# Color style for an inactive selected item
+# One of: DEFAULT, FLAT, GRADIENT
+# (case-insensitive).
+#gui.inactive_frame.style: DEFAULT
+
+# Color preferences for a marked frame
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.marked_frame.fg: ffffff
+
+# Color preferences for a marked frame
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.marked_frame.bg: 00202a
+
+# Color preferences for a ignored frame
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.ignored_frame.fg: 7f7f7f
+
+# Color preferences for a ignored frame
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.ignored_frame.bg: ffffff
+
+# TCP stream window color preference
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.stream.client.fg: 7f0000
+
+# TCP stream window color preference
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.stream.client.bg: fbeded
+
+# TCP stream window color preference
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.stream.server.fg: 00007f
+
+# TCP stream window color preference
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.stream.server.bg: ededfb
+
+# Valid color filter background
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.color_filter_bg.valid: afffaf
+
+# Invalid color filter background
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.color_filter_bg.invalid: ffafaf
+
+# Deprecated color filter background
+# A six-digit hexadecimal RGB color triplet (e.g. fce94f)
+#gui.color_filter_bg.deprecated: ffffaf
+
+####### User Interface: Columns ########
+
+# Packet list hidden columns
+# List all columns to hide in the packet list.
+gui.column.hidden: %t,%Cus:frame.time:0:R,%Cus:frame.time_delta:0:R,%s,%d,%Cus:frame.interface_id:0:R,%Cus:sll.pkttype:0:R,%Cus:btbbd.clk:0:R,%Cus:pdcp-nr.direction:0:R,%L,%Cus:btbbd.role:0:R,%Cus:btbbd.ptt:0:R,%Cus:btbbd.txenc:0:R,%Cus:btbbd.rxenc:0:R,%Cus:rlc-nr.direction:0:R,%Cus:tcp.dstport:0:R,%Cus:frame.comment:0:R,%Cus:can.flags.err:0:R,%Cus:tecmp.payload:0:R
+
+# Packet list column format
+# Each pair of strings consists of a column title and its format
+gui.column.format: 
+	"No.", "%m",
+	"Time", "%t",
+	"Arrival Time", "%Cus:frame.time:0:R",
+	"Time delta from previous captured frame", "%Cus:frame.time_delta:0:R",
+	"Source", "%s",
+	"Destination", "%d",
+	"Interface id", "%Cus:frame.interface_id:0:R",
+	"Packet type", "%Cus:sll.pkttype:0:R",
+	"CLK", "%Cus:btbbd.clk:0:R",
+	"Direction", "%Cus:pdcp-nr.direction:0:R",
+	"Protocol", "%p",
+	"Length", "%L",
+	"Role", "%Cus:btbbd.role:0:R",
+	"Table Type", "%Cus:btbbd.ptt:0:R",
+	"TX Enc.", "%Cus:btbbd.txenc:0:R",
+	"RX Enc.", "%Cus:btbbd.rxenc:0:R",
+	"Direction", "%Cus:rlc-nr.direction:0:R",
+	"Destination Port", "%Cus:tcp.dstport:0:R",
+	"Direction", "%Cus:mac-nr.direction:0:R",
+	"Info", "%i",
+	"Comment", "%Cus:frame.comment:0:R",
+	"Error Message Flag", "%Cus:can.flags.err:0:R",
+	"Technically Enhanced Capture Module Protocol Payload", "%Cus:tecmp.payload:0:R"
+
+####### User Interface: Font ########
+
+# Font name for packet list, protocol tree, and hex dump panes. (Qt)
+# A string
+gui.qt.font_name: Liberation Mono,9,-1,5,50,0,0,0,0,0
+
+####### User Interface: Layout ########
+
+# Layout type (1-6)
+# A decimal number
+#gui.layout_type: 2
+
+# Layout content of the pane 1
+# One of: NONE, PLIST, PDETAILS, PBYTES, PDIAGRAM
+# (case-insensitive).
+#gui.layout_content_1: PLIST
+
+# Layout content of the pane 2
+# One of: NONE, PLIST, PDETAILS, PBYTES, PDIAGRAM
+# (case-insensitive).
+#gui.layout_content_2: PDETAILS
+
+# Layout content of the pane 3
+# One of: NONE, PLIST, PDETAILS, PBYTES, PDIAGRAM
+# (case-insensitive).
+#gui.layout_content_3: PBYTES
+
+# Enable Packet List Separator
+# TRUE or FALSE (case-insensitive)
+#gui.packet_list_separator.enabled: FALSE
+
+# Show column definition in packet list header
+# TRUE or FALSE (case-insensitive)
+#gui.packet_header_column_definition.enabled: TRUE
+
+# Enable Packet List mouse-over colorization
+# TRUE or FALSE (case-insensitive)
+#gui.packet_list_hover_style.enabled: TRUE
+
+# Show selected packet in the Status Bar
+# TRUE or FALSE (case-insensitive)
+#gui.show_selected_packet.enabled: FALSE
+
+# Show file load time in the Status Bar
+# TRUE or FALSE (case-insensitive)
+#gui.show_file_load_time.enabled: FALSE
+
+# Show related packet indicators in the first column
+# TRUE or FALSE (case-insensitive)
+#gui.packet_list_show_related: TRUE
+
+# Show the intelligent scroll bar (a minimap of packet list colors in the scrollbar)
+# TRUE or FALSE (case-insensitive)
+#gui.packet_list_show_minimap: TRUE
+
+####### Capture ########
+
+# Default capture device
+# A string
+#capture.device: 
+
+# Interface link-layer header types (Ex: en0(1),en1(143),...)
+# A string
+capture.devices_linktypes: eth0(1),wlan0(1),vmnet1(1),any(113),lo(1),ogstun(12),docker0(1),bluetooth0(201),nflog(239),nfqueue(228),ciscodump(147),dpauxmon(275),randpkt(147),sdjournal(147),sshdump(147),udpdump(252)
+
+# Interface descriptions (Ex: eth0(eth0 descr),eth1(eth1 descr),...)
+# A string
+#capture.devices_descr: 
+
+# Hide interface? (Ex: eth0,eth3,...)
+# A string
+#capture.devices_hide: 
+
+# By default, capture in monitor mode on interface? (Ex: eth0,eth3,...)
+# A string
+#capture.devices_monitor_mode: 
+
+# Interface buffer size (Ex: en0(1),en1(143),...)
+# A string
+capture.devices_buffersize: eth0(2),wlan0(2),vmnet1(2),any(2),lo(2),ogstun(2),docker0(2),bluetooth0(2),nflog(2),nfqueue(2),usbmon1(2),usbmon2(2),usbmon3(2),usbmon4(2),usbmon5(2),usbmon6(2),ciscodump(2),dpauxmon(2),randpkt(2),sdjournal(2),sshdump(2),udpdump(2)
+
+# Interface snap length (Ex: en0(65535),en1(1430),...)
+# A string
+capture.devices_snaplen: eth0:0(262144),wlan0:0(262144),vmnet1:0(262144),any:0(262144),lo:0(262144),ogstun:0(262144),docker0:0(262144),bluetooth0:0(262144),nflog:0(262144),nfqueue:0(262144),usbmon1:0(262144),usbmon2:0(262144),usbmon3:0(262144),usbmon4:0(262144),usbmon5:0(262144),usbmon6:0(262144),ciscodump:0(262144),dpauxmon:0(262144),randpkt:0(262144),sdjournal:0(262144),sshdump:0(262144),udpdump:0(262144)
+
+# Interface promiscuous mode (Ex: en0(0),en1(1),...)
+# A string
+capture.devices_pmode: eth0(1),wlan0(1),vmnet1(1),any(1),lo(1),ogstun(1),docker0(1),bluetooth0(1),nflog(1),nfqueue(1),usbmon1(1),usbmon2(1),usbmon3(1),usbmon4(1),usbmon5(1),usbmon6(1),ciscodump(1),dpauxmon(1),randpkt(1),sdjournal(1),sshdump(1),udpdump(1)
+
+# Capture in promiscuous mode?
+# TRUE or FALSE (case-insensitive)
+#capture.prom_mode: TRUE
+
+# Interface capture filter (Ex: en0(tcp),en1(udp),...)
+# A string
+#capture.devices_filter: 
+
+# Capture in pcapng format?
+# TRUE or FALSE (case-insensitive)
+#capture.pcap_ng: TRUE
+
+# Update packet list in real time during capture?
+# TRUE or FALSE (case-insensitive)
+#capture.real_time_update: TRUE
+
+# Don't automatically load capture interfaces on startup
+# TRUE or FALSE (case-insensitive)
+#capture.no_interface_load: FALSE
+
+# Disable external capture modules (extcap)
+# TRUE or FALSE (case-insensitive)
+#capture.no_extcap: FALSE
+
+# Scroll packet list during capture?
+# TRUE or FALSE (case-insensitive)
+#capture.auto_scroll: TRUE
+
+# Show capture information dialog while capturing?
+# TRUE or FALSE (case-insensitive)
+#capture.show_info: FALSE
+
+# Column list
+# List of columns to be displayed in the capture options dialog.
+# Possible values: INTERFACE, LINK, PMODE, SNAPLEN, BUFFER, FILTER
+# 
+#capture.columns: 
+#	"INTERFACE", "LINK",
+#	"PMODE", "SNAPLEN",
+#	"BUFFER", "FILTER"
+
+####### Console ########
+
+# Look for dissectors that left some bytes undecoded (debug)
+# TRUE or FALSE (case-insensitive)
+console.incomplete_dissectors_check_debug: TRUE
+
+####### Extcap Utilities ########
+
+# Save arguments on start of capture
+# TRUE or FALSE (case-insensitive)
+#extcap.gui_save_on_start: TRUE
+
+####### Name Resolution ########
+
+# Resolve Ethernet MAC addresses to host names from the preferences or system's Ethers file, or to a manufacturer based name.
+# TRUE or FALSE (case-insensitive)
+#nameres.mac_name: TRUE
+
+# Resolve TCP/UDP ports into service names
+# TRUE or FALSE (case-insensitive)
+#nameres.transport_name: FALSE
+
+# Resolve IPv4, IPv6, and IPX addresses into host names. The next set of check boxes determines how name resolution should be performed. If no other options are checked name resolution is made from Wireshark's host file and capture file name resolution blocks.
+# TRUE or FALSE (case-insensitive)
+#nameres.network_name: FALSE
+
+# Use address/name pairs found in captured DNS packets for name resolution.
+# TRUE or FALSE (case-insensitive)
+#nameres.dns_pkt_addr_resolution: TRUE
+
+# Use your system's configured name resolver (usually DNS) to resolve network names. Only applies when network name resolution is enabled.
+# TRUE or FALSE (case-insensitive)
+#nameres.use_external_name_resolver: TRUE
+
+# Use a DNS Servers list to resolve network names if TRUE.  If FALSE, default information is used
+# TRUE or FALSE (case-insensitive)
+#nameres.use_custom_dns_servers: FALSE
+
+# The maximum number of DNS requests that may be active at any time. A large value (many thousands) might overload the network or make your DNS server behave badly.
+# A decimal number
+#nameres.name_resolve_concurrency: 500
+
+# By default "hosts" files will be loaded from multiple sources. Checking this box only loads the "hosts" in the current profile.
+# TRUE or FALSE (case-insensitive)
+#nameres.hosts_file_handling: FALSE
+
+# Resolve VLAN IDs to network names from the preferences "vlans" file. Format of the file is: "ID<Tab>Name". One line per VLAN, e.g.: 1 Management
+# TRUE or FALSE (case-insensitive)
+#nameres.vlan_name: FALSE
+
+# Resolve SS7 Point Codes to node names from the profiles "ss7pcs" file. Format of the file is: "Network_Indicator<Dash>PC_Decimal<Tab>Name". One line per Point Code, e.g.: 2-1234 MyPointCode1
+# TRUE or FALSE (case-insensitive)
+#nameres.ss7_pc_name: FALSE
+
+# Resolve Object IDs to object names from the MIB and PIB modules defined below. You must restart Wireshark for this change to take effect
+# TRUE or FALSE (case-insensitive)
+#nameres.load_smi_modules: FALSE
+
+# While loading MIB or PIB modules errors may be detected, which are reported. Some errors can be ignored. If unsure, set to false.
+# TRUE or FALSE (case-insensitive)
+#nameres.suppress_smi_errors: FALSE
+
+####### Protocols ########
+
+# Display all hidden protocol items in the packet list.
+# TRUE or FALSE (case-insensitive)
+#protocols.display_hidden_proto_items: FALSE
+
+# Display all byte fields with a space character between each byte in the packet list.
+# TRUE or FALSE (case-insensitive)
+protocols.display_byte_fields_with_spaces: TRUE
+
+# Look for dissectors that left some bytes undecoded.
+# TRUE or FALSE (case-insensitive)
+#protocols.enable_incomplete_dissectors_check: FALSE
+
+# Protocols may use things like VLAN ID or interface ID to narrow the potential for duplicate conversations. Currently ICMP and ICMPv6 use this preference to add VLAN ID to conversation tracking, and IPv4 uses this preference to take VLAN ID into account during reassembly
+# TRUE or FALSE (case-insensitive)
+#protocols.strict_conversation_tracking_heuristics: FALSE
+
+# Use a registered heuristic sub-dissector to decode the data payload
+# TRUE or FALSE (case-insensitive)
+#lbmc.use_heuristic_subdissectors: TRUE
+
+# Reassemble data message fragments
+# TRUE or FALSE (case-insensitive)
+#lbmc.reassemble_fragments: FALSE
+
+# Recognize and dissect payloads containing LBMPDM messages (requires reassembly to be enabled)
+# TRUE or FALSE (case-insensitive)
+#lbmc.dissect_lbmpdm: FALSE
+
+# Set the low end of the TCP port range
+# A decimal number
+#lbmpdm_tcp.port_low: 14371
+
+# Set the high end of the port range
+# A decimal number
+#lbmpdm_tcp.port_high: 14390
+
+# Use table of LBMPDM-TCP tags to decode the packet instead of above values
+# TRUE or FALSE (case-insensitive)
+#lbmpdm_tcp.use_lbmpdm_tcp_domain: FALSE
+
+# Set the UDP port for incoming multicast topic resolution (context resolver_multicast_incoming_port)
+# A decimal number
+#lbmr.mc_incoming_port: 12965
+
+# Set the multicast address for incoming multicast topic resolution (context resolver_multicast_incoming_address)
+# A string
+#lbmr.mc_incoming_address: 224.9.10.11
+
+# Set the UDP port for outgoing multicast topic resolution (context resolver_multicast_outgoing_port)
+# A decimal number
+#lbmr.mc_outgoing_port: 12965
+
+# Set the multicast address for outgoing multicast topic resolution (context resolver_multicast_outgoing_address)
+# A string
+#lbmr.mc_outgoing_address: 224.9.10.11
+
+# Set the low UDP port for unicast topic resolution (context resolver_unicast_port_low)
+# A decimal number
+#lbmr.uc_port_low: 14402
+
+# Set the high UDP port for unicast topic resolution (context resolver_unicast_port_high)
+# A decimal number
+#lbmr.uc_port_high: 14406
+
+# Set the destination port for unicast topic resolution (context resolver_unicast_destination_port)
+# A decimal number
+#lbmr.uc_dest_port: 15380
+
+# Set the address of the unicast resolver daemon (context resolver_unicast_address)
+# A string
+#lbmr.uc_address: 0.0.0.0
+
+# Use table of LBMR tags to decode the packet instead of above values
+# TRUE or FALSE (case-insensitive)
+#lbmr.use_lbmr_domain: FALSE
+
+# Set the LBMSRS IP Address
+# A string
+#lbmsrs.source_ip_address: 127.0.0.1
+
+# Set the source TCP port
+# A decimal number
+#lbmsrs.source_port: 0
+
+# Use table of LBMSRS tags to decode the packet instead of above values
+# TRUE or FALSE (case-insensitive)
+#lbmsrs.use_lbmsrs_domain: FALSE
+
+# Set the low end of the LBT-RM multicast address range (context transport_lbtrm_multicast_address_low)
+# A string
+#lbtrm.mc_address_low: 224.10.10.10
+
+# Set the high end of the LBT-RM multicast address range (context transport_lbtrm_multicast_address_high)
+# A string
+#lbtrm.mc_address_high: 224.10.10.14
+
+# Set the low end of the LBT-RM UDP destination port range (source transport_lbtrm_destination_port)
+# A decimal number
+#lbtrm.dport_low: 14400
+
+# Set the high end of the LBT-RM UDP destination port range (source transport_lbtrm_destination_port)
+# A decimal number
+#lbtrm.dport_high: 14400
+
+# Set the low end of the LBT-RM UDP source port range (context transport_lbtrm_source_port_low)
+# A decimal number
+#lbtrm.sport_low: 14390
+
+# Set the high end of the LBT-RM UDP source port range (context transport_lbtrm_source_port_high)
+# A decimal number
+#lbtrm.sport_high: 14399
+
+# Set the incoming MIM multicast address (context mim_incoming_address)
+# A string
+#lbtrm.mim_incoming_address: 224.10.10.21
+
+# Set the outgoing MIM multicast address (context mim_outgoing_address)
+# A string
+#lbtrm.mim_outgoing_address: 224.10.10.21
+
+# Set the incoming MIM UDP port (context mim_incoming_destination_port)
+# A decimal number
+#lbtrm.mim_incoming_dport: 14401
+
+# Set the outgoing MIM UDP port (context mim_outgoing_destination_port)
+# A decimal number
+#lbtrm.mim_outgoing_dport: 14401
+
+# Separate multiple NAKs from a single packet into distinct Expert Info entries
+# TRUE or FALSE (case-insensitive)
+#lbtrm.expert_separate_naks: FALSE
+
+# Separate multiple NCFs from a single packet into distinct Expert Info entries
+# TRUE or FALSE (case-insensitive)
+#lbtrm.expert_separate_ncfs: FALSE
+
+# Perform analysis on LBT-RM sequence numbers to determine out-of-order, gaps, loss, etc
+# TRUE or FALSE (case-insensitive)
+#lbtrm.sequence_analysis: FALSE
+
+# Use table of LBT-RM tags to decode the packet instead of above values
+# TRUE or FALSE (case-insensitive)
+#lbtrm.use_lbtrm_domain: FALSE
+
+# Set the low end of the LBT-RU source UDP port range (context transport_lbtru_port_low)
+# A decimal number
+#lbtru.source_port_low: 14380
+
+# Set the high end of the LBT-RU source UDP port range (context transport_lbtru_port_high)
+# A decimal number
+#lbtru.source_port_high: 14389
+
+# Set the low end of the LBT-RU receiver UDP port range (receiver transport_lbtru_port_low)
+# A decimal number
+#lbtru.receiver_port_low: 14360
+
+# Set the high end of the LBT-RU receiver UDP port range (receiver transport_lbtru_port_high)
+# A decimal number
+#lbtru.receiver_port_high: 14379
+
+# Separate multiple NAKs from a single packet into distinct Expert Info entries
+# TRUE or FALSE (case-insensitive)
+#lbtru.expert_separate_naks: FALSE
+
+# Separate multiple NCFs from a single packet into distinct Expert Info entries
+# TRUE or FALSE (case-insensitive)
+#lbtru.expert_separate_ncfs: FALSE
+
+# Perform analysis on LBT-RU sequence numbers to determine out-of-order, gaps, loss, etc
+# TRUE or FALSE (case-insensitive)
+#lbtru.sequence_analysis: FALSE
+
+# Use table of LBT-RU tags to decode the packet instead of above values
+# TRUE or FALSE (case-insensitive)
+#lbtru.use_lbtru_domain: FALSE
+
+# Set the low end of the LBT-TCP source TCP port range (context transport_tcp_port_low)
+# A decimal number
+#lbttcp.source_port_low: 14371
+
+# Set the high end of the LBT-TCP source TCP port range (context transport_tcp_port_high)
+# A decimal number
+#lbttcp.source_port_high: 14390
+
+# Set the low end of the LBT-TCP request TCP port range (context request_tcp_port_low)
+# A decimal number
+#lbttcp.request_port_low: 14391
+
+# Set the high end of the LBT-TCP request TCP port range (context request_tcp_port_high)
+# A decimal number
+#lbttcp.request_port_high: 14395
+
+# Set the low end of the LBT-TCP UME Store TCP port range
+# A decimal number
+#lbttcp.store_port_low: 0
+
+# Set the high end of the LBT-TCP UME Store TCP port range
+# A decimal number
+#lbttcp.store_port_high: 0
+
+# Use table of LBT-TCP tags to decode the packet instead of above values
+# TRUE or FALSE (case-insensitive)
+#lbttcp.use_lbttcp_domain: FALSE
+
+# Enable this option to recognise all traffic on RTP dynamic payload type 96 (0x60) as FEC data corresponding to Pro-MPEG Code of Practice #3 release 2
+# TRUE or FALSE (case-insensitive)
+#2dparityfec.enable: FALSE
+
+# Derive IID from a short 16-bit address according to RFC 4944 (using the PAN ID).
+# TRUE or FALSE (case-insensitive)
+#6lowpan.rfc4944_short_address_format: FALSE
+
+# Linux kernels before version 4.12 does toggle the Universal/Local bit.
+# TRUE or FALSE (case-insensitive)
+#6lowpan.iid_has_universal_local_bit: FALSE
+
+# Whether the IPv6 summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#6lowpan.summary_in_tree: TRUE
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context0: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context1: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context2: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context3: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context4: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context5: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context6: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context7: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context8: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context9: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context10: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context11: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context12: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context13: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context14: 
+
+# IPv6 prefix to use for stateful address decompression.
+# A string
+#6lowpan.context15: 
+
+# Some generators incorrectly indicate long preamble when the preamble was actuallyshort. Always assume short preamble when calculating duration.
+# TRUE or FALSE (case-insensitive)
+#wlan_radio.always_short_preamble: FALSE
+
+# Some generators timestamp the end of the PPDU rather than the start of the (A)MPDU.
+# TRUE or FALSE (case-insensitive)
+#wlan_radio.tsf_at_end: TRUE
+
+# Enables an additional panel for navigating through packets
+# TRUE or FALSE (case-insensitive)
+#wlan_radio.timeline: FALSE
+
+# Radiotap has a bit to indicate whether the FCS is still on the frame or not. Some generators (e.g. AirPcap) use a non-standard radiotap flag 14 to put the FCS into the header.
+# TRUE or FALSE (case-insensitive)
+#radiotap.bit14_fcs_in_header: FALSE
+
+# Some generators use rates with bit 7 set to indicate an MCS, e.g. BSD. others (Linux, AirPcap) do not.
+# TRUE or FALSE (case-insensitive)
+#radiotap.interpret_high_rates_as_mcs: FALSE
+
+# Whether to use the FCS bit, assume the FCS is always present, or assume the FCS is never present.
+# One of: Use the FCS bit, Assume all packets have an FCS at the end, Assume all packets don't have an FCS at the end
+# (case-insensitive).
+#radiotap.fcs_handling: Use the FCS bit
+
+# Use ipaccess nanoBTS specific definitions for OML
+# One of: ETSI/3GPP TS 12.21, Siemens, ip.access, Ericsson OM2000
+# (case-insensitive).
+#gsm_abis_oml.oml_dialect: ETSI/3GPP TS 12.21
+
+# Enable Streaming DMX extension dissector (ANSI BSR E1.31)
+# TRUE or FALSE (case-insensitive)
+#acn.dmx_enable: FALSE
+
+# Display format
+# One of: Hex    , Decimal, Percent
+# (case-insensitive).
+#acn.dmx_display_view: Hex    
+
+# Display zeros instead of dots
+# TRUE or FALSE (case-insensitive)
+#acn.dmx_display_zeros: FALSE
+
+# Display leading zeros on levels
+# TRUE or FALSE (case-insensitive)
+#acn.dmx_display_leading_zeros: FALSE
+
+# Display line format
+# One of: 20 per line, 16 per line
+# (case-insensitive).
+#acn.dmx_display_line_format: 20 per line
+
+# Server Port
+# A decimal number
+#adb_cs.server_port: 5037
+
+# Dissect more detail for framebuffer service
+# TRUE or FALSE (case-insensitive)
+#adb_service.framebuffer_more_details: FALSE
+
+# Specify if the Data sections of packets should be dissected or not
+# TRUE or FALSE (case-insensitive)
+#adwin.dissect_data: TRUE
+
+# Include next/previous frame for channel, stream, and term, and other transport sequence analysis.
+# TRUE or FALSE (case-insensitive)
+#aeron.sequence_analysis: FALSE
+
+# Include stream analysis, tracking publisher and subscriber positions. Requires "Analyze transport sequencing".
+# TRUE or FALSE (case-insensitive)
+#aeron.stream_analysis: FALSE
+
+# Reassemble fragmented data messages. Requires "Analyze transport sequencing" and "Analyze stream sequencing".
+# TRUE or FALSE (case-insensitive)
+#aeron.reassemble_fragments: FALSE
+
+# Use a registered heuristic sub-dissector to decode the payload data. Requires "Analyze transport sequencing", "Analyze stream sequencing", and "Reassemble fragmented data".
+# TRUE or FALSE (case-insensitive)
+#aeron.use_heuristic_subdissectors: FALSE
+
+# Whether fragmented AFS PDUs should be reassembled
+# TRUE or FALSE (case-insensitive)
+#afs.defragment: FALSE
+
+# Whether the AIM dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#aim.desegment: TRUE
+
+# Whether the LCT header Codepoint field should be considered the FEC Encoding ID of carried object
+# TRUE or FALSE (case-insensitive)
+#alc.lct.codepoint_as_fec_id: TRUE
+
+# How to decode LCT header extension 192
+# One of: Don't decode, Decode as FLUTE extension (EXT_FDT)
+# (case-insensitive).
+#alc.lct.ext.192: Decode as FLUTE extension (EXT_FDT)
+
+# How to decode LCT header extension 193
+# One of: Don't decode, Decode as FLUTE extension (EXT_CENC)
+# (case-insensitive).
+#alc.lct.ext.193: Decode as FLUTE extension (EXT_CENC)
+
+# Whether persistent call leg information is to be kept
+# TRUE or FALSE (case-insensitive)
+#alcap.leg_info: TRUE
+
+# Set the TCP port for AMQP over SSL/TLS(if other than the default of 5671)
+# A decimal number
+#amqp.tls.port: 5671
+
+# Type of AMR encoding of the payload
+# One of: RFC 3267 octet aligned, RFC 3267 BW-efficient, AMR IF1, AMR IF2
+# (case-insensitive).
+#amr.encoding.version: RFC 3267 octet aligned
+
+# The AMR mode
+# One of: Narrowband AMR, Wideband AMR
+# (case-insensitive).
+#amr.mode: Narrowband AMR
+
+# (if other than the default of IOS 4.0.1)
+# One of: IS-634 rev. 0, TSB-80, IS-634-A, IOS 2.x, IOS 3.x, IOS 4.0.1, IOS 5.0.1
+# (case-insensitive).
+#ansi_a_bsmap.global_variant: IOS 4.0.1
+
+# Whether the mobile ID and service options are displayed in the INFO column
+# TRUE or FALSE (case-insensitive)
+#ansi_a_bsmap.top_display_mid_so: TRUE
+
+# ANSI MAP SSNs to decode as ANSI MAP
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#ansi_map.map.ssn: 5-14
+
+# Type of matching invoke/response, risk of mismatch if loose matching chosen
+# One of: Transaction ID only, Transaction ID and Source, Transaction ID Source and Destination
+# (case-insensitive).
+#ansi_map.transaction.matchtype: Transaction ID and Source
+
+# Type of matching invoke/response, risk of mismatch if loose matching chosen
+# One of: Transaction ID only, Transaction ID and Source, Transaction ID Source and Destination
+# (case-insensitive).
+#ansi_tcap.transaction.matchtype: Transaction ID only
+
+# Whether the AOL dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#aol.desegment: TRUE
+
+# Attempt to display common APRS protocol violations correctly
+# TRUE or FALSE (case-insensitive)
+#aprs.showaprslax: FALSE
+
+# Attempt to detect excessive rate of ARP requests
+# TRUE or FALSE (case-insensitive)
+#arp.detect_request_storms: FALSE
+
+# Number of requests needed within period to indicate a storm
+# A decimal number
+#arp.detect_storm_number_of_packets: 30
+
+# Period in milliseconds during which a packet storm may be detected
+# A decimal number
+#arp.detect_storm_period: 100
+
+# Attempt to detect duplicate use of IP addresses
+# TRUE or FALSE (case-insensitive)
+#arp.detect_duplicate_ips: TRUE
+
+# Try to resolve physical addresses to host names from ARP requests/responses
+# TRUE or FALSE (case-insensitive)
+#arp.register_network_address_binding: TRUE
+
+# Select the CAT001 version
+# One of: Version 1.4 (latest), Version 1.4, Version 1.3, Version 1.2
+# (case-insensitive).
+#asterix.i001_version: Version 1.4 (latest)
+
+# Select the CAT002 version
+# One of: Version 1.1 (latest), Version 1.1, Version 1.0
+# (case-insensitive).
+#asterix.i002_version: Version 1.1 (latest)
+
+# Select the CAT004 version
+# One of: Version 1.12 (latest), Version 1.12
+# (case-insensitive).
+#asterix.i004_version: Version 1.12 (latest)
+
+# Select the CAT008 version
+# One of: Version 1.3 (latest), Version 1.3, Version 1.2
+# (case-insensitive).
+#asterix.i008_version: Version 1.3 (latest)
+
+# Select the CAT009 version
+# One of: Version 2.1 (latest), Version 2.1
+# (case-insensitive).
+#asterix.i009_version: Version 2.1 (latest)
+
+# Select the CAT010 version
+# One of: Version 1.1 (latest), Version 1.1
+# (case-insensitive).
+#asterix.i010_version: Version 1.1 (latest)
+
+# Select the CAT011 version
+# One of: Version 1.3 (latest), Version 1.3, Version 1.2
+# (case-insensitive).
+#asterix.i011_version: Version 1.3 (latest)
+
+# Select the CAT015 version
+# One of: Version 1.1 (latest), Version 1.1, Version 1.0
+# (case-insensitive).
+#asterix.i015_version: Version 1.1 (latest)
+
+# Select the CAT016 version
+# One of: Version 1.0 (latest), Version 1.0
+# (case-insensitive).
+#asterix.i016_version: Version 1.0 (latest)
+
+# Select the CAT018 version
+# One of: Version 1.7 (latest), Version 1.7
+# (case-insensitive).
+#asterix.i018_version: Version 1.7 (latest)
+
+# Select the CAT019 version
+# One of: Version 1.3 (latest), Version 1.3
+# (case-insensitive).
+#asterix.i019_version: Version 1.3 (latest)
+
+# Select the CAT020 version
+# One of: Version 1.10 (latest), Version 1.10, Version 1.9
+# (case-insensitive).
+#asterix.i020_version: Version 1.10 (latest)
+
+# Select the CAT021 version
+# One of: Version 2.6 (latest), Version 2.6, Version 2.5, Version 2.4
+# (case-insensitive).
+#asterix.i021_version: Version 2.6 (latest)
+
+# Select the CAT023 version
+# One of: Version 1.3 (latest), Version 1.3, Version 1.2
+# (case-insensitive).
+#asterix.i023_version: Version 1.3 (latest)
+
+# Select the CAT025 version
+# One of: Version 1.5 (latest), Version 1.5
+# (case-insensitive).
+#asterix.i025_version: Version 1.5 (latest)
+
+# Select the CAT032 version
+# One of: Version 1.1 (latest), Version 1.1
+# (case-insensitive).
+#asterix.i032_version: Version 1.1 (latest)
+
+# Select the CAT034 version
+# One of: Version 1.29 (latest), Version 1.29, Version 1.28, Version 1.27
+# (case-insensitive).
+#asterix.i034_version: Version 1.29 (latest)
+
+# Select the CAT048 version
+# One of: Version 1.30 (latest), Version 1.30, Version 1.29, Version 1.28, Version 1.27
+# (case-insensitive).
+#asterix.i048_version: Version 1.30 (latest)
+
+# Select the CAT062 version
+# One of: Version 1.19 (latest), Version 1.19, Version 1.18, Version 1.17
+# (case-insensitive).
+#asterix.i062_version: Version 1.19 (latest)
+
+# Select the CAT063 version
+# One of: Version 1.6 (latest), Version 1.6
+# (case-insensitive).
+#asterix.i063_version: Version 1.6 (latest)
+
+# Select the CAT065 version
+# One of: Version 1.5 (latest), Version 1.5
+# (case-insensitive).
+#asterix.i065_version: Version 1.5 (latest)
+
+# Select the CAT240 version
+# One of: Version 1.3 (latest), Version 1.3
+# (case-insensitive).
+#asterix.i240_version: Version 1.3 (latest)
+
+# Select the CAT247 version
+# One of: Version 1.3 (latest), Version 1.3, Version 1.2
+# (case-insensitive).
+#asterix.i247_version: Version 1.3 (latest)
+
+# Force treat packets as DTE (PC) or DCE (Modem) role
+# One of: Off, Sent is DTE, Rcvd is DCE, Sent is DCE, Rcvd is DTE
+# (case-insensitive).
+#at.role: Off
+
+# Autodetection between LANE and SSCOP is hard. As default LANE is preferred
+# TRUE or FALSE (case-insensitive)
+#atm.dissect_lane_as_sscop: FALSE
+
+# Whether the ATP dissector should reassemble messages spanning multiple DDP packets
+# TRUE or FALSE (case-insensitive)
+#atp.desegment: TRUE
+
+# Define the standard version that applies to the CBV field
+# One of: AUTOSAR 3.0 or 3.1, AUTOSAR 3.2, AUTOSAR 4.0, AUTOSAR 4.1 or newer, AUTOSAR 20-11
+# (case-insensitive).
+#autosar-nm.cbv_version: AUTOSAR 4.1 or newer
+
+# Make the NM dissector interpret this byte as Control Bit Vector (CBV)
+# One of: Byte Position 0, Byte Position 1, Turned off
+# (case-insensitive).
+#autosar-nm.cbv_position: Byte Position 0
+
+# Make the NM dissector interpret this byte as Source Node Identifier (SNI)
+# One of: Byte Position 0, Byte Position 1, Turned off
+# (case-insensitive).
+#autosar-nm.sni_position: Byte Position 1
+
+# Identifier that is used to filter packets that should be dissected. Set bit 31 when defining an extended id. (works with the mask defined below)
+# A hexadecimal number
+#autosar-nm.can_id: 0
+
+# Mask applied to CAN identifiers when decoding whether a packet should dissected. Use 0xFFFFFFFF mask to require exact match.
+# A hexadecimal number
+#autosar-nm.can_id_mask: 0xffffffff
+
+# PDU Transport IDs.
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#autosar-nm.pdu_transport.ids: 
+
+# I-PDU Multiplexer PDU IDs.
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#autosar-nm.ipdum.pdu.id: 
+
+# Enable checksum calculation.
+# TRUE or FALSE (case-insensitive)
+#ax25_kiss.showcksum: FALSE
+
+# Enable decoding of the payload as APRS.
+# TRUE or FALSE (case-insensitive)
+#ax25_nol3.showaprs: FALSE
+
+# Enable decoding of the payload as DX cluster info.
+# TRUE or FALSE (case-insensitive)
+#ax25_nol3.showcluster: FALSE
+
+# Ethertype used to indicate B.A.T.M.A.N. packet.
+# A hexadecimal number
+#batadv.batmanadv.ethertype: 0x4305
+
+# Whether the Bazaar dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#bzr.desegment: TRUE
+
+# Specifies that BEEP requires CRLF as a terminator, and not just CR or LF
+# TRUE or FALSE (case-insensitive)
+#beep.strict_header_terminator: TRUE
+
+# Whether the dissector should also display internal ASN.1 BER details such as Identifier and Length fields
+# TRUE or FALSE (case-insensitive)
+#ber.show_internals: FALSE
+
+# Whether the dissector should decode unexpected tags as ASN.1 BER encoded data
+# TRUE or FALSE (case-insensitive)
+#ber.decode_unexpected: FALSE
+
+# Whether the dissector should try decoding OCTET STRINGs as constructed ASN.1 BER encoded data
+# TRUE or FALSE (case-insensitive)
+#ber.decode_octetstring: FALSE
+
+# Whether the dissector should try decoding unknown primitive as constructed ASN.1 BER encoded data
+# TRUE or FALSE (case-insensitive)
+#ber.decode_primitive: FALSE
+
+# Whether the dissector should warn if excessive leading zero (0) bits
+# TRUE or FALSE (case-insensitive)
+#ber.warn_too_many_bytes: FALSE
+
+# Whether the BGP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#bgp.desegment: TRUE
+
+# BGP dissector detect the length of the AS number in AS_PATH attributes automatically or manually (NOTE: Automatic detection is not 100% accurate)
+# One of: Auto-detect, 2 octet, 4 octet
+# (case-insensitive).
+#bgp.asn_len: Auto-detect
+
+# Whether the Bitcoin dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#bitcoin.desegment: TRUE
+
+# Whether the BitTorrent dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#bittorrent.desegment: TRUE
+
+# Enabling this will tell which BitTorrent client that produced the handshake message
+# TRUE or FALSE (case-insensitive)
+#bittorrent.decode_client: FALSE
+
+# The maximum size of the buffer for uncompressed messages. If a message is larger than this, then the packet containing the message, as well as subsequent packets, will fail to decompress
+# A decimal number
+#blip.max_uncompressed_size: 64
+
+# Force decoding stream as A2DP with Content Protection SCMS-T 
+# TRUE or FALSE (case-insensitive)
+#bta2dp.a2dp.content_protection.scms_t: FALSE
+
+# Force decoding stream as A2DP with specified codec
+# One of: Default, SBC, MPEG12 AUDIO, MPEG24 AAC, aptX, aptX HD, LDAC
+# (case-insensitive).
+#bta2dp.a2dp.codec: Default
+
+# Dissecting the top protocols
+# TRUE or FALSE (case-insensitive)
+#btbnep.bnep.top_dissect: TRUE
+
+# If "yes" localhost will be treat as Client, "no" as Server
+# One of: Default, Yes, No
+# (case-insensitive).
+#bthcrp.hcrp.force_client: Default
+
+# L2CAP PSM for Control
+# A decimal number
+#bthcrp.hcrp.control.psm: 0
+
+# L2CAP PSM for Data
+# A decimal number
+#bthcrp.hcrp.data.psm: 0
+
+# L2CAP PSM for Notification
+# A decimal number
+#bthcrp.hcrp.notification.psm: 0
+
+# Force treat packets as AG or HS role
+# One of: Off, Sent is AG, Rcvd is HS, Sent is HS, Rcvd is AG
+# (case-insensitive).
+#bthfp.hfp.hfp_role: Off
+
+# Show what is deprecated in HID 1.1
+# TRUE or FALSE (case-insensitive)
+#bthid.hid.deprecated: FALSE
+
+# Force treat packets as AG or HS role
+# One of: Off, Sent is AG, Rcvd is HS, Sent is HS, Rcvd is AG
+# (case-insensitive).
+#bthsp.hsp.hsp_role: Off
+
+# Detect retransmission based on SN (Sequence Number)
+# TRUE or FALSE (case-insensitive)
+#btle.detect_retransmit: TRUE
+
+# Turn on/off decode by next rules
+# TRUE or FALSE (case-insensitive)
+#btrfcomm.rfcomm.decode_by.enabled: FALSE
+
+# Dissecting the top protocols
+# One of: off, Put higher dissectors under this one, On top
+# (case-insensitive).
+#btsap.sap.top_dissect: Put higher dissectors under this one
+
+# Force decoding stream as VDP with Content Protection SCMS-T 
+# TRUE or FALSE (case-insensitive)
+#btvdp.vdp.content_protection.scms_t: FALSE
+
+# Force decoding stream as VDP with specified codec
+# One of: H263, MPEG4 VSP
+# (case-insensitive).
+#btvdp.vdp.codec: H263
+
+# Whether the ACL dissector should reassemble fragmented PDUs
+# TRUE or FALSE (case-insensitive)
+#bthci_acl.hci_acl_reassembly: TRUE
+
+# Whether the ISO dissector should reassemble fragmented PDUs
+# TRUE or FALSE (case-insensitive)
+#bthci_iso.hci_iso_reassembly: TRUE
+
+# Whether the BMP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#bmp.desegment: TRUE
+
+# If enabled, the blocks will have CRC checks performed.
+# TRUE or FALSE (case-insensitive)
+#bpv7.bp_compute_crc: TRUE
+
+# Whether the dissector should reassemble fragmented bundle payloads.
+# TRUE or FALSE (case-insensitive)
+#bpv7.bp_reassemble_payload: TRUE
+
+# When dissecting block type-specific data and payload and no destination matches, attempt heuristic dissection.
+# TRUE or FALSE (case-insensitive)
+#bpv7.bp_payload_try_heur: FALSE
+
+# The default protocol assumed by the heuristic dissector,which does not easily distinguish between BSSAP (on the GSM A interface between the BSC and the MSC), BSSAP-LE (on the GSM Lb interface between the BSC and the SMLC), and BSAP (on the CDMA2000 A interface between the BS and MSC).
+# One of: BSSAP (GSM A-I/F), BSAP (CDMA2000 A-I/F), BSSAP-LE (GSM Lb-I/F)
+# (case-insensitive).
+#bssap.default_protocol: BSSAP (GSM A-I/F)
+
+# Make the uTP dissector analyze uTP sequence numbers. Currently this just means that it tries to find the correct start offset of a PDU if it detected that previous in-order packets spanned multiple frames.
+# TRUE or FALSE (case-insensitive)
+#bt-utp.analyze_sequence_numbers: TRUE
+
+# Whether the dissector should attempt to dissect packets with the obsolete format (version 0) that predates BEP 29 (22-Jun-2009)
+# TRUE or FALSE (case-insensitive)
+#bt-utp.enable_version0: FALSE
+
+# Maximum receive window size allowed by the dissector. Early clients (and a few modern ones) set this value to 0x380000 (the default), later ones use smaller values like 0x100000 and 0x40000. A higher value can detect nonstandard packets, but at the cost of false positives.
+# A hexadecimal number
+#bt-utp.max_window_size: 0x380000
+
+# Dissect next layer
+# TRUE or FALSE (case-insensitive)
+#btsnoop.dissect_next_layer: FALSE
+
+# Whether the C12.22 dissector should reassemble all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#c1222.desegment: TRUE
+
+# Base object identifier for use in resolving relative object identifiers
+# A string
+#c1222.baseoid: 
+
+# Whether the C12.22 dissector should verify the crypto for all relevant messages
+# TRUE or FALSE (case-insensitive)
+#c1222.decrypt: TRUE
+
+# Whether the C12.22 dissector should interpret procedure numbers as big-endian
+# TRUE or FALSE (case-insensitive)
+#c1222.big_endian: FALSE
+
+# The date format: (DD/MM) or (MM/DD)
+# One of: DD/MM/YYYY, MM/DD/YYYY
+# (case-insensitive).
+#camel.date.format: DD/MM/YYYY
+
+# TCAP Subsystem numbers used for Camel
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#camel.tcap.ssn: 146
+
+# Statistics for Response Time
+# TRUE or FALSE (case-insensitive)
+#camel.persistentsrt: FALSE
+
+# Whether the CAN ID/flags field should be byte-swapped
+# TRUE or FALSE (case-insensitive)
+#can.byte_swap: FALSE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to "decode as"
+# TRUE or FALSE (case-insensitive)
+#can.try_heuristic_first: FALSE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to "decode as"
+# TRUE or FALSE (case-insensitive)
+#acf-can.try_heuristic_first: FALSE
+
+# Enable support of Cisco Wireless Controller (based on old 8 draft revision).
+# TRUE or FALSE (case-insensitive)
+#capwap.draft_8_cisco: FALSE
+
+# Reassemble fragmented CAPWAP packets.
+# TRUE or FALSE (case-insensitive)
+#capwap.reassemble: TRUE
+
+# Swap frame control bytes (needed for some APs).
+# TRUE or FALSE (case-insensitive)
+#capwap.swap_fc: TRUE
+
+# Whether the CAST dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#cast.reassembly: TRUE
+
+# Whether the checksum of all messages should be validated or not
+# TRUE or FALSE (case-insensitive)
+#cattp.checksum: TRUE
+
+# Specify how the dissector should handle the CCSDS checkword
+# One of: Use header flag, Override header flag to be false, Override header flag to be true
+# (case-insensitive).
+#ccsds.global_pref_checkword: Use header flag
+
+# Whether or not the RTP header is present in the CES payload.
+# TRUE or FALSE (case-insensitive)
+#cesoeth.rtp_header: FALSE
+
+# Heuristically determine if an RTP header is present in the CES payload.
+# TRUE or FALSE (case-insensitive)
+#cesoeth.rtp_header_heuristic: TRUE
+
+# Set the port(s) for NetFlow messages (default: 2055,9996)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#cflow.netflow.ports: 2055,9996
+
+# Set the port(s) for IPFIX messages (default: 4739)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#cflow.ipfix.ports: 4739
+
+# Set the number of fields allowed in a template.  Use 0 (zero) for unlimited.   (default: 60)
+# A decimal number
+#cflow.max_template_fields: 60
+
+# Whether the Netflow/Ipfix dissector should reassemble messages spanning multiple TCP segments.  To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#cflow.desegment: TRUE
+
+# Whether to validate the Frame Check Sequence
+# TRUE or FALSE (case-insensitive)
+#cfp.check_fcs: FALSE
+
+# The type of CHDLC frame checksum (none, 16-bit, 32-bit)
+# One of: None, 16-Bit, 32-Bit
+# (case-insensitive).
+#chdlc.fcs_type: None
+
+# The version of CIGI with which to dissect packets
+# One of: From Packet, CIGI 2, CIGI 3
+# (case-insensitive).
+#cigi.version: From Packet
+
+# The byte order with which to dissect CIGI packets (CIGI3)
+# One of: From Packet, Big-Endian, Little-Endian
+# (case-insensitive).
+#cigi.byte_order: From Packet
+
+# IPv4 address or hostname of the host
+# A string
+#cigi.host: 
+
+# IPv4 address or hostname of the image generator
+# A string
+#cigi.ig: 
+
+# Whether the CIP dissector should display enhanced/verbose data in the Info column for CIP explicit messages
+# TRUE or FALSE (case-insensitive)
+#cip.enhanced_info_column: TRUE
+
+# Whether the CIP Motion dissector always display the full raw attribute data bytes
+# TRUE or FALSE (case-insensitive)
+#cipm.display_full_attribute_data: FALSE
+
+# NSAP selector for Transport Protocol (last byte in hex)
+# A hexadecimal number
+#clnp.tp_nsap_selector: 0x21
+
+# Always try to decode NSDU as transport PDUs
+# TRUE or FALSE (case-insensitive)
+#clnp.always_decode_transport: FALSE
+
+# Whether segmented CLNP datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#clnp.reassemble: TRUE
+
+# Whether ATN security label should be decoded
+# TRUE or FALSE (case-insensitive)
+#clnp.decode_atn_options: FALSE
+
+# Whether the CMP-over-TCP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#cmp.desegment: TRUE
+
+# Decode this TCP port's traffic as CMP-over-HTTP. Set to "0" to disable. Use this if the Content-Type is not set correctly.
+# A decimal number
+#cmp.http_alternate_port: 0
+
+# Decode this TCP port's traffic as TCP-transport-style CMP-over-HTTP. Set to "0" to disable. Use this if the Content-Type is not set correctly.
+# A decimal number
+#cmp.tcp_style_http_alternate_port: 0
+
+# Whether to base64-encode the Community ID hash value
+# TRUE or FALSE (case-insensitive)
+#communityid.do_base64: TRUE
+
+# A 16-bit seed value to add to the hashed data
+# A decimal number
+#communityid.seed: 0
+
+# Whether the COPS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#cops.desegment: TRUE
+
+# Decode the COPS messages using PacketCable clients. (Select port 2126)
+# TRUE or FALSE (case-insensitive)
+#cops.packetcable: TRUE
+
+# Semicolon-separated  list of keys for decryption(e.g. key1;key2;...
+# A string
+#corosync_totemnet.private_keys: 
+
+# Whether segmented COTP datagrams should be reassembled. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#cotp.reassemble: TRUE
+
+# How TSAPs should be displayed
+# One of: As strings if printable, As strings, As bytes
+# (case-insensitive).
+#cotp.tsap_display: As strings if printable
+
+# Whether to decode OSI TPDUs with ATN (Aeronautical Telecommunications Network) extensions. To use this option, you must also enable "Always try to decode NSDU as transport PDUs" in the CLNP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#cotp.decode_atn: FALSE
+
+# Whether the Couchbase dissector should reassemble PDUs spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#couchbase.desegment_pdus: TRUE
+
+# The port used for communicating with the data service via SSL/TLS
+# A decimal number
+#couchbase.tls.port: 11207
+
+# Whether the SEL Protocol dissector should automatically pre-process Telnet data to remove IAC bytes
+# TRUE or FALSE (case-insensitive)
+#cp2179.telnetclean: TRUE
+
+# Set the port for InstanceToInstance messages (if other than the default of 5001)
+# A decimal number
+#cpfi.udp.port2: 5001
+
+# Control the way the '-->' is displayed. When enabled, keeps the 'lowest valued' endpoint of the src-dest pair on the left, and the arrow moves to distinguish source from dest. When disabled, keeps the arrow pointing right so the source of the frame is always on the left.
+# TRUE or FALSE (case-insensitive)
+#cpfi.arrow_ctl: TRUE
+
+# Show not dissected data on new Packet Bytes pane
+# TRUE or FALSE (case-insensitive)
+#data.datapref.newpane: FALSE
+
+# Try to uncompress zlib compressed data and show as uncompressed if successful
+# TRUE or FALSE (case-insensitive)
+#data.uncompress_data: FALSE
+
+# Show data as text in the Packet Details pane
+# TRUE or FALSE (case-insensitive)
+#data.show_as_text: FALSE
+
+# Whether or not MD5 hashes should be generated and shown for each payload.
+# TRUE or FALSE (case-insensitive)
+#data.md5_hash: FALSE
+
+# Whether the LAN sync dissector should reassemble PDUs spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#db-lsp.desegment_pdus: TRUE
+
+# Try to decode the payload using an heuristic sub-dissector
+# TRUE or FALSE (case-insensitive)
+#db-lsp.try_heuristic: TRUE
+
+# Whether the DCCP summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#dccp.summary_in_tree: TRUE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to a specific port
+# TRUE or FALSE (case-insensitive)
+#dccp.try_heuristic_first: FALSE
+
+# Whether to check the validity of the DCCP checksum
+# TRUE or FALSE (case-insensitive)
+#dccp.check_checksum: TRUE
+
+# Make the DCCP dissector use relative sequence numbers instead of absolute ones.
+# TRUE or FALSE (case-insensitive)
+#dccp.relative_sequence_numbers: TRUE
+
+# Whether the DCE/RPC dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#dcerpc.desegment_dcerpc: TRUE
+
+# Whether the DCE/RPC dissector should reassemble fragmented DCE/RPC PDUs
+# TRUE or FALSE (case-insensitive)
+#dcerpc.reassemble_dcerpc: TRUE
+
+# Display some DCOM unmarshalled fields usually hidden
+# TRUE or FALSE (case-insensitive)
+#dcom.display_unmarshalling_details: FALSE
+
+# If a payload looks like it's embedded in an IP primitive message, and there is a Wireshark dissector matching the DCT2000 protocol name, try parsing the payload using that dissector
+# TRUE or FALSE (case-insensitive)
+#dct2000.ipprim_heuristic: TRUE
+
+# If a payload looks like it's embedded in an SCTP primitive message, and there is a Wireshark dissector matching the DCT2000 protocol name, try parsing the payload using that dissector
+# TRUE or FALSE (case-insensitive)
+#dct2000.sctpprim_heuristic: TRUE
+
+# When set, attempt to decode LTE RRC frames. Note that this won't affect other protocols that also call the LTE RRC dissector
+# TRUE or FALSE (case-insensitive)
+#dct2000.decode_lte_rrc: TRUE
+
+# When set, look for formatted messages indicating specific events.  This may be quite slow, so should be disabled if LTE MAC is not being analysed
+# TRUE or FALSE (case-insensitive)
+#dct2000.decode_mac_lte_oob_messages: TRUE
+
+# When set, look for some older protocol names so thatthey may be matched with wireshark dissectors.
+# TRUE or FALSE (case-insensitive)
+#dct2000.convert_old_protocol_names: FALSE
+
+# When set, if there is a Wireshark dissector matching the protocol name, it will parse the PDU using that dissector. This may be slow, so should be disabled unless you are using this feature.
+# TRUE or FALSE (case-insensitive)
+#dct2000.use_protocol_name_as_dissector_name: FALSE
+
+# Novell Servers option 85 can be configured as a string instead of address
+# TRUE or FALSE (case-insensitive)
+#dhcp.novellserverstring: FALSE
+
+# The PacketCable CCC protocol version
+# One of: PKT-SP-PROV-I05-021127, IETF Draft 5, RFC 3495
+# (case-insensitive).
+#dhcp.pkt.ccc.protocol_version: RFC 3495
+
+# Option Number for PacketCable CableLabs Client Configuration
+# A decimal number
+#dhcp.pkt.ccc.option: 122
+
+# Endianness applied to UUID fields
+# One of: Little Endian, Big Endian
+# (case-insensitive).
+#dhcp.uuid.endian: Little Endian
+
+# Whether the DHCP failover dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#dhcpfo.desegment: TRUE
+
+# Whether Option 18 is dissected as CableLab or RFC 3315
+# TRUE or FALSE (case-insensitive)
+#dhcpv6.cablelabs_interface_id: FALSE
+
+# Whether the Bulk Leasequery dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#dhcpv6.bulk_leasequery.desegment: TRUE
+
+# Whether the Diameter dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#diameter.desegment: TRUE
+
+# Create DICOM File Meta Header according to PS 3.10 on export for PDUs. If the captured PDV does not contain a SOP Class UID and SOP Instance UID (e.g. for command PDVs), wireshark specific ones will be created.
+# TRUE or FALSE (case-insensitive)
+#dicom.export_header: TRUE
+
+# Do not show items below this size in the export list. Set it to 0, to see DICOM commands and responses in the list. Set it higher, to just export DICOM IODs (i.e. CT Images, RT Structures).
+# A decimal number
+#dicom.export_minsize: 4096
+
+# Create a node for sequences and items, and show children in a hierarchy. De-select this option, if you prefer a flat display or e.g. when using TShark to create a text output.
+# TRUE or FALSE (case-insensitive)
+#dicom.seq_tree: TRUE
+
+# Create a node for a tag and show tag details as single elements. This can be useful to debug a tag and to allow display filters on these attributes. When using TShark to create a text output, it's better to have it disabled. 
+# TRUE or FALSE (case-insensitive)
+#dicom.tag_tree: FALSE
+
+# Show message ID and number of completed, remaining, warned or failed operations in header and info column.
+# TRUE or FALSE (case-insensitive)
+#dicom.cmd_details: TRUE
+
+# Decode all DICOM tags in the last PDV. This will ensure the proper reassembly. De-select, to troubleshoot PDU length issues, or to understand PDV fragmentation. When not set, the decoding may fail and the exports may become corrupt.
+# TRUE or FALSE (case-insensitive)
+#dicom.pdv_reassemble: TRUE
+
+# Whether the DISTCC dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#distcc.desegment_distcc_over_tcp: TRUE
+
+# Whether DJIUAV should reassemble messages spanning multiple TCP segments (required to get useful results)
+# TRUE or FALSE (case-insensitive)
+#djiuav.desegment: TRUE
+
+# Whether the DLEP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#dlep.desegment: TRUE
+
+# Select the type of decoding for nationally-defined values
+# One of: None (raw data), As for regular, Thales XOmail
+# (case-insensitive).
+#dmp.national_decode: As for regular
+
+# Select the nation of sending server.  This is used when presenting security classification values in messages with security policy set to National (nation of local server)
+# One of: None, Albania, Armenia, Austria, Azerbaijan, Belarus, Belgium, Bosnia and Hercegowina, Bulgaria, Canada, Croatia, Czech Republic, Denmark, Estonia, Euro-Atlantic Partnership Council (EAPC), European Union (EU), Finland, Former Yugoslav Republic of Macedonia, France, Georgia, Germany, Greece, Hungary, Iceland, International Security Assistance Force (ISAF), Ireland, Italy, Kazakhstan, Kyrgyztan, Latvia, Lithuania, Luxembourg, Malta, Moldova, Montenegro, Netherlands, Norway, Partnership for Peace (PfP), Poland, Portugal, Romania, Russian Federation, Serbia, Slovakia, Slovenia, Spain, Sweden, Switzerland, Tajikistan, Turkey, Turkmenistan, United Kingdom, United States, Ukraine, Uzbekistan, Western European Union (WEU)
+# (case-insensitive).
+#dmp.local_nation: None
+
+# Calculate sequence/acknowledgement analysis
+# TRUE or FALSE (case-insensitive)
+#dmp.seq_ack_analysis: TRUE
+
+# Align identifiers in info list (does not align when retransmission or duplicate acknowledgement indication)
+# TRUE or FALSE (case-insensitive)
+#dmp.align_ids: FALSE
+
+# The way DMX values are displayed
+# One of: Percent, Hexadecimal, Decimal
+# (case-insensitive).
+#dmx_chan.dmx_disp_chan_val_type: Percent
+
+# The way DMX channel numbers are displayed
+# One of: Hexadecimal, Decimal
+# (case-insensitive).
+#dmx_chan.dmx_disp_chan_nr_type: Hexadecimal
+
+# The number of columns for the DMX display
+# One of: 6, 10, 12, 16, 24
+# (case-insensitive).
+#dmx_chan.dmx_disp_col_count: 16
+
+# Whether the DNP3 dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#dnp3.desegment: TRUE
+
+# Whether the DNS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#dns.desegment_dns_messages: TRUE
+
+# Number of seconds allowed between DNS requests with the same transaction ID to consider it a retransmission. Otherwise its considered a new request.
+# A decimal number
+#dns.retransmission_timer: 5
+
+# Whether or not to validate the Header Check Sequence
+# TRUE or FALSE (case-insensitive)
+#docsis.check_fcs: TRUE
+
+# Whether or not to attempt to dissect encrypted DOCSIS payload
+# TRUE or FALSE (case-insensitive)
+#docsis.dissect_encrypted_frames: FALSE
+
+# Specifies that decryption should be attempted on all packets, even if the session initialization wasn't captured.
+# TRUE or FALSE (case-insensitive)
+#dof.custom_dof_decrypt_all: FALSE
+
+# Specifies that operations should be tracked across multiple packets, providing summary lists. This takes time and memory.
+# TRUE or FALSE (case-insensitive)
+#dof.custom_dof_track_operations: FALSE
+
+# Limits the number of operations shown before and after the current operations
+# A decimal number
+#dof.custom_dof_track_operations_window: 5
+
+# Should the dissector hide the names for addresses?
+# TRUE or FALSE (case-insensitive)
+#doip.hide_address_name_entries: TRUE
+
+# Whether the DRDA dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#drda.desegment: TRUE
+
+# Whether the DSI dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#dsi.desegment: TRUE
+
+# Semicolon-separated list of private RSA keys used for DTLS decryption. Used by versions of Wireshark prior to 1.6
+# A string
+#dtls.keys_list: 
+
+# redirect dtls debug to file name; leave empty to disable debug, use "-" to redirect output to stderr
+# 
+# A path to a file
+#dtls.debug_file: 
+
+# Default client Connection ID length used when the Client Handshake message is missing
+# A decimal number
+#dtls.client_cid_length: 0
+
+# Default server Connection ID length used when the Server Handshake message is missing
+# A decimal number
+#dtls.server_cid_length: 0
+
+# Pre-Shared Key as HEX string. Should be 0 to 16 bytes.
+# A string
+#dtls.psk: 
+
+# SAC Encryption Key (16 hex bytes)
+# A string
+#dvb-ci.sek: 
+
+# SAC Init Vector (16 hex bytes)
+# A string
+#dvb-ci.siv: 
+
+# Dissect the content of messages transmitted on the Low-Speed Communication resource. This requires a dissector for the protocol and target port contained in the connection descriptor.
+# TRUE or FALSE (case-insensitive)
+#dvb-ci.dissect_lsc_msg: FALSE
+
+# Check this to enable full protocol dissection of data above BBHeader
+# TRUE or FALSE (case-insensitive)
+#dvb-s2_modeadapt.decode_df: FALSE
+
+# Check this to enable full protocol dissection of data above GSE Layer
+# TRUE or FALSE (case-insensitive)
+#dvb-s2_modeadapt.full_decode: FALSE
+
+# The preferred Mode Adaptation Interface
+# One of: L.1 (0 bytes), L.2 (2 bytes including sync), L.3 (4 bytes including sync), L.4 (3 bytes)
+# (case-insensitive).
+#dvb-s2_modeadapt.default_modeadapt: L.3 (4 bytes including sync)
+
+# Try all supported Mode Adaptation Interface Types, using the preferred value in the case of ambiguity; if unset, only look for Base Band Frames with the preferred type
+# TRUE or FALSE (case-insensitive)
+#dvb-s2_modeadapt.try_all_modeadapt: TRUE
+
+# defines the RCS protocol version used in table dissection
+# One of: RCS protocol, RCS2 protocol
+# (case-insensitive).
+#dvb-s2_table.rcs_protocol: RCS2 protocol
+
+# Allow only packets with Major=0x03//Minor=0xFF as DVMRP V3 packets
+# TRUE or FALSE (case-insensitive)
+#dvmrp.strict_v3: FALSE
+
+# Decode the Message Types according to eCPRI Specification V1.2
+# TRUE or FALSE (case-insensitive)
+#ecpri.ecpripref.msg.decoding: TRUE
+
+# Whether the eDonkey dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#edonkey.desegment: TRUE
+
+# Whether the EtherNet/IP dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#enip.desegment: TRUE
+
+# Determines whether all I/O connections will assume a 32-bit header in the O->T direction
+# TRUE or FALSE (case-insensitive)
+#enip.o2t_run_idle: TRUE
+
+# Determines whether all I/O connections will assume a 32-bit header in the T->O direction
+# TRUE or FALSE (case-insensitive)
+#enip.t2o_run_idle: FALSE
+
+# The way DMX values are displayed
+# One of: Percent, Hexadecimal, Decimal
+# (case-insensitive).
+#enttec.dmx_disp_chan_val_type: Percent
+
+# The way DMX channel numbers are displayed
+# One of: Hexadecimal, Decimal
+# (case-insensitive).
+#enttec.dmx_disp_chan_nr_type: Hexadecimal
+
+# The number of columns for the DMX display
+# One of: 6, 10, 12, 16, 24
+# (case-insensitive).
+#enttec.dmx_disp_col_count: 16
+
+# If you are capturing in networks with multiplexed or slow nodes, this can be useful
+# TRUE or FALSE (case-insensitive)
+#epl.show_soc_flags: FALSE
+
+# For analysis purposes one might want to show the command layer even if the dissector assumes a duplicated frame
+# TRUE or FALSE (case-insensitive)
+#epl.show_duplicated_command_layer: FALSE
+
+# For analysis purposes one might want to see how long the current mapping has been active for and what OD write caused it
+# TRUE or FALSE (case-insensitive)
+#epl.show_pdo_meta_info: FALSE
+
+# Partition PDOs according to ObjectMappings sent via SDO
+# TRUE or FALSE (case-insensitive)
+#epl.use_sdo_mappings: TRUE
+
+# If you want to parse the defaultValue (XDD) and actualValue (XDC) attributes for ObjectMappings in order to detect default PDO mappings, which may not be sent over SDO 
+# TRUE or FALSE (case-insensitive)
+#epl.use_xdc_mappings: TRUE
+
+# If a data field has untyped data under 8 byte long, interpret it as unsigned little endian integer and show decimal and hexadecimal representation thereof. Otherwise use stock data dissector
+# TRUE or FALSE (case-insensitive)
+#epl.interpret_untyped_as_le: TRUE
+
+# If you have a capture without IdentResponse and many nodes, it's easier to set a default profile here than to add entries for all MAC address or Node IDs
+# A path to a file
+#epl.default_profile: 
+
+# Protocol encapsulated in HDLC records
+# One of: Cisco HDLC, PPP serial, Frame Relay, SS7 MTP2, Attempt to guess
+# (case-insensitive).
+#erf.hdlc_type: Attempt to guess
+
+# Whether raw ATM cells should be treated as the first cell of an AAL5 PDU
+# TRUE or FALSE (case-insensitive)
+#erf.rawcell_first: FALSE
+
+# Protocol encapsulated in ATM AAL5 packets
+# One of: Attempt to guess, LLC multiplexed, Unspecified
+# (case-insensitive).
+#erf.aal5_type: Attempt to guess
+
+# The packets contain the optional Incremental Redundancy (IR) fields
+# TRUE or FALSE (case-insensitive)
+#gsm_abis_pgsl.ir: FALSE
+
+# This is done only if the Decoding is not SET or the packet does not belong to a SA. Tries ICV lengths of 12, 16, 24, and 32 bytes, checks for valid padding, and attempts to decode based on the derived Next Header field. Does not detect ENCR_NULL_AUTH_AES_GMAC (i.e. assumes 0 length IV)
+# TRUE or FALSE (case-insensitive)
+#esp.enable_null_encryption_decode_heuristic: FALSE
+
+# Check that successive frames increase sequence number by 1 within an SPI.  This should work OK when only one host is sending frames on an SPI
+# TRUE or FALSE (case-insensitive)
+#esp.do_esp_sequence_analysis: TRUE
+
+# Attempt to decode based on the SAD described hereafter.
+# TRUE or FALSE (case-insensitive)
+#esp.enable_encryption_decode: FALSE
+
+# Attempt to Check ESP Authentication based on the SAD described hereafter.
+# TRUE or FALSE (case-insensitive)
+#esp.enable_authentication_check: FALSE
+
+# Whether the E-Tag summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#etag.summary_in_tree: TRUE
+
+# Place the hash/symbol files (generated by the Apache Etch compiler) ending with .ewh here
+# A path to a directory
+#etch.file: 
+
+# Some devices add trailing data to frames.  Depending on where this device exists in the network, padding could be added to short frames before the additional trailer.  This option determines how that padding will be detected.
+# 
+# Never - Don't detect any padding.  Any bytes after the ethernet payload will be considered trailer.
+# Zeros (default) - Consecutive bytes of zeros up to the minimum ethernet frame size will be treated as padding.  Additional bytes will be considered trailer.
+# Any - Any bytes after the payload up to the minimum ethernet frame size will be treated as padding.  Additional bytes will be considered trailer.
+# One of: Never, Zeros, Any
+# (case-insensitive).
+#eth.padding: Zeros
+
+# Some TAPs add a fixed length ethernet trailer at the end of the frame, but before the (optional) FCS. Make sure it gets interpreted correctly.
+# A decimal number
+#eth.trailer_length: 0
+
+# Some Ethernet adapters and drivers include the FCS at the end of a packet, others do not.  Some capture file formats and protocols do not indicate whether or not the FCS is included. The Ethernet dissector then attempts to guess whether a captured packet has an FCS, but it cannot always guess correctly.  This option can override that heuristic and assume that the FCS is either never or always present in such cases.
+# One of: According to heuristic, Never, Always
+# (case-insensitive).
+#eth.fcs: According to heuristic
+
+# Whether to validate the Frame Check Sequence
+# TRUE or FALSE (case-insensitive)
+#eth.check_fcs: FALSE
+
+# Whether packets should be interpreted as coming from CheckPoint FireWall-1 monitor file if they look as if they do
+# TRUE or FALSE (case-insensitive)
+#eth.interpret_as_fw1_monitor: FALSE
+
+# When capturing on a Cisco FEX some frames start with an extra destination mac
+# TRUE or FALSE (case-insensitive)
+#eth.deduplicate_dmac: FALSE
+
+# Set the condition that must be true for the CCSDS dissector to be called
+# TRUE or FALSE (case-insensitive)
+#eth.ccsds_heuristic_length: FALSE
+
+# Set the condition that must be true for the CCSDS dissector to be called
+# TRUE or FALSE (case-insensitive)
+#eth.ccsds_heuristic_version: FALSE
+
+# Set the condition that must be true for the CCSDS dissector to be called
+# TRUE or FALSE (case-insensitive)
+#eth.ccsds_heuristic_header: FALSE
+
+# Set the condition that must be true for the CCSDS dissector to be called
+# TRUE or FALSE (case-insensitive)
+#eth.ccsds_heuristic_bit: FALSE
+
+# Whether the EVRC dissector should process payload type 60 as legacy EVRC packets
+# TRUE or FALSE (case-insensitive)
+#evrc.legacy_pt_60: FALSE
+
+# Controls the display of the session's username in the info column.  This is only displayed if the packet containing it was seen during this capture session.
+# TRUE or FALSE (case-insensitive)
+#exec.info_show_username: TRUE
+
+# Controls the display of the command being run on the server by this session in the info column.  This is only displayed if the packet containing it was seen during this capture session.
+# TRUE or FALSE (case-insensitive)
+#exec.info_show_command: FALSE
+
+# In a few cases a short ethernet frame will be padded with non-zerobytes.  If this happens, an f5ethtrailer will not be found.Enabling this will step through each byte of the ethernet trailerto try and find the start of an f5ethtrailer
+# TRUE or FALSE (case-insensitive)
+#f5ethtrailer.pref_walk_trailer: FALSE
+
+# Disable this if you do not want this dissector to populate well-known fields in other dissectors (i.e. ip.addr, ipv6.addr, tcp.port and udp.port).  Enabling this will allow filters that reference those fields to also find data in the trailers but will reduce performance.  After disabling, you should restart Wireshark to get performance back.
+# TRUE or FALSE (case-insensitive)
+#f5ethtrailer.pref_pop_other_fields: FALSE
+
+# Enabling this will perform analysis of the trailer data.  It will enable taps on other protocols and slow down Wireshark.
+# TRUE or FALSE (case-insensitive)
+#f5ethtrailer.perform_analysis: FALSE
+
+# In/out only removes slot/tmm information.  Brief shortens the string to >S/T (for in) or <S/T (for out).  See "Brief in/out characters" below.
+# One of: None, Full, In/out only, Brief, Brief in/out only
+# (case-insensitive).
+#f5ethtrailer.info_type: Full
+
+# A string specifying the characters to use to represent "in" and "out" in the brief summary.  The default is "><" ('>' for in and '<' for out).  If this is not set or is less than two characters, the default is used.  If it is longer than two characters, the extra characters are ignored.
+# A string
+#f5ethtrailer.brief_inout_chars: 
+
+# If the platform in the F5 FILEINFO packet matches the provided regex, slot information will be displayed in the info column; otherwise, it will not.  A reasonable value is "^(A.*|Z101)$".  If the regex is empty or there is no platform information in the capture, slot information is always displayed.
+# A string
+#f5ethtrailer.slots_regex: 
+
+# If present, include the RST cause text from the trailer in the "info" column of the packet list pane.
+# TRUE or FALSE (case-insensitive)
+#f5ethtrailer.rstcause_in_info: TRUE
+
+# If enabled, KEYLOG entries will be added to the TLS decode in the f5ethtrailer protocol tree.  It will populate the f5ethtrailer.tls.keylog field.
+# TRUE or FALSE (case-insensitive)
+#f5ethtrailer.generate_keylog: TRUE
+
+# If enabled, reassembly of multi-frame sequences is done
+# TRUE or FALSE (case-insensitive)
+#fc.reassemble: TRUE
+
+# This is the size of non-last frames in a multi-frame sequence
+# A decimal number
+#fc.max_frame_size: 1024
+
+# Whether the FDDI dissector should add 3-byte padding to all captured FDDI packets (useful with e.g. Tru64 UNIX tcpdump)
+# TRUE or FALSE (case-insensitive)
+#fddi.padding: FALSE
+
+# Whether the FCIP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#fcip.desegment: TRUE
+
+# Port number used for FCIP
+# A decimal number
+#fcip.target_port: 3225
+
+# Dissect next layer
+# TRUE or FALSE (case-insensitive)
+#file-pcap.dissect_next_layer: FALSE
+
+# Dissect next layer
+# TRUE or FALSE (case-insensitive)
+#file-pcapng.dissect_next_layer: FALSE
+
+# Whether the FIX dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#fix.desegment: TRUE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to "decode as"
+# TRUE or FALSE (case-insensitive)
+#flexray.try_heuristic_first: FALSE
+
+# With this option display filters for fmp fhandle a RPC call, even if the actual fhandle is only present in one of the packets
+# TRUE or FALSE (case-insensitive)
+#fmp.fhandle_find_both_reqrep: FALSE
+
+# Decode packets on this sctp port as ForCES
+# A decimal number
+#forces.sctp_high_prio_port: 0
+
+# Decode packets on this sctp port as ForCES
+# A decimal number
+#forces.sctp_med_prio_port: 0
+
+# Decode packets on this sctp port as ForCES
+# A decimal number
+#forces.sctp_low_prio_port: 0
+
+# Show reported release info
+# TRUE or FALSE (case-insensitive)
+#fp.show_release_info: TRUE
+
+# Call MAC dissector for payloads
+# TRUE or FALSE (case-insensitive)
+#fp.call_mac: TRUE
+
+# Validate FP payload checksums
+# TRUE or FALSE (case-insensitive)
+#fp.payload_checksum: TRUE
+
+# Validate FP header checksums
+# TRUE or FALSE (case-insensitive)
+#fp.header_checksum: TRUE
+
+# For each PCH data frame, Try to show the paging indications bitmap found in the previous frame
+# TRUE or FALSE (case-insensitive)
+#fp.track_paging_indications: TRUE
+
+# Whether the UID value should be appended in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#fp_mux.uid_in_tree: TRUE
+
+# Whether to try heuristic FP dissectors for the muxed payloads
+# TRUE or FALSE (case-insensitive)
+#fp_mux.call_heur_fp: TRUE
+
+# Encapsulation
+# One of: FRF 3.2/Cisco HDLC, GPRS Network Service, Raw Ethernet, LAPB (T1.617a-1994 Annex G)
+# (case-insensitive).
+#fr.encap: FRF 3.2/Cisco HDLC
+
+# Show offset of frame in capture file
+# TRUE or FALSE (case-insensitive)
+#frame.show_file_off: FALSE
+
+# Treat all frames as DOCSIS Frames
+# TRUE or FALSE (case-insensitive)
+#frame.force_docsis_encap: FALSE
+
+# Whether or not MD5 hashes should be generated for each frame, useful for finding duplicate frames.
+# TRUE or FALSE (case-insensitive)
+#frame.generate_md5_hash: FALSE
+
+# Whether or not an Epoch time entry should be generated for each frame.
+# TRUE or FALSE (case-insensitive)
+#frame.generate_epoch_time: TRUE
+
+# Whether or not the number of bits in the frame should be shown.
+# TRUE or FALSE (case-insensitive)
+#frame.generate_bits_field: TRUE
+
+# Whether or not 'packet size limited during capture' message in shown in Info column.
+# TRUE or FALSE (case-insensitive)
+#frame.disable_packet_size_limited_in_summary: FALSE
+
+# Maximum file size (in megabytes) for export objects  (use 0 for unlimited).
+# A decimal number
+#ftp-data.export.maxsize: 0
+
+# Whether the FireWall-1 summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#fw1.summary_in_tree: TRUE
+
+# Whether the Firewall-1 monitor file includes UUID information
+# TRUE or FALSE (case-insensitive)
+#fw1.with_uuid: FALSE
+
+# Whether the interface list includes the chain position
+# TRUE or FALSE (case-insensitive)
+#fw1.iflist_with_chain: FALSE
+
+# Whether the Gadu-Gadu dissector should reassemble messages spanning multiple TCP segments.To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#gadu-gadu.desegment: TRUE
+
+# Whether the Gearman dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#gearman.desegment: TRUE
+
+# Whether the GED125 dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#ged125.desegment_body: TRUE
+
+# Whether the GIOP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#giop.desegment_giop_messages: TRUE
+
+# Whether fragmented GIOP messages should be reassembled
+# TRUE or FALSE (case-insensitive)
+#giop.reassemble: TRUE
+
+# Maximum allowed message size in bytes (default=10485760)
+# A decimal number
+#giop.max_message_size: 10485760
+
+# File containing stringified IORs, one per line.
+# A path to a file
+#giop.ior_txt: IOR.txt
+
+# Whether the GIT dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#git.desegment: TRUE
+
+# Whether the Gigamon header summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#gmhdr.summary_in_tree: TRUE
+
+# Whether the Gigamon Trailer summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#gmtrailer.summary_in_tree: TRUE
+
+# Whether the Gigamon trailer containing HW timestamp, source id and original CRC should be decoded
+# TRUE or FALSE (case-insensitive)
+#gmtrailer.decode_trailer_timestamp: TRUE
+
+# Make the GeoNetworking dissector analyze GeoNetworking sequence numbers to find and flag duplicate packet (Annex A)
+# TRUE or FALSE (case-insensitive)
+#gnw.analyze_sequence_numbers: TRUE
+
+# Whether to autodetect the cipher bit (because it might be set on unciphered data)
+# TRUE or FALSE (case-insensitive)
+#llcgprs.autodetect_cipher_bit: FALSE
+
+# Help for debug...
+# TRUE or FALSE (case-insensitive)
+#gquic.debug.quic: FALSE
+
+# Normally application/grpc message is protobuf, but sometime the true message is json. If this option in on, we always check whether the message is JSON (body starts with '{' and ends with '}') regardless of grpc_message_type_subdissector_table settings (which dissect grpc message according to content-type).
+# TRUE or FALSE (case-insensitive)
+#grpc.detect_json_automatically: TRUE
+
+# Embed gRPC messages under HTTP2 (or other) protocol tree items.
+# TRUE or FALSE (case-insensitive)
+#grpc.embedded_under_http2: FALSE
+
+# Whether the Gryphon dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#gryphon.desegment: TRUE
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#gsm_ipa.hsl_debug_in_root_tree: FALSE
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#gsm_ipa.hsl_debug_in_info: FALSE
+
+# Whether to decode NRI in TLLI. NRI is not used if length is zero
+# A decimal number
+#gsm_a.rr.nri_length: 0
+
+# Whether the dissector should reassemble SMS spanning multiple packets
+# TRUE or FALSE (case-insensitive)
+#gsm_sms.reassemble: TRUE
+
+# Whether the dissector should take into account info coming from lower layers (like GSM-MAP) to perform SMS reassembly
+# TRUE or FALSE (case-insensitive)
+#gsm_sms.reassemble_with_lower_layers_info: TRUE
+
+# Always decode a GSM Short Message as Connectionless WSP if a Port Number Information Element is present in the SMS User Data Header.
+# TRUE or FALSE (case-insensitive)
+#gsm_sms_ud.port_number_udh_means_wsp: FALSE
+
+# Always try subdissection of the 1st fragment of a fragmented GSM Short Message. If reassembly is possible, the Short Message may be dissected twice (once as a short frame, once in its entirety).
+# TRUE or FALSE (case-insensitive)
+#gsm_sms_ud.try_dissect_1st_fragment: FALSE
+
+# Prevent sub-dissectors from replacing column data with their own. Eg. Prevent WSP dissector overwriting SMPP information.
+# TRUE or FALSE (case-insensitive)
+#gsm_sms_ud.prevent_dissectors_chg_cols: FALSE
+
+# Treat ARFCN 512-810 as DCS 1800 rather than PCS 1900
+# TRUE or FALSE (case-insensitive)
+#gsm_um.dcs1800: TRUE
+
+# Dissect Q.931 User-To-User information
+# TRUE or FALSE (case-insensitive)
+#gsm-r-uus1.dissect_q931_u2u: FALSE
+
+# Dissect GSM-A User-To-User information
+# TRUE or FALSE (case-insensitive)
+#gsm-r-uus1.dissect_gsm_a_u2u: TRUE
+
+# TCAP Subsystem numbers used for GSM MAP
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#gsm_map.tcap.ssn: 6-9,145,148-150
+
+# How to treat Application context
+# One of: Use application context from the trace, Treat as AC 1, Treat as AC 2, Treat as AC 3
+# (case-insensitive).
+#gsm_map.application.context.version: Use application context from the trace
+
+# When enabled, dissector will use the non 3GPP standard extensions from Ericsson (that can override the standard ones)
+# TRUE or FALSE (case-insensitive)
+#gsm_map.ericsson.proprietary.extensions: FALSE
+
+# Whether or not to try reassembling GSSAPI blobs spanning multiple (SMB/SessionSetup) PDUs
+# TRUE or FALSE (case-insensitive)
+#gss-api.gssapi_reassembly: TRUE
+
+# Show GSUP Source/Destination names as text in the Packet Details pane
+# TRUE or FALSE (case-insensitive)
+#gsup.show_name_as_text: TRUE
+
+# GTPv0 and GTP' port (default 3386)
+# A decimal number
+#gtp.v0_port: 3386
+
+# GTPv1 and GTPv2 control plane port (default 2123)
+# A decimal number
+#gtp.v1c_port: 2123
+
+# GTPv1 user plane port (default 2152)
+# A decimal number
+#gtp.v1u_port: 2152
+
+# Dissect T-PDU as
+# One of: None, TPDU Heuristic, PDCP-LTE, PDCP-NR, SYNC, ETHERNET, Custom
+# (case-insensitive).
+#gtp.dissect_tpdu_as: TPDU Heuristic
+
+# Request/reply pair matches only if their timestamps are closer than that value, in ms (default 0, i.e. don't use timestamps)
+# A decimal number
+#gtp.pair_max_interval: 0
+
+# GTP ETSI order
+# TRUE or FALSE (case-insensitive)
+#gtp.check_etsi: FALSE
+
+# Dissect GTP over TCP
+# TRUE or FALSE (case-insensitive)
+#gtp.dissect_gtp_over_tcp: TRUE
+
+# Track GTP session
+# TRUE or FALSE (case-insensitive)
+#gtp.track_gtp_session: FALSE
+
+# Use this setting to decode the Transparent Containers in the SRVCC PS-to-CS messages.
+# This is needed until there's a reliable way to determine the contents of the transparent containers.
+# One of: Don't decode, Assume UTRAN target
+# (case-insensitive).
+#gtpv2.decode_srvcc_p2c_trans_cont_target: Don't decode
+
+# Request/reply pair matches only if their timestamps are closer than that value, in ms (default 0, i.e. don't use timestamps)
+# A decimal number
+#gtpv2.pair_max_interval: 0
+
+# H.225 Server TLS Port
+# A decimal number
+#h225.tls.port: 1300
+
+# Whether the H.225 dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#h225.reassembly: TRUE
+
+# ON - display tunnelled H.245 inside H.225.0 tree, OFF - display tunnelled H.245 in root tree after H.225.0
+# TRUE or FALSE (case-insensitive)
+#h225.h245_in_tree: TRUE
+
+# ON - display tunnelled protocols inside H.225.0 tree, OFF - display tunnelled protocols in root tree after H.225.0
+# TRUE or FALSE (case-insensitive)
+#h225.tp_in_tree: TRUE
+
+# Whether the H.245 dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#h245.reassembly: TRUE
+
+# Whether the dissector should show short names or the long names from the standard
+# TRUE or FALSE (case-insensitive)
+#h245.shorttypes: FALSE
+
+# Whether the dissector should print items of h245 Info column in reversed order
+# TRUE or FALSE (case-insensitive)
+#h245.prepand: FALSE
+
+# Maintain relationships between transactions and contexts and display an extra tree showing context data
+# TRUE or FALSE (case-insensitive)
+#h248.ctx_info: FALSE
+
+# Desegment H.248 messages that span more TCP segments
+# TRUE or FALSE (case-insensitive)
+#h248.desegment: TRUE
+
+# Desegment H.501 messages that span more TCP segments
+# TRUE or FALSE (case-insensitive)
+#h501.desegment: TRUE
+
+# Whether the HART-IP dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#hart_ip.desegment: TRUE
+
+# Whether the hazel dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#hzlcst.desegment: TRUE
+
+# The ethernet type used for L2 communications
+# A decimal number
+#hcrt.dissector_ethertype: 61522
+
+# Specifies that the raw text of the HL7 message should be displayed in addition to the dissection tree
+# TRUE or FALSE (case-insensitive)
+#hl7.display_raw: FALSE
+
+# Specifies that the LLP session information should be displayed (Start/End Of Block) in addition to the dissection tree
+# TRUE or FALSE (case-insensitive)
+#hl7.display_llp: FALSE
+
+# Whether the HPFEEDS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#hpfeeds.desegment_hpfeeds_messages: TRUE
+
+# Try to decode the payload using an heuristic sub-dissector
+# TRUE or FALSE (case-insensitive)
+#hpfeeds.try_heuristic: TRUE
+
+# Whether the HTTP dissector should reassemble headers of a request spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#http.desegment_headers: TRUE
+
+# Whether the HTTP dissector should use the "Content-length:" value, if present, to reassemble the body of a request spanning multiple TCP segments, and reassemble chunked data spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#http.desegment_body: TRUE
+
+# Whether to reassemble bodies of entities that are transferred using the "Transfer-Encoding: chunked" method
+# TRUE or FALSE (case-insensitive)
+#http.dechunk_body: TRUE
+
+# Whether to uncompress entity bodies that are compressed using "Content-Encoding: "
+# TRUE or FALSE (case-insensitive)
+#http.decompress_body: TRUE
+
+# SSL/TLS Ports range
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#http.tls.port: 443
+
+# The UDP port for RROCE messages (default 4791)
+# A decimal number
+#infiniband.rroce.port: 4791
+
+# Try to decode a packet using an heuristic sub-dissector before using Decode As
+# TRUE or FALSE (case-insensitive)
+#infiniband.try_heuristic_first: TRUE
+
+# Maximum number of batch requests allowed
+# A decimal number
+#icep.max_batch_requests: 64
+
+# Maximum length allowed of an ICEP string
+# A decimal number
+#icep.max_ice_string_len: 512
+
+# Maximum number of context pairs allowed
+# A decimal number
+#icep.max_ice_context_pairs: 64
+
+# Whether the 128th and following bytes of the ICMP payload should be decoded as MPLS extensions or as a portion of the original packet
+# TRUE or FALSE (case-insensitive)
+#icmp.favor_icmp_mpls: FALSE
+
+# Length of the Link Address Field, configurable in '101 and absent in '104
+# One of: 0 octet, 1 octet, 2 octet
+# (case-insensitive).
+#iec60870_101.linkaddr_len: 1 octet
+
+# Length of the Cause of Transmission Field, configurable in '101 and fixed at 2 octets with '104
+# One of: 1 octet, 2 octet
+# (case-insensitive).
+#iec60870_101.cot_len: 1 octet
+
+# Length of the Common ASDU Address Field, configurable in '101 and fixed at 2 octets with '104
+# One of: 1 octet, 2 octet
+# (case-insensitive).
+#iec60870_101.asdu_addr_len: 1 octet
+
+# Length of the Information Object Address Field, configurable in '101 and fixed at 3 octets with '104
+# One of: 1 octet, 2 octet, 3 octet
+# (case-insensitive).
+#iec60870_101.asdu_ioa_len: 2 octet
+
+# Whether fragmented 802.11 datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#wlan.defragment: TRUE
+
+# Don't dissect 802.11n draft HT elements (which might contain duplicate information).
+# TRUE or FALSE (case-insensitive)
+#wlan.ignore_draft_ht: FALSE
+
+# Whether retransmitted 802.11 frames should be subdissected
+# TRUE or FALSE (case-insensitive)
+#wlan.retransmitted: TRUE
+
+# Some 802.11 cards include the FCS at the end of a packet, others do not.
+# TRUE or FALSE (case-insensitive)
+#wlan.check_fcs: FALSE
+
+# Whether to validate the FCS checksum or not.
+# TRUE or FALSE (case-insensitive)
+#wlan.check_checksum: FALSE
+
+# Some 802.11 cards leave the Protection bit set even though the packet is decrypted, and some also leave the IV (initialization vector).
+# One of: No, Yes - without IV, Yes - with IV
+# (case-insensitive).
+#wlan.ignore_wep: No
+
+# Whether to enable MIC Length override or not.
+# TRUE or FALSE (case-insensitive)
+#wlan.wpa_key_mic_len_enable: FALSE
+
+# Some Key MIC lengths are greater than 16 bytes, so set the length you require
+# A decimal number
+#wlan.wpa_key_mic_len: 0
+
+# Treat all WiFi packets as S1G
+# TRUE or FALSE (case-insensitive)
+#wlan.treat_as_s1g: FALSE
+
+# Enable WEP and WPA/WPA2 decryption
+# TRUE or FALSE (case-insensitive)
+#wlan.enable_decryption: TRUE
+
+# (Hexadecimal) Ethertype used to indicate IEEE 802.15.4 frame.
+# A hexadecimal number
+#wpan.802154_ethertype: 0x809a
+
+# The FCS format in the captured payload
+# One of: TI CC24xx metadata, ITU-T CRC-16, ITU-T CRC-32
+# (case-insensitive).
+#wpan.fcs_format: ITU-T CRC-16
+
+# Dissect payload only if FCS is valid.
+# TRUE or FALSE (case-insensitive)
+#wpan.802154_fcs_ok: TRUE
+
+# Match frames with ACK request to ACK packets
+# TRUE or FALSE (case-insensitive)
+#wpan.802154_ack_tracking: FALSE
+
+# Parse assuming 802.15.4e quirks for compatibility
+# TRUE or FALSE (case-insensitive)
+#wpan.802154e_compatibility: FALSE
+
+# Specifies the security suite to use for 802.15.4-2003 secured frames (only supported suites are listed). Option ignored for 802.15.4-2006 and unsecured frames.
+# One of: AES-128 Encryption, 128-bit Integrity Protection, AES-128 Encryption, 64-bit Integrity Protection, AES-128 Encryption, 32-bit Integrity Protection
+# (case-insensitive).
+#wpan.802154_sec_suite: AES-128 Encryption, 64-bit Integrity Protection
+
+# Set if the manufacturer extends the authentication data with the security header. Option ignored for 802.15.4-2006 and unsecured frames.
+# TRUE or FALSE (case-insensitive)
+#wpan.802154_extend_auth: TRUE
+
+# (Hexadecimal) Ethertype used to indicate IEEE 802.1ah tag.
+# A hexadecimal number
+#ieee8021ah.8021ah_ethertype: 0x88e7
+
+# Whether the iFCP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ifcp.desegment: TRUE
+
+# Whether the ILP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ilp.desegment_ilp_messages: TRUE
+
+# Whether to use heuristics for post-STARTTLS detection of encrypted IMAP conversations
+# TRUE or FALSE (case-insensitive)
+#imap.ssl_heuristic: TRUE
+
+# TCAP Subsystem numbers used for INAP
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#inap.ssn: 106,241
+
+# Whether the IPDC dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ipdc.desegment_ipdc_messages: TRUE
+
+# Range of session IDs to be decoded as SAMIS-TYPE-1 records
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#ipdr.sessions.samis_type_1: 
+
+# Dissect IPMB commands
+# TRUE or FALSE (case-insensitive)
+#ipmi.dissect_bus_commands: FALSE
+
+# FRU Language Code is English; strings are ASCII+LATIN1 (vs. Unicode)
+# TRUE or FALSE (case-insensitive)
+#ipmi.fru_langcode_is_english: TRUE
+
+# Do not search for responses coming after this timeout (milliseconds)
+# A decimal number
+#ipmi.response_after_req: 5000
+
+# Allow for responses before requests (milliseconds)
+# A decimal number
+#ipmi.response_before_req: 0
+
+# Format of messages embedded into Send/Get/Forward Message
+# One of: None, IPMB, Session-based (LAN, ...), Use heuristics
+# (case-insensitive).
+#ipmi.msgfmt: Use heuristics
+
+# Selects which OEM format is used for commands that IPMI does not define
+# One of: None, Pigeon Point Systems
+# (case-insensitive).
+#ipmi.selected_oem: None
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#ippusb.attempt_reassembly: TRUE
+
+# Whether the IPv4 type-of-service field should be decoded as a Differentiated Services field (see RFC2474/RFC2475)
+# TRUE or FALSE (case-insensitive)
+#ip.decode_tos_as_diffserv: TRUE
+
+# Whether fragmented IPv4 datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#ip.defragment: TRUE
+
+# Whether the IPv4 summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#ip.summary_in_tree: TRUE
+
+# Whether to validate the IPv4 checksum
+# TRUE or FALSE (case-insensitive)
+#ip.check_checksum: FALSE
+
+# Whether to correct for TSO-enabled (TCP segmentation offload) hardware captures, such as spoofing the IP packet length
+# TRUE or FALSE (case-insensitive)
+#ip.tso_support: TRUE
+
+# Whether to look up IP addresses in each MaxMind database we have loaded
+# TRUE or FALSE (case-insensitive)
+#ip.use_geoip: TRUE
+
+# Whether to interpret the originally reserved flag as security flag
+# TRUE or FALSE (case-insensitive)
+#ip.security_flag: FALSE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to a specific port
+# TRUE or FALSE (case-insensitive)
+#ip.try_heuristic_first: FALSE
+
+# Whether fragmented IPv6 datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#ipv6.defragment: TRUE
+
+# Whether the IPv6 summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#ipv6.summary_in_tree: TRUE
+
+# Whether to look up IPv6 addresses in each MaxMind database we have loaded
+# TRUE or FALSE (case-insensitive)
+#ipv6.use_geoip: TRUE
+
+# Check that all RPL Source Routed packets conform to RFC 6554 and do not visit a node more than once
+# TRUE or FALSE (case-insensitive)
+#ipv6.perform_strict_rpl_srh_rfc_checking: FALSE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to a specific port
+# TRUE or FALSE (case-insensitive)
+#ipv6.try_heuristic_first: FALSE
+
+# Whether to display IPv6 extension headers as a separate protocol or a sub-protocol of the IPv6 packet
+# TRUE or FALSE (case-insensitive)
+#ipv6.exthdr_under_root_protocol_tree: FALSE
+
+# If enabled the Length field in octets will be hidden
+# TRUE or FALSE (case-insensitive)
+#ipv6.exthdr_hide_len_oct_field: FALSE
+
+# Whether to correct for TSO-enabled (TCP segmentation offload) hardware captures, such as spoofing the IPv6 packet length
+# TRUE or FALSE (case-insensitive)
+#ipv6.tso_support: FALSE
+
+# The iSCSI protocol version
+# One of: Draft 08, Draft 09, Draft 11, Draft 12, Draft 13
+# (case-insensitive).
+#iscsi.protocol_version: Draft 13
+
+# Whether the iSCSI dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#iscsi.desegment_iscsi_messages: TRUE
+
+# When enabled, packets that appear bogus are ignored
+# TRUE or FALSE (case-insensitive)
+#iscsi.bogus_pdu_filter: TRUE
+
+# Ignore packets that haven't set the F bit when they should have
+# TRUE or FALSE (case-insensitive)
+#iscsi.demand_good_f_bit: FALSE
+
+# Treat packets whose data segment length is greater than this value as bogus
+# A decimal number
+#iscsi.bogus_pdu_max_data_len: 262144
+
+# Range of iSCSI target ports(default 3260)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#iscsi.target_ports: 3260
+
+# System port number of iSCSI target
+# A decimal number
+#iscsi.target_system_port: 860
+
+# The protocol running on the D channel
+# One of: LAPD, DPNSS
+# (case-insensitive).
+#isdn.dchannel_protocol: LAPD
+
+# Range of iSER target ports(default 3260)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#iser.target_ports: 3260
+
+# ISMACryp version
+# One of: ISMACryp v1.1, ISMACryp v2.0
+# (case-insensitive).
+#ismacryp.version: ISMACryp v1.1
+
+# Indicates whether or not the ISMACryp version deduced from RTP payload type, if present, is used or whether the version above is used
+# TRUE or FALSE (case-insensitive)
+#ismacryp.override_rtp_pt: FALSE
+
+# Set the length of the IV in the ISMACryp AU Header in bytes
+# A decimal number
+#ismacryp.iv_length: 4
+
+# Set the length of the Delta IV in the ISMACryp AU Header in bytes
+# A decimal number
+#ismacryp.delta_iv_length: 0
+
+# Set the length of the Key Indicator in the ISMACryp AU Header in bytes
+# A decimal number
+#ismacryp.key_indicator_length: 0
+
+# Indicates whether or not the Key Indicator is present in all AU Headers (T/F)
+# TRUE or FALSE (case-insensitive)
+#ismacryp.key_indicator_per_au_flag: FALSE
+
+# Indicates whether or not selective encryption is enabled (T/F)
+# TRUE or FALSE (case-insensitive)
+#ismacryp.selective_encryption: TRUE
+
+# Indicates whether or not slice start / end is present (T/F)
+# TRUE or FALSE (case-insensitive)
+#ismacryp.slice_indication: FALSE
+
+# Indicates whether or not padding information is present (T/F)
+# TRUE or FALSE (case-insensitive)
+#ismacryp.padding_indication: FALSE
+
+# RFC3640 mode
+# One of: aac-hbr, mpeg4-video, avc-video
+# (case-insensitive).
+#ismacryp.rfc3640_mode: avc-video
+
+# Indicates use of user mode instead of RFC3640 modes (T/F)
+# TRUE or FALSE (case-insensitive)
+#ismacryp.user_mode: FALSE
+
+# Set the length of the AU size in the AU Header in bits
+# A decimal number
+#ismacryp.au_size_length: 0
+
+# Set the length of the AU index in the AU Header in bits
+# A decimal number
+#ismacryp.au_index_length: 0
+
+# Set the length of the AU delta index in the AU Header in bits
+# A decimal number
+#ismacryp.au_index_delta_length: 0
+
+# Set the length of the CTS delta field in the AU Header in bits
+# A decimal number
+#ismacryp.cts_delta_length: 0
+
+# Set the length of the DTS delta field in the AU Header in bits
+# A decimal number
+#ismacryp.dts_delta_length: 0
+
+# Indicates whether or not the RAP field is present in the AU Header (T/F)
+# TRUE or FALSE (case-insensitive)
+#ismacryp.random_access_indication: FALSE
+
+# Indicates the number of bits on which the stream state field is encoded in the AU Header (bits)
+# A decimal number
+#ismacryp.stream_state_indication: 0
+
+# Whether the iSNS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#isns.desegment: TRUE
+
+# FlexRay IDs (combined) - 4bit Bus-ID (0 any), 4bit Channel, 16bit Frame-ID, 8bit Cycle (0xff any)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#iso10681.flexray.flexrayids: 
+
+# TP frames are spread over multiple cycles. Cycle is ignored for matching.
+# TRUE or FALSE (case-insensitive)
+#iso10681.spread_over_cycles: TRUE
+
+# Addressing of ISO 15765. Normal or Extended
+# One of: Normal addressing, Extended addressing
+# (case-insensitive).
+#iso15765.addressing: Normal addressing
+
+# Window of ISO 15765 fragments
+# A decimal number
+#iso15765.window: 8
+
+# ISO15765 bound standard CAN IDs
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#iso15765.can.ids: 
+
+# ISO15765 bound extended CAN IDs
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#iso15765.can.extended_ids: 
+
+# Handle LIN Diagnostic Frames
+# TRUE or FALSE (case-insensitive)
+#iso15765.lin_diag: TRUE
+
+# Addressing of FlexRay TP. 1 Byte or 2 Byte
+# One of: 1 byte addressing, 2 byte addressing
+# (case-insensitive).
+#iso15765.flexray_addressing: 1 byte addressing
+
+# Segment Size Limit for first and consecutive frames of FlexRay (bytes after addresses)
+# A decimal number
+#iso15765.flexray_segment_size_limit: 0
+
+# I-PduM PDU-IDs
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#iso15765.ipdum.pdu.id: 
+
+# Addressing of I-PduM TP. 0, 1, or 2 Bytes
+# One of: 0 byte addressing, 1 byte addressing, 2 byte addressing
+# (case-insensitive).
+#iso15765.ipdum_addressing: 0 byte addressing
+
+# Endian of the length field. Big endian or Little endian
+# One of: Big endian, Little endian
+# (case-insensitive).
+#iso8583.len_endian: Little endian
+
+#  charset for numbers
+# One of: Digits represented as ASCII Characters, Digits represented in nibbles
+# (case-insensitive).
+#iso8583.charset: Digits represented as ASCII Characters
+
+#  binary data representation
+# One of: Bin data represented as Hex Ascii characters, Bin data not encoded
+# (case-insensitive).
+#iso8583.binencode: Bin data represented as Hex Ascii characters
+
+# File containing a translation from object ID to string
+# A path to a file
+#isobus.vt.object_ids: 
+
+# Note national variants may not be fully supported
+# One of: ITU Standard, French National Standard, Israeli National Standard, Russian National Standard, Japan National Standard, Japan National Standard (TTC)
+# (case-insensitive).
+#isup.variant: ITU Standard
+
+# Show the CIC value (in addition to the message type) in the Info column
+# TRUE or FALSE (case-insensitive)
+#isup.show_cic_in_info: TRUE
+
+# Whether APM messages datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#isup.defragment_apm: TRUE
+
+# The MPLS label (aka Flow Bundle ID) used by ITDM traffic.
+# A hexadecimal number
+#itdm.mpls_label: 0x99887
+
+# Flow Number used by I-TDM Control Protocol traffic.
+# A decimal number
+#itdm.ctl_flowno: 0
+
+# Support Implementers Guide (version 01)
+# TRUE or FALSE (case-insensitive)
+#iua.support_ig: FALSE
+
+# Use SAPI values as specified in TS 48 056
+# TRUE or FALSE (case-insensitive)
+#iua.use_gsm_sapi_values: TRUE
+
+# Whether IuUP Payload bits should be dissected
+# TRUE or FALSE (case-insensitive)
+#iuup.dissect_payload: FALSE
+
+# The payload contains a two byte pseudoheader indicating direction and circuit_id
+# TRUE or FALSE (case-insensitive)
+#iuup.two_byte_pseudoheader: FALSE
+
+# Whether the iWarp RDMA dissector should reassemble Send fragmented payloads
+# TRUE or FALSE (case-insensitive)
+#iwarp_ddp_rdmap.reassemble_iwarp_rdma_send: TRUE
+
+# Whether the trailer summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#ixiatrailer.summary_in_tree: TRUE
+
+# Display JSON like in browsers devtool
+# TRUE or FALSE (case-insensitive)
+#json.compact_form: FALSE
+
+# Leading bytes will be ignored until first '[' or '{' is found.
+# TRUE or FALSE (case-insensitive)
+#json.ignore_leading_bytes: FALSE
+
+# Hide extended path based filtering
+# TRUE or FALSE (case-insensitive)
+#json.hide_extended_path_based_filtering: FALSE
+
+# Replace character escapes with the escaped literal value
+# TRUE or FALSE (case-insensitive)
+#json.unescape_strings: FALSE
+
+# Enable to have correctly typed MIME media dissected as JXTA Messages.
+# TRUE or FALSE (case-insensitive)
+#jxta.msg.mediatype: TRUE
+
+# Whether the JXTA dissector should reassemble messages spanning multiple UDP/TCP/SCTP segments. To use this option you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings  and enable "Reassemble fragmented IP datagrams" in the IP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#jxta.desegment: TRUE
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#kafka.show_string_bytes_lengths: FALSE
+
+# Keyring.XML file (exported from ETS)
+# A path to a file
+#kip.key_file: 
+
+# Keyring password
+# A string
+#kip.key_file_pwd: 
+
+# Output file (- for stdout) for keys extracted from key file
+# A path to a file
+#kip.key_info_file: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_1: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_2: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_3: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_4: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_5: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_6: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_7: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_8: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_9: 
+
+# KNX decryption key (format: 16 bytes as hex; example: A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF)
+# A string
+#kip.key_10: 
+
+# Whether the KNX/IP dissector should reassemble messages spanning multiple TCP segments.  To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#kip.desegment: TRUE
+
+# Whether the Kpasswd dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#kpasswd.desegment: TRUE
+
+# Whether the Kerberos dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#kerberos.desegment: TRUE
+
+# Whether the dissector should try to decrypt encrypted Kerberos blobs. This requires that the proper keytab file is installed as well.
+# TRUE or FALSE (case-insensitive)
+#kerberos.decrypt: FALSE
+
+# The keytab file containing all the secrets
+# A path to a file
+#kerberos.file: 
+
+# KT allows binary values in keys and values. Attempt to show an ASCII representation anyway (which might be prematurely terminated by a NULL!
+# TRUE or FALSE (case-insensitive)
+#kt.present_key_val_as_ascii: FALSE
+
+# Whether the L&G 8979 dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#lg8979.desegment: TRUE
+
+# L2TPv3 Cookie Size
+# One of: Detect, None, 4 Byte Cookie, 8 Byte Cookie
+# (case-insensitive).
+#l2tp.cookie_size: Detect
+
+# L2TPv3 L2-Specific Sublayer
+# One of: Detect, None, Default L2-Specific, ATM-Specific, LAPD-Specific, DOCSIS DMPT-Specific
+# (case-insensitive).
+#l2tp.l2_specific: Detect
+
+# Shared secret used for control message digest authentication
+# A string
+#l2tp.shared_secret: 
+
+# Use SAPI values as specified in TS 48 056
+# TRUE or FALSE (case-insensitive)
+#lapd.use_gsm_sapi_values: FALSE
+
+# Whether the dissector should defragment LAPDm messages spanning multiple packets.
+# TRUE or FALSE (case-insensitive)
+#lapdm.reassemble: TRUE
+
+# Whether the Laplink dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#laplink.desegment_laplink_over_tcp: TRUE
+
+# Whether the LDAP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ldap.desegment_ldap_messages: TRUE
+
+# Set the port for LDAP operations over TLS
+# A decimal number
+#ldap.tls.port: 636
+
+# Whether the LDP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ldp.desegment_ldp_messages: TRUE
+
+# Which Information will be showed at Column Information is decided by the selection
+# One of: Default Column Info, PROFINET Special Column Info
+# (case-insensitive).
+#lldp.column_info_selection: Default Column Info
+
+# Dissect this ethertype as LLT traffic in addition to the default, 0xCAFE.
+# A hexadecimal number
+#llt.alternate_ethertype: 0
+
+# Whether LMP contains a checksum which can be checked
+# TRUE or FALSE (case-insensitive)
+#lmp.checksum: FALSE
+
+# There might be plugins corresponding to different version of the specification If they are present they should be listed here.
+# One of: FD1, Rel8 dec 2008
+# (case-insensitive).
+#log3gpp.rrc_release_version: Rel8 dec 2008
+
+# There might be plugins corresponding to different version of the specification If they are present they should be listed here.
+# One of: FD1, Rel8 dec 2008
+# (case-insensitive).
+#log3gpp.nas_eps_release_version: Rel8 dec 2008
+
+# Use oneline info column by replace all new line characters by spaces
+# TRUE or FALSE (case-insensitive)
+#logcat.oneline_info_column: TRUE
+
+# Whether the NAS PDU should be shown in the root packet details tree
+# TRUE or FALSE (case-insensitive)
+#lte_rrc.nas_in_root_tree: FALSE
+
+# Whether the dissector should analyze the sequencing and cross-references of the segments within each session.
+# TRUE or FALSE (case-insensitive)
+#ltp.analyze_sequence: TRUE
+
+# Whether the dissector should combine block segments together into a full block.
+# TRUE or FALSE (case-insensitive)
+#ltp.reassemble_block: TRUE
+
+# Swap frame control bytes (needed for some APs).
+# TRUE or FALSE (case-insensitive)
+#lwapp.swap_fc: FALSE
+
+# Whether to validate the LWL4 crc when crc bit is not set
+# TRUE or FALSE (case-insensitive)
+#lwl4.check_crc: TRUE
+
+# 128-bit decryption key in hexadecimal format
+# A string
+#lwm.lwmes_key: 
+
+# Version used by Wireshark
+# One of: Internet Draft version 2, Internet Draft version 8, RFC 4165
+# (case-insensitive).
+#m2pa.version: RFC 4165
+
+# The value of the parameter tag for protocol data 1
+# One of: 0x000e (Draft 7), 0x0300 (RFC3331)
+# (case-insensitive).
+#m2ua.protocol_data_1_tag: 0x0300 (RFC3331)
+
+# Version used by Wireshark
+# One of: Internet Draft version 5, Internet Draft version 6, Internet Draft version 7, RFC 4666
+# (case-insensitive).
+#m3ua.version: RFC 4666
+
+# TSN size in bits, either 6 or 14 bit
+# One of: 6 bits, 14 bits
+# (case-insensitive).
+#mac.tsn_size: 6 bits
+
+# Number of Re-Transmits before expert warning triggered
+# A decimal number
+#mac-lte.retx_count_warn: 3
+
+# Attempt to decode BCH, PCH and CCCH data using LTE RRC dissector
+# TRUE or FALSE (case-insensitive)
+#mac-lte.attempt_rrc_decode: TRUE
+
+# Attempt to dissect frames that have failed CRC check
+# TRUE or FALSE (case-insensitive)
+#mac-lte.attempt_to_dissect_crc_failures: FALSE
+
+# Will call LTE RLC dissector with standard settings as per RRC spec
+# TRUE or FALSE (case-insensitive)
+#mac-lte.attempt_to_dissect_srb_sdus: TRUE
+
+# Will call LTE RLC dissector for MCH LCID 0
+# TRUE or FALSE (case-insensitive)
+#mac-lte.attempt_to_dissect_mcch: FALSE
+
+# Call RLC dissector MTCH LCIDs
+# TRUE or FALSE (case-insensitive)
+#mac-lte.call_rlc_for_mtch: FALSE
+
+# Set whether LCID -> drb Table is taken from static table (below) or from info learned from control protocol (e.g. RRC)
+# One of: From static table, From configuration protocol
+# (case-insensitive).
+#mac-lte.lcid_to_drb_mapping_source: From static table
+
+# If any BSR report is >= this number, an expert warning will be added
+# A decimal number
+#mac-lte.bsr_warn_threshold: 50
+
+# Track status of SRs, providing links between requests, failure indications and grants
+# TRUE or FALSE (case-insensitive)
+#mac-lte.track_sr: TRUE
+
+# Can show PHY, MAC or RLC layer info in Info column
+# One of: PHY Info, MAC Info, RLC Info
+# (case-insensitive).
+#mac-lte.layer_to_show: RLC Info
+
+# Attempt to decode 6 bytes of Contention Resolution body as an UL CCCH PDU
+# TRUE or FALSE (case-insensitive)
+#mac-lte.decode_cr_body: FALSE
+
+# Apply DRX config and show DRX state within each UE
+# TRUE or FALSE (case-insensitive)
+#mac-lte.show_drx: FALSE
+
+# Add as a generated field the middle of the range indicated by the BSR index
+# TRUE or FALSE (case-insensitive)
+#mac-lte.show_bsr_median: FALSE
+
+# Attempt to decode BCCH, PCCH and CCCH data using NR RRC dissector
+# TRUE or FALSE (case-insensitive)
+#mac-nr.attempt_rrc_decode: TRUE
+
+# Will call NR RLC dissector with standard settings as per RRC spec
+# TRUE or FALSE (case-insensitive)
+#mac-nr.attempt_to_dissect_srb_sdus: TRUE
+
+# Set whether LCID -> drb Table is taken from static table (below) or from info learned from control protocol (i.e. RRC)
+# One of: From static table, From configuration protocol
+# (case-insensitive).
+mac-nr.lcid_to_drb_mapping_source: From configuration protocol
+
+# The name of the file containing the mate module's configuration
+# A path to a file
+#mate.config: 
+
+# Decode control data received on "usb.control" with an unknown interface class as MBIM
+# TRUE or FALSE (case-insensitive)
+#mbim.control_decode_unknown_itf: FALSE
+
+# Format used for SMS PDU decoding
+# One of: Automatic, 3GPP, 3GPP2
+# (case-insensitive).
+#mbim.sms_pdu_format: Automatic
+
+# No description
+# One of: 1.0, 2.0, 3.0, 4.0
+# (case-insensitive).
+#mbim.extended_version: 1.0
+
+# Set the UDP port for the MCPE Server
+# A decimal number
+#mcpe.udp.port: 19132
+
+# A frame is considered for decoding as MDSHDR if either ethertype is 0xFCFC or zero. Turn this flag off if you don't want ethertype zero to be decoded as MDSHDR. This might be useful to avoid problems with test frames.
+# TRUE or FALSE (case-insensitive)
+#mdshdr.decode_if_etype_zero: FALSE
+
+# Specifies that the raw text of the MEGACO message should be displayed instead of (or in addition to) the dissection tree
+# TRUE or FALSE (case-insensitive)
+#megaco.display_raw_text: TRUE
+
+# Specifies that the dissection tree of the MEGACO message should be displayed instead of (or in addition to) the raw text
+# TRUE or FALSE (case-insensitive)
+#megaco.display_dissect_tree: TRUE
+
+# Maintain relationships between transactions and contexts and display an extra tree showing context data
+# TRUE or FALSE (case-insensitive)
+#megaco.ctx_info: FALSE
+
+# Whether the MEMCACHE dissector should reassemble headers of a request spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#memcache.desegment_headers: TRUE
+
+# Whether the memcache dissector should reassemble PDUs spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#memcache.desegment_pdus: TRUE
+
+# Set the UDP port for gateway messages (if other than the default of 2427)
+# A decimal number
+#mgcp.tcp.gateway_port: 2427
+
+# Set the TCP port for gateway messages (if other than the default of 2427)
+# A decimal number
+#mgcp.udp.gateway_port: 2427
+
+# Set the TCP port for callagent messages (if other than the default of 2727)
+# A decimal number
+#mgcp.tcp.callagent_port: 2727
+
+# Set the UDP port for callagent messages (if other than the default of 2727)
+# A decimal number
+#mgcp.udp.callagent_port: 2727
+
+# Specifies that the raw text of the MGCP message should be displayed instead of (or in addition to) the dissection tree
+# TRUE or FALSE (case-insensitive)
+#mgcp.display_raw_text: FALSE
+
+# Display the number of MGCP messages found in a packet in the protocol column.
+# TRUE or FALSE (case-insensitive)
+#mgcp.display_mgcp_message_count: FALSE
+
+# Display multipart bodies with no media type dissector as raw text (may cause problems with binary data).
+# TRUE or FALSE (case-insensitive)
+#mime_multipart.display_unknown_body_as_text: FALSE
+
+# Remove any base64 content-transfer encoding from bodies. This supports export of the body and its further dissection.
+# TRUE or FALSE (case-insensitive)
+#mime_multipart.remove_base64_encoding: FALSE
+
+# Uncompress parts which are compressed. GZIP for example. This supports export of the body and its further dissection.
+# TRUE or FALSE (case-insensitive)
+#mime_multipart.uncompress_data: TRUE
+
+# Dissect payload only if MIC is valid.
+# TRUE or FALSE (case-insensitive)
+#mle.meshlink_mic_ok: FALSE
+
+# Register Format
+# One of: UINT16     , INT16      , UINT32     , INT32      , IEEE FLT   , MODICON FLT
+# (case-insensitive).
+#modbus.mbus_register_format: UINT16     
+
+# Whether the Modbus RTU dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#mbrtu.desegment: TRUE
+
+# Whether to validate the CRC
+# TRUE or FALSE (case-insensitive)
+#mbrtu.crc_verification: FALSE
+
+# Whether the Modbus RTU dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#mbtcp.desegment: TRUE
+
+# Whether the section dissector should verify the CRC or checksum
+# TRUE or FALSE (case-insensitive)
+#mpeg_dsmcc.verify_crc: FALSE
+
+# Whether the section dissector should verify the CRC
+# TRUE or FALSE (case-insensitive)
+#mpeg_sect.verify_crc: FALSE
+
+# Lowest label is used to segregate flows inside a pseudowire
+# TRUE or FALSE (case-insensitive)
+#mpls.flowlabel_in_mpls_header: FALSE
+
+# Enable to allow non-zero Length in Control Word. This may be needed to correctly decode traffic from some legacy devices which generate non-zero Length even if there is no padding in the packet. Note that Length should have proper value (dissector checks this anyway).
+# 
+# Disable to blame all packets with CW.Length <> 0. This conforms to RFC4717.
+# TRUE or FALSE (case-insensitive)
+#mplspwatmaal5sdu.allow_cw_length_nonzero_aal5: FALSE
+
+# Enable to use reserved bits (8..9) of Control Word as an extension of CW.Length. This may be needed to correctly decode traffic from some legacy devices which uses reserved bits as extension of Length
+# 
+# Disable to blame all packets with CW.Reserved <> 0. This conforms to RFC4717.
+# TRUE or FALSE (case-insensitive)
+#mplspwatmaal5sdu.extend_cw_length_with_rsvd_aal5: FALSE
+
+# Enable to allow non-zero Length in Control Word. This may be needed to correctly decode traffic from some legacy devices which generate non-zero Length even if there is no padding in the packet. Note that Length should have proper value (dissector checks this anyway).
+# 
+# Disable to blame all packets with CW.Length <> 0. This conforms to RFC4717.
+# TRUE or FALSE (case-insensitive)
+#mplspwatmn1cw.allow_cw_length_nonzero: FALSE
+
+# Enable to use reserved bits (8..9) of Control Word as an extension of CW.Length. This may be needed to correctly decode traffic from some legacy devices which uses reserved bits as extension of Length
+# 
+# Disable to blame all packets with CW.Reserved <> 0. This conforms to RFC4717.
+# TRUE or FALSE (case-insensitive)
+#mplspwatmn1cw.extend_cw_length_with_rsvd: FALSE
+
+# To use this option you must also enable "Analyze TCP sequence numbers". 
+# TRUE or FALSE (case-insensitive)
+#mptcp.analyze_mptcp: TRUE
+
+# In case you don't capture the key, it will use the first DSN seen
+# TRUE or FALSE (case-insensitive)
+#mptcp.relative_sequence_numbers: TRUE
+
+# Scales logarithmically with the number of packetsYou need to capture the handshake for this to work."Map TCP subflows to their respective MPTCP connections"
+# TRUE or FALSE (case-insensitive)
+#mptcp.analyze_mappings: FALSE
+
+# (Greedy algorithm: Scales linearly with number of subflows and logarithmic scaling with number of packets)You need to enable DSS mapping analysis for this option to work
+# TRUE or FALSE (case-insensitive)
+#mptcp.intersubflows_retransmission: FALSE
+
+# Whether the MQ dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#mq.desegment: TRUE
+
+# Whether the MQ dissector should reassemble MQ messages spanning multiple TSH segments
+# TRUE or FALSE (case-insensitive)
+#mq.reassembly: TRUE
+
+# When dissecting PCF there can be a lot of parameters. You can limit the number of parameter decoded, before it continue with the next PCF.
+# A decimal number
+#mqpcf.maxprm: 999
+
+# When dissecting a parameter of a PCFm, if it is a StringList, IntegerList or Integer64 List,  You can limit the number of elements displayed, before it continues with the next Parameter.
+# A decimal number
+#mqpcf.maxlst: 20000
+
+# Select the MQTT version to use as protocol version if the CONNECT packet is not captured
+# One of: None, MQTT v3.1, MQTT v3.1.1, MQTT v5.0
+# (case-insensitive).
+#mqtt.default_version: None
+
+# Show Publish Message as text
+# TRUE or FALSE (case-insensitive)
+#mqtt.show_msg_as_text: FALSE
+
+# Specifies that the raw text of the MSRP message should be displayed in addition to the dissection tree
+# TRUE or FALSE (case-insensitive)
+#msrp.display_raw_text: TRUE
+
+# Where available, show which protocol and frame caused this MSRP stream to be created
+# TRUE or FALSE (case-insensitive)
+#msrp.show_setup_info: TRUE
+
+# Whether the MTP2 dissector should use extended sequence numbers as described in Q.703, Annex A as a default.
+# TRUE or FALSE (case-insensitive)
+#mtp2.use_extended_sequence_numbers: FALSE
+
+# Some SS7 capture hardware includes the FCS at the end of the packet, others do not.
+# TRUE or FALSE (case-insensitive)
+#mtp2.capture_contains_frame_check_sequence: FALSE
+
+# Reverse the bit order inside bytes specified in Q.703.
+# TRUE or FALSE (case-insensitive)
+#mtp2.reverse_bit_order_mtp2: FALSE
+
+# This only works for SCCP traffic for now
+# TRUE or FALSE (case-insensitive)
+#mtp3.heuristic_standard: FALSE
+
+# The SS7 standard used in MTP3 packets
+# One of: ITU, ANSI, Chinese ITU, Japan
+# (case-insensitive).
+#mtp3.standard: ITU
+
+# The structure of the pointcodes in ITU networks
+# One of: Unstructured, 3-8-3, 4-3-4-3
+# (case-insensitive).
+#mtp3.itu_pc_structure: Unstructured
+
+# The structure of the pointcodes in Japan networks
+# One of: Unstructured, 7-4-5, 3-4-4-5
+# (case-insensitive).
+#mtp3.japan_pc_structure: Unstructured
+
+# Use 5-bit (instead of 8-bit) SLS in ANSI MTP3 packets
+# TRUE or FALSE (case-insensitive)
+#mtp3.ansi_5_bit_sls: FALSE
+
+# Use 5-bit (instead of 4-bit) SLS in Japan MTP3 packets
+# TRUE or FALSE (case-insensitive)
+#mtp3.japan_5_bit_sls: FALSE
+
+# Format for point code in the address columns
+# One of: Decimal, Hexadecimal, NI-Decimal, NI-Hexadecimal, Dashed
+# (case-insensitive).
+#mtp3.addr_format: Dashed
+
+# Decode the spare bits of the SIO as the MSU priority (a national option in ITU)
+# TRUE or FALSE (case-insensitive)
+#mtp3.itu_priority: FALSE
+
+# Whether the MySQL dissector should reassemble MySQL buffers spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#mysql.desegment_buffers: TRUE
+
+# Whether the MySQL dissector should display the SQL query string in the INFO column.
+# TRUE or FALSE (case-insensitive)
+#mysql.show_sql_query: FALSE
+
+# This should work when the NAS ciphering algorithm is NULL (5G-EEA0)
+# TRUE or FALSE (case-insensitive)
+nas-5gs.null_decipher: TRUE
+
+# No description
+# One of: None, IP, Non IP, Ethernet
+# (case-insensitive).
+#nas-5gs.decode_user_data_container_as: None
+
+# No description
+# A string
+#nas-5gs.non_ip_data_dissector: 
+
+# Always dissect NAS EPS messages as plain
+# TRUE or FALSE (case-insensitive)
+#nas-eps.dissect_plain: FALSE
+
+# This should work when the NAS ciphering algorithm is NULL (128-EEA0)
+# TRUE or FALSE (case-insensitive)
+#nas-eps.null_decipher: TRUE
+
+# No description
+# One of: None, IP, Non IP, Ethernet
+# (case-insensitive).
+#nas-eps.decode_user_data_container_as: None
+
+# No description
+# A string
+#nas-eps.non_ip_data_dissector: 
+
+# Whether the Nasdaq ITCH dissector should decode Chi X extensions.
+# TRUE or FALSE (case-insensitive)
+#nasdaq_itch.chi_x: TRUE
+
+# Whether the Nasdaq-SoupTCP dissector should reassemble messages spanning multiple TCP segments.
+# TRUE or FALSE (case-insensitive)
+#nasdaq_soup.desegment: TRUE
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch1_content: MAC_CONTENT_DCCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch2_content: MAC_CONTENT_DCCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch3_content: MAC_CONTENT_DCCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch4_content: MAC_CONTENT_DCCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch5_content: MAC_CONTENT_CS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch6_content: MAC_CONTENT_CS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch7_content: MAC_CONTENT_CS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch8_content: MAC_CONTENT_DCCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch9_content: MAC_CONTENT_PS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch10_content: MAC_CONTENT_UNKNOWN
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch11_content: MAC_CONTENT_PS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch12_content: MAC_CONTENT_PS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch13_content: MAC_CONTENT_CS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch14_content: MAC_CONTENT_PS_DTCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch15_content: MAC_CONTENT_CCCH
+
+# foo
+# One of: MAC_CONTENT_UNKNOWN, MAC_CONTENT_DCCH, MAC_CONTENT_PS_DTCH, MAC_CONTENT_CS_DTCH, MAC_CONTENT_CCCH
+# (case-insensitive).
+#nbap.lch16_content: MAC_CONTENT_DCCH
+
+# Encoding used for the IB-SG-DATA element carrying segments of information blocks
+# One of: Encoding Variant 1 (TS 25.433 Annex D.2), Encoding Variant 2 (TS 25.433 Annex D.3)
+# (case-insensitive).
+#nbap.ib_sg_data_encoding: Encoding Variant 1 (TS 25.433 Annex D.2)
+
+# Whether the NBD dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings
+# TRUE or FALSE (case-insensitive)
+#nbd.desegment_nbd_messages: TRUE
+
+# Whether the NBSS dissector should reassemble packets spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#nbss.desegment_nbss_commands: TRUE
+
+# Whether the NCP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ncp.desegment: TRUE
+
+# Whether the NCP dissector should defragment NDS messages spanning multiple reply packets.
+# TRUE or FALSE (case-insensitive)
+#ncp.defragment_nds: TRUE
+
+# Dissect the NetWare Information Structure as NetWare 5.x or higher or as older NetWare 3.x.
+# TRUE or FALSE (case-insensitive)
+#ncp.newstyle: TRUE
+
+# Whether the NCP dissector should echo the NDS Entry ID to name resolves to the expert table.
+# TRUE or FALSE (case-insensitive)
+#ncp.eid_2_expert: TRUE
+
+# Whether the NCP dissector should echo NCP connection information to the expert table.
+# TRUE or FALSE (case-insensitive)
+#ncp.connection_2_expert: FALSE
+
+# Whether the NCP dissector should echo protocol errors to the expert table.
+# TRUE or FALSE (case-insensitive)
+#ncp.error_2_expert: TRUE
+
+# Whether the NCP dissector should echo server information to the expert table.
+# TRUE or FALSE (case-insensitive)
+#ncp.server_2_expert: TRUE
+
+# Whether the NCP dissector should echo file open/close/oplock information to the expert table.
+# TRUE or FALSE (case-insensitive)
+#ncp.file_2_expert: FALSE
+
+# Version of the NDMP protocol to assume if the version can not be automatically detected from the capture
+# One of: Version 2, Version 3, Version 4, Version 5
+# (case-insensitive).
+#ndmp.default_protocol_version: Version 4
+
+# Whether the NDMP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ndmp.desegment: TRUE
+
+# Whether the dissector should defragment NDMP messages spanning multiple packets.
+# TRUE or FALSE (case-insensitive)
+#ndmp.defragment: TRUE
+
+# Whether the NDPS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ndps.desegment_tcp: TRUE
+
+# Whether the NDPS dissector should reassemble fragmented NDPS messages spanning multiple SPX packets
+# TRUE or FALSE (case-insensitive)
+#ndps.desegment_spx: TRUE
+
+# Whether or not the NDPS dissector should show object id's and other details
+# TRUE or FALSE (case-insensitive)
+#ndps.show_oid: FALSE
+
+# Whether the NetBIOS dissector should defragment messages spanning multiple frames
+# TRUE or FALSE (case-insensitive)
+#netbios.defragment: TRUE
+
+# Whether the Netsync dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#netsync.desegment_netsync_messages: TRUE
+
+# Whether the dissector should snoop the FH to filename mappings by looking inside certain packets
+# TRUE or FALSE (case-insensitive)
+#nfs.file_name_snooping: FALSE
+
+# Whether the dissector should snoop the full pathname for files for matching FH's
+# TRUE or FALSE (case-insensitive)
+#nfs.file_full_name_snooping: FALSE
+
+# With this option display filters for nfs fhandles (nfs.fh.{name|full_name|hash}) will find both the request and response packets for a RPC call, even if the actual fhandle is only present in one of the packets
+# TRUE or FALSE (case-insensitive)
+#nfs.fhandle_find_both_reqrep: FALSE
+
+# When enabled, this option will print the NFSv4 tag (if one exists) in the Info column in the Summary pane
+# TRUE or FALSE (case-insensitive)
+#nfs.display_nfsv4_tag: TRUE
+
+# When enabled, shows only the significant NFSv4 Operations in the info column.  Others (like GETFH, PUTFH, etc) are not displayed
+# TRUE or FALSE (case-insensitive)
+#nfs.display_major_nfsv4_ops: TRUE
+
+# Dissect TransparentContainers that are opaque to NGAP
+# TRUE or FALSE (case-insensitive)
+#ngap.dissect_container: TRUE
+
+# Select whether target NG-RAN container should be decoded automatically (based on NG Setup procedure) or manually
+# One of: automatic, gNB, ng-eNB
+# (case-insensitive).
+#ngap.dissect_target_ng_ran_container_as: automatic
+
+# Select whether LTE container should be dissected as NB-IOT or legacy LTE
+# One of: Automatic, Legacy LTE, NB-IoT
+# (case-insensitive).
+#ngap.dissect_lte_container_as: Automatic
+
+# Whether the Authentication Extension data contains the source address. Some Cisco IOS implementations forgo this part of RFC2332.
+# TRUE or FALSE (case-insensitive)
+#nhrp.auth_ext_has_addr: TRUE
+
+# Whether the dissector will track and match MSG and RES calls for asynchronous NLM
+# TRUE or FALSE (case-insensitive)
+#nlm.msg_res_matching: FALSE
+
+# Whether the NAS PDU should be shown in the root packet details tree
+# TRUE or FALSE (case-insensitive)
+#nr-rrc.nas_in_root_tree: FALSE
+
+# NT Password (used to decrypt payloads)
+# A string
+#ntlmssp.nt_password: 
+
+# Range of NVMe Subsystem ports(default 4420)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#nvme-rdma.subsystem_ports: 4420
+
+# Range of NVMe Subsystem ports(default 4420)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#nvme-tcp.subsystem_ports: 4420
+
+# Whether to validate the PDU header digest or not.
+# TRUE or FALSE (case-insensitive)
+#nvme-tcp.check_hdgst: FALSE
+
+# Whether to validate the PDU data digest or not.
+# TRUE or FALSE (case-insensitive)
+#nvme-tcp.check_ddgst: FALSE
+
+# The bit width of DU Port ID, sum of a,b,c&d must be 16
+# A decimal number
+#oran_fh_cus.oran.du_port_id_bits: 2
+
+# The bit width of BandSector ID, sum of a,b,c&d must be 16
+# A decimal number
+#oran_fh_cus.oran.bandsector_id_bits: 6
+
+# The bit width of CC ID, sum of a,b,c&d must be 16
+# A decimal number
+#oran_fh_cus.oran.cc_id_bits: 4
+
+# The bit width of RU Port ID, sum of a,b,c&d must be 16
+# A decimal number
+#oran_fh_cus.oran.ru_port_id_bits: 4
+
+# The bit width of a sample in the Uplink
+# A decimal number
+#oran_fh_cus.oran.iq_bitwidth_up: 14
+
+# Uplink User Data Compression
+# One of: No Compression, Block Floating Point Compression, Block Scaling Compression, u-Law Compression, Modulation Compression, BFP + selective RE sending, mod-compr + selective RE sending
+# (case-insensitive).
+#oran_fh_cus.oran.ud_comp_up: Block Floating Point Compression
+
+# The udCompHdr field in U-Plane messages may or may not be present, depending on the configuration of the O-RU. This preference instructs the dissector to expect this field to be present in uplink messages.
+# TRUE or FALSE (case-insensitive)
+#oran_fh_cus.oran.ud_comp_hdr_up: FALSE
+
+# The bit width of a sample in the Downlink
+# A decimal number
+#oran_fh_cus.oran.iq_bitwidth_down: 14
+
+# Downlink User Data Compression
+# One of: No Compression, Block Floating Point Compression, Block Scaling Compression, u-Law Compression, Modulation Compression, BFP + selective RE sending, mod-compr + selective RE sending
+# (case-insensitive).
+#oran_fh_cus.oran.ud_comp_down: Block Floating Point Compression
+
+# The udCompHdr field in U-Plane messages may or may not be present, depending on the configuration of the O-RU. This preference instructs the dissector to expect this field to be present in downlink messages.
+# TRUE or FALSE (case-insensitive)
+#oran_fh_cus.oran.ud_comp_hdr_down: FALSE
+
+# This is used if numPrbu is signalled as 0
+# A decimal number
+#oran_fh_cus.oran.rbs_in_uplane_section: 273
+
+# Used in decoding of section extension type 11 (Flexible BF weights)
+# A decimal number
+#oran_fh_cus.oran.num_weights_per_bundle: 32
+
+# Number of BF Antennas (used for C section type 6)
+# A decimal number
+#oran_fh_cus.oran.num_bf_antennas: 32
+
+# When enabled, for U-Plane frames show each I and Q value in PRB.
+# TRUE or FALSE (case-insensitive)
+#oran_fh_cus.oran.show_iq_samples: TRUE
+
+# Whether the dissector should put the internal OER data in the tree or if it should hide it
+# TRUE or FALSE (case-insensitive)
+#oer.display_internal_oer_fields: FALSE
+
+# Dissect custom olsr.org message types (compatible with rfc routing agents)
+# TRUE or FALSE (case-insensitive)
+#olsr.ff_olsrorg: TRUE
+
+# Dissect custom nrlolsr tc message (incompatible with rfc routing agents)
+# TRUE or FALSE (case-insensitive)
+#olsr.nrlolsr: TRUE
+
+# SSL/TLS Ports range
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#opa.fe.tls.port: 3249-3252
+
+# Attempt to parse mad payload even when MAD.Status is non-zero
+# TRUE or FALSE (case-insensitive)
+#opa.mad.parse_mad_error: FALSE
+
+# Attempt to reassemble the mad payload of RMPP segments
+# TRUE or FALSE (case-insensitive)
+#opa.mad.reassemble_rmpp: TRUE
+
+# Whether the OpenFlow dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#openflow.desegment: TRUE
+
+# To be able to fully dissect SSDO and SPDO packages, a valid UDID for the SCM has to be provided
+# A string
+#opensafety.scm_udid: 00:00:00:00:00:00
+
+# Automatically assign a detected SCM UDID (by reading SNMT->SNTM_assign_UDID_SCM) and set it for the file
+# TRUE or FALSE (case-insensitive)
+#opensafety.scm_udid_autoset: TRUE
+
+# A comma-separated list of nodes to be filtered during dissection
+# A string
+#opensafety.filter_nodes: 
+
+# If set to true, only nodes in the list will be shown, otherwise they will be hidden
+# TRUE or FALSE (case-insensitive)
+#opensafety.filter_show_nodes_in_filterlist: TRUE
+
+# Port used by any UDP demo implementation to transport data
+# A decimal number
+#opensafety.network_udp_port: 9877
+
+# UDP port used by SercosIII to transport data
+# A decimal number
+#opensafety.network_udp_port_sercosiii: 8755
+
+# In an SercosIII/UDP transport stream, openSAFETY frame 2 will be expected before frame 1
+# TRUE or FALSE (case-insensitive)
+#opensafety.network_udp_frame_first_sercosiii: FALSE
+
+# In the transport stream, openSAFETY frame 2 will be expected before frame 1
+# TRUE or FALSE (case-insensitive)
+#opensafety.network_udp_frame_first: FALSE
+
+# Modbus/TCP words can be transcoded either big- or little endian. Default will be little endian
+# TRUE or FALSE (case-insensitive)
+#opensafety.mbtcp_big_endian: FALSE
+
+# Enables additional information in the dissection for better debugging an openSAFETY trace
+# TRUE or FALSE (case-insensitive)
+#opensafety.debug_verbose: FALSE
+
+# Enable heuristic dissection for openSAFETY over UDP encoded traffic
+# TRUE or FALSE (case-insensitive)
+#opensafety.enable_udp: TRUE
+
+# Enable heuristic dissection for Modbus/TCP
+# TRUE or FALSE (case-insensitive)
+#opensafety.enable_mbtcp: TRUE
+
+# Display the data between openSAFETY packets
+# TRUE or FALSE (case-insensitive)
+#opensafety.display_intergap_data: FALSE
+
+# SPDOs may only be found in cyclic data, SSDOs/SNMTS only in acyclic data
+# TRUE or FALSE (case-insensitive)
+#opensafety.classify_transport: TRUE
+
+# Port used by the openSAFETY over UDP data transport
+# A decimal number
+#opensafety_udp.network_udp_port: 9877
+
+# If tls-auth detection fails, you can choose to override detection and set tls-auth yourself
+# TRUE or FALSE (case-insensitive)
+#openvpn.tls_auth_detection_override: FALSE
+
+# Assume the connection uses tls-crypt
+# TRUE or FALSE (case-insensitive)
+#openvpn.tls_crypt: FALSE
+
+# If the parameter --tls-auth is used, the following preferences must also be defined.
+# TRUE or FALSE (case-insensitive)
+#openvpn.tls_auth: FALSE
+
+# If the parameter --tls-auth is used, a HMAC header is being inserted.
+# The default HMAC algorithm is SHA-1 which generates a 160 bit HMAC, therefore 20 bytes should be ok.
+# The value must be between 20 (160 bits) and 64 (512 bits).
+# A decimal number
+#openvpn.tls_auth_hmac_size: 20
+
+# If the parameter --tls-auth is used, an additional packet-id for replay protection is inserted after the HMAC signature. This field can either be 4 bytes or 8 bytes including an optional time_t timestamp long.
+#  This option is only evaluated if tls_auth_hmac_size > 0.
+#  The default value is TRUE.
+# TRUE or FALSE (case-insensitive)
+#openvpn.long_format: TRUE
+
+# Whether the Openwire dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#openwire.desegment: TRUE
+
+# Whether verbose type and length information are displayed in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#openwire.verbose_type: FALSE
+
+# Whether the OPSI dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#opsi.desegment_opsi_messages: TRUE
+
+# Select the option of the network to interpret the Quality Level for
+# One of: Option I network, Option II network
+# (case-insensitive).
+#ossp.option_network: Option I network
+
+# Whether segmented TPKT datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#osi.tpkt_reassemble: FALSE
+
+# Whether segmented RTSE datagrams should be reassembled. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#rtse.reassemble: TRUE
+
+# Whether the IDMP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#idmp.desegment_idmp_messages: TRUE
+
+# Whether segmented IDMP datagrams should be reassembled. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#idmp.reassemble: TRUE
+
+# Reassemble fragmented P_Mul packets
+# TRUE or FALSE (case-insensitive)
+#p_mul.reassemble: TRUE
+
+# Make the P_Mul dissector use relative message id number instead of absolute ones
+# TRUE or FALSE (case-insensitive)
+#p_mul.relative_msgid: TRUE
+
+# Calculate sequence/acknowledgement analysis
+# TRUE or FALSE (case-insensitive)
+#p_mul.seq_ack_analysis: TRUE
+
+# Type of content in Data_PDU
+# One of: No decoding, BER encoded ASN.1, Compressed Data Type
+# (case-insensitive).
+#p_mul.decode: No decoding
+
+# Attempt to decode parts of the message that aren't fully understood yet
+# TRUE or FALSE (case-insensitive)
+#papi.experimental_decode: FALSE
+
+# Whether the PCLI summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#pcli.summary_in_tree: TRUE
+
+# Show uncompressed User-Plane data as IP
+# TRUE or FALSE (case-insensitive)
+pdcp-lte.show_user_plane_as_ip: FALSE
+
+# Show unciphered Signalling-Plane data as RRC
+# TRUE or FALSE (case-insensitive)
+#pdcp-lte.show_signalling_plane_as_rrc: TRUE
+
+# Do sequence number analysis
+# One of: No-Analysis, Only-RLC-frames, Only-PDCP-frames
+# (case-insensitive).
+#pdcp-lte.check_sequence_numbers: Only-RLC-frames
+
+# Attempt to decode ROHC data
+# TRUE or FALSE (case-insensitive)
+#pdcp-lte.dissect_rohc: FALSE
+
+# Can show RLC, PDCP or Traffic layer info in Info column
+# One of: RLC Info, PDCP Info, Traffic Info
+# (case-insensitive).
+#pdcp-lte.layer_to_show: RLC Info
+
+# If RRC Security Info not seen, e.g. in Handover
+# One of: EEA0 (NULL), EEA1 (SNOW3G), EEA2 (AES), EEA3 (ZUC)
+# (case-insensitive).
+#pdcp-lte.default_ciphering_algorithm: EEA0 (NULL)
+
+# If RRC Security Info not seen, e.g. in Handover
+# One of: EIA0 (NULL), EIA1 (SNOW3G), EIA2 (AES), EIA3 (ZUC)
+# (case-insensitive).
+#pdcp-lte.default_integrity_algorithm: EIA0 (NULL)
+
+# N.B. only possible if build with algorithm support, and have key available and configured
+# TRUE or FALSE (case-insensitive)
+pdcp-lte.decipher_signalling: FALSE
+
+# N.B. only possible if build with algorithm support, and have key available and configured
+# TRUE or FALSE (case-insensitive)
+#pdcp-lte.decipher_userplane: FALSE
+
+# N.B. only possible if build with algorithm support, and have key available and configured
+# TRUE or FALSE (case-insensitive)
+pdcp-lte.verify_integrity: FALSE
+
+# Ignore the LTE RRC security algorithm configuration, to be used when PDCP is already deciphered in the capture
+# TRUE or FALSE (case-insensitive)
+#pdcp-lte.ignore_rrc_sec_params: FALSE
+
+# Show uncompressed User-Plane data as IP
+# TRUE or FALSE (case-insensitive)
+pdcp-nr.show_user_plane_as_ip: FALSE
+
+# Show unciphered Signalling-Plane data as RRC
+# TRUE or FALSE (case-insensitive)
+#pdcp-nr.show_signalling_plane_as_rrc: TRUE
+
+# Do sequence number analysis
+# One of: No-Analysis, Only-RLC-frames, Only-PDCP-frames
+# (case-insensitive).
+#pdcp-nr.check_sequence_numbers: Only-RLC-frames
+
+# Attempt to decode ROHC data
+# TRUE or FALSE (case-insensitive)
+#pdcp-nr.dissect_rohc: FALSE
+
+# Can show RLC, PDCP or Traffic layer info in Info column
+# One of: RLC Info, PDCP Info, Traffic Info
+# (case-insensitive).
+#pdcp-nr.layer_to_show: RLC Info
+
+# If RRC Security Info not seen, e.g. in Handover
+# One of: NEA0 (NULL), NEA1 (SNOW3G), NEA2 (AES), NEA3 (ZUC)
+# (case-insensitive).
+#pdcp-nr.default_ciphering_algorithm: NEA0 (NULL)
+
+# If RRC Security Info not seen, e.g. in Handover
+# One of: NIA0 (NULL), NIA1 (SNOW3G), NIA2 (AES), NIA3 (ZUC)
+# (case-insensitive).
+#pdcp-nr.default_integrity_algorithm: NIA0 (NULL)
+
+# N.B. only possible if build with algorithm support, and have key available and configured
+# TRUE or FALSE (case-insensitive)
+pdcp-nr.decipher_signalling: FALSE
+
+# N.B. only possible if build with algorithm support, and have key available and configured
+# TRUE or FALSE (case-insensitive)
+#pdcp-nr.decipher_userplane: FALSE
+
+# N.B. only possible if build with algorithm support, and have key available and configured
+# TRUE or FALSE (case-insensitive)
+pdcp-nr.verify_integrity: FALSE
+
+# Ignore the NR RRC security algorithm configuration, to be used when PDCP is already deciphered in the capture
+# TRUE or FALSE (case-insensitive)
+#pdcp-nr.ignore_rrc_sec_params: FALSE
+
+# Whether the dissector should put the internal PER data in the tree or if it should hide it
+# TRUE or FALSE (case-insensitive)
+#per.display_internal_per_fields: FALSE
+
+# Track PFCP session
+# TRUE or FALSE (case-insensitive)
+#pfcp.track_pfcp_session: FALSE
+
+# Whether or not UID and PID fields are dissected in host, big, or little endian byte order
+# One of: Host-endian, Big-endian, Little-endian
+# (case-insensitive).
+#pflog.id_endian: Host-endian
+
+# Whether to check the validity of the PGM checksum
+# TRUE or FALSE (case-insensitive)
+#pgm.check_checksum: TRUE
+
+# Whether the PIM payload is shown off of the main tree or encapsulated within the PIM options
+# TRUE or FALSE (case-insensitive)
+#pim.payload_tree: TRUE
+
+# The password to used to decrypt the encrypted elements within the PKCS#12 file
+# A string
+#pkcs12.password: 
+
+# Whether to try and decrypt the encrypted data within the PKCS#12 with a NULL password
+# TRUE or FALSE (case-insensitive)
+#pkcs12.try_null_password: FALSE
+
+# Whether the PN-RT summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#pn_rt.summary_in_tree: TRUE
+
+# Reassemble PNIO Fragments and get them decoded
+# TRUE or FALSE (case-insensitive)
+#pn_rt.desegment: TRUE
+
+# Protocol payload type
+# One of: Data, Sony FeliCa, NXP MiFare, ISO 7816
+# (case-insensitive).
+#pn532.prtype532: Data
+
+# Whether the PNIO dissector is allowed to use detailed PROFIsafe dissection of cyclic data frames
+# TRUE or FALSE (case-insensitive)
+#pn_io.pnio_ps_selection: TRUE
+
+# Select your Networkpath to your GSD-Files.
+# A path to a directory
+#pn_io.pnio_ps_networkpath: 
+
+# Whether the POP dissector should reassemble RETR and TOP responses and spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#pop.desegment_data: TRUE
+
+# Whether fragmented 802.11 aggregated MPDUs should be reassembled
+# TRUE or FALSE (case-insensitive)
+#ppi.reassemble: TRUE
+
+# The type of PPP frame checksum (none, 16-bit, 32-bit)
+# One of: None, 16-Bit, 32-Bit
+# (case-insensitive).
+#ppp.fcs_type: None
+
+# Default Protocol ID to be used for PPPMuxCP
+# A hexadecimal number
+#ppp.default_proto_id: 0
+
+# Whether PPP Multilink frames use 12-bit sequence numbers
+# TRUE or FALSE (case-insensitive)
+#mp.short_seqno: FALSE
+
+# Maximum number of PPP Multilink fragments to try to reassemble into one frame
+# A decimal number
+#mp.max_fragments: 6
+
+# Age off unreassembled fragments after this many packets
+# A decimal number
+#mp.fragment_aging: 4000
+
+# Show values of tags and lengths of data fields
+# TRUE or FALSE (case-insensitive)
+#pppoed.show_tags_and_lengths: FALSE
+
+# Load .proto files when Wireshark starts. By default, the .proto files are loaded only when the Protobuf dissector is called for the first time.
+# TRUE or FALSE (case-insensitive)
+#protobuf.preload_protos: FALSE
+
+# If Protobuf messages and fields are defined in loaded .proto files, they will be dissected as wireshark fields if this option is turned on. The names of all these wireshark fields will be prefixed with "pbf." (for fields) or "pbm." (for messages) followed by their full names in the .proto files.
+# TRUE or FALSE (case-insensitive)
+#protobuf.pbf_as_hf: FALSE
+
+# Show the names of message, field, enum and enum_value. Show the wire type and field number format of field. Show value nodes of field and enum_value.
+# TRUE or FALSE (case-insensitive)
+#protobuf.show_details: FALSE
+
+# Show all fields of bytes type as string. For example ETCD string
+# TRUE or FALSE (case-insensitive)
+#protobuf.bytes_as_string: FALSE
+
+# Make Protobuf fields that are not serialized on the wire to be displayed with default values.
+# The default value will be one of the following: 
+#   1) The value of the 'default' option of an optional field defined in 'proto2' file. (explicitly-declared)
+#   2) False for bools.
+#   3) First defined enum value for enums.
+#   4) Zero for numeric types.
+# There are no default values for fields 'repeated' or 'bytes' and 'string' without default value declared.
+# If the missing field is 'required' in a 'proto2' file, a warning item will be added to the tree.
+# One of: None, Only Explicitly-Declared (proto2), Explicitly-Declared, ENUM and BOOL, All
+# (case-insensitive).
+#protobuf.add_default_value: None
+
+# Specifies that the JSON text of the Protobuf message should be displayed in addition to the dissection tree
+# TRUE or FALSE (case-insensitive)
+#protobuf.display_json_mapping: FALSE
+
+# Try to dissect all undefined length-delimited fields as string.
+# TRUE or FALSE (case-insensitive)
+#protobuf.try_dissect_as_string: FALSE
+
+# Try to show all possible field types for each undefined field according to wire type.
+# TRUE or FALSE (case-insensitive)
+#protobuf.show_all_types: FALSE
+
+# Make the PTP dissector analyze PTP messages. Accurate Capture Timestamps required!
+# TRUE or FALSE (case-insensitive)
+#ptp.analyze_ptp_messages: FALSE
+
+# Properly translates vendor specific opcodes
+# One of: Unknown vendor, Eastman Kodak, Canon, Nikon, Casio EX-F1, Microsoft / MTP, Olympus E series
+# (case-insensitive).
+#ptpip.vendor: Unknown vendor
+
+# Whether the PVFS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#pvfs.desegment: TRUE
+
+# Whether the Q.931 dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#q931.desegment_h323_messages: TRUE
+
+# Reassemble segmented Q.931 messages (Q.931 - Annex H)
+# TRUE or FALSE (case-insensitive)
+#q931.reassembly: TRUE
+
+# Decode ISO/IEC cause coding standard as ITU-T
+# TRUE or FALSE (case-insensitive)
+#q931.iso_iec_cause_coding: FALSE
+
+# Type of Facility encoding
+# One of: Dissect facility as QSIG, Dissect facility as ETSI
+# (case-insensitive).
+#q932.facility_encoding: Dissect facility as QSIG
+
+# Set the UDP base port for the Quake III Arena Server
+# A decimal number
+#quake3.udp.arena_port: 27960
+
+# Set the UDP base port for the Quake III Arena Master Server
+# A decimal number
+#quake3.udp.master_port: 27950
+
+# Whether out-of-order CRYPTO frames should be buffered and reordered before passing them to the TLS handshake dissector.
+# TRUE or FALSE (case-insensitive)
+#quic.reassemble_crypto_out_of_order: TRUE
+
+# Shared secret used to decode User Passwords and validate Accounting Request and Response Authenticators
+# A string
+#radius.shared_secret: 
+
+# Whether to check or not if Accounting Request and Response Authenticator are correct. You need to define shared secret for this to work.
+# TRUE or FALSE (case-insensitive)
+#radius.validate_authenticator: FALSE
+
+# Whether to add or not to the tree the AVP's payload length
+# TRUE or FALSE (case-insensitive)
+#radius.show_length: FALSE
+
+# Whether to interpret 241-246 as extended attributes according to RFC 6929
+# TRUE or FALSE (case-insensitive)
+#radius.disable_extended_attributes: FALSE
+
+# Attempt to dissect RRC message embedded in RRC-Container IE
+# TRUE or FALSE (case-insensitive)
+#ranap.dissect_rrc_container: FALSE
+
+# Where available, show which protocol and frame caused this RDT stream to be created
+# TRUE or FALSE (case-insensitive)
+#rdt.show_setup_info: TRUE
+
+# Whether fragmented RELOAD datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#reload.defragment: TRUE
+
+# Length of the NodeId as defined in the overlay.
+# A decimal number
+#reload.nodeid_length: 16
+
+# topology plugin defined in the overlay
+# A string
+#reload.topology_plugin: CHORD-RELOAD
+
+# Whether the RESP dissector should reassemble command and response lines spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#resp.desegment_data: TRUE
+
+# Display the third and forth bytes of the RIPv2 header as the Routing Domain field (introduced in RFC 1388 [January 1993] and obsolete as of RFC 1723 [November 1994])
+# TRUE or FALSE (case-insensitive)
+#rip.display_routing_domain: FALSE
+
+# When enabled, try to reassemble SDUs from the various PDUs received
+# TRUE or FALSE (case-insensitive)
+#rlc.perform_reassembly: TRUE
+
+# When enabled, if data is not present, don't report as an error, but instead add expert info to indicate that headers were omitted
+# TRUE or FALSE (case-insensitive)
+#rlc.header_only_mode: FALSE
+
+# When enabled, RLC will ignore sequence numbers reported in 'Security Mode Command'/'Security Mode Complete' (RRC) messages when checking if frames are ciphered
+# TRUE or FALSE (case-insensitive)
+#rlc.ignore_rrc_cipher_indication: FALSE
+
+# When enabled, RLC will assume all payloads in RLC frames are ciphered
+# TRUE or FALSE (case-insensitive)
+#rlc.ciphered_data: FALSE
+
+# LI size in bits, either 7 or 15 bit
+# One of: 7 bits, 15 bits, Let upper layers decide
+# (case-insensitive).
+#rlc.li_size: Let upper layers decide
+
+# Attempt to keep track of PDUs for AM channels, and point out problems
+# One of: No-Analysis, Only-MAC-frames, Only-RLC-frames
+# (case-insensitive).
+#rlc-lte.do_sequence_analysis_am: Only-MAC-frames
+
+# Attempt to keep track of PDUs for UM channels, and point out problems
+# One of: No-Analysis, Only-MAC-frames, Only-RLC-frames
+# (case-insensitive).
+#rlc-lte.do_sequence_analysis: Only-MAC-frames
+
+# Call PDCP dissector for signalling PDUs.  Note that without reassembly, it canonly be called for complete PDUs (i.e. not segmented over RLC)
+# TRUE or FALSE (case-insensitive)
+#rlc-lte.call_pdcp_for_srb: TRUE
+
+# Call PDCP dissector for user-plane PDUs.  Note that without reassembly, it canonly be called for complete PDUs (i.e. not segmented over RLC)
+# One of: Off, 7-bit SN, 12-bit SN, 15-bit SN, 18-bit SN, Use signalled value
+# (case-insensitive).
+#rlc-lte.call_pdcp_for_drb: Use signalled value
+
+# Call RRC dissector for CCCH PDUs
+# TRUE or FALSE (case-insensitive)
+#rlc-lte.call_rrc_for_ccch: TRUE
+
+# Call RRC dissector for MCCH PDUs  Note that without reassembly, it canonly be called for complete PDUs (i.e. not segmented over RLC)
+# TRUE or FALSE (case-insensitive)
+#rlc-lte.call_rrc_for_mcch: FALSE
+
+# Call ip dissector for MTCH PDUs  Note that without reassembly, it canonly be called for complete PDUs (i.e. not segmented over RLC)
+# TRUE or FALSE (case-insensitive)
+#rlc-lte.call_ip_for_mtch: FALSE
+
+# When enabled, if data is not present, don't report as an error, but instead add expert info to indicate that headers were omitted
+# TRUE or FALSE (case-insensitive)
+#rlc-lte.header_only_mode: FALSE
+
+# When enabled, attempts to re-assemble upper-layer SDUs that are split over more than one RLC PDU.  Note: does not currently support out-of-order or re-segmentation. N.B. sequence analysis must also be turned on in order for reassembly to work
+# TRUE or FALSE (case-insensitive)
+rlc-lte.reassembly: FALSE
+
+# Call PDCP dissector for signalling PDUs.  Note that without reassembly, it canonly be called for complete PDUs (i.e. not segmented over RLC)
+# TRUE or FALSE (case-insensitive)
+#rlc-nr.call_pdcp_for_srb: TRUE
+
+# Call PDCP dissector for UL user-plane PDUs.  Note that without reassembly, it canonly be called for complete PDUs (i.e. not segmented over RLC)
+# One of: Off, 12-bit SN, 18-bit SN, Use signalled value
+# (case-insensitive).
+rlc-nr.call_pdcp_for_ul_drb: Use signalled value
+
+# Call PDCP dissector for DL user-plane PDUs.  Note that without reassembly, it canonly be called for complete PDUs (i.e. not segmented over RLC)
+# One of: Off, 12-bit SN, 18-bit SN, Use signalled value
+# (case-insensitive).
+rlc-nr.call_pdcp_for_dl_drb: Use signalled value
+
+# Call RRC dissector for CCCH PDUs
+# TRUE or FALSE (case-insensitive)
+#rlc-nr.call_rrc_for_ccch: TRUE
+
+# When enabled, if data is not present, don't report as an error, but instead add expert info to indicate that headers were omitted
+# TRUE or FALSE (case-insensitive)
+#rlc-nr.header_only_mode: FALSE
+
+# N.B. This should be considered experimental/incomplete, in that it doesn't try to discard reassembled state when reestablishment happens, or in certain packet-loss cases
+# TRUE or FALSE (case-insensitive)
+rlc-nr.reassemble_am_frames: FALSE
+
+# N.B. This should be considered experimental/incomplete, in that it doesn't try to discard reassembled state when reestablishment happens, or in certain packet-loss cases
+# TRUE or FALSE (case-insensitive)
+#rlc-nr.reassemble_um_frames: FALSE
+
+# Whether the RPC dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#rpc.desegment_rpc_over_tcp: TRUE
+
+# Whether the RPC dissector should defragment RPC-over-TCP messages.
+# TRUE or FALSE (case-insensitive)
+#rpc.defragment_rpc_over_tcp: TRUE
+
+# Set the maximum size of RPCoverTCP PDUs.  If the size field of the record marker is larger than this value it will not be considered a valid RPC PDU.
+# A decimal number
+#rpc.max_tcp_pdu_size: 4194304
+
+# Whether the RPC dissector should attempt to dissect RPC PDUs containing programs that are not known to Wireshark. This will make the heuristics significantly weaker and elevate the risk for falsely identifying and misdissecting packets significantly.
+# TRUE or FALSE (case-insensitive)
+#rpc.dissect_unknown_programs: FALSE
+
+# Whether the RPC dissector should attempt to locate RPC PDU boundaries when initial fragment alignment is not known.  This may cause false positives, or slow operation.
+# TRUE or FALSE (case-insensitive)
+#rpc.find_fragment_start: FALSE
+
+# Whether the RPCAP dissector should reassemble PDUs spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#rpcap.desegment_pdus: TRUE
+
+# Whether the packets should be decoded according to the link-layer type.
+# TRUE or FALSE (case-insensitive)
+#rpcap.decode_content: TRUE
+
+# Default link-layer type to use if an Open Reply packet has not been captured.
+# A decimal number
+#rpcap.linktype: 4294967295
+
+# RPKI-Router Protocol TCP TLS port if other than the default
+# A decimal number
+#rpkirtr.tcp.rpkirtr_tls.port: 324
+
+# Whether the NAS PDU should be shown in the root packet details tree
+# TRUE or FALSE (case-insensitive)
+#rrc.nas_in_root_tree: FALSE
+
+# Controls the display of the session's client username in the info column.  This is only displayed if the packet containing it was seen during this capture session.
+# TRUE or FALSE (case-insensitive)
+#rsh.info_show_client_username: FALSE
+
+# Controls the display of the session's server username in the info column.  This is only displayed if the packet containing it was seen during this capture session.
+# TRUE or FALSE (case-insensitive)
+#rsh.info_show_server_username: TRUE
+
+# Controls the display of the command being run on the server by this session in the info column.  This is only displayed if the packet containing it was seen during this capture session.
+# TRUE or FALSE (case-insensitive)
+#rsh.info_show_command: FALSE
+
+# Use ipaccess nanoBTS specific definitions for RSL
+# TRUE or FALSE (case-insensitive)
+#gsm_abis_rsl.use_ipaccess_rsl: FALSE
+
+# Use Osmocom specific definitions for RSL
+# TRUE or FALSE (case-insensitive)
+#gsm_abis_rsl.use_osmocom_rsl: FALSE
+
+# The Physical Context Information field is not specified This information should be not be analysed by BSC, but merely forwarded from one TRX/channel to another.
+# TRUE or FALSE (case-insensitive)
+#gsm_abis_rsl.dissect_phy_ctx_inf: TRUE
+
+# Specifies whether Wireshark should decode and display sub-messages within BUNDLE messages
+# TRUE or FALSE (case-insensitive)
+#rsvp.process_bundle: TRUE
+
+# Specifies how Wireshark should dissect generalized labels
+# One of: data (no interpretation), SONET/SDH ("S, U, K, L, M" scheme), Wavelength Label (fixed or flexi grid), ODUk Label
+# (case-insensitive).
+#rsvp.generalized_label_options: data (no interpretation)
+
+# Whether the RSYNC dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#rsync.desegment: TRUE
+
+# The default protocol assumed by the heuristic dissector, which does not easily distinguish between RTCP and SRTCP.
+# One of: RTCP, SRTCP
+# (case-insensitive).
+#rtcp.default_protocol: RTCP
+
+# Where available, show which protocol and frame caused this RTCP stream to be created
+# TRUE or FALSE (case-insensitive)
+#rtcp.show_setup_info: TRUE
+
+# Try to work out network delay by comparing time between packets as captured and delays as seen by endpoint
+# TRUE or FALSE (case-insensitive)
+#rtcp.show_roundtrip_calculation: FALSE
+
+# Minimum (absolute) calculated roundtrip delay time in milliseconds that should be reported
+# A decimal number
+#rtcp.roundtrip_min_threshhold: 10
+
+# Whether the RTMPT dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#rtmpt.desegment: TRUE
+
+# The largest acceptable packet size for reassembly
+# A decimal number
+#rtmpt.max_packet_size: 32768
+
+# Where available, show which protocol and frame caused this RTP stream to be created
+# TRUE or FALSE (case-insensitive)
+#rtp.show_setup_info: TRUE
+
+# Whether subdissector can request RTP streams to be reassembled
+# TRUE or FALSE (case-insensitive)
+#rtp.desegment_rtp_streams: TRUE
+
+# If an RTP version 0 packet is encountered, it can be treated as an invalid or ZRTP packet, a CLASSIC-STUN packet, or a T.38 packet
+# One of: Invalid or ZRTP packets, STUN packets, CLASSIC-STUN packets, T.38 packets, SPRT packets
+# (case-insensitive).
+#rtp.version0_type: Invalid or ZRTP packets
+
+# Specifies that RTP/RTCP/T.38/MSRP/etc streams are decoded based upon port numbers found in RTPproxy answers
+# TRUE or FALSE (case-insensitive)
+#rtpproxy.establish_conversation: TRUE
+
+# Maximum timeout value in waiting for reply from RTPProxy (in milliseconds).
+# A decimal number
+#rtpproxy.reply.timeout: 1000
+
+# Specifies the maximum number of samples dissected in a DATA_BATCH submessage. Increasing this value may affect performances if the trace has a lot of big batched samples.
+# A decimal number
+#rtps.max_batch_samples_dissected: 16
+
+# Enabling this option may affect performance if the trace has messages with large Data Types.
+# TRUE or FALSE (case-insensitive)
+#rtps.enable_max_dissection_info_elements: TRUE
+
+# Specifies the maximum number of Data Type elements dissected. Increasing this value may affect performance if the trace has messages with large Data Types.
+# A decimal number
+#rtps.max_dissection_info_elements: 100
+
+# Disabling this option may affect performance if the trace has messages with large arrays or sequences.
+# TRUE or FALSE (case-insensitive)
+#rtps.enable_max_dissection_array_elements: TRUE
+
+# Specifies the maximum number of Data Type elements dissected in arrays or sequences. Increasing this value may affect performance if the trace has messages with large Data Types.
+# A decimal number
+#rtps.max_dissection_array_elements: 100
+
+# Shows the Topic Name and Type Name of the samples. Note: this can considerably increase the dissection time
+# TRUE or FALSE (case-insensitive)
+#rtps.enable_topic_info: TRUE
+
+# Dissects the user data if the Type Object is propagated in Discovery.
+# TRUE or FALSE (case-insensitive)
+#rtps.enable_user_data_dissection: FALSE
+
+# Enables the reassembly of DATA_FRAG submessages.
+# TRUE or FALSE (case-insensitive)
+#rtps.enable_rtps_reassembly: FALSE
+
+# Whether the RTSP dissector should reassemble headers of a request spanning multiple TCP segments.  To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#rtsp.desegment_headers: TRUE
+
+# Whether the RTSP dissector should use the "Content-length:" value to desegment the body of a request spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#rtsp.desegment_body: TRUE
+
+# Dissect TransparentContainers that are opaque to S1AP
+# TRUE or FALSE (case-insensitive)
+#s1ap.dissect_container: TRUE
+
+# Select whether LTE TransparentContainer should be dissected as NB-IOT or legacy LTE
+# One of: Automatic, Legacy LTE, NB-IoT
+# (case-insensitive).
+#s1ap.dissect_lte_container_as: Automatic
+
+# Show length of text field
+# TRUE or FALSE (case-insensitive)
+#sametime.show_length: FALSE
+
+# reassemble packets
+# TRUE or FALSE (case-insensitive)
+#sametime.reassemble: TRUE
+
+# Port numbers used for SAP NI Protocol (default 3200,40000)
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#sapni.tcp_ports: 3200,40000
+
+# Whether the SAP NI Protocol dissector should reassemble messages spanning multiple TCP segments.
+# TRUE or FALSE (case-insensitive)
+#sapni.desegment: TRUE
+
+# Whether the SASP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#sasp.desegment_sasp_messages: TRUE
+
+# The source point code (usually MSC) (to determine whether message is uplink or downlink)
+# A hexadecimal number
+#sccp.source_pc: 0
+
+# Show parameter length in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#sccp.show_length: FALSE
+
+# Whether SCCP messages should be reassembled
+# TRUE or FALSE (case-insensitive)
+#sccp.defragment_xudt: TRUE
+
+# Whether to keep information about messages and their associations
+# TRUE or FALSE (case-insensitive)
+#sccp.trace_sccp: FALSE
+
+# Show SLR, DLR, and CAUSE Parameters in the Information Column of the Summary
+# TRUE or FALSE (case-insensitive)
+#sccp.show_more_info: FALSE
+
+# Set the source and destination addresses to the GT digits (if present).  This may affect TCAP's ability to recognize which messages belong to which TCAP session.
+# TRUE or FALSE (case-insensitive)
+#sccp.set_addresses: FALSE
+
+# The protocol which should be used to dissect the payload if nothing else has claimed it
+# A string
+#sccp.default_payload: 
+
+# Use all bytes for data payload. Overcome 255 bytes limit of SCCP standard.  (Some tracing tools externally reassemble segmented data.)
+# TRUE or FALSE (case-insensitive)
+#sccp.dt1_ignore_length: FALSE
+
+# When Target Cannot Be Identified, Decode SCSI Messages As
+# One of: Block Device, Sequential Device, Object Based Storage Device, Medium Changer Device, Multimedia Device
+# (case-insensitive).
+#scsi.decode_scsi_messages_as: Block Device
+
+# Whether fragmented SCSI DATA IN/OUT transfers should be reassembled
+# TRUE or FALSE (case-insensitive)
+#scsi.defragment: FALSE
+
+# Show source and destination port numbers in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#sctp.show_port_numbers_in_tree: TRUE
+
+# Use relative TSNs instead of absolute ones
+# TRUE or FALSE (case-insensitive)
+#sctp.relative_tsns: TRUE
+
+# The type of checksum used in SCTP packets
+# One of: None, Adler 32, CRC 32c, Automatic
+# (case-insensitive).
+#sctp.checksum: None
+
+# Show always SCTP control chunks in the Info column
+# TRUE or FALSE (case-insensitive)
+#sctp.show_always_control_chunks: TRUE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to a specific port or PPI
+# TRUE or FALSE (case-insensitive)
+#sctp.try_heuristic_first: FALSE
+
+# Whether fragmented SCTP user messages should be reassembled
+# TRUE or FALSE (case-insensitive)
+#sctp.reassembly: TRUE
+
+# Match TSNs and their SACKs
+# TRUE or FALSE (case-insensitive)
+#sctp.tsn_analysis: TRUE
+
+# Match verification tags (CPU intense)
+# TRUE or FALSE (case-insensitive)
+#sctp.association_index: FALSE
+
+# Dissect upper layer protocols
+# TRUE or FALSE (case-insensitive)
+#sctp.ulp_dissection: TRUE
+
+# Whether Scylla dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#scylla.desegment: TRUE
+
+# Data rate
+# One of: Attempt to guess, OC-3, OC-12, OC-24, OC-48
+# (case-insensitive).
+#sdh.data.rate: OC-3
+
+# Specifies that RTP/RTCP/T.38/MSRP/etc streams are decoded based upon port numbers found in SDP payload
+# TRUE or FALSE (case-insensitive)
+#sdp.establish_conversation: TRUE
+
+# Whether the SEL Protocol dissector should desegment all messages spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#selfm.desegment: TRUE
+
+# Whether the SEL Protocol dissector should automatically pre-process Telnet data to remove duplicate 0xFF IAC bytes
+# TRUE or FALSE (case-insensitive)
+#selfm.telnetclean: TRUE
+
+# Perform CRC16 validation on Fast Messages
+# TRUE or FALSE (case-insensitive)
+#selfm.crc_verification: FALSE
+
+# List of word bits contained in SER equations (Comma-separated, no Quotes or Checksums)
+# A string
+#selfm.ser_list: 
+
+# Whether the session dissector should reassemble messages spanning multiple SES segments
+# TRUE or FALSE (case-insensitive)
+#ses.desegment: TRUE
+
+# Enabling dissection makes it easy to view protocol details in each of the sampled headers.  Disabling dissection may reduce noise caused when display filters match the contents of any sampled header(s).
+# TRUE or FALSE (case-insensitive)
+#sflow.enable_dissection: TRUE
+
+# This option only makes sense if dissection of sampled headers is enabled and probably not even then.
+# TRUE or FALSE (case-insensitive)
+#sflow.enable_analysis: FALSE
+
+# Preference whether to Dissect the UDVM code or not
+# TRUE or FALSE (case-insensitive)
+#sigcomp.display.udvm.code: FALSE
+
+# preference whether to display the bytecode in UDVM operands or not
+# TRUE or FALSE (case-insensitive)
+#sigcomp.display.bytecode: FALSE
+
+# preference whether to decompress message or not
+# TRUE or FALSE (case-insensitive)
+#sigcomp.decomp.msg: FALSE
+
+# preference whether to display the decompressed message as raw text or not
+# TRUE or FALSE (case-insensitive)
+#sigcomp.display.decomp.msg.as.txt: FALSE
+
+# 'No-Printout' = UDVM executes silently, then increasing detail about execution of UDVM instructions; Warning! CPU intense at high detail
+# One of: No-Printout, Low-detail, Medium-detail, High-detail
+# (case-insensitive).
+#sigcomp.show.udvm.execution: No-Printout
+
+# Should the payload dissector be active?
+# TRUE or FALSE (case-insensitive)
+#signal_pdu.payload_dissector_activated: TRUE
+
+# Should the payload dissector show entries marked as hidden in the configuration?
+# TRUE or FALSE (case-insensitive)
+#signal_pdu.payload_dissector_show_hidden: FALSE
+
+# Should the payload dissector hide raw values?
+# TRUE or FALSE (case-insensitive)
+#signal_pdu.payload_dissector_hide_raw_values: TRUE
+
+# Set the CA_system_ID used to decode ECM datagram as MIKEY
+# A hexadecimal number
+#simulcrypt.ca_system_id_mikey: 0x9999
+
+# SIP Server TLS Port
+# A decimal number
+#sip.tls.port: 5061
+
+# Specifies that the raw text of the SIP message should be displayed in addition to the dissection tree
+# TRUE or FALSE (case-insensitive)
+#sip.display_raw_text: FALSE
+
+# If the raw text of the SIP message is displayed, the trailing carriage return and line feed are not shown
+# TRUE or FALSE (case-insensitive)
+#sip.display_raw_text_without_crlf: FALSE
+
+# If enabled, only SIP/2.0 traffic will be dissected as SIP. Disable it to allow SIP traffic with a different version to be dissected as SIP.
+# TRUE or FALSE (case-insensitive)
+#sip.strict_sip_version: TRUE
+
+# Whether the SIP dissector should reassemble headers of a request spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#sip.desegment_headers: TRUE
+
+# Whether the SIP dissector should use the "Content-length:" value, if present, to reassemble the body of a request spanning multiple TCP segments, and reassemble chunked data spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#sip.desegment_body: TRUE
+
+# Whether retransmissions are detected coming from the same source port only.
+# TRUE or FALSE (case-insensitive)
+#sip.retrans_the_same_sport: TRUE
+
+# Whether SIP should delay tracking the media (e.g., RTP/RTCP) until an SDP offer is answered. If enabled, mid-dialog changes to SDP and media state only take effect if and when an SDP offer is successfully answered; however enabling this prevents tracking media in early-media call scenarios
+# TRUE or FALSE (case-insensitive)
+#sip.delay_sdp_changes: FALSE
+
+# Whether the generated call id should be hidden(not displayed) in the tree or not.
+# TRUE or FALSE (case-insensitive)
+#sip.hide_generatd_call_id: FALSE
+
+# Validate SIP authorizations with known credentials
+# TRUE or FALSE (case-insensitive)
+#sip.validate_authorization: FALSE
+
+# Whether the SKINNY dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#skinny.desegment: TRUE
+
+# Whether the dissector should reassemble the payload of SMB Transaction commands spanning multiple SMB PDUs
+# TRUE or FALSE (case-insensitive)
+#smb.trans_reassembly: TRUE
+
+# Whether the dissector should reassemble DCERPC over SMB commands
+# TRUE or FALSE (case-insensitive)
+#smb.dcerpc_reassembly: TRUE
+
+# Whether the dissector should snoop SMB and related CIFS protocols to discover and display Names associated with SIDs
+# TRUE or FALSE (case-insensitive)
+#smb.sid_name_snooping: FALSE
+
+# Whether the dissector should display SIDs and RIDs in hexadecimal rather than decimal
+# TRUE or FALSE (case-insensitive)
+#smb.sid_display_hex: FALSE
+
+# Whether the export object functionality will take the full path file name as file identifier
+# TRUE or FALSE (case-insensitive)
+#smb.eosmb_take_name_as_fid: FALSE
+
+# Whether the export object functionality will take the full path file name as file identifier
+# TRUE or FALSE (case-insensitive)
+#smb2.eosmb2_take_name_as_fid: FALSE
+
+# Whether the dissector should reassemble Named Pipes over SMB2 commands
+# TRUE or FALSE (case-insensitive)
+#smb2.pipe_reassembly: TRUE
+
+# Whether the dissector should try to verify SMB2 signatures
+# TRUE or FALSE (case-insensitive)
+#smb2.verify_signatures: FALSE
+
+# Whether the SMB Direct dissector should reassemble fragmented payloads
+# TRUE or FALSE (case-insensitive)
+#smb_direct.reassemble_smb_direct: TRUE
+
+# Enable reassembling (default is enabled)
+# TRUE or FALSE (case-insensitive)
+#sml.reassemble: TRUE
+
+# Enable crc (default is disabled)
+# TRUE or FALSE (case-insensitive)
+#sml.crc: FALSE
+
+# Whether the SMP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#smp.desegment: TRUE
+
+# Whether the SMPP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#smpp.reassemble_smpp_over_tcp: TRUE
+
+# Whether to decode the SMS contents when DCS is equal to 0 (zero).
+# One of: None, ASCII, GSM 7-bit, GSM 7-bit (packed), ISO-8859-1, ISO-8859-5, ISO-8859-8, UCS2, KS C 5601 (Korean)
+# (case-insensitive).
+#smpp.decode_sms_over_smpp: None
+
+# When the DCS indicates that the encoding is the GSM 7-bit alphabet, whether to decode it as unpacked (one character per octet) instead of packed.
+# TRUE or FALSE (case-insensitive)
+#smpp.gsm7_unpacked: TRUE
+
+# Whether the SMTP dissector should reassemble command and response lines spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#smtp.desegment_lines: TRUE
+
+# Whether the SMTP dissector should reassemble DATA command and lines spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#smtp.desegment_data: TRUE
+
+# Whether the SMTP dissector should decode Base64 encoded AUTH parameters
+# TRUE or FALSE (case-insensitive)
+#smtp.decryption: FALSE
+
+# Whether fragmented BIUs should be reassembled
+# TRUE or FALSE (case-insensitive)
+#sna.defragment: TRUE
+
+# Whether the SNMP OID should be shown in the info column
+# TRUE or FALSE (case-insensitive)
+#snmp.display_oid: TRUE
+
+# Whether the SNMP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#snmp.desegment: TRUE
+
+# ON - display dissected variables inside SNMP tree, OFF - display dissected variables in root tree after SNMP
+# TRUE or FALSE (case-insensitive)
+#snmp.var_in_tree: TRUE
+
+# Set whether dissector should run Snort and pass frames into it, or read alerts from user packet comments
+# One of: Not looking for Snort alerts, From running Snort, From user packet comments
+# (case-insensitive).
+#snort.alerts_source: Not looking for Snort alerts
+
+# The name of the snort binary file to run
+# A path to a file
+#snort.binary: /usr/sbin/snort
+
+# The name of the file containing the snort IDS configuration.  Typically snort.conf
+# A path to a file
+#snort.config: /etc/snort/snort.conf
+
+# Whether or not information about the rule set and detected alerts should be shown in the tree of every snort PDU tree
+# TRUE or FALSE (case-insensitive)
+#snort.show_rule_set_stats: FALSE
+
+# Whether or not expert info should be used to highlight fired alerts
+# TRUE or FALSE (case-insensitive)
+#snort.show_alert_expert_info: FALSE
+
+# Attempt to show alert in reassembled frame where possible.  Note that this won't work during live capture
+# TRUE or FALSE (case-insensitive)
+#snort.show_alert_in_reassembled_frame: FALSE
+
+# When enabled, will run Snort with '-k none'
+# TRUE or FALSE (case-insensitive)
+#snort.ignore_checksum_errors: TRUE
+
+# Show unidentified fields ("padding") in packet dissections
+# TRUE or FALSE (case-insensitive)
+#solaredge.unknown: TRUE
+
+# Inverter system encryption key
+# A string
+#solaredge.system_encryption_key: 
+
+# Reassemble SOME/IP-TP segments
+# TRUE or FALSE (case-insensitive)
+#someip.reassemble_tp: TRUE
+
+# Should the SOME/IP Dissector use the payload dissector?
+# TRUE or FALSE (case-insensitive)
+#someip.payload_dissector_activated: TRUE
+
+# Should the SOME/IP Dissector use the payload dissector with the experimental WTLV encoding for unconfigured messages?
+# TRUE or FALSE (case-insensitive)
+#someip.payload_dissector_wtlv_default: FALSE
+
+# SOME/IP Ignore Port Ranges UDP. These ports are not automatically added by the SOME/IP-SD.
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#someipsd.ports.udp.ignore: 
+
+# SOME/IP Ignore Port Ranges TCP. These ports are not automatically added by the SOME/IP-SD.
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#someipsd.ports.tcp.ignore: 
+
+# Whether the SoulSeek dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#slsk.desegment: TRUE
+
+# Whether the SoulSeek dissector should decompress all zlib compressed packets inside messages
+# TRUE or FALSE (case-insensitive)
+#slsk.decompress: TRUE
+
+# Whether the SoupBinTCP dissector should reassemble messages spanning multiple TCP segments.
+# TRUE or FALSE (case-insensitive)
+#soupbintcp.desegment: TRUE
+
+# Whether the SPDY dissector should reassemble multiple data frames into an entity body.
+# TRUE or FALSE (case-insensitive)
+#spdy.assemble_data_frames: TRUE
+
+# Whether to uncompress SPDY headers.
+# TRUE or FALSE (case-insensitive)
+#spdy.decompress_headers: TRUE
+
+# Whether to uncompress entity bodies that are compressed using "Content-Encoding: "
+# TRUE or FALSE (case-insensitive)
+#spdy.decompress_body: TRUE
+
+# Where available, show which protocol and frame caused this SPRT stream to be created
+# TRUE or FALSE (case-insensitive)
+#sprt.show_setup_info: TRUE
+
+# Show the DLCI field in I_OCTET messages as well as the frame that enabled/disabled the DLCI
+# TRUE or FALSE (case-insensitive)
+#sprt.show_dlci_info: TRUE
+
+# Decode the subtype as this application
+# One of: None, MCPT
+# (case-insensitive).
+#srtcp.decode_application_subtype: None
+
+# Whether the SRVLOC dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#srvloc.desegment_tcp: TRUE
+
+# SSCOP payload (dissector to call on SSCOP payload)
+# One of: Data (no further dissection), Q.2931, SSCF-NNI (MTP3-b), ALCAP, NBAP
+# (case-insensitive).
+#sscop.payload: Q.2931
+
+# Whether the SSH dissector should reassemble SSH buffers spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ssh.desegment_buffers: TRUE
+
+# The path to the file which contains a list of key exchange secrets in the following format:
+# "<hex-encoded-cookie> <hex-encoded-key>" (without quotes or leading spaces).
+# 
+# A path to a file
+#ssh.keylog_file: 
+
+# Redirect SSH debug to the file specified. Leave empty to disable debugging or use "-" to redirect output to stderr.
+# A path to a file
+#ssh.debug_file: 
+
+# MOSH_KEY AES key (from mosh-{client,server} environment variable)
+# A string
+#ssyncp.key: 
+
+# Whether the STANAG 5066 DTS Layer dissector should reassemble DPDUs spanning multiple TCP segments
+# TRUE or FALSE (case-insensitive)
+#s5066dts.proto_desegment: TRUE
+
+# Whether the S5066 SIS dissector should reassemble PDUs spanning multiple TCP segments. The default is to use reassembly.
+# TRUE or FALSE (case-insensitive)
+#s5066sis.desegment_pdus: TRUE
+
+# Whether the S5066 SIS dissector should dissect this edition of the STANAG. This edition was never formally approved and is very rare. The common edition is edition 1.2.
+# TRUE or FALSE (case-insensitive)
+#s5066sis.edition_one: FALSE
+
+# Whether the StarTeam dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#starteam.desegment: TRUE
+
+# Whether the BPDU dissector should use 802.1t System ID Extensions when dissecting the Bridge Identifier
+# TRUE or FALSE (case-insensitive)
+#stp.use_system_id_extension: TRUE
+
+# Reassembles greater than MTU sized STT packets broken into segments on transmit
+# TRUE or FALSE (case-insensitive)
+#stt.reassemble: TRUE
+
+# Whether to validate the STT checksum or not.
+# TRUE or FALSE (case-insensitive)
+#stt.check_checksum: FALSE
+
+# Stun Version on the Network
+# One of: Auto, MS-TURN, RFC3489 and earlier, RFC5389 and later
+# (case-insensitive).
+#stun.stunversion: RFC5389 and later
+
+# Version used by Wireshark
+# One of: Internet Draft version 08, RFC 3868
+# (case-insensitive).
+#sua.version: RFC 3868
+
+# Set the source and destination addresses to the PC or GT digits, depending on the routing indicator.  This may affect TCAP's ability to recognize which messages belong to which TCAP session.
+# TRUE or FALSE (case-insensitive)
+#sua.set_addresses: FALSE
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#sv.decode_data_as_phsmeas: FALSE
+
+# Whether the T.38 dissector should decode using the Pre-Corrigendum T.38 ASN.1 specification (1998).
+# TRUE or FALSE (case-insensitive)
+#t38.use_pre_corrigendum_asn1_specification: TRUE
+
+# Whether a UDP packet that looks like RTP version 2 packet will be dissected as RTP packet or T.38 packet. If enabled there is a risk that T.38 UDPTL packets with sequence number higher than 32767 may be dissected as RTP.
+# TRUE or FALSE (case-insensitive)
+#t38.dissect_possible_rtpv2_packets_as_rtp: FALSE
+
+# Whether the dissector should reassemble T.38 PDUs spanning multiple TCP segments when TPKT is used over TCP. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#t38.reassembly: TRUE
+
+# Whether T.38 is used with TPKT for TCP
+# One of: Never, Always, Maybe
+# (case-insensitive).
+#t38.tpkt_usage: Maybe
+
+# Where available, show which protocol and frame caused this T.38 stream to be created
+# TRUE or FALSE (case-insensitive)
+#t38.show_setup_info: TRUE
+
+# Whether the TACACS+ dissector should reassemble messages spanning multiple TCP segments.  To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tacplus.desegment: TRUE
+
+# TACACS+ Encryption Key
+# A string
+#tacplus.key: 
+
+# Whether the TALI dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tali.reassemble: TRUE
+
+# SCCP (and SUA) SSNs to decode as TCAP
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#tcap.ssn: 
+
+# Statistics for Response Time
+# TRUE or FALSE (case-insensitive)
+#tcap.persistentsrt: FALSE
+
+# Maximal delay for message repetition
+# A decimal number
+#tcap.repetitiontimeout: 10
+
+# Maximal delay for message lost
+# A decimal number
+#tcap.losttimeout: 30
+
+# Whether the TCP summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#tcp.summary_in_tree: TRUE
+
+# Whether to validate the TCP checksum or not.  (Invalid checksums will cause reassembly, if enabled, to fail.)
+# TRUE or FALSE (case-insensitive)
+#tcp.check_checksum: FALSE
+
+# Whether subdissector can request TCP streams to be reassembled
+# TRUE or FALSE (case-insensitive)
+#tcp.desegment_tcp_streams: TRUE
+
+# Whether out-of-order segments should be buffered and reordered before passing it to a subdissector. To use this option you must also enable "Allow subdissector to reassemble TCP streams".
+# TRUE or FALSE (case-insensitive)
+#tcp.reassemble_out_of_order: FALSE
+
+# Make the TCP dissector analyze TCP sequence numbers to find and flag segment retransmissions, missing segments and RTT
+# TRUE or FALSE (case-insensitive)
+#tcp.analyze_sequence_numbers: TRUE
+
+# Make the TCP dissector use relative sequence numbers instead of absolute ones. To use this option you must also enable "Analyze TCP sequence numbers". 
+# TRUE or FALSE (case-insensitive)
+#tcp.relative_sequence_numbers: TRUE
+
+# Make the TCP dissector use this scaling factor for streams where the signalled scaling factor is not visible in the capture
+# One of: Not known, 0 (no scaling), 1 (multiply by 2), 2 (multiply by 4), 3 (multiply by 8), 4 (multiply by 16), 5 (multiply by 32), 6 (multiply by 64), 7 (multiply by 128), 8 (multiply by 256), 9 (multiply by 512), 10 (multiply by 1024), 11 (multiply by 2048), 12 (multiply by 4096), 13 (multiply by 8192), 14 (multiply by 16384)
+# (case-insensitive).
+#tcp.default_window_scaling: Not known
+
+# Make the TCP dissector track the number on un-ACKed bytes of data are in flight per packet. To use this option you must also enable "Analyze TCP sequence numbers". This takes a lot of memory but allows you to track how much data are in flight at a time and graphing it in io-graphs
+# TRUE or FALSE (case-insensitive)
+#tcp.track_bytes_in_flight: TRUE
+
+# Evaluate BiF on actual sequence numbers or use the historical method based on payloads (default). This option has no effect if not used with "Track number of bytes in flight". 
+# TRUE or FALSE (case-insensitive)
+#tcp.bif_seq_based: FALSE
+
+# Calculate timestamps relative to the first frame and the previous frame in the tcp conversation
+# TRUE or FALSE (case-insensitive)
+#tcp.calculate_timestamps: TRUE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to a specific port
+# TRUE or FALSE (case-insensitive)
+#tcp.try_heuristic_first: FALSE
+
+# Do not place the TCP Timestamps in the summary line
+# TRUE or FALSE (case-insensitive)
+#tcp.ignore_tcp_timestamps: FALSE
+
+# When interpreting ambiguous packets, give precedence to Fast Retransmission or OOO 
+# TRUE or FALSE (case-insensitive)
+#tcp.fastrt_supersedes_ooo: TRUE
+
+# Do not call any subdissectors for Retransmitted or OutOfOrder segments
+# TRUE or FALSE (case-insensitive)
+#tcp.no_subdissector_on_error: TRUE
+
+# Assume TCP Experimental Options (253, 254) have an Experiment Identifier and use it for dissection
+# TRUE or FALSE (case-insensitive)
+#tcp.dissect_experimental_options_rfc6994: TRUE
+
+# Collect and store process information retrieved from IPFIX dissector
+# TRUE or FALSE (case-insensitive)
+#tcp.display_process_info_from_ipfix: FALSE
+
+# Read the sequence number as it was a syn cookie
+# TRUE or FALSE (case-insensitive)
+#tcp.read_seq_as_syn_cookie: FALSE
+
+# Whether the TCPCLv4 dissector should analyze the sequencing of the messages within each session.
+# TRUE or FALSE (case-insensitive)
+#tcpcl.analyze_sequence: TRUE
+
+# Whether the TCPCLv4 dissector should combine the sequential segments of a transfer into the full bundle being transfered.To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tcpcl.desegment_transfer: TRUE
+
+# If enabled, the bundle will be decoded as BPv7 content. Otherwise, it is assumed to be plain CBOR.
+# TRUE or FALSE (case-insensitive)
+#tcpcl.decode_bundle: TRUE
+
+# Whether the TCPROS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tcpros.desegment_tcpros_messages: TRUE
+
+# The TDMoE channel that contains the D-Channel.
+# A decimal number
+#tdmoe.d_channel: 24
+
+# The TDMoD channel that contains the D-Channel.
+# A decimal number
+#tdmop.d_channel: 16
+
+# The bitmask of channels in uncompressed TDMoP frame
+# A hexadecimal number
+#tdmop.ts_mask: 0xffffffff
+
+# The ethertype assigned to TDMoP (without IP/UDP) stream
+# A hexadecimal number
+#tdmop.ethertype: 0
+
+# Whether the TDS dissector should reassemble TDS buffers spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tds.desegment_buffers: TRUE
+
+# Whether the TDS dissector should defragment messages spanning multiple Netlib buffers
+# TRUE or FALSE (case-insensitive)
+#tds.defragment: TRUE
+
+# Hint as to version of TDS protocol being decoded
+# One of: Not Specified, TDS 4.x, TDS 5.0, TDS 7.0, TDS 7.1, TDS 7.2, TDS 7.3, TDS 7.3A, TDS 7.3B, TDS 7.4
+# (case-insensitive).
+#tds.protocol_type: Not Specified
+
+# Hint as to whether to decode TDS protocol as little-endian or big-endian. (TDS7/8 always decoded as little-endian)
+# One of: Little Endian, Big Endian
+# (case-insensitive).
+#tds.endian_type: Little Endian
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to "decode as"
+# TRUE or FALSE (case-insensitive)
+#tecmp.try_heuristic_first: FALSE
+
+# Treat the analog samples as signed integers and decode them accordingly.
+# TRUE or FALSE (case-insensitive)
+#tecmp.analog_samples_sint: TRUE
+
+# Move Ethernet into the TECMP Tree to be more space efficient.
+# TRUE or FALSE (case-insensitive)
+#tecmp.move_ethernet_in_tecmp_tree: FALSE
+
+# Whether the captured data include carrier number
+# TRUE or FALSE (case-insensitive)
+#tetra.include_carrier_number: TRUE
+
+# Whether fragmented TFTP files should be reassembled
+# TRUE or FALSE (case-insensitive)
+#tftp.defragment: FALSE
+
+# 32-bit sequence counter for hash
+# A string
+#thread.thr_seq_ctr: 
+
+# Set if the PAN ID should be used as the first two octets of the master key (PAN ID LSB), (PAN ID MSB), Key[2]...
+# TRUE or FALSE (case-insensitive)
+#thread.thr_use_pan_id_in_key: FALSE
+
+# Set if the Thread sequence counter should be automatically acquired from Key ID mode 2 MLE messages.
+# TRUE or FALSE (case-insensitive)
+#thread.thr_auto_acq_thr_seq_ctr: TRUE
+
+# How the binary should be decoded
+# One of: UTF-8 if printable, Binary (hexadecimal string), ASCII String, UTF-8 String, UTF-16 Big Endian, UTF-16 Little Endian, UTF-32 Big Endian, UTF-32 Little Endian
+# (case-insensitive).
+#thrift.decode_binary: UTF-8 if printable
+
+# Thrift TLS port
+# A decimal number
+#thrift.tls.port: 0
+
+# Whether the Thrift dissector should display Thrift internal fields for sub-dissectors.
+# TRUE or FALSE (case-insensitive)
+#thrift.show_internal: FALSE
+
+# Whether the Thrift dissector should try to dissect the data if the sub-dissector failed. This option can be useful if the data is well-formed but the sub-dissector is expecting different type/content.
+# TRUE or FALSE (case-insensitive)
+#thrift.fallback_on_generic: FALSE
+
+# Maximum expected depth of nested types in the Thrift structures and containers. A Thrift-based protocol using no parameter and void return types only uses a depth of 0. A Thrift-based protocol using only simple types as parameters or return values uses a depth of 1.
+# A decimal number
+#thrift.nested_type_depth: 25
+
+# Whether the Thrift dissector should reassemble framed messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#thrift.desegment_framed: TRUE
+
+# Try the default RSA key in use by nearly all Open Tibia servers
+# TRUE or FALSE (case-insensitive)
+#tibia.try_otserv_key: TRUE
+
+# Shows active character for every packet
+# TRUE or FALSE (case-insensitive)
+#tibia.show_char_name: TRUE
+
+# Shows account name/password or session key for every packet
+# TRUE or FALSE (case-insensitive)
+#tibia.show_acc_info: TRUE
+
+# Shows which XTEA key was applied for a packet
+# TRUE or FALSE (case-insensitive)
+#tibia.show_xtea_key: FALSE
+
+# Only decrypt packets and dissect login packets. Pass game commands to the data dissector
+# TRUE or FALSE (case-insensitive)
+#tibia.dissect_game_commands: FALSE
+
+# Whether the Tibia dissector should reassemble packets spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tibia.reassemble_tcp_segments: TRUE
+
+# Time display type
+# One of: UTC, Local
+# (case-insensitive).
+#time.display_time_type: Local
+
+# Whether TIPCv1 SEGMENTATION_MANAGER datagrams should be reassembled
+# TRUE or FALSE (case-insensitive)
+#tipc.defragment: TRUE
+
+# Whether to try to dissect TIPC data or not
+# TRUE or FALSE (case-insensitive)
+#tipc.dissect_tipc_data: TRUE
+
+# Try to decode a TIPCv2 packet using an heuristic sub-dissector before using a registered sub-dissector
+# TRUE or FALSE (case-insensitive)
+#tipc.try_heuristic_first: FALSE
+
+# TIPC 1.7 removes/adds fields (not) available in TIPC 1.5/1.6 while keeping the version number 2 in the packages. "ALL" shows all fields that were ever used in both versions.
+# One of: ALL, TIPC 1.5/1.6, TIPC 1.7
+# (case-insensitive).
+#tipc.handle_v2_as: ALL
+
+# Whether the TIPC-over-TCP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tipc.desegment: TRUE
+
+# Semicolon-separated list of private RSA keys used for TLS decryption. Used by versions of Wireshark prior to 1.6
+# A string
+#tls.keys_list: 
+
+# Redirect TLS debug to the file specified. Leave empty to disable debugging or use "-" to redirect output to stderr.
+# A path to a file
+#tls.debug_file: 
+
+# Whether the TLS dissector should reassemble TLS records spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tls.desegment_ssl_records: TRUE
+
+# Whether the TLS dissector should reassemble TLS Application Data spanning multiple TLS records. 
+# TRUE or FALSE (case-insensitive)
+#tls.desegment_ssl_application_data: TRUE
+
+# For troubleshooting ignore the mac check result and decrypt also if the Message Authentication Code (MAC) fails.
+# TRUE or FALSE (case-insensitive)
+#tls.ignore_ssl_mac_failed: FALSE
+
+# Pre-Shared Key as HEX string. Should be 0 to 16 bytes.
+# A string
+#tls.psk: 
+
+# The name of a file which contains a list of 
+# (pre-)master secrets in one of the following formats:
+# 
+# RSA <EPMS> <PMS>
+# RSA Session-ID:<SSLID> Master-Key:<MS>
+# CLIENT_RANDOM <CRAND> <MS>
+# PMS_CLIENT_RANDOM <CRAND> <PMS>
+# 
+# Where:
+# <EPMS> = First 8 bytes of the Encrypted PMS
+# <PMS> = The Pre-Master-Secret (PMS) used to derive the MS
+# <SSLID> = The SSL Session ID
+# <MS> = The Master-Secret (MS)
+# <CRAND> = The Client's random number from the ClientHello message
+# 
+# (All fields are in hex notation)
+# A path to a file
+#tls.keylog_file: 
+
+# Whether the TNS dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tns.desegment_tns_messages: TRUE
+
+# Whether Linux mangling of the link-layer header should be checked for and worked around
+# TRUE or FALSE (case-insensitive)
+#tr.fix_linux_botches: FALSE
+
+# Whether the TPKT dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#tpkt.desegment: TRUE
+
+# Whether to load the Database or not; not loading the DB disables the protocol; Wireshark has to be restarted for the setting to take effect.
+# TRUE or FALSE (case-insensitive)
+#tpncp.load_db: FALSE
+
+# Position of the capture unit that produced this trace.  This setting affects the way TRANSUM handles TCP Retransmissions.  See the manual for details.
+# One of: Client, Intermediate, Service
+# (case-insensitive).
+#transum.capture_position: Client
+
+# Set this to match to the TCP subdissector reassembly setting
+# TRUE or FALSE (case-insensitive)
+#transum.reassembly: TRUE
+
+# Add and remove ports numbers separated by commas
+# Ranges are supported e.g. 25,80,2000-3000,5432
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#transum.tcp_port_ranges: 25,80,443,1433
+
+# Add and remove ports numbers separated by commas
+# Ranges are supported e.g. 123,137-139,520-521,2049
+# A string denoting an positive integer range (e.g., "1-20,30-40")
+#transum.udp_port_ranges: 137-139
+
+# Set this to discard any packet in the direction client to service,
+# with a 1-byte payload of 0x00 and the ACK flag set
+# TRUE or FALSE (case-insensitive)
+#transum.orphan_ka_discard: FALSE
+
+# RTE data will be added to the first request packet
+# TRUE or FALSE (case-insensitive)
+#transum.rte_on_first_req: FALSE
+
+# RTE data will be added to the last request packet
+# TRUE or FALSE (case-insensitive)
+#transum.rte_on_last_req: TRUE
+
+# RTE data will be added to the first response packet
+# TRUE or FALSE (case-insensitive)
+#transum.rte_on_first_rsp: FALSE
+
+# RTE data will be added to the last response packet
+# TRUE or FALSE (case-insensitive)
+#transum.rte_on_last_rsp: FALSE
+
+# Set this only to troubleshoot problems
+# TRUE or FALSE (case-insensitive)
+#transum.debug_enabled: FALSE
+
+# Critical Traffic Mask (base hex)
+# A hexadecimal number
+#tte.ct_mask_value: 0
+
+# Critical Traffic Marker (base hex)
+# A hexadecimal number
+#tte.ct_marker_value: 0xffffffff
+
+# Setup RTP/RTCP conversations when parsing Start/Record RTP messages
+# TRUE or FALSE (case-insensitive)
+#ua3g.setup_conversations: TRUE
+
+# NOE SIP Protocol
+# TRUE or FALSE (case-insensitive)
+#uasip.noesip: FALSE
+
+# IPv4 address of the proxy (Invalid values will be ignored)
+# A string
+#uasip.proxy_ipaddr: 
+
+# IPv4 (or IPv6) address of the call server. (Used only in case of identical source and destination ports)
+# A string
+#uaudp.system_ip: 
+
+# Whether the UCP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ucp.desegment_ucp_messages: TRUE
+
+# Whether the UDP summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#udp.summary_in_tree: TRUE
+
+# Try to decode a packet using an heuristic sub-dissector before using a sub-dissector registered to a specific port
+# TRUE or FALSE (case-insensitive)
+udp.try_heuristic_first: TRUE
+
+# Whether to validate the UDP checksum
+# TRUE or FALSE (case-insensitive)
+#udp.check_checksum: FALSE
+
+# Whether to ignore zero-value UDP checksums over IPv6
+# TRUE or FALSE (case-insensitive)
+#udp.ignore_ipv6_zero_checksum: FALSE
+
+# Collect process flow information from IPFIX
+# TRUE or FALSE (case-insensitive)
+#udp.process_info: FALSE
+
+# Calculate timestamps relative to the first frame and the previous frame in the udp conversation
+# TRUE or FALSE (case-insensitive)
+#udp.calculate_timestamps: TRUE
+
+# Ignore an invalid checksum coverage field and continue dissection
+# TRUE or FALSE (case-insensitive)
+#udplite.ignore_checksum_coverage: TRUE
+
+# Whether to validate the UDP-Lite checksum
+# TRUE or FALSE (case-insensitive)
+#udplite.check_checksum: FALSE
+
+# Calculate timestamps relative to the first frame and the previous frame in the udp-lite conversation
+# TRUE or FALSE (case-insensitive)
+#udplite.calculate_timestamps: TRUE
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#udpcp.attempt_reassembly: TRUE
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#udpcp.attempt_xml_decode: TRUE
+
+# Whether the ULP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ulp.desegment_ulp_messages: TRUE
+
+# Whether the UMA dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#uma.desegment_ucp_messages: TRUE
+
+# Try to decode a packet using a heuristic sub-dissector before attempting to dissect the packet using the "usb.bulk", "usb.interrupt" or "usb.control" dissector tables.
+# TRUE or FALSE (case-insensitive)
+#usb.try_heuristics: TRUE
+
+# Use specified speed if speed is not indicated in capture
+# One of: Unknown, Low-Speed, Full-Speed, High-Speed
+# (case-insensitive).
+#usbll.global_pref_dissect_unknown_speed_as: Unknown
+
+# Activate workaround for weird Ettus UHD header offset on data packets
+# TRUE or FALSE (case-insensitive)
+#vrt.ettus_uhd_header_format: FALSE
+
+# Whether the vlan summary line should be shown in the protocol tree
+# TRUE or FALSE (case-insensitive)
+#vlan.summary_in_tree: TRUE
+
+# The (hexadecimal) Ethertype used to indicate 802.1QinQ VLAN in VLAN tunneling.
+# A hexadecimal number
+#vlan.qinq_ethertype: 0x9100
+
+# IEEE 802.1Q specification version used (802.1Q-1998 uses 802.1D-2004 for PRI values)
+# One of: IEEE 802.1Q-1998, IEEE 802.1Q-2005, IEEE 802.1Q-2011
+# (case-insensitive).
+#vlan.version: IEEE 802.1Q-2011
+
+# Number of priorities supported, and number of those drop eligible (not used for 802.1Q-1998)
+# One of: 8 Priorities, 0 Drop Eligible, 7 Priorities, 1 Drop Eligible, 6 Priorities, 2 Drop Eligible, 5 Priorities, 3 Drop Eligible
+# (case-insensitive).
+#vlan.priority_drop: 8 Priorities, 0 Drop Eligible
+
+# Whether the VNC dissector should reassemble messages spanning multiple TCP segments.  To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#vnc.desegment: TRUE
+
+# There is some ambiguity on how to calculate V3 checksumsAs in V3 will use a pseudo header(which may only be implemented for IPv6 by some manufacturers)
+# TRUE or FALSE (case-insensitive)
+#vrrp.v3_checksum_as_in_v2: FALSE
+
+# Whether the VSS Monitoring dissector should attempt to dissect trailers with no timestamp, only port stamping.  Note that this can result in a large number of false positives.
+# TRUE or FALSE (case-insensitive)
+#vssmonitoring.dissect_portstamping_only: FALSE
+
+# Whether the VSS Monitoring dissector should assume that the port stamp is two bytes, instead of the standard one byte.
+# TRUE or FALSE (case-insensitive)
+#vssmonitoring.two_byte_portstamps: FALSE
+
+# Enable this preference if you want to view the WBXML tokens without the representation in a media type (e.g., WML). Tokens will show up as Tag_0x12, attrStart_0x08 or attrValue_0x0B for example.
+# TRUE or FALSE (case-insensitive)
+#wbxml.skip_wbxml_token_mapping: FALSE
+
+# Enable this preference if you want to skip the parsing of the WBXML tokens that constitute the body of the WBXML document. Only the WBXML header will be dissected (and visualized) then.
+# TRUE or FALSE (case-insensitive)
+#wbxml.disable_wbxml_token_parsing: FALSE
+
+# Select dissector for websocket text
+# One of: No subdissection, Line based text, As json, As SIP
+# (case-insensitive).
+#websocket.text_type: No subdissection
+
+# No description
+# TRUE or FALSE (case-insensitive)
+#websocket.decompress: TRUE
+
+# The TCP port DPP over TCP uses
+# A decimal number
+#dpp.tcp.port: 7871
+
+# Set the maximum Basic CID used in the Wimax decoder (if other than the default of 320).  Note: The maximum Primary CID is double the maximum Basic CID.
+# A decimal number
+#wmx.basic_cid_max: 320
+
+# Set to TRUE to use the Corrigendum 2 version of Wimax message decoding. Set to FALSE to use the 802.16e-2005  version.
+# TRUE or FALSE (case-insensitive)
+#wmx.corrigendum_2_version: FALSE
+
+# Show transaction ID direction bit separately from the rest of the transaction ID field.
+# TRUE or FALSE (case-insensitive)
+#wimaxasncp.show_transaction_id_d_bit: FALSE
+
+# Print debug output to the console.
+# TRUE or FALSE (case-insensitive)
+#wimaxasncp.debug_enabled: FALSE
+
+# Version of the NWG that the R6 protocol complies with
+# One of: R1.0 v1.0.0, R1.0 v1.2.0, R1.0 v1.2.1
+# (case-insensitive).
+#wimaxasncp.nwg_version: R1.0 v1.2.1
+
+# Whether the WINS-Replication dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#winsrepl.reassemble: TRUE
+
+# Whether the IP dissector should dissect decrypted transport data.
+# TRUE or FALSE (case-insensitive)
+#wg.dissect_packet: TRUE
+
+# The path to the file which contains a list of secrets in the following format:
+# "<key-type> = <base64-encoded-key>" (without quotes, leading spaces and spaces around '=' are ignored).
+# <key-type> is one of: LOCAL_STATIC_PRIVATE_KEY, REMOTE_STATIC_PUBLIC_KEY, LOCAL_EPHEMERAL_PRIVATE_KEY or PRESHARED_KEY.
+# A path to a file
+#wg.keylog_file: 
+
+# Whether the wow dissector should reassemble messages spanning multiple TCP segments.  To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#wow.desegment: TRUE
+
+# If CALL REQUEST not seen or didn't specify protocol, dissect as QLLC/SNA
+# TRUE or FALSE (case-insensitive)
+#x25.payload_is_qllc_sna: FALSE
+
+# If CALL REQUEST has no data, assume the protocol handled is COTP
+# TRUE or FALSE (case-insensitive)
+#x25.call_request_nodata_is_cotp: FALSE
+
+# If CALL REQUEST not seen or didn't specify protocol, check user data before checking heuristic dissectors
+# TRUE or FALSE (case-insensitive)
+#x25.payload_check_data: FALSE
+
+# Reassemble fragmented X.25 packets
+# TRUE or FALSE (case-insensitive)
+#x25.reassemble: TRUE
+
+# Whether the X11 dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#x11.desegment: TRUE
+
+# Select whether RRC Context should be dissected as legacy LTE or NB-IOT
+# One of: LTE, NB-IoT
+# (case-insensitive).
+#x2ap.dissect_rrc_context_as: LTE
+
+# Try to recognize XML encoded in Unicode (UCS-2BE)
+# TRUE or FALSE (case-insensitive)
+#xml.heuristic_unicode: FALSE
+
+# Whether the XMPP dissector should reassemble messages. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings
+# TRUE or FALSE (case-insensitive)
+#xmpp.desegment: TRUE
+
+# Select whether target NG-RAN container should be decoded automatically (based on Xn Setup procedure) or manually
+# One of: automatic, gNB, ng-eNB
+# (case-insensitive).
+#xnap.dissect_target_ng_ran_container_as: automatic
+
+# Select whether LTE RRC Context should be dissected as legacy LTE or NB-IOT
+# One of: LTE, NB-IoT
+# (case-insensitive).
+#xnap.dissect_lte_rrc_context_as: LTE
+
+# Whether the X.25-over-TCP dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings
+# TRUE or FALSE (case-insensitive)
+#xot.desegment: TRUE
+
+# Whether the X.25-over-TCP dissector should reassemble all X.25 packets before calling the X25 dissector. If the TCP packets arrive out-of-order, the X.25 reassembly can otherwise fail. To use this option, you should also enable "Reassemble X.25-over-TCP messages spanning multiple TCP segments", "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings and "Reassemble fragmented X.25 packets" in the X.25 protocol settings.
+# TRUE or FALSE (case-insensitive)
+#xot.x25_desegment: FALSE
+
+# Whether the YAMI dissector should reassemble messages spanning multiple TCP segments.To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#yami.desegment: TRUE
+
+# Whether the YMSG dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#ymsg.desegment: TRUE
+
+# Whether the Z39.50 dissector should reassemble TDS buffers spanning multiple TCP segments. To use this option, you must also enable "Allow subdissectors to reassemble TCP streams" in the TCP protocol settings.
+# TRUE or FALSE (case-insensitive)
+#z3950.desegment_buffers: TRUE
+
+# Specifies the security level to use in the
+# decryption process. This value is ignored
+# for ZigBee 2004 and unsecured networks.
+# One of: No Security, No Encryption, 32-bit Integrity Protection, No Encryption, 64-bit Integrity Protection, No Encryption, 128-bit Integrity Protection, AES-128 Encryption, No Integrity Protection, AES-128 Encryption, 32-bit Integrity Protection, AES-128 Encryption, 64-bit Integrity Protection, AES-128 Encryption, 128-bit Integrity Protection
+# (case-insensitive).
+#zbee_nwk.seclevel: AES-128 Encryption, 32-bit Integrity Protection
+
+# Specifies the ZigBee Smart Energy version used when dissecting ZigBee APS messages within the Smart Energy Profile
+# One of: SE 1.1b, SE 1.2, SE 1.2a, SE 1.2b, SE 1.4
+# (case-insensitive).
+#zbee_aps.zbeeseversion: SE 1.4
+
+####### Statistics ########
+
+# Determines time between tap updates
+# A decimal number
+#statistics.update_interval: 3000
+
+# If enabled burst rates will be calculated for statistics that use the stats_tree system. Burst rates are calculated over a much shorter time interval than the rate column.
+# TRUE or FALSE (case-insensitive)
+#statistics.st_enable_burstinfo: TRUE
+
+# If selected the stats_tree statistics nodes will show the count of events within the burst window instead of a burst rate. Burst rate is calculated as number of events within burst window divided by the burst windown length.
+# TRUE or FALSE (case-insensitive)
+#statistics.st_burst_showcount: FALSE
+
+# Sets the duration of the time interval into which events are grouped when calculating the burst rate. Higher resolution (smaller number) increases processing overhead.
+# A decimal number
+#statistics.st_burst_resolution: 5
+
+# Sets the duration of the sliding window during which the burst rate is measured. Longer window relative to burst rate resolution increases processing overhead. Will be truncated to a multiple of burst resolution.
+# A decimal number
+#statistics.st_burst_windowlen: 100
+
+# Sets the default column by which stats based on the stats_tree system is sorted.
+# One of: Node name (topic/item), Item count, Average value of the node, Minimum value of the node, Maximum value of the node, Burst rate of the node
+# (case-insensitive).
+#statistics.st_sort_defcolflag: Item count
+
+# When selected, statistics based on the stats_tree system will by default be sorted in descending order.
+# TRUE or FALSE (case-insensitive)
+#statistics.st_sort_defdescending: TRUE
+
+# When selected, the item/node names of statistics based on the stats_tree system will be sorted taking case into account. Else the case of the name will be ignored.
+# TRUE or FALSE (case-insensitive)
+#statistics.st_sort_casesensitve: TRUE
+
+# When selected, the stats_tree nodes representing a range of values (0-49, 50-100, etc.) will always be sorted by name (the range of the node). Else range nodes are sorted by the same column as the rest of  the tree.
+# TRUE or FALSE (case-insensitive)
+#statistics.st_sort_rng_nameonly: TRUE
+
+# When selected, the stats_tree nodes representing a range of values (0-49, 50-100, etc.) will always be sorted ascending; else it follows the sort direction of the tree. Only effective if "Always sort 'range' nodes by name" is also selected.
+# TRUE or FALSE (case-insensitive)
+#statistics.st_sort_rng_fixorder: TRUE
+
+# When selected, the full name (including menu path) of the stats_tree plug-in is show in windows. If cleared the plug-in name is shown without menu path (only the part of the name after last '/' character.)
+# TRUE or FALSE (case-insensitive)
+#statistics.st_sort_showfullname: FALSE
diff --git a/resources/share/wireshark/profiles/WDissector/user_dlts b/resources/share/wireshark/profiles/WDissector/user_dlts
new file mode 100644
index 00000000000..aab294658a1
--- /dev/null
+++ b/resources/share/wireshark/profiles/WDissector/user_dlts
@@ -0,0 +1 @@
+# This file is automatically generated, DO NOT MODIFY.
diff --git a/speexdsp/resample.c b/speexdsp/resample.c
index 32197fe5f6d..c0f520f41b6 100644
--- a/speexdsp/resample.c
+++ b/speexdsp/resample.c
@@ -59,7 +59,7 @@
 
 #include <config.h>
 
-#define OUTSIDE_SPEEX 1
+//#define OUTSIDE_SPEEX 1
 #define FLOATING_POINT 1
 
 #ifdef OUTSIDE_SPEEX
diff --git a/speexdsp/speex_resampler.h b/speexdsp/speex_resampler.h
index 284e7ec8eda..bcaa1f19c5e 100644
--- a/speexdsp/speex_resampler.h
+++ b/speexdsp/speex_resampler.h
@@ -40,7 +40,7 @@
 #ifndef SPEEX_RESAMPLER_H
 #define SPEEX_RESAMPLER_H
 
-#define OUTSIDE_SPEEX 1
+
 #define RANDOM_PREFIX ws_codec
 #include <ws_symbol_export.h>
 #include <ws_diag_control.h>
@@ -84,17 +84,13 @@
 #define speex_resampler_reset_mem CAT_PREFIX(RANDOM_PREFIX,_resampler_reset_mem)
 #define speex_resampler_strerror CAT_PREFIX(RANDOM_PREFIX,_resampler_strerror)
 
+#endif /* OUTSIDE_SPEEX */
+
 #define spx_int16_t short
 #define spx_int32_t int
 #define spx_uint16_t unsigned short
 #define spx_uint32_t unsigned int
 
-#else /* OUTSIDE_SPEEX */
-
-#include "speexdsp_types.h"
-
-#endif /* OUTSIDE_SPEEX */
-
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/tshark.c b/tshark.c
index 066491fb500..b1f7867d0a3 100644
--- a/tshark.c
+++ b/tshark.c
@@ -4593,7 +4593,7 @@ reset_epan_mem(capture_file *cf,epan_dissect_t *edt, gboolean tree, gboolean vis
     if (!epan_auto_reset || (cf->count < epan_auto_reset_count))
         return;
 
-    fprintf(stderr, "resetting session.\n");
+    // fprintf(stderr, "resetting session.\n");
 
     epan_dissect_cleanup(edt);
     epan_free(cf->epan);
diff --git a/ui/recent.c b/ui/recent.c
index e3d8b6bdc04..0b3552c3cf4 100644
--- a/ui/recent.c
+++ b/ui/recent.c
@@ -27,6 +27,8 @@
 #include "ui/recent_utils.h"
 #include "ui/packet_list_utils.h"
 #include "ui/simple_dialog.h"
+#include "ui/profile.h"
+
 
 #include <wsutil/file_util.h>
 
@@ -650,7 +652,6 @@ write_recent(void)
     char        *rf_path;
     FILE        *rf;
     char        *string_list;
-
     /* To do:
      * - Split output lines longer than MAX_VAL_LEN
      * - Create a function for the preference directory check/creation
@@ -977,7 +978,6 @@ read_set_recent_common_pair_static(gchar *key, const gchar *value,
 {
     long num;
     char *p;
-
     if (strcmp(key, RECENT_GUI_GEOMETRY_MAIN_MAXIMIZED) == 0) {
         parse_recent_boolean(value, &recent.gui_geometry_main_maximized);
     } else if (strcmp(key, RECENT_GUI_GEOMETRY_LEFTALIGN_ACTIONS) == 0) {
@@ -1340,6 +1340,8 @@ recent_read_static(char **rf_path_return, int *rf_errno_return)
         /* We failed to open it.  If we failed for some reason other than
            "it doesn't exist", return the errno and the pathname, so our
            caller can report the error. */
+        // Force first wireshark run to set WDissector profile
+        set_profile_name ("WDissector");
         if (errno != ENOENT) {
             *rf_errno_return = errno;
             *rf_path_return = rf_path;
diff --git a/vcs_version.h b/vcs_version.h
new file mode 100644
index 00000000000..e48907b15c8
--- /dev/null
+++ b/vcs_version.h
@@ -0,0 +1 @@
+#define VCSVERSION "v4.1.0rc0-673-g3baf3216acca"
diff --git a/wiretap/CMakeLists.txt b/wiretap/CMakeLists.txt
index 7f6c062bec1..a38a2a6fb50 100644
--- a/wiretap/CMakeLists.txt
+++ b/wiretap/CMakeLists.txt
@@ -150,8 +150,8 @@ file(GENERATE
 )
 add_custom_command(
 	OUTPUT wtap_modules.c
-	COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_SOURCE_DIR}/tools/make-regs.py wtap_modules wtap_modules.c @wtap_modules.in.txt
-	DEPENDS ${CMAKE_SOURCE_DIR}/tools/make-regs.py ${WIRETAP_MODULE_FILES}
+	COMMAND ${PYTHON_EXECUTABLE} ${PROJECT_SOURCE_DIR}/tools/make-regs.py wtap_modules wtap_modules.c @wtap_modules.in.txt
+	DEPENDS ${PROJECT_SOURCE_DIR}/tools/make-regs.py ${WIRETAP_MODULE_FILES}
 		"${CMAKE_CURRENT_BINARY_DIR}/wtap_modules.in.txt"
 	COMMENT "Making wtap_modules.c"
 )
@@ -167,7 +167,7 @@ set_source_files_properties(
 
 add_library(wiretap
 	${WIRETAP_FILES}
-	${CMAKE_BINARY_DIR}/resources/libwiretap.rc
+	${PROJECT_BINARY_DIR}/resources/libwiretap.rc
 )
 
 set_target_properties(wiretap PROPERTIES
@@ -202,6 +202,9 @@ target_include_directories(wiretap PUBLIC
 	$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
 )
 
+export(TARGETS wiretap NAMESPACE wireshark::
+FILE ${PROJECT_BINARY_DIR}/wiretap-targets.cmake)
+
 install(TARGETS wiretap
 	EXPORT WiresharkTargets
 	RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
diff --git a/wiretap/packetlogger.c b/wiretap/packetlogger.c
index 1d9951d3208..75766658de0 100644
--- a/wiretap/packetlogger.c
+++ b/wiretap/packetlogger.c
@@ -83,7 +83,6 @@ wtap_open_return_val packetlogger_open(wtap *wth, int *err, gchar **err_info)
 	packetlogger_header_t pl_hdr;
 	wtap_open_return_val ret;
 	packetlogger_t *packetlogger;
-
 	/*
 	 * Try to read the first record.
 	 */
diff --git a/wiretap/wtap_opttypes.c b/wiretap/wtap_opttypes.c
index 268d31a1d2e..2f76f3c6868 100644
--- a/wiretap/wtap_opttypes.c
+++ b/wiretap/wtap_opttypes.c
@@ -285,7 +285,7 @@ void* wtap_block_get_mandatory_data(wtap_block_t block)
     return block->mandatory_data;
 }
 
-static wtap_optval_t *
+wtap_optval_t *
 wtap_block_get_option(wtap_block_t block, guint option_id)
 {
     guint i;
diff --git a/wiretap/wtap_opttypes.h b/wiretap/wtap_opttypes.h
index 93300161b66..704bedf59c7 100644
--- a/wiretap/wtap_opttypes.h
+++ b/wiretap/wtap_opttypes.h
@@ -596,6 +596,14 @@ wtap_block_get_type(wtap_block_t block);
 WS_DLL_PUBLIC void*
 wtap_block_get_mandatory_data(wtap_block_t block);
 
+/** Provide option pointer
+ *
+ * @param[in] block Block from which to retrieve option pointer
+ * @return Option pointer.
+ */
+WS_DLL_PUBLIC wtap_optval_t *
+wtap_block_get_option(wtap_block_t block, guint option_id);
+
 /** Count the number of times the given option appears in the block
  *
  * @param[in] block Block to which to add the option
diff --git a/wsutil/CMakeLists.txt b/wsutil/CMakeLists.txt
index 61786a1ccb2..e49dc87e14f 100644
--- a/wsutil/CMakeLists.txt
+++ b/wsutil/CMakeLists.txt
@@ -7,9 +7,12 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 #
 
-add_definitions(-DPLUGIN_DIR=\"${CMAKE_INSTALL_PREFIX}/${PLUGIN_INSTALL_LIBDIR}\")
-add_definitions(-DEXTCAP_DIR=\"${CMAKE_INSTALL_PREFIX}/${EXTCAP_INSTALL_LIBDIR}\")
-add_definitions(-DDATA_DIR=\"${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_DATADIR}\")
+# add_definitions(-DPLUGIN_DIR=\"${CMAKE_INSTALL_PREFIX}/${PLUGIN_INSTALL_LIBDIR}\")
+# add_definitions(-DEXTCAP_DIR=\"${CMAKE_INSTALL_PREFIX}/${EXTCAP_INSTALL_LIBDIR}\")
+# add_definitions(-DDATA_DIR=\"${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_DATADIR}\")
+add_definitions(-DPLUGIN_DIR=\"bin/ws/plugins\")
+add_definitions(-DEXTCAP_DIR=\"bin/ws/extcap\")
+add_definitions(-DDATA_DIR=\"bin/ws\")
 
 add_subdirectory(wmem)
 
@@ -262,7 +265,7 @@ endif()
 add_library(wsutil
 	${WSUTIL_FILES}
 	$<TARGET_OBJECTS:wmem>
-	${CMAKE_BINARY_DIR}/resources/libwsutil.rc
+	${PROJECT_BINARY_DIR}/resources/libwsutil.rc
 )
 
 target_compile_definitions(wsutil PRIVATE
@@ -306,6 +309,9 @@ target_include_directories(wsutil
 		${PCRE2_INCLUDE_DIRS}
 )
 
+export(TARGETS wsutil NAMESPACE wireshark::
+FILE ${PROJECT_BINARY_DIR}/wsutil-targets.cmake)
+
 install(TARGETS wsutil
 	EXPORT WiresharkTargets
 	RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
diff --git a/wsutil/filesystem.c b/wsutil/filesystem.c
index 4d749da2fb5..9adad7714c7 100644
--- a/wsutil/filesystem.c
+++ b/wsutil/filesystem.c
@@ -1217,7 +1217,6 @@ void
 set_profile_name(const gchar *profilename)
 {
     g_free (persconfprofile);
-
     if (profilename && strlen(profilename) > 0 &&
         strcmp(profilename, DEFAULT_PROFILE) != 0) {
         persconfprofile = g_strdup (profilename);
@@ -1435,8 +1434,13 @@ set_persconffile_dir(const char *p)
 char *
 get_profiles_dir(void)
 {
-    return ws_strdup_printf ("%s%s%s", get_persconffile_dir_no_profile (),
-                    G_DIR_SEPARATOR_S, PROFILES_DIR);
+    if (persconffile_dir)
+         g_free(persconffile_dir);
+
+    persconffile_dir = g_strdup(DATA_DIR "/profiles");
+    return g_strdup(DATA_DIR "/profiles");
+    // return ws_strdup_printf ("%s%s%s", get_persconffile_dir_no_profile (),
+    //                 G_DIR_SEPARATOR_S, PROFILES_DIR);
 }
 
 int
diff --git a/wsutil/privileges.c b/wsutil/privileges.c
index 9bee5bbd398..562f1d0a758 100644
--- a/wsutil/privileges.c
+++ b/wsutil/privileges.c
@@ -142,6 +142,10 @@ init_process_policies(void)
 	egid = getegid();
 
 	init_process_policies_called = TRUE;
+
+	g_setenv("WIRESHARK_DATA_DIR", "bin/ws", TRUE);
+	g_setenv("WIRESHARK_PLUGIN_DIR", "bin/ws/plugins", TRUE);
+	g_setenv("WIRESHARK_EXTCAP_DIR", "bin/ws/extcap", TRUE);
 }
 
 /*
diff --git a/wsutil/wmem/wmem_allocator_block_fast.c b/wsutil/wmem/wmem_allocator_block_fast.c
index bdb8c2f75dc..4fb361e4227 100644
--- a/wsutil/wmem/wmem_allocator_block_fast.c
+++ b/wsutil/wmem/wmem_allocator_block_fast.c
@@ -26,7 +26,7 @@
  * extensions for x86 and ppc32 would want a larger alignment than this, but
  * we don't need to do better than malloc.
  */
-#define WMEM_ALIGN_AMOUNT (2 * sizeof (gsize))
+#define WMEM_ALIGN_AMOUNT (1 * sizeof (gsize))
 #define WMEM_ALIGN_SIZE(SIZE) ((~(WMEM_ALIGN_AMOUNT-1)) & \
         ((SIZE) + (WMEM_ALIGN_AMOUNT-1)))
 
@@ -39,7 +39,7 @@
  * 2MB is a pretty arbitrary value - it's big enough that it should last a while
  * and small enough that a mostly-unused one doesn't waste *too* much. It's
  * also a nice power of two, of course. */
-#define WMEM_BLOCK_SIZE (2 * 1024 * 1024)
+#define WMEM_BLOCK_SIZE (64 * 1024 * 1024)
 
 /* The header for an entire OS-level 'block' of memory */
 typedef struct _wmem_block_fast_hdr {
diff --git a/wsutil/wmem/wmem_map.c b/wsutil/wmem/wmem_map.c
index 2807e06aa93..1b930f3f5d2 100644
--- a/wsutil/wmem/wmem_map.c
+++ b/wsutil/wmem/wmem_map.c
@@ -60,6 +60,8 @@ struct _wmem_map_t {
 
     wmem_allocator_t *metadata_allocator;
     wmem_allocator_t *data_allocator;
+
+    GMutex mutex;
 };
 
 /* As per the comment on the 'capacity' member of the wmem_map_t struct, this is
@@ -98,6 +100,7 @@ wmem_map_new(wmem_allocator_t *allocator,
     map->data_allocator = allocator;
     map->count = 0;
     map->table = NULL;
+    g_mutex_init(&map->mutex);
 
     return map;
 }
@@ -113,6 +116,7 @@ wmem_map_reset_cb(wmem_allocator_t *allocator _U_, wmem_cb_event_t event,
 
     if (event == WMEM_CB_DESTROY_EVENT) {
         wmem_unregister_callback(map->metadata_allocator, map->metadata_scope_cb_id);
+        g_mutex_clear(&map->mutex);
         wmem_free(map->metadata_allocator, map);
     }
 
@@ -144,6 +148,7 @@ wmem_map_new_autoreset(wmem_allocator_t *metadata_scope, wmem_allocator_t *data_
     map->data_allocator = data_scope;
     map->count = 0;
     map->table = NULL;
+    g_mutex_init(&map->mutex);
 
     map->metadata_scope_cb_id = wmem_register_callback(metadata_scope, wmem_map_destroy_cb, map);
     map->data_scope_cb_id  = wmem_register_callback(data_scope, wmem_map_reset_cb, map);
@@ -189,6 +194,8 @@ wmem_map_insert(wmem_map_t *map, const void *key, void *value)
     wmem_map_item_t **item;
     void *old_val;
 
+    g_mutex_lock(&map->mutex);
+
     /* Make sure we have a table */
     if (map->table == NULL) {
         wmem_map_init_table(map);
@@ -203,6 +210,7 @@ wmem_map_insert(wmem_map_t *map, const void *key, void *value)
             /* replace and return old value for this key */
             old_val = (*item)->value;
             (*item)->value = value;
+            g_mutex_unlock(&map->mutex);
             return old_val;
         }
         item = &((*item)->next);
@@ -222,6 +230,8 @@ wmem_map_insert(wmem_map_t *map, const void *key, void *value)
         wmem_map_grow(map);
     }
 
+    g_mutex_unlock(&map->mutex);
+
     /* no previous entry, return NULL */
     return NULL;
 }
@@ -236,17 +246,22 @@ wmem_map_contains(wmem_map_t *map, const void *key)
         return FALSE;
     }
 
+    g_mutex_lock(&map->mutex);
+
     /* find correct slot */
     item = map->table[HASH(map, key)];
 
     /* scan list of items in this slot for the correct value */
     while (item) {
         if (map->eql_func(key, item->key)) {
+            g_mutex_unlock(&map->mutex);
             return TRUE;
         }
         item = item->next;
     }
 
+    g_mutex_unlock(&map->mutex);
+
     return FALSE;
 }
 
@@ -260,17 +275,22 @@ wmem_map_lookup(wmem_map_t *map, const void *key)
         return NULL;
     }
 
+    g_mutex_lock(&map->mutex);
+
     /* find correct slot */
     item = map->table[HASH(map, key)];
 
     /* scan list of items in this slot for the correct value */
     while (item) {
         if (map->eql_func(key, item->key)) {
+            g_mutex_unlock(&map->mutex);
             return item->value;
         }
         item = item->next;
     }
 
+    g_mutex_unlock(&map->mutex);
+
     return NULL;
 }
 
@@ -284,6 +304,8 @@ wmem_map_lookup_extended(wmem_map_t *map, const void *key, const void **orig_key
         return FALSE;
     }
 
+    g_mutex_lock(&map->mutex);
+
     /* find correct slot */
     item = map->table[HASH(map, key)];
 
@@ -296,11 +318,14 @@ wmem_map_lookup_extended(wmem_map_t *map, const void *key, const void **orig_key
             if (value) {
                 *value = item->value;
             }
+            g_mutex_unlock(&map->mutex);
             return TRUE;
         }
         item = item->next;
     }
 
+    g_mutex_unlock(&map->mutex);
+
     return FALSE;
 }
 
@@ -315,6 +340,8 @@ wmem_map_remove(wmem_map_t *map, const void *key)
         return NULL;
     }
 
+    g_mutex_lock(&map->mutex);
+
     /* get a pointer to the slot */
     item = &(map->table[HASH(map, key)]);
 
@@ -327,11 +354,14 @@ wmem_map_remove(wmem_map_t *map, const void *key)
             (*item) = tmp->next;
             wmem_free(map->data_allocator, tmp);
             map->count--;
+            g_mutex_unlock(&map->mutex);
             return value;
         }
         item = &((*item)->next);
     }
 
+    g_mutex_unlock(&map->mutex);
+
     /* didn't find it */
     return NULL;
 }
@@ -346,6 +376,8 @@ wmem_map_steal(wmem_map_t *map, const void *key)
         return FALSE;
     }
 
+    g_mutex_lock(&map->mutex);
+
     /* get a pointer to the slot */
     item = &(map->table[HASH(map, key)]);
 
@@ -356,11 +388,14 @@ wmem_map_steal(wmem_map_t *map, const void *key)
             tmp     = (*item);
             (*item) = tmp->next;
             map->count--;
+            g_mutex_unlock(&map->mutex);
             return TRUE;
         }
         item = &((*item)->next);
     }
 
+    g_mutex_unlock(&map->mutex);
+
     /* didn't find it */
     return FALSE;
 }
@@ -372,6 +407,8 @@ wmem_map_get_keys(wmem_allocator_t *list_allocator, wmem_map_t *map)
     wmem_map_item_t *cur;
     wmem_list_t* list = wmem_list_new(list_allocator);
 
+    g_mutex_lock(&map->mutex);
+
     if (map->table != NULL) {
         capacity = CAPACITY(map);
 
@@ -385,6 +422,8 @@ wmem_map_get_keys(wmem_allocator_t *list_allocator, wmem_map_t *map)
         }
     }
 
+    g_mutex_unlock(&map->mutex);
+
     return list;
 }
 
@@ -399,6 +438,8 @@ wmem_map_foreach(wmem_map_t *map, GHFunc foreach_func, gpointer user_data)
         return;
     }
 
+    g_mutex_lock(&map->mutex);
+
     for (i = 0; i < CAPACITY(map); i++) {
         cur = map->table[i];
         while (cur) {
@@ -406,6 +447,8 @@ wmem_map_foreach(wmem_map_t *map, GHFunc foreach_func, gpointer user_data)
             cur = cur->next;
         }
     }
+
+    g_mutex_unlock(&map->mutex);
 }
 
 guint
@@ -419,6 +462,8 @@ wmem_map_foreach_remove(wmem_map_t *map, GHRFunc foreach_func, gpointer user_dat
         return 0;
     }
 
+    g_mutex_lock(&map->mutex);
+
     for (i = 0; i < CAPACITY(map); i++) {
         item = &(map->table[i]);
         while (*item) {
@@ -433,6 +478,8 @@ wmem_map_foreach_remove(wmem_map_t *map, GHRFunc foreach_func, gpointer user_dat
             }
         }
     }
+
+    g_mutex_unlock(&map->mutex);
     return deleted;
 }
 
diff --git a/wsutil/wmem/wmem_tree-int.h b/wsutil/wmem/wmem_tree-int.h
index 3dc6de866ac..8d8d75e4782 100644
--- a/wsutil/wmem/wmem_tree-int.h
+++ b/wsutil/wmem/wmem_tree-int.h
@@ -51,6 +51,9 @@ struct _wmem_tree_t {
     wmem_tree_node_t *root;
     guint             metadata_scope_cb_id;
     guint             data_scope_cb_id;
+    GMutex            mutex_lv1;
+    GMutex            mutex_lv2;
+    GMutex            mutex_lv3;
 
     void (*post_rotation_cb)(wmem_tree_node_t *);
 };
diff --git a/wsutil/wmem/wmem_tree.c b/wsutil/wmem/wmem_tree.c
index 045cb017a81..f4982c87f5d 100644
--- a/wsutil/wmem/wmem_tree.c
+++ b/wsutil/wmem/wmem_tree.c
@@ -201,6 +201,9 @@ wmem_tree_new(wmem_allocator_t *allocator)
     tree = wmem_new0(allocator, wmem_tree_t);
     tree->metadata_allocator    = allocator;
     tree->data_allocator = allocator;
+    g_mutex_init(&tree->mutex_lv1);
+    g_mutex_init(&tree->mutex_lv2);
+    g_mutex_init(&tree->mutex_lv3);
 
     return tree;
 }
@@ -215,6 +218,9 @@ wmem_tree_reset_cb(wmem_allocator_t *allocator _U_, wmem_cb_event_t event,
 
     if (event == WMEM_CB_DESTROY_EVENT) {
         wmem_unregister_callback(tree->metadata_allocator, tree->metadata_scope_cb_id);
+        g_mutex_clear(&tree->mutex_lv1);
+        g_mutex_clear(&tree->mutex_lv2);
+        g_mutex_clear(&tree->mutex_lv3);
         wmem_free(tree->metadata_allocator, tree);
     }
 
@@ -246,6 +252,10 @@ wmem_tree_new_autoreset(wmem_allocator_t *metadata_scope, wmem_allocator_t *data
     tree->data_scope_cb_id  = wmem_register_callback(data_scope, wmem_tree_reset_cb,
             tree);
 
+    g_mutex_init(&tree->mutex_lv1);
+    g_mutex_init(&tree->mutex_lv2);
+    g_mutex_init(&tree->mutex_lv3);
+
     return tree;
 }
 
@@ -261,7 +271,15 @@ free_tree_node(wmem_allocator_t *allocator, wmem_tree_node_t* node, gboolean fre
     }
 
     if (node->is_subtree) {
-        wmem_tree_destroy((wmem_tree_t *)node->data, free_keys, free_values);
+        wmem_tree_t *node_data = (wmem_tree_t *)node->data;
+        free_tree_node(node_data->data_allocator, node_data->root, free_keys, free_values);
+        if (node_data->metadata_allocator) {
+            wmem_unregister_callback(node_data->metadata_allocator, node_data->metadata_scope_cb_id);
+        }
+        if (node_data->data_allocator) {
+            wmem_unregister_callback(node_data->data_allocator, node_data->data_scope_cb_id);
+        }
+        wmem_free(node_data->metadata_allocator, node_data);
         node->data = NULL;
     }
 
@@ -282,6 +300,7 @@ free_tree_node(wmem_allocator_t *allocator, wmem_tree_node_t* node, gboolean fre
 void
 wmem_tree_destroy(wmem_tree_t *tree, gboolean free_keys, gboolean free_values)
 {
+    g_mutex_lock(&tree->mutex_lv1);
     free_tree_node(tree->data_allocator, tree->root, free_keys, free_values);
     if (tree->metadata_allocator) {
         wmem_unregister_callback(tree->metadata_allocator, tree->metadata_scope_cb_id);
@@ -290,6 +309,7 @@ wmem_tree_destroy(wmem_tree_t *tree, gboolean free_keys, gboolean free_values)
         wmem_unregister_callback(tree->data_allocator, tree->data_scope_cb_id);
     }
     wmem_free(tree->metadata_allocator, tree);
+    g_mutex_unlock(&tree->mutex_lv1);
 }
 
 gboolean
@@ -447,10 +467,13 @@ wmem_tree_insert(wmem_tree_t *tree, const void *key, void *data, compare_func cm
     wmem_tree_node_t *node = tree->root;
     wmem_tree_node_t *new_node = NULL;
 
+    g_mutex_lock(&tree->mutex_lv3);
+
     /* is this the first node ?*/
     if (!node) {
         tree->root = create_node(tree->data_allocator, node, key,
                 data, WMEM_NODE_COLOR_BLACK, FALSE);
+        g_mutex_unlock(&tree->mutex_lv3);
         return tree->root;
     }
 
@@ -462,6 +485,7 @@ wmem_tree_insert(wmem_tree_t *tree, const void *key, void *data, compare_func cm
         if (result == 0) {
             node->data = data;
             node->is_removed = data ? FALSE : TRUE;
+            g_mutex_unlock(&tree->mutex_lv3);
             return node;
         }
         else if (result < 0) {
@@ -490,17 +514,21 @@ wmem_tree_insert(wmem_tree_t *tree, const void *key, void *data, compare_func cm
     /* node will now point to the newly created node */
     rb_insert_case1(tree, new_node);
 
+    g_mutex_unlock(&tree->mutex_lv3);
     return new_node;
 }
 
 void
 wmem_tree_insert32(wmem_tree_t *tree, guint32 key, void *data)
 {
+    g_mutex_lock(&tree->mutex_lv2);
     lookup_or_insert32(tree, key, NULL, data, FALSE, TRUE);
+    g_mutex_unlock(&tree->mutex_lv2);
 }
 
 gboolean wmem_tree_contains32(wmem_tree_t *tree, guint32 key)
 {
+    g_mutex_lock(&tree->mutex_lv1);
     wmem_tree_node_t *node = tree->root;
 
     while (node) {
@@ -514,17 +542,20 @@ gboolean wmem_tree_contains32(wmem_tree_t *tree, guint32 key)
             node = node->right;
         }
     }
-
+    g_mutex_unlock(&tree->mutex_lv1);
     return FALSE;
 }
 
 void *
 wmem_tree_lookup32(wmem_tree_t *tree, guint32 key)
 {
+    g_mutex_lock(&tree->mutex_lv2);
+
     wmem_tree_node_t *node = tree->root;
 
     while (node) {
         if (key == GPOINTER_TO_UINT(node->key)) {
+            g_mutex_unlock(&tree->mutex_lv2);
             return node->data;
         }
         else if (key < GPOINTER_TO_UINT(node->key)) {
@@ -535,16 +566,20 @@ wmem_tree_lookup32(wmem_tree_t *tree, guint32 key)
         }
     }
 
+    g_mutex_unlock(&tree->mutex_lv2);
     return NULL;
 }
 
 void *
 wmem_tree_lookup32_le(wmem_tree_t *tree, guint32 key)
 {
+    g_mutex_lock(&tree->mutex_lv2);
+
     wmem_tree_node_t *node = tree->root;
 
     while (node) {
         if (key == GPOINTER_TO_UINT(node->key)) {
+            g_mutex_unlock(&tree->mutex_lv2);
             return node->data;
         }
         else if (key < GPOINTER_TO_UINT(node->key)) {
@@ -562,6 +597,7 @@ wmem_tree_lookup32_le(wmem_tree_t *tree, guint32 key)
     }
 
     if (!node) {
+        g_mutex_unlock(&tree->mutex_lv2);
         return NULL;
     }
 
@@ -572,14 +608,17 @@ wmem_tree_lookup32_le(wmem_tree_t *tree, guint32 key)
      */
     if (node->parent == NULL) {
         if (key > GPOINTER_TO_UINT(node->key)) {
+            g_mutex_unlock(&tree->mutex_lv2);
             return node->data;
         } else {
+            g_mutex_unlock(&tree->mutex_lv2);
             return NULL;
         }
     }
 
     if (GPOINTER_TO_UINT(node->key) <= key) {
         /* if our key is <= the search key, we have the right node */
+        g_mutex_unlock(&tree->mutex_lv2);
         return node->data;
     }
     else if (node == node->parent->left) {
@@ -587,15 +626,18 @@ wmem_tree_lookup32_le(wmem_tree_t *tree, guint32 key)
          * we have to check if any of our ancestors are smaller. */
         while (node) {
             if (key > GPOINTER_TO_UINT(node->key)) {
+                g_mutex_unlock(&tree->mutex_lv2);
                 return node->data;
             }
             node=node->parent;
         }
+        g_mutex_unlock(&tree->mutex_lv2);
         return NULL;
     }
     else {
         /* our key is bigger than the search key and we're a right child,
          * our parent is the one we want */
+        g_mutex_unlock(&tree->mutex_lv2);
         return node->parent->data;
     }
 }
@@ -603,11 +645,13 @@ wmem_tree_lookup32_le(wmem_tree_t *tree, guint32 key)
 void *
 wmem_tree_remove32(wmem_tree_t *tree, guint32 key)
 {
+    g_mutex_lock(&tree->mutex_lv1);
     void *ret = wmem_tree_lookup32(tree, key);
     if (ret) {
         /* Not really a remove, but set data to NULL to mark node with is_removed */
         wmem_tree_insert32(tree, key, NULL);
     }
+    g_mutex_unlock(&tree->mutex_lv1);
     return ret;
 }
 
@@ -617,6 +661,8 @@ wmem_tree_insert_string(wmem_tree_t* tree, const gchar* k, void* v, guint32 flag
     char *key;
     compare_func cmp;
 
+    g_mutex_lock(&tree->mutex_lv2);
+
     key = wmem_strdup(tree->data_allocator, k);
 
     if (flags & WMEM_TREE_STRING_NOCASE) {
@@ -626,30 +672,41 @@ wmem_tree_insert_string(wmem_tree_t* tree, const gchar* k, void* v, guint32 flag
     }
 
     wmem_tree_insert(tree, key, v, cmp);
+    g_mutex_unlock(&tree->mutex_lv2);
 }
 
 void *
 wmem_tree_lookup_string(wmem_tree_t* tree, const gchar* k, guint32 flags)
 {
+    if (tree == NULL || k == NULL) {
+        return NULL;
+    }
+
     compare_func cmp;
 
+    g_mutex_lock(&tree->mutex_lv2);
+
     if (flags & WMEM_TREE_STRING_NOCASE) {
         cmp = (compare_func)g_ascii_strcasecmp;
     } else {
         cmp = (compare_func)strcmp;
     }
 
-    return wmem_tree_lookup(tree, k, cmp);
+    void *p = wmem_tree_lookup(tree, k, cmp);
+    g_mutex_unlock(&tree->mutex_lv2);
+    return p;
 }
 
 void *
 wmem_tree_remove_string(wmem_tree_t* tree, const gchar* k, guint32 flags)
 {
+    g_mutex_lock(&tree->mutex_lv1);
     void *ret = wmem_tree_lookup_string(tree, k, flags);
     if (ret) {
         /* Not really a remove, but set data to NULL to mark node with is_removed */
         wmem_tree_insert_string(tree, k, NULL, flags);
     }
+    g_mutex_unlock(&tree->mutex_lv1);
     return ret;
 }
 
@@ -666,6 +723,8 @@ wmem_tree_insert32_array(wmem_tree_t *tree, wmem_tree_key_t *key, void *data)
     wmem_tree_key_t *cur_key;
     guint32 i, insert_key32 = 0;
 
+    g_mutex_lock(&tree->mutex_lv1);
+
     for (cur_key = key; cur_key->length > 0; cur_key++) {
         for (i = 0; i < cur_key->length; i++) {
             /* Insert using the previous key32 */
@@ -682,6 +741,7 @@ wmem_tree_insert32_array(wmem_tree_t *tree, wmem_tree_key_t *key, void *data)
     ASSERT(insert_tree);
 
     wmem_tree_insert32(insert_tree, insert_key32, data);
+    g_mutex_unlock(&tree->mutex_lv1);
 }
 
 static void *
@@ -722,13 +782,19 @@ wmem_tree_lookup32_array_helper(wmem_tree_t *tree, wmem_tree_key_t *key,
 void *
 wmem_tree_lookup32_array(wmem_tree_t *tree, wmem_tree_key_t *key)
 {
-    return wmem_tree_lookup32_array_helper(tree, key, wmem_tree_lookup32);
+    g_mutex_lock(&tree->mutex_lv1);
+    void *p = wmem_tree_lookup32_array_helper(tree, key, wmem_tree_lookup32);
+    g_mutex_unlock(&tree->mutex_lv1);
+    return p;
 }
 
 void *
 wmem_tree_lookup32_array_le(wmem_tree_t *tree, wmem_tree_key_t *key)
 {
-    return wmem_tree_lookup32_array_helper(tree, key, wmem_tree_lookup32_le);
+    g_mutex_lock(&tree->mutex_lv1);
+    void *p = wmem_tree_lookup32_array_helper(tree, key, wmem_tree_lookup32_le);
+    g_mutex_unlock(&tree->mutex_lv1);
+    return p;
 }
 
 static gboolean
@@ -748,8 +814,11 @@ wmem_tree_foreach_nodes(wmem_tree_node_t* node, wmem_foreach_func callback,
     }
 
     if (node->is_subtree) {
-        stop_traverse = wmem_tree_foreach((wmem_tree_t *)node->data,
-                callback, user_data);
+        wmem_tree_t *node_data = (wmem_tree_t *)node->data;
+        if (!node_data->root)
+            stop_traverse = FALSE;
+        else
+            stop_traverse = wmem_tree_foreach_nodes(node_data->root, callback, user_data);
     } else if (!node->is_removed) {
         /* No callback for "removed" nodes */
         stop_traverse = callback(node->key, node->data, user_data);
@@ -775,7 +844,10 @@ wmem_tree_foreach(wmem_tree_t* tree, wmem_foreach_func callback,
     if(!tree->root)
         return FALSE;
 
-    return wmem_tree_foreach_nodes(tree->root, callback, user_data);
+    g_mutex_lock(&tree->mutex_lv1);
+    gboolean ret = wmem_tree_foreach_nodes(tree->root, callback, user_data);
+    g_mutex_unlock(&tree->mutex_lv1);
+    return ret;
 }
 
 static void wmem_print_subtree(wmem_tree_t *tree, guint32 level, wmem_printer_func key_printer, wmem_printer_func data_printer);
@@ -841,7 +913,9 @@ wmem_print_subtree(wmem_tree_t *tree, guint32 level, wmem_printer_func key_print
 void
 wmem_print_tree(wmem_tree_t *tree, wmem_printer_func key_printer, wmem_printer_func data_printer)
 {
+    g_mutex_lock(&tree->mutex_lv1);
     wmem_print_subtree(tree, 0, key_printer, data_printer);
+    g_mutex_unlock(&tree->mutex_lv1);
 }
 /*
  * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
